<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06192516B1.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as first publication">
      <document-id>
        <country>US</country>
        <doc-number>06192516</doc-number>
        <kind>B1</kind>
        <date>20010220</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6192516</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B1</original-publication-kind>
    <application-reference is-representative="YES" family-id="25385926" extended-family-id="14420733">
      <document-id>
        <country>US</country>
        <doc-number>09300555</doc-number>
        <kind>A</kind>
        <date>19990427</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09300555</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>14741213</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>30055599</doc-number>
        <kind>A</kind>
        <date>19990427</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09300555</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>88500897</doc-number>
        <kind>A</kind>
        <date>19970630</date>
        <priority-linkage-type>1</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-08885008</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010220</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <term-of-grant>
      <disclaimer/>
    </term-of-grant>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/45        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>45</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/44        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>44</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>717139000</text>
        <class>717</class>
        <subclass>139000</subclass>
      </main-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/455B2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>455B2</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-008/30</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>30</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/45508</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>45508</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-008/30</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>30</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>24</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>10</number-of-drawing-sheets>
      <number-of-figures>13</number-of-figures>
      <image-key data-format="questel">US6192516</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Interpreter generation and implementation utilizing interpreter states and register caching</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>PASTILHA MARIO VIEIRA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5678044</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5678044</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>WESTERHOLM VILLE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5684996</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5684996</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>YELLIN FRANK, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5999731</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5999731</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>SUN MICROSYSTEMS INC</text>
          <document-id>
            <country>EP</country>
            <doc-number>0838756</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-838756</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>TAKAYAMA SHUICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5758162</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5758162</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Ertl, M., Stack Caching for Interpreters, 1994, p3-12.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Ertl, M., Stack Caching for Interpreters, 1995, p.315-327.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <continuation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>88500897</doc-number>
              <kind>A</kind>
              <date>19970630</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>6021273</doc-number>
              <kind>A</kind>
            </document-id>
          </parent-doc>
        </relation>
      </continuation>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Sun Microsystems, Inc.</orgname>
            <address>
              <address-1>Palo Alto, CA, US</address-1>
              <city>Palo Alto</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>SUN MICROSYSTEMS</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Griesemer, Robert</name>
            <address>
              <address-1>Menlo Park, CA, US</address-1>
              <city>Menlo Park</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Beyer Weaver&amp;Thomas, LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Powell, Mark R.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Systems and methods for increasing the execution speed of interpreted programs which utilize an operand stack are provided.
      <br/>
      The value for the top of the operand stack is stored in one or more registers.
      <br/>
      A state of the interpreter indicates the data type of the value for the top of the operand stack stored in the one or more registers.
      <br/>
      An interpreter may be generated that is both fast and efficient in terms of the memory required for the interpreter.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This is a Continuation application of prior application Ser.
      <br/>
      No. 08/885,008 filed on Jun. 30, 1997, now U.S. Pat. No. 6,021,273.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      The present invention relates to software interpreter implementation and generation.
      <br/>
      More specifically, implementing and generating an interpreter for the Java (tm)  virtual machine that utilizes registers to optimize the stack-based operations.
    </p>
    <p num="3">
      The Java (tm)  programming language is an object-oriented high level programming language developed by Sun Microsystems and designed to be portable enough to be executed on a wide range of computers ranging from small personal computers up to supercomputers.
      <br/>
      Computer programs written in Java (and other languages) may be compiled into virtual machine instructions for execution by a Java virtual machine.
      <br/>
      In general the Java virtual machine is an interpreter that decodes and executes the virtual machine instructions.
    </p>
    <p num="4">
      The virtual machine instructions for the Java virtual machine are bytecodes, meaning they include one or more bytes.
      <br/>
      The bytecodes are stored in a particular file format called a "class file." In addition to the bytecodes, the class file includes a symbol table as well as other ancillary information.
    </p>
    <p num="5">
      A computer program embodied as Java bytecodes in one or more class files is platform independent.
      <br/>
      The computer program may be executed, unmodified, on any computer that is able to run an implementation of the Java virtual machine.
      <br/>
      The Java virtual machine is a software emulator of a "generic" computer which is a major factor in allowing computer programs for the Java virtual machine to be platform independent.
    </p>
    <p num="6">
      The Java virtual machine is commonly implemented as an software interpreter.
      <br/>
      Conventional interpreters decode and execute the virtual machine instructions of an interpreted program one instruction at a time during execution.
      <br/>
      Compilers, on the other hand, decode source code into native machine instructions prior to execution so that decoding is not performed during execution.
      <br/>
      Because conventional interpreters decode each instruction before it is executed repeatedly each time the instruction is encountered, execution of interpreted programs is typically quite slower than compiled programs because the native machine instructions of compiled programs can be executed on the native machine or computer system without necessitating decoding.
    </p>
    <p num="7">
      As a software interpreter must be executing in order to decode and execute an interpreted program, the software interpreter consumes resources (e.g., memory) that will therefore no longer be available to the interpreted program.
      <br/>
      This is in stark contrast to compiled programs that execute as native machine instructions so they may be directly executed on the target computer and are therefore generally free to utilize more resources than interpreted programs.
    </p>
    <p num="8">
      Accordingly, there is a need for new techniques for increasing the execution speed of computer programs that are being interpreted.
      <br/>
      Additionally, there is a need to provide interpreters that are efficient in terms of the resources they require.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="9">
      In general, some embodiments of the present invention provide innovative systems and methods for increasing the execution speed of computer programs executed by an interpreter.
      <br/>
      The interpreter includes an operand stack that is utilized to execute the virtual machine instructions.
      <br/>
      The value for the top of the operand stack is stored in one or more registers which allows the execution speed of stack-based virtual machine instructions to be increased.
      <br/>
      A state of the interpreter is utilized to indicate the data type of the value for the top of the operand stack stored in the one or more registers.
      <br/>
      With the invention, the programs may be interpreted in a more efficient manner utilizing registers.
      <br/>
      Additionally, the size of the interpreter may kept small which allows more resources to be available for the interpreted program.
      <br/>
      Several embodiments of the invention are described below.
    </p>
    <p num="10">
      In one embodiment, a computer implemented method for implementing an interpreter including an operand stack is provided.
      <br/>
      A value for the top of the operand stack is stored in at least one register of the computer instead of on the stack.
      <br/>
      Many conventional computers have registers for storing different data types.
      <br/>
      Accordingly, the value for the top of the stack is stored in one or more registers appropriate for its data type and the state of the interpreter is utilized to indicate the data type of the value for the top of the operand stack that is stored in the one or more registers.
      <br/>
      In preferred embodiments, the interpreter is a Java virtual machine and the states of the interpreter may include integer, long integer, single-precision floating point, and double-precision floating point.
    </p>
    <p num="11">
      In another embodiment, a computer implemented method for generating an interpreter that stores a value for the top of an operand stack in one or more registers is provided.
      <br/>
      The state of the interpreter indicates a data type of the value for the top of the operand stack that is stored in the one or more registers.
      <br/>
      In order to generate the interpreter, the computer may loop through all the possible virtual instructions and states of the interpreter.
      <br/>
      In each iteration, a virtual machine instruction and a state of the interpreter may be selected.
      <br/>
      If the selected state differs from the state of the interpreter that is expected prior to the execution of the selected virtual machine instructions, computer code for the interpreter is generated to put the interpreter in the expected state.
      <br/>
      Once it is known that the interpreter is in the expected state prior to the execution of the selected virtual machine instruction, computer code for the interpreter is generated to execute the selected virtual machine instruction.
      <br/>
      The expected state for the selected virtual machine instruction may be obtained by accessing a table indexed by virtual machine instructions that stores expected states of the interpreter before execution of the virtual machine instructions and current states of the interpreter after execution of the virtual machine instructions.
      <br/>
      Additionally, the computer code for the interpreter to execute the selected virtual machine instruction may be generated by calling a function specified in the table.
    </p>
    <p num="12">
      In another embodiment, a data structure stored by a computer readable medium for an interpreter of virtual machine instructions is provided.
      <br/>
      The data structure is a table indexed by virtual machine instructions and having multiple fields.
      <br/>
      In one field of the table, expected states of the interpreter before execution of the virtual machine instructions are stored.
      <br/>
      In another field of the table is stored current states of the interpreter after execution of the virtual machine instructions.
      <br/>
      Additionally, a field of the table may be utilized to store pointers to functions that generate computer code for the interpreter to execute the virtual machine instructions.
      <br/>
      In a preferred embodiment, a state of the interpreter indicates the data type of a value for the top of an operand stack of the interpreter that is stored in one or more registers.
    </p>
    <p num="13">
      In another embodiment, a data structure stored by a computer readable medium for an interpreter of virtual machine instructions is provided.
      <br/>
      The data structure is a table indexed by virtual machine instructions and having multiple fields, each field being associated with a state of the interpreter and storing a pointer to a location in the interpreter that executes the indexed virtual machine instructions.
      <br/>
      The state of the interpreter may indicate the data type of a value for the top of an operand stack of the interpreter that is stored in one or more registers.
      <br/>
      In preferred embodiments, the state of the interpreter may be integer, long integer, single-precision floating point, and double-precision floating point.
    </p>
    <p num="14">Other features and advantages of the invention will become readily apparent upon review of the following detailed description in association with the accompanying drawings.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="15">
      FIG. 1 illustrates an example of a computer system that may be utilized to execute the software of an embodiment of the invention.
      <br/>
      FIG. 2 shows a system block diagram of the computer system of FIG. 1.
      <br/>
      FIG. 3 shows how a Java source code program is executed.
      <br/>
      FIG. 4A shows a stack; FIG. 4B shows an operand stack of the present invention where the value for the top of the operand stack is stored in a register; and FIG. 4C shows an operand stack of the present invention where multiple registers and registers for storing different data types may store the value for the top of the operand stack.
      <br/>
      FIG. 5 illustrates a template table utilized during interpreter generation to organize interpreter states and template functions.
      <br/>
      FIG. 6 illustrates a dispatch table generated during interpreter generation that stores pointers to locations within the interpreter utilized to direct interpreter execution flow.
      <br/>
      FIG. 7 shows a process of generating an interpreter that utilizes a state of the interpreter to indicate that data type of the value for the top of the operand stack that is store in one or more registers.
      <br/>
      FIG. 8 shows a process of generating epilog computer code that executes the advance and dispatch steps of the interpreter.
      <br/>
      FIG. 9 shows a portion of a dispatch table of FIG. 6 for executing the bytecode IADD.
      <br/>
      FIG. 10 shows sections of computer code for interpreter that execute virtual machine instructions and handle errors.
      <br/>
      FIG. 11 shows a process of executing a virtual machine instruction with an interpreter according to an embodiment of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
    <p num="16">Definitions</p>
    <p num="17">Machine instruction--An instruction that directs a computer to perform an operation specified by an operation code (opcode) and optionally one or more operand.</p>
    <p num="18">Virtual machine instruction--A machine instruction for a software emulated microprocessor or computer architecture (also called virtual code).</p>
    <p num="19">Native machine instruction--A machine instruction that is designed for a specific microprocessor or computer architecture (also called native code).</p>
    <p num="20">Class--An object-oriented data type that defines the data and methods that each object of a class will include.</p>
    <p num="21">Function--A software routine (also called a subroutine, procedure, member function, and method).</p>
    <p num="22">Operand stack--A stack utilized to store operands for use by machine instructions during execution.</p>
    <p num="23">Bytecode pointer (BCP)--A pointer that points to the current Java virtual machine instruction (e.g., bytecode) that is being executed.</p>
    <p num="24">Program counter (PC)--A pointer that points to the machine instruction (typically native) of the interpreter that is being executed.</p>
    <p num="25">Interpreter--A program in software or hardware that typically translates and then executes each instruction in a computer program.</p>
    <p num="26">Interpreter generator--A program in software or hardware that generates an interpreter.</p>
    <p num="27">Overview</p>
    <p num="28">
      In the description that follows, the present invention will be described in reference to a preferred embodiment that implements a Java virtual machine for executing Java virtual machine instructions (bytecodes).
      <br/>
      In particular, examples will be described including native machine instructions of IBM personal computers (Intel x86 microprocessor architectures).
      <br/>
      However, the invention is not limited to any particular language, computer architecture, or specific implementation.
      <br/>
      Therefore, the description of the embodiments that follow is for purposes of illustration and not limitation.
    </p>
    <p num="29">
      FIG. 1 illustrates an example of a computer system that may be used to execute the software of an embodiment of the invention.
      <br/>
      FIG. 1 shows a computer system 1 which includes a display 3, screen 5, cabinet 7, keyboard 9, and mouse 11.
      <br/>
      Mouse 11 may have one or more buttons for interacting with a graphical user interface.
      <br/>
      Cabinet 7 houses a CD-ROM drive 13, system memory and a hard drive (see FIG. 2) which may be utilized to store and retrieve software programs incorporating computer code that implements the invention, data for use with the invention, and the like.
      <br/>
      Although the CD-ROM 15 is shown as an exemplary computer readable storage medium, other computer readable storage media including floppy disk, tape, flash memory, system memory, and hard drive may be utilized.
      <br/>
      Additionally, a data signal embodied in a carrier wave (e.g., in a network including the Internet) may be the computer readable storage medium.
    </p>
    <p num="30">
      FIG. 2 shows a system block diagram of computer system 1 used to execute the software of an embodiment of the invention.
      <br/>
      As in FIG. 1, computer system 1 includes monitor 3 and keyboard 9, and mouse 11.
      <br/>
      Computer system 1 further includes subsystems such as a central processor 51, system memory 53, fixed storage 55 (e.g., hard drive), removable storage 57 (e.g., CD-ROM drive), display adapter 59, sound card 61, speakers 63, and network interface 65.
      <br/>
      Other computer systems suitable for use with the invention may include additional or fewer subsystems.
      <br/>
      For example, another computer system could include more than one processor 51 (i.e., a multi-processor system), or a cache memory.
    </p>
    <p num="31">
      The system bus architecture of computer system 1 is represented by arrows 67.
      <br/>
      However, these arrows are illustrative of any interconnection scheme serving to link the subsystems.
      <br/>
      For example, a local bus could be utilized to connect the central processor to the system memory and display adapter.
      <br/>
      Computer system 1 shown in FIG. 2 is but an example of a computer system suitable for use with the invention.
      <br/>
      Other computer architectures having different configurations of subsystems may also be utilized.
    </p>
    <p num="32">
      Typically, computer programs written in the Java programming language are compiled into bytecodes or Java virtual machine instructions which are then executed by a Java virtual machine.
      <br/>
      The bytecodes are stored in class files which are input into the Java virtual machine for interpretation.
      <br/>
      FIG. 3 shows a progression of a simple piece of Java source code through execution by an interpreter, the Java virtual machine.
    </p>
    <p num="33">
      Java source code 101 includes the classic Hello World program written in Java.
      <br/>
      The source code is then input into a bytecode compiler 103 which compiles the source code into bytecodes.
      <br/>
      The bytecodes are virtual machine instructions as they will be executed by a software emulated computer.
      <br/>
      Typically, virtual machine instructions are generic (i.e., not designed for any specific microprocessor or computer architecture) but this is not required.
      <br/>
      The bytecode compiler outputs a Java class file 105 which includes the bytecodes for the Java program.
    </p>
    <p num="34">
      The Java class file is input into a Java virtual machine 107.
      <br/>
      The Java virtual machine is an interpreter that decodes and executes the bytecodes in the Java class file.
      <br/>
      The Java virtual machine is an interpreter, but is commonly referred to as a virtual machine as it emulates a microprocessor or computer architecture in software (e.g., the microprocessor or computer architecture that may not exist in hardware).
    </p>
    <p num="35">An interpreter may execute a bytecode program by repeatedly executing the following steps:</p>
    <p num="36">
      Execute--execute operation of the current bytecode
      <br/>
      Advance--advance bytecode pointer to next bytecode
      <br/>
      Dispatch--fetch the bytecode at the bytecode pointer and jump to the implementation (i.e., execute step) of that bytecode.
    </p>
    <p num="37">
      The execute step implements the operation of a particular bytecode.
      <br/>
      The advance step increments the bytecode pointer so that it points to the next bytecode.
      <br/>
      Lastly, the dispatch step fetches the bytecode at the current bytecode pointer and jumps to the piece of native machine code that implements that bytecode.
      <br/>
      The execution of the execute-advance-dispatch sequence for a bytecode is commonly called an "interpretation cycle."
    </p>
    <p num="38">
      Although in a preferred embodiment, the interpreter utilizes the interpretation cycle described above, many other interpretation cycles may be utilized in conjunction with the present invention.
      <br/>
      For example, an interpreter may perform dispatch-execute-advance interpretation cycles or there may be more or fewer steps in each cycle.
      <br/>
      Accordingly, the invention is not limited to the embodiments described herein.
    </p>
    <p num="39">Java Virtual Machine Implementation and Generation</p>
    <p num="40">
      The virtual machine instructions for the Java virtual machine include stack-based instructions.
      <br/>
      Thus, one or more of the operands of the virtual machine instructions may be stored in an operand stack.
      <br/>
      Before describing the operand stack, it may be beneficial to discuss a general stack.
    </p>
    <p num="41">
      FIG. 4A shows a stack 201 that stores data 203.
      <br/>
      With the stack, a data value may be "pushed" onto the top of the stack.
      <br/>
      Alternatively, a data value may be "popped" off the top of the stack.
      <br/>
      Conceptually, only the top of the stack may be accessed so the stack is known as a first in, first out (FIFO) data structure meaning that the data that was most recently pushed onto the stack will be the first data to be popped off the stack.
      <br/>
      A stack pointer (SP) 205 points to the top of stack 201.
      <br/>
      Thus, the SP will change as data values are pushed onto and popped off the stack.
      <br/>
      For simplicity, the stacks described herein are shown and described as growing upwards in memory; however, this is just a graphical representation and those of skill in the art will readily recognize that a stack may be shown and/or implemented in many other ways (e.g., growing downwards in memory).
    </p>
    <p num="42">
      The virtual machine instructions for the Java virtual machine call for an implementation of an operand stack that may be similar to the stack shown in FIG. 4A. More specifically, the operand stack in the Java virtual machine is utilized to store operands for use by the bytecodes during execution.
      <br/>
      The following is an example that may help illustrate how an operand stack is utilized in the Java virtual machine.
    </p>
    <p num="43">
      Assume that the Java source code includes a statement X:=A+B, where X, A and B are integer variables.
      <br/>
      This statement may be compiled into the following bytecodes:
      <br/>
      1.
      <br/>
      ILOAD A
      <br/>
      2. ILOAD B
      <br/>
      3. IADD
      <br/>
      4. ISTORE X
    </p>
    <p num="44">
      It should be noted that the "I" preceding each bytecode indicates that the data type of the values manipulated by the bytecodes are integers.
      <br/>
      There are corresponding bytecodes for other data types which are designated by an "L" for long integer, "F" for single-precision floating point, and "D" for double-precision floating point.
      <br/>
      In the Java virtual machine, the integer data type is 32 bits, long integer data type is 64 bits, the single-precision floating point data type is 32 bits, and the double-precision floating point data type is 64 bits.
      <br/>
      As will be illustrated below, the size of these data types in the virtual machine may not be the same as in the computer system implementing the virtual machine (e.g., the standard integer data type on an IBM personal computer is 16 bits and there is no direct support for 64 bit long integers), so it is important to make a distinction between the Java virtual machine instructions and the native machine instructions that direct the computer on which the virtual machine is implemented.
    </p>
    <p num="45">
      The first ILOAD bytecode loads the value of variable A onto the operand stack.
      <br/>
      Similarly, the second ILOAD bytecode loads the value of variable B onto the operand stack.
      <br/>
      The bytecode IADD pops two data values off the operand stack, adds the two values and pushes the sum onto the operand stack.
      <br/>
      As may be expected, the ISTORE bytecode pops a data value off the operand stack, the sum in this case, and stores it in variable X. This simple example illustrates conceptually how Java bytecodes utilize an operand stack.
    </p>
    <p num="46">
      Some embodiments of the present invention take advantage of the fact that oftentimes when a data value is pushed onto the operand stack, it will subsequently be popped off the operand stack (with or without intervening bytecodes that do not modify the top of the operand stack).
      <br/>
      Typically, the operand stack is implemented in memory but with some embodiments of the present invention, the value for the top of the operand stack is stored in one or more registers.
      <br/>
      As registers have a faster access time than memory, access time for the top of the operand stack may be decreased resulting in faster interpretation of the interpreted program.
    </p>
    <p num="47">
      FIG. 4B shows an operand stack 301 that stores data 303.
      <br/>
      Data 303 includes both data values in memory and a data value for the top of the operand stack stored in a register 305.
      <br/>
      A stack pointer' (SP') 307 points to the data value conceptually just below the top of operand stack 301.
      <br/>
      It should be noted that this discussion focuses on a single operand stack.
      <br/>
      However, there may be multiple operand stacks in a single computer system (e.g., for different threads and methods) which may implemented according to the present invention.
    </p>
    <p num="48">
      Conventional computer systems typically have many different registers, with certain registers being better suited to store specific data types.
      <br/>
      For example, a computer may have registers that are 32 bits wide and registers that are 64 bits wide.
      <br/>
      If an integer on this hypothetical computer is a 32 bit quantity while a long integer is a 64 bit quantity, it would be more efficient to store the data values in a register that matches the size of the data value.
      <br/>
      Furthermore, computer systems may have registers that are designed to store specific data types like single-precision floating point or double-precision floating point.
    </p>
    <p num="49">
      More specifically, the IBM personal computers (Intel x86 architectures) include many different types of registers.
      <br/>
      There are 32 bit registers (e.g., EAX) and floating point registers (e.g., F(0)).
      <br/>
      Additionally, some of the data types of Intel x86 microprocessors have different sizes then their counterparts in the Java virtual machine.
      <br/>
      For example, a standard integer data type is 16 bits wide and a long integer data type is 32 bits wide in an Intel 80386 microprocessor.
      <br/>
      These data types are half the size of their Java virtual machine counterparts.
      <br/>
      Accordingly, in preferred embodiments where the Java virtual machine is implemented on an x86 machine, an integer in the Java virtual machine is the same size as a long integer in the x86 machine (i.e., both are 32 bit quantities).
    </p>
    <p num="50">
      As mentioned previously, it is important to keep in mind whether an instruction is a virtual machine instruction or a native machine instruction.
      <br/>
      Although the Java virtual machine instructions look similar to assembly language, fortunately there is an easily recognizable difference.
      <br/>
      In the bytecodes described herein for the Java virtual machine, the data type for which the bytecodes pertain precedes the instruction (e.g., ISTORE where the "I" designates integer).
      <br/>
      This is in stark contrast to the assembly code (or native machine instructions) for the x86 microprocessors where the data type follows the instructions (e.g., POPL where the "L" designates long integer).
      <br/>
      Although this will likely not be true for all embodiments of the invention, it is hoped that this distinction will aid the reader's understanding of the preferred embodiments described herein.
    </p>
    <p num="51">
      Returning briefly to FIG. 4B, there is a problem since there is only one register shown and operand stack 301 may be utilized to store different data types so it would be desirable to have different registers available to store the value for the top of the operand stack.
      <br/>
      FIG. 4C shows an operand stack 401 for a Java virtual machine implemented on an x86 microprocessor.
      <br/>
      Operand stack 401 stores data 403 which includes both data values in memory and a data value for the top of the operand stack stored in one of registers 405, 407 or 409.
      <br/>
      In a preferred embodiment, register 405 is a 32 bit register (EAX) for storing virtual machine integers for the top of the operand stack.
      <br/>
      Register 407 is a combination of two 32 bit registers (EDX:EAX) for storing virtual machine long integers for the top of the operand stack.
      <br/>
      Register 409 is a 64 bit floating point register (F(0)) for storing both single-precision floating point and double-precision floating point.
      <br/>
      The designation of specific registers is provided to better illustrate the invention; however, it should be understood that the present invention is not limited to any specific registers or computer architectures.
    </p>
    <p num="52">
      A stack pointer' (SP') 411 points to the data value conceptually just below the top of operand stack 401.
      <br/>
      Now that there is more than one register that may be storing the value for the top of the operand stack, it would be desirable to know which register or registers stored this value.
      <br/>
      One technique would be to store a value in memory or a register indicating the data type of the value on the top of the operand stack.
      <br/>
      Accordingly, this could be accessed to determine the right register or registers storing the top of the operand stack.
    </p>
    <p num="53">
      Although this technique may work, it has some significant drawbacks that may make it unsatisfactory.
      <br/>
      For example, the extra determination of the data type of the top of the operand stack may offset the performance increase of utilizing registers to store the top of the operand stack.
    </p>
    <p num="54">
      With some embodiments of the present invention, the interpreter operates in multiple states.
      <br/>
      Each state indicates the data type of the value of the top of the operand stack stored in the one or more registers.
      <br/>
      The state is an inherent quality of the interpreter at any point in time so a determination of the data type of the top of the operand stack is not required.
    </p>
    <p num="55">
      In a preferred embodiment, the interpreter may be in one of five different states as follows:
      <br/>
      ITOS--an integer for the top of the operand stack (TOS) is stored in register(s)
      <br/>
      LTOS--a long integer for the TOS is stored in register(s)
      <br/>
      FTOS--a single-precision floating point for the TOS is stored in register(s)
      <br/>
      DTOS--a double-precision floating point for the TOS is stored in register(s)
      <br/>
      VTOS--void TOS, meaning the TOS is not currently stored in register(s)
    </p>
    <p num="56">
      As indicated above, the VTOS state is different from the rest of the states because it indicates that the top of the operand stack is not currently stored in any of the registers.
      <br/>
      It should be apparent that as data values are pushed onto and popped off of the operand stack, the interpreter may alternate between the VTOS state and one of the other states.
    </p>
    <p num="57">
      In order to assist in managing the different states of the interpreter, a template table (data structure) 501 shown in FIG. 5 is utilized in some embodiments of the invention.
      <br/>
      Template table 501 is a table that is indexed by bytecodes 503 and includes fields 505, 507, and 509.
      <br/>
      Although template table 501 may have over two hundred records (e.g., one for each bytecode), only a subset are shown which are thought to best illustrate the invention.
    </p>
    <p num="58">
      The virtual machine instructions (or bytecodes) are utilized to index the template table 501.
      <br/>
      Field 505 stores the state of the interpreter that is expected before virtual machine instructions 503 execute.
      <br/>
      For example, before an ISTORE bytecode is executed (i.e., store the integer on the top of the operand stack), it is expected that the interpreter will be in the ITOS state indicating that there is an integer for the top of the operand stack stored in the one or more registers.
      <br/>
      If the interpreter is not in the expected state during execution, that does not necessarily indicate there is an error, but as will described in more detail below, preferred embodiments of the invention are able to detect many errors in the bytecode sequence.
    </p>
    <p num="59">
      Field 507 stores pointers to functions that generate computer code (or a "template" and hence "template table") for the interpreter to execute virtual machine instructions 503.
      <br/>
      In a preferred embodiment, the names of the functions are the same as the name of the bytecodes and the functions are written in the C++ programming language.
    </p>
    <p num="60">
      Lastly, field 509 stores the current state of the interpreter after execution of virtual machine instructions 503.
      <br/>
      For example, after an ISTORE bytecode is executed, the current state of the interpreter would be VTOS since the integer stored in the one or more registers has been popped off the operand stack.
    </p>
    <p num="61">
      In preferred embodiments, field 505 stores the state of the interpreter that is expected before a virtual machine instruction executes and field 509 stores the current state of the interpreter after the virtual machine instruction executes.
      <br/>
      However, in other embodiments field 505 stores the state of the interpreter that is expected before the template function specified in field 507 executes and field 509 stores the current state of the interpreter after the template function executes.
      <br/>
      In other words, the state of the interpret may be based on the template functions instead of the virtual machine instructions.
    </p>
    <p num="62">
      The template table has been described but during interpreter generation, another table (the "dispatch table") is utilized in conjunction with the template table.
      <br/>
      FIG. 6 shows a layout of a dispatch table 601 which is indexed by virtual machine instructions 603 and includes fields 605, 607, 609, 611, and 613.
      <br/>
      Field 605 stores pointers to a location or address in the interpreter that executes the indexed virtual machine instructions for the ITOS state.
      <br/>
      Similarly, fields 607, 609, 611, and 613 store pointers to a location or address in the interpreter that executes the indexed virtual machine instructions for the LTOS, FTOS, DTOS, and VTOS states, respectively.
      <br/>
      Accordingly, each field is associated with a state of the interpreter.
      <br/>
      The values of the fields are not shown as they are pointers to within a generated interpreter.
    </p>
    <p num="63">
      Recalling that the interpreter is typically a software program itself, the dispatch table is a jump table to different locations within the computer code of the interpreter program.
      <br/>
      In other words, once the next bytecode to be executed is fetched, the interpreter jumps to the location indicated in the dispatch table specified by the next bytecode (utilized as an index) and the current state of the interpreter which specifies one of fields 605, 607, 609, 611, or 613 for the location of the jump.
      <br/>
      Thus, the program counter of the interpreter is set to the specified address in the dispatch table.
      <br/>
      In a preferred embodiment, dispatch table 601 is implemented as five single-dimensional tables, one for each interpreter state.
    </p>
    <p num="64">
      It should be apparent that the template table and the dispatch table may be implemented as one table (or more than two tables for that matter).
      <br/>
      However, in preferred embodiments, the template table and dispatch table are separate tables as the template table may be utilized solely during interpreter generation and therefore may be discarded after the interpreter is generated.
      <br/>
      The dispatch table is generated or filled during interpreter generation and advantageously utilized during interpreter execution.
      <br/>
      Nevertheless, the information in these tables may be implemented in any number of ways in any number of data structures known to those of skill in the art.
    </p>
    <p num="65">
      Now that the template and dispatch tables have been described, it may be appropriate to describe how the interpreter may be generated.
      <br/>
      FIG. 7 shows a process of generating an interpreter.
      <br/>
      In general, the process generates the interpreter by cycling through all the virtual machine instructions and interpreter state combinations.
      <br/>
      This may be implemented with nested loops, a single loop or other control structures.
      <br/>
      In a preferred embodiment, nested loops are utilized.
    </p>
    <p num="66">
      At step 701, the computer system selects a virtual machine instruction (e.g., by one iteration through a loop through the virtual machine instructions).
      <br/>
      The system selects an interpreter state at step 703.
      <br/>
      Once a virtual machine instruction and an interpreter state are selected, the rest of the process in FIG. 7 generates computer code for the interpreter that will handle the selected virtual machine instruction when the interpreter is currently in the selected state.
      <br/>
      Although the drawings show flowcharts for embodiments of the invention for purposes of illustration, no specific ordering or combination of steps should be implied.
      <br/>
      In general, steps may be reordered, combined or deleted without departing from the scope of the invention.
    </p>
    <p num="67">
      At step 705, the system determines if the selected virtual machine instruction and interpreter state are legal.
      <br/>
      In one embodiment, this is accomplished by determining the expected state of the interpreter for the selected bytecode utilizing the template table (see FIG. 5).
      <br/>
      If the expected state is the same as the selected state, then the combination of selected virtual machine instruction and state is legal.
    </p>
    <p num="68">
      If the expected state is different from the selected state, this does not necessarily mean that the combination is illegal.
      <br/>
      Instead, the system determines if there is a legal way (meaning that does not corrupt the operand stack) from the selected state to the expected state.
      <br/>
      For example, if the expected state is ITOS and the selected state is VTOS, the interpreter may be put in the ITOS state by moving the top data value in the operand stack that is stored in memory into one or more registers (e.g., store the data value pointed to by SP' into a register and then decrement SP').
      <br/>
      As another example, if the expected state is ITOS and the selected state is DTOS, there is no legal way to put the interpreter in the ITOS state since the top of the operand stack currently is a double-precision floating point.
    </p>
    <p num="69">
      In general, it is legal to go from the state of VTOS to any other state or to go from any other state to VTOS.
      <br/>
      The reason is that these shifts of interpreter state typically include moving a data value from memory to one or more registers, or vice versa.
    </p>
    <p num="70">
      If the selected virtual machine instruction and interpreter state are legal, the system may generate prolog computer code at step 707.
      <br/>
      The prolog computer code is any code that would be advantageously generated before execution of the selected virtual machine instruction.
      <br/>
      In general, the prolog may depend on the selected virtual machine instruction and the selected interpreter state.
      <br/>
      For example, if the expected state of the interpreter (for the selected virtual machine instruction) is different than the selected interpreter state, the prolog may include computer code to put the interpreter in the expected state.
      <br/>
      If the expected and selected states of the interpreter are the same, it may not be necessary to generate prolog computer code.
    </p>
    <p num="71">
      At step 709, the system calls the template function for the selected virtual machine instruction in order to generate computer code for the interpreter to execute the selected virtual machine instruction.
      <br/>
      In a preferred embodiment, the template function is called by indexing the template table shown in FIG. 5 with the selected virtual machine instruction.
      <br/>
      The field, field 507, which stores the pointer to (or address for) the template function is then accessed and the template function is called.
    </p>
    <p num="72">
      The template function generates computer code to execute the selected virtual machine instruction.
      <br/>
      It may be helpful to discuss a few examples of template functions.
      <br/>
      As mentioned earlier, in a preferred embodiment the template functions are written in the C++ and Java programming languages for an x86 microprocessor.
      <br/>
      The following is a template function for the bytecode ILOAD:
    </p>
    <p num="73">
      --
      <br/>
      --                void TemplateTable::iload(int n) +
      <br/>
      --                 assembler.movl(eax, address(n));
      <br/>
      --                }
    </p>
    <p num="74">
      The ILOAD method is defined for a class called TEMPLATE_TABLE for the Java virtual machine.
      <br/>
      As the ILOAD bytecode pushes an integer onto the operand stack, the template function by the same name has a parameter that is an integer.
      <br/>
      The MOVL method is a C++ function for an ASSEMBLER object that pushes the value of N onto the operand stack by placing it in a register.
      <br/>
      Recall that MOVL corresponds to the x86 assembly language instruction that moves a 32 bit quantity which is an integer in the Java virtual machine instruction but a long integer in the x86 microprocessor.
    </p>
    <p num="75">As another example, the following is a template function for the bytecode IADD:</p>
    <p num="76">
      --
      <br/>
      --                  void TemplateTable::iadd() +
      <br/>
      --                   assembler.popl(edx);
      <br/>
      --                   assembler.addl(eax, edx);
      <br/>
      --                  }
    </p>
    <p num="77">
      The IADD method is defined for a class called TEMPLATE_TABLE for the Java virtual machine.
      <br/>
      The expected state for the IADD bytecode is ITOS so there should be an integer at the top of the operand stack stored in a register (EAX in this example).
      <br/>
      First, the value pointed to by the SP' pointer (which may be the ESP pointer in the x86 microprocessor) is popped off the stack utilizing the POPL method.
      <br/>
      It is important to understand that the stack we are discussing now is the native stack stored in memory on the target microprocessor (see left side of FIGS. 4B and 4C).
      <br/>
      Thus, the data value pointed to by the SP' pointer is moved into the register EDX and SP' is then decremented.
    </p>
    <p num="78">
      At this point, the top of the operand stack is stored in the register EAX and the next highest data value on the operand stack is stored in EDX.
      <br/>
      The ADDL method corresponds to an assembly language instruction that adds the values stored in EAX and EDX, storing the sum in EAX.
      <br/>
      The EAX register now stores the desired sum in the appropriate register for the top of the operand stack, meaning the interpreter is now in the ITOS state as specified in the template table of FIG. 5 following the execution of the selected function IADD.
    </p>
    <p num="79">
      As illustrated above, in preferred embodiments, an object is instantiated for the assembler which includes methods for each assembly language instruction that will be utilized in the interpreter.
      <br/>
      For simplicity, the names of the methods are the same as the assembly language instructions.
      <br/>
      It has been found that utilizing an assembler object is beneficial for generation of the interpreter because an extra assembler need not be utilized.
      <br/>
      In some embodiments, the template functions may be written in assembly language for the desired computer architecture.
    </p>
    <p num="80">
      At step 711, the system generates epilog computer code.
      <br/>
      The epilog is computer code that sets up the interpreter to execute the next virtual machine instruction.
      <br/>
      Thus, the epilog performs the advance and dispatch steps of the interpreter described earlier.
    </p>
    <p num="81">
      Initially, the prolog computer code fetches the next virtual machine instruction.
      <br/>
      Since the current state of the interpreter after the execution of the selected virtual machine instruction is known (e.g., from field 509 of the template table in FIG. 5), the next virtual machine instruction may be utilized as an index (or offset) into the dispatch table of FIG. 6 in order to determine the location within the interpreter to execute the next virtual machine instruction.
      <br/>
      The computer code in the epilog will be discussed in more detail in reference to FIG. 8, but in general, the epilog depends on the selected virtual machine and the current interpreter state.
    </p>
    <p num="82">
      The system determines if there are more virtual machine instruction/interpreter states for which to generate computer code for the interpreter at step 701.
      <br/>
      If there are the process returns to step 701 and performs another iteration.
    </p>
    <p num="83">
      Back at step 705 if it is determined that the selected virtual machine instruction and interpreter state are illegal, the system may generate computer code to handle the error at step 715.
      <br/>
      Generally speaking, the error is an illegal bytecode sequence.
      <br/>
      In a preferred embodiment, computer code is generated for the interpreter that jumps to instructions that inform the user that this error has occurred.
      <br/>
      Although the number of errors detected in this manner will not be as numerous as those detected by a bytecode verifier, it may be desirable especially if one is not required or able to use a bytecode verifier.
      <br/>
      In some embodiments, the error checking and handling steps 707 and 715 may be omitted.
    </p>
    <p num="84">
      FIG. 8 shows a process of generating the epilog computer code for the interpreter.
      <br/>
      The epilog computer code is generated at step 711 of FIG. 7, but a specific embodiment that generates the epilog computer code will be discussed in reference to FIG. 8.
      <br/>
      At step 801, computer code that fetches the next virtual machine instruction is generated.
      <br/>
      The next virtual machine instruction may be fetched by incrementing the current bytecode pointer to the next bytecode and then fetching the bytecode pointed to or referenced by the bytecode pointer.
      <br/>
      As the size of the virtual machine instructions may vary as in the case of Java bytecodes, in a preferred embodiment a table is utilized to store the size of each bytecode so that the bytecode pointer may be incremented by the size in the table to point to the next bytecode.
    </p>
    <p num="85">
      Once the next virtual machine instruction is fetched, the system generates computer code to calculate an offset into the dispatch table at step 803.
      <br/>
      The offset is the number which when added to the starting address of the dispatch table of FIG. 6 results in the field indexed by the next bytecode and the current interpreter state.
      <br/>
      In a preferred embodiment, the dispatch table includes five single-dimensional tables (or subtables), one for each interpreter state.
      <br/>
      The current state of the interpreter determines which subtable to utilize.
      <br/>
      The size of each field in the subtables may be a fixed size (e.g., four bytes) so calculating the offset includes multiplying the next bytecode value by the fixed size.
      <br/>
      In other embodiments where the dispatch table is a single two-dimensional table, numerous techniques well known to those of skill in the art of calculating offsets into two-dimensional arrays may be utilized.
      <br/>
      Furthermore, the invention is not limited to tables but may be implemented utilizing any number of data structures including linked lists, hash tables, and the like.
    </p>
    <p num="86">
      At step 805, the system generates computer code to jump to the location or address in the interpreter specified by the field at the offset in the dispatch table.
      <br/>
      The dispatch table is a jump table storing addresses within the computer code of the interpreter itself.
      <br/>
      During interpretation, the epilog computer code performs the advance and dispatch steps for the interpreter.
      <br/>
      However, other embodiments may place the advance step in the prolog and the dispatch step in the epilog; therefore, the invention is not limited to the specific implementation described herein.
    </p>
    <p num="87">
      The above has described preferred embodiments of the present invention.
      <br/>
      Conceptually, one may think that there are five separate interpreters generated: one for each of the interpreter states ITOS, LTOS, FTOS, DTOS, and VTOS.
      <br/>
      However, in practice, many of the virtual machine instruction/interpreter state combinations are illegal so five separate interpreters are not generated.
      <br/>
      Furthermore, computer code that executes the virtual machine instructions may be shared so an interpreter according to the present invention may not be much larger in size than a conventional interpreter.
      <br/>
      In order to more clearly see how computer code that executes the virtual machine instructions may be shared, it may be helpful to the reader to describe how computer code for a sample bytecode may be generated for the interpreter.
    </p>
    <heading>EXAMPLE</heading>
    <p num="88">
      As described in reference to FIG. 7, an interpreter may be generated by cycling or looping through the possible virtual machine instruction and interpreter state combinations.
      <br/>
      As the interpreter is generated, a section of computer code is generated for each virtual machine instruction with a dispatch table being utilized during interpreter execution to hold the entry or jump points for different virtual machine instruction and interpreter state combinations.
      <br/>
      Therefore, the generated interpreter may include a dispatch table and a sequence of sections of computer code that execute different virtual machine instructions (or handle errors).
    </p>
    <p num="89">
      With this example, it will be described how computer code that executes the IADD bytecode is generated.
      <br/>
      FIG. 9 shows a portion of a dispatch table 901 pertaining to the IADD bytecode.
      <br/>
      The structure of dispatch table 901 is the same as described in reference to FIG. 6.
      <br/>
      In short, the dispatch table is indexed by virtual machine instructions 903 and includes fields 905, 907, 909, 911, and 913, one field for each state of the interpreter.
    </p>
    <p num="90">
      The decimal value for the IADD bytecode is 96 as shown in parenthesis.
      <br/>
      Pointer AI points to a location or address in the interpreter that executes the IADD bytecode if the interpreter is in the ITOS state.
      <br/>
      Similarly, pointers AL, AF, AD, and AV point to a locations or addresses in the interpreter that execute the IADD bytecode when the interpreter is in the LTOS, FTOS, DTOS, and VTOS states, respectively.
    </p>
    <p num="91">
      The pointers in dispatch table 901 point to addresses within the sequences of sections of computer code generated for the interpreter.
      <br/>
      FIG. 10 shows sequences of sections of computer code generated for the interpreter.
      <br/>
      Each section of computer code executes a specific bytecode.
      <br/>
      Section 1003 includes computer code for execution the IADD bytecode.
      <br/>
      As shown, section 1003 includes two POPL instructions and an ADDL instruction.
      <br/>
      These instructions are assembly language (or native machine instructions) for an x86 microprocessor and were generated as follows.
    </p>
    <p num="92">During interpreter generation, the following sections of assembly language instructions may be generated to execute the IADD byte when the interpreter is in the ITOS or VTOS states:</p>
    <p num="93">
      --
      <br/>
      --      ITOS                        VTOS
      <br/>
      --      POPL EDX                    POPL EAX
      <br/>
      --      ADDL EAX, EDX               POPL EDX
      <br/>
      --      &lt;DISPATCH/ADVANCE&gt;    ADDL EAX, EDX
      <br/>
      --                                  &lt;DISPATCH/ADVANCE&gt;
    </p>
    <p num="94">
      For simplicity, the computer code that performs the dispatch and advance steps are not explicitly shown.
      <br/>
      As shown, the only difference between the two sections of computer code is that there is an additional instruction when the interpreter is in the VTOS state.
      <br/>
      The POPL EAX pops a value off the stack of the native machine and places it in register EAX.
      <br/>
      This instruction was generated as prolog to shift the interpreter from the VTOS state into the ITOS state which is the state which is expected for the IADD bytecode (see step 707 of FIG. 7).
    </p>
    <p num="95">
      The POPL EDX instruction and the ADDL instruction were generated by the template function IADD( ) accessed in the template table (see previous example and step 709 of FIG. 7).
      <br/>
      Additionally, the computer code that implements the dispatch and advance steps are the epilog computer code (see step 711 of FIG. 7).
      <br/>
      As each section of code differs only by an initial assembly language instruction, pointers may be utilized to access a single section of computer code.
    </p>
    <p num="96">
      Accordingly, section 1003 includes computer code to execute the IADD bytecode when the interpreter is in either the ITOS or VTOS states.
      <br/>
      As shown in FIG. 10, pointer AV from dispatch table 901 in FIG. 9 points to the first instruction in section 1003 so that the initial instruction that puts the interpreter from the VTOS state into the ITOS state is executed.
      <br/>
      Pointer AI from the dispatch table points to the second instruction in section 1003 since the interpreter is in the ITOS state.
      <br/>
      As shown, whether the interpreter is in the VTOS or ITOS state, the computer code specified by pointer AI will direct the interpreter to execute IADD bytecodes.
    </p>
    <p num="97">
      States LTOS, FTOS and DTOS for the IADD bytecode in dispatch table 901 represent illegal states for the bytecode.
      <br/>
      Accordingly, pointers AL, AF and AD pointer to a section 1005 of computer code in FIG. 10 that handles the error.
      <br/>
      The computer code in section 1005 typically indicates to the user that the interpreter has been placed in an illegal state (see also step 715 of FIG. 7).
      <br/>
      For simplicity, one section of computer code is shown that handles errors; however, more than one section of computer code (or none if error checking is not desired) may be utilized.
      <br/>
      Additionally, the sections of computer code the execute virtual machine instructions or handle errors may be arranged in any order.
    </p>
    <p num="98">
      Having discussed an example, it may be beneficial to describe a process of executing a virtual machine instruction with an interpreter according to one embodiment as shown in FIG. 11. The process shown may be utilized to execute virtual machine instructions in an interpreter generated as described herein.
      <br/>
      However, the process may be utilized with interpreters that are generated by other methods so the interpreter generation described should not be taken as limiting the implementation of the interpreter.
    </p>
    <p num="99">
      At step 1101, a computer system puts the interpreter in the expected state, where the expected state is the interpreter state that is expected before a selected virtual machine instruction is executed.
      <br/>
      In other embodiments, the expected state is the interpreter state that is expected before the computer code in the interpreter that executes the selected virtual machine instruction is run (e.g., the computer code generated by the template function).
      <br/>
      Step 1101 occurs during interpreter execution and corresponds to the prolog computer code generated at step 707 of FIG. 7 during interpreter generation.
      <br/>
      If the system is in the expected state, this step may be omitted.
    </p>
    <p num="100">
      The system executes the selected virtual machine instruction at step 1103.
      <br/>
      This step occurs during interpreter execution and corresponds to the computer code generated by the template function at step 709 of FIG. 7 during interpreter generation.
    </p>
    <p num="101">
      Once the selected virtual machine instruction has been executed, the system fetches the next virtual machine instruction at step 1105.
      <br/>
      Utilizing the next virtual machine instruction, the system calculates an offset into the dispatch table at step 1107.
      <br/>
      The current state of the interpreter after execution of the selected virtual machine instruction is known.
      <br/>
      Therefore, the current state along with the next virtual machine instruction may be utilized to calculate an offset into the dispatch table that specifies the location in the interpreter to execute the next virtual machine instruction.
      <br/>
      In a preferred embodiment where the dispatch table is implemented as multiple single-dimensional subtables, one for each interpreter state, the current state specifies the subtable and the offset is calculated utilizing the next virtual machine instruction (e.g., virtual machine instruction * a fixed size).
    </p>
    <p num="102">
      At step 1109, the system jumps to the address or location in the interpreter stored in the field at the offset in the dispatch table.
      <br/>
      The field may include a pointer to a location in the interpreter that executes the next virtual machine instruction.
      <br/>
      Thus, the jump may cause the system to go back to step 1101 for the next virtual machine instruction.
    </p>
    <p num="103">
      Steps 1105, 1107 and 1109 occur during interpreter execution and correspond to the computer code generated by the epilog computer code at step 711 of FIG. 7 during interpreter generation.
      <br/>
      It should be noted that with the embodiment of the invention shown in FIG. 11, explicit error checking is not required.
      <br/>
      Instead, if there is an error, the system may jump to computer code to handle the error at step 1109.
      <br/>
      Accordingly, error checking may be achieved without an impact on performance.
    </p>
    <p num="104">Conclusion</p>
    <p num="105">
      While the above is a complete description of preferred embodiments of the invention, various alternatives, modifications and equivalents may be used.
      <br/>
      It should be evident that the invention is equally applicable by making appropriate modifications to the embodiments described above.
      <br/>
      For example, the embodiments described have been in reference to increasing the performance of the Java virtual machine interpreting bytecodes, but the principles of the present invention may be readily applied to other systems and languages.
      <br/>
      Therefore, the above description should not be taken as limiting the scope of the invention which is defined by the meets and bounds of the impended claims along with their full scope of equivalents.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>In a computer system including a plurality of registers, a method for implementing an interpreter including an operand stack having a top, the method comprising:</claim-text>
      <claim-text>storing a value for the top of the operand stack in at least one register of the plurality of registers;</claim-text>
      <claim-text>and utilizing a state of the interpreter to indicate a data type of the value for the top of the operand stack that is stored in the at least one register; wherein the data type is selected from a group that includes at least integer and void data types, wherein the void data type indicates that the value for the top of the operand stack is not currently stored in the at least one register;</claim-text>
      <claim-text>and wherein the plurality of registers includes at least two registers that are used for storing values of different data types.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein the group that the data type is selected from further includes long integer, single-precision floating point, and double-precision floating point.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 1, wherein an instruction that utilizes the top of the operand stack accesses the at least one register.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 1, wherein the data type indicated by the state of the interpreter specifies the at least one register of the plurality of registers that stores the top of the operand stack.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 4, wherein the interpreter is a Java virtual machine.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. In a computer system, a method for generating an interpreter, the method comprising: selecting a virtual machine instruction to be interpreted by the interpreter; selecting a state of the interpreter, wherein the state of the interpreter indicates a data type of the value associated with the instruction; generating computer code for the interpreter to put the interpreter in an expected state for the selected virtual machine instruction if the selected state differs from an expected state;</claim-text>
      <claim-text>and generating computer code for the interpreter to execute the selected virtual machine instruction.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 6, wherein the expected state for the interpreter is obtained by accessing a table indexed by virtual machine instructions that stores expected states of the interpreter before execution of the virtual machine instructions.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 7, wherein the table stores current states of the interpreter after execution of the virtual machine instructions.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 7, wherein the table stores pointers to functions that generate computer code for the interpreter to execute the virtual machine instructions.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of claim 6, wherein the computer code for the interpreter to execute the selected function is generated by calling a function specified in a table indexed by virtual machine instructions that stores pointers to functions that generate computer code for the interpreter to execute the virtual machine functions.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 6, further comprising generating computer code for the interpreter to fetch the next virtual machine instruction.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 11, further comprising generating computer code for the interpreter to jump to a location in the interpreter that executes the next virtual machine instruction for a current state of the interpreter after execution of the selected virtual machine instruction.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 12, wherein the location in the interpreter handles an error if the selected virtual machine instruction is illegal for the selected state.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 6, wherein the interpreter is a Java virtual machine.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A computer program product that generates an interpreter, the computer program product comprising: computer code that selects a virtual machine instruction to be interpreted by the interpreter; computer code that selects a state of the interpreter, wherein the state of the interpreter indicates a data type of the value associated with the instruction; computer code that generates computer code for the interpreter to put the interpreter in an expected state for the selected virtual machine instruction if the selected state differs from the expected state; computer code that generates computer code for the interpreter to execute the selected virtual machine instruction;</claim-text>
      <claim-text>and a computer readable medium that stores the computer codes.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The computer program product of claim 15, wherein the computer readable medium is selected from the group consisting of CD-ROM, floppy disk, tape, flash memory, system memory, hard drive, and data signal embodied in a carrier wave.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. A data structure stored by a computer readable medium for use in creating an interpreter of virtual machine instructions, comprising: a table stored by the computer readable medium, the table indexed by the virtual machine instructions; a first field in the table stored by the computer readable medium, the first field storing expected states of the interpreter before execution of the virtual machine instructions; a second field in the table stored by the computer readable medium, the second field storing current states of the interpreter after execution of the virtual machine instructions.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The data structure of claim 17, further comprising a third field in the table stored by the computer readable medium, the third field storing pointers to functions that generate computer code for the interpreter to execute the virtual machine instructions.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The data structure of claim 17, wherein states of the interpreter indicate a data type of a value for the top of an operand stack of the interpreter that is stored in at least one register.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The data structure of claim 19, wherein the data type is selected from the group consisting of integer, long integer, single-precision floating point, and double-precision floating point.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The data structure of claim 17, wherein the data type is void to indicate that the value for the top of the operand stack is not currently stored in the at least one register.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. A data structure stored by a computer readable medium for use by an interpreter of virtual machine instructions, the data structure being indexed by the virtual machine instructions and including a plurality of fields in the table stored by the computer readable medium, each field being associated with a state of the interpreter, wherein at least some of the fields store associated pointers to locations in the interpreter that execute the associated indexed virtual machine instructions.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The data structure of claim 22, wherein the data structure includes a plurality of fields for each virtual machine instruction, wherein each field is associated with a particular data type, wherein the fields include a plurality selected from the group consisting of integer, long integer, single-precision floating point, double-precision floating point, and void.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A data structure as recited in claim 23 wherein the data structure is implemented a plurality of single dimensional tables.</claim-text>
    </claim>
  </claims>
</questel-patent-document>