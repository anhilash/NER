<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06195466B1.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as first publication">
      <document-id>
        <country>US</country>
        <doc-number>06195466</doc-number>
        <kind>B1</kind>
        <date>20010227</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6195466</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B1</original-publication-kind>
    <application-reference is-representative="YES" family-id="25297660" extended-family-id="13416823">
      <document-id>
        <country>US</country>
        <doc-number>09378616</doc-number>
        <kind>A</kind>
        <date>19990820</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09378616</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>13701295</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>37861699</doc-number>
        <kind>A</kind>
        <date>19990820</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09378616</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>84635297</doc-number>
        <kind>A</kind>
        <date>19970430</date>
        <priority-linkage-type>3</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-08846352</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010227</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   1/02        20060101AFI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>1</main-group>
        <subgroup>02</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   5/00        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>5</main-group>
        <subgroup>00</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   7/548       20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>548</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="4">
        <text>G06T   1/20        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>1</main-group>
        <subgroup>20</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="5">
        <text>G06T   9/00        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>9</main-group>
        <subgroup>00</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="6">
        <text>H03M   7/30        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>7</main-group>
        <subgroup>30</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="7">
        <text>H04N   7/30        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>N</subclass>
        <main-group>7</main-group>
        <subgroup>30</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>382250000</text>
        <class>382</class>
        <subclass>250000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>382244000</text>
        <class>382</class>
        <subclass>244000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06T-009/00T</text>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>009</main-group>
        <subgroup>00T</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06T-009/007</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>9</main-group>
        <subgroup>007</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>2</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>13</number-of-drawing-sheets>
      <number-of-figures>18</number-of-figures>
      <image-key data-format="questel">US6195466</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Reversible DCT for lossless-lossy compression</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>ALLEN JAMES D, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5129015</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5129015</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>OHTA MUTSUMI</text>
          <document-id>
            <country>US</country>
            <doc-number>5703799</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5703799</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>OAMI RYOMA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5790441</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5790441</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <related-documents>
      <division>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>84635297</doc-number>
              <kind>A</kind>
              <date>19970430</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>6058215</doc-number>
              <kind>A</kind>
            </document-id>
          </parent-doc>
        </relation>
      </division>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Ricoh Company, Ltd.</orgname>
            <address>
              <address-1>Tokyo, JP</address-1>
              <city>Tokyo</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </applicant>
        <applicant data-format="original" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>Ricoh Corporation</orgname>
            <address>
              <address-1>Menlo Park, CA, US</address-1>
              <city>Menlo Park</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="3">
          <addressbook lang="en">
            <orgname>RICOH</orgname>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Schwartz, Edward L.</name>
            <address>
              <address-1>Sunnyvale, CA, US</address-1>
              <city>Sunnyvale</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Zandi, Ahmad</name>
            <address>
              <address-1>Cupertino, CA, US</address-1>
              <city>Cupertino</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Blakely, Sokoloff, Taylor &amp; Zafman LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Tran, Phuoc</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A reversible Discrete Cosine Transform (DCT) is described.
      <br/>
      The reversible DCT may be part of a compressor in a system.
      <br/>
      The system may include a decompressor with a reversible inverse DCT for lossless decompression or a legacy decompressor with an inverse DCT for lossy decompression.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This application is a division of application Ser.
      <br/>
      No. 08/846,352 filed Apr. 30, 1997, now U.S. Pat. No. 6,058,215.
    </p>
    <heading>FIELD OF THE INVENTION</heading>
    <p num="2">The present invention relates to the field of compression and decompression systems; more particularly, the present invention relates to lossless discrete cosine transform (DCT)-based compression which is reversible.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="3">
      The Discrete Cosine Transform (DCT) is an irrational transform commonly used in lossy image compression.
      <br/>
      The DCT is commonly used in lossy image compression.
      <br/>
      It is used in many modes of the JPEG standard and the MPEG standards and future HDTV in the United States.
      <br/>
      For a discussion on the various standards, see ISO Standard documents ISO/EEC 10918 (JPEG), 11172 (MPEG 1), 13818 (MPEG 2) and William B. Pennebaker and Joan L. Mitchell, "JPEG Still Image Data Compression Standard," 1993.
      <br/>
      The basis vectors of DCT have irrational values.
      <br/>
      Theoretically, integer inputs result in irrational transform coefficients.
      <br/>
      Therefore, infinite precision is required to perform those transforms exactly.
      <br/>
      For use in compression, transform coefficients must be rounded to a finite representation.
    </p>
    <p num="4">
      With most transform implementations, the rounding coefficients to integers does not guarantee that every unique integer input results in a different output.
      <br/>
      Therefore, the inverse DCT cannot reconstruct the input exactly.
      <br/>
      The error due to forward and inverse DCT transforms without quantization is referred to as systemic error.
      <br/>
      This systemic error prevents DCT implementations from being used in lossless compression without retaining a difference or error image.
    </p>
    <p num="5">
      In practical DCT implementations, the transform basis vectors are also rounded.
      <br/>
      The difference between a given implementation and the ideal transform (or a high accuracy floating point implementation) is referred to as mismatch.
      <br/>
      Low mismatch is required for data interchange.
      <br/>
      There can be a trade-off between the amount of mismatch and speed, cost and other desirable features.
    </p>
    <p num="6">
      A parameterized transform referred to herein as the Allen Parameterized Transform (APT) is a family of fast transforms which can implement the DCT or rational transforms that are arbitrarily close to the DCT.
      <br/>
      The APT is also referred to as a generalized Chen transform (GCT) For more information on the APT, see J. Allen, "Generalized Chen Transform: A Fast Transform for Image Compression," Journal of Electronic Imaging, Vol. 3(4), October 1994, pgs. 341-347; J. Allen, "An Approach to Fast Transform Coding in Software," Signal Processing: Image Communication, Vol. 8, pp. 3-11, 1996; and U.S. Pat. No. 5,129,015.
    </p>
    <p num="7">
      The present invention provides a reversible block based transform, such as, for example, a reversible DCT.
      <br/>
      The DCT of the present invention may be included in a DCT-based compressor/decompressor that may be used in a lossless compression/decompression system.
      <br/>
      The present invention also provides DCT transforms with no systemic error and no (or low) mismatch.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="8">
      A reversible Discrete Cosine Transform (DCT) is described.
      <br/>
      The reversible DCT may be part of a compressor in a system.
      <br/>
      The system may include a decompressor with a reversible inverse DCT for lossless decompression or a legacy decompressor with an inverse DCT for lossy decompression.
    </p>
    <p num="9">
      In one embodiment, the compressor comprises a DCT compressor having a multiple rotations (e.g., 2 point (2 * 2) integer rotations), a 4 point parametrized transform, and a subsidiary matrix.
      <br/>
      The 4 point transform comprises a rotation by B, while the subsidiary matrix comprises a rotation by A and a rotation by C.
    </p>
    <p num="10">The present invention also provides a method for creating a look up table for rounding offsets for use in a reversible DCT.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="11">
      The present invention will be understood more fully from the detailed description given below and from the accompanying drawings of various embodiments of the invention, which, however, should not be taken to limit the invention to the specific embodiments, but are for explanation and understanding only.
      <br/>
      FIG. 1A is a block diagram of one embodiment of a lossless and lossy DCT based compression system.
      <br/>
      FIG. 1B is a block diagram of one embodiment of the compressor of the present invention.
      <br/>
      FIG. 1C is a block diagram of an alternate embodiment of the compressor of the present invention.
      <br/>
      FIG. 2 is a block diagram of one embodiment of a video authoring system.
      <br/>
      FIG. 3A illustrates a block diagram of one embodiment of a one dimensional (1D), 8-point forward parameterized transform.
      <br/>
      FIG. 3B illustrates intermediate values in a parameterized transform which have the same scale factor.
      <br/>
      FIG. 4 illustrates the Hein form of the subsidiary matrix of FIG. 3A.
      <br/>
      FIG. 5A is a block diagram of one embodiment of an 8-point Hadamard transform according to the present invention.
      <br/>
      FIG. 5B is a block diagram of one embodiment of an 8-point Haar transform according to the present invention.
      <br/>
      FIG. 5C is a block diagram of one embodiment of a 4-point Sine transform according to the present invention.
      <br/>
      FIG. 5D is a block diagram of one embodiment of a 4-point Slant transform according to the present invention.
      <br/>
      FIG. 6 illustrates one embodiment of a forward ladder filter of a 2-point rotation.
      <br/>
      FIG. 7 illustrates one embodiment of an inverse ladder filter of a 2-point rotation.
      <br/>
      FIG. 8 illustrates a portion of the mapping for a 45 (degree)  rotation.
      <br/>
      FIG. 9 illustrates extras ("+") and collisions ("o") for 45 (degree)  rotation.
      <br/>
      FIG. 10 is a plot of collisions and extras in a 2,1 almost balanced transform.
      <br/>
      FIG. 11 illustrates one embodiment of a look up table of part of a "B" 2-point rotation.
      <br/>
      FIG. 12 is a block diagram of one embodiment of a rotation according to the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PRESENT INVENTION</heading>
    <p num="12">
      A reversible DCT-based compression/decompression apparatus and method are described.
      <br/>
      In the following detailed description of the present invention numerous specific details are set forth, such as types of transforms, coefficient sizes, etc., in order to provide a thorough understanding of the present invention.
      <br/>
      However, it will be apparent to one skilled in the art that the present invention may be practiced without these specific details.
      <br/>
      In other instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.
    </p>
    <p num="13">
      Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory.
      <br/>
      These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art.
      <br/>
      An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result.
      <br/>
      The steps are those requiring physical manipulations of physical quantities.
      <br/>
      Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated.
      <br/>
      It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.
    </p>
    <p num="14">
      Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory.
      <br/>
      These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art.
      <br/>
      An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result.
      <br/>
      The steps are those requiring physical manipulations of physical quantities.
      <br/>
      Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated.
      <br/>
      It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.
    </p>
    <p num="15">
      It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities.
      <br/>
      Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as "processing" or "computing" or "calculating" or "determining" or "displaying" or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.
      <br/>
      Such computer systems typically employ one or more processors to process data, which are coupled to one or more memories via one or more buses.
    </p>
    <p num="16">
      The present invention also relates to apparatus for performing the operations herein.
      <br/>
      This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer.
      <br/>
      Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magneto-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnet or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.
      <br/>
      The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus.
      <br/>
      Various general purpose machines may be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps.
      <br/>
      The required structure for a variety of these machines will appear from the description below.
      <br/>
      In addition, the present invention is not described with reference to any particular programming language.
      <br/>
      It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.
    </p>
    <p num="17">Overview of the Present Invention</p>
    <p num="18">
      The present invention provides a reversible transform that allows DCT-based compression to be lossy and lossless.
      <br/>
      Reversible Transforms are efficient transforms implemented with integer arithmetic whose compressed results can be reconstructed into the original.
      <br/>
      One embodiment of the reversible transform is an extension of the APT.
    </p>
    <p num="19">
      The reversible transforms of the present invention are efficient (or almost efficient), in that there is no redundancy in the least significant bits of the coefficients.
      <br/>
      That is, the transforms of the present invention are efficient in that they do not require a large number of bits of precision (which would otherwise be used in an attempt to eliminate the systemic error.
      <br/>
      Efficiency leads to better lossless compression than using a non- reversible transform with a difference image.
      <br/>
      Several methods of constructing reversible APT implementations are described below.
      <br/>
      The reversible APT has many applications, such as in video authoring systems.
    </p>
    <p num="20">
      While transform coefficients may be rounded to any degree of precision, the present invention rounds transform coefficients to integers.
      <br/>
      Rounding more coarsely than to integers eliminates information and is a type of quantization.
      <br/>
      Rounding more finely than to integers introduces redundancy in the least significant bits of the transform coefficients, hindering compression.
    </p>
    <p num="21">
      The present invention provides DCT transforms with no systemic error.
      <br/>
      Because there is no systemic error, the transforms are reversible, or lossless, transforms.
      <br/>
      These reversible transforms can be used for lossless compression.
    </p>
    <p num="22">
      The present invention provides reversible DCT transforms which have low mismatch.
      <br/>
      Minimum quantization matrices are given for  +- 1 mismatch of quantized coefficients.
      <br/>
      If the minimum or greater quantization is used, the resulting coefficients can be used with any inverse DCT.
    </p>
    <p num="23">The present invention may be implemented in hardware of software, or a combination of both.</p>
    <p num="24">System Overview</p>
    <p num="25">
      The reversible DCT of the present invention may be used in lossless or lossy systems containing either a reversible inverse DCT to obtain exactly what was originally input or containing a prior art (not reversible) inverse DCT.
      <br/>
      A prior art DCT would be able to take the output of the reversible DCT because of its low enough mismatch with the true DCT to obtain exactly the same result as the normal DCT.
      <br/>
      In other words, a MPEG or JPEG decoder with a legacy DCT decoder may be used with the reversible DCT of the present invention.
    </p>
    <p num="26">
      FIG. 1 is a block diagram of one embodiment of a lossless and lossy DCT based compression system.
      <br/>
      Note that although the present invention is described at times in terms of a DCT-based system, the present invention is applicable to other block-based transforms.
      <br/>
      Referring to FIG. 1, input data 100 (e.g., an input image) is compressed with a reversible DCT based compressor 101 of the present invention.
      <br/>
      The input image 100 may be retrieved from a memory or received from a channel, both of which have not been shown to avoid obscuring the present invention.
      <br/>
      The input image may be generated by a camera, a digitizer, a scanner, a frame grabber, or other well-known or similarly functioning device.
      <br/>
      The results of the compression are a plurality of coefficients that may be output to a channel or to a storage device.
      <br/>
      Note that other types of compression may follow or precede the use of the DCT-based compressor.
    </p>
    <p num="27">
      For lossless decompression, a decompressor with a reversible inverse DCT (IDCT) 102 is used on unquantized coefficients to exactly reconstruct the original.
      <br/>
      For lossy decompression, transform coefficients are quantized and then may be decompressed with a decompressor using any inverse DCT (IDCT) 103. As discussed above, the lossy decompressor may be a legacy system such as a JPEG or MPEG compliant decoder.
    </p>
    <p num="28">
      In one embodiment, the DCT compressor receives pixel components into a DCT transform, the output of which undergoes zigzag ordering to produce frequency coefficients.
      <br/>
      Thereafter, the coefficients typically undergo lossless entropy coding.
      <br/>
      Similarly, in the inverse DCT compressor, frequency coefficients undergo lossless entropy encoding and then are input to a zigzag unordering block and thereafter to a DCT transform to retrieve the pixel components.
    </p>
    <p num="29">
      Compressor 101 is shown coupled to decompressors 102 and 103 through a channel or storage device 104.
      <br/>
      They may not be physically coupled together at all.
      <br/>
      That is, data may be compressed and stored using the compressor and an entirely separate decompression system may access the information, or copies thereof, to access the compressed information.
      <br/>
      In this manner, the channel or storage is transparent.
    </p>
    <p num="30">
      FIG. 1B illustrates is a block diagram of one embodiment of the compressor of the present invention.
      <br/>
      Referring to FIG. 1B, the compressor includes color space or subsampling block 121 which performs color space conversion or subsampling of the input data.
      <br/>
      This is an optional block and may not be included in some compressors.
      <br/>
      In one embodiment, the color space performed by block 121 is reversible.
    </p>
    <p num="31">
      The output of color space/subsampling block 121 is coupled to reversible DCT 122.
      <br/>
      The transformed values output from reversible DCT 122 are coupled to the input of zigzag ordering block 123, which performs well-known zig-zag ordering techniques.
      <br/>
      It should be noted that this zigzag ordering block 123 is also optional.
      <br/>
      The output of zigzag ordering block 123 is coupled to run length block 124 which identifies run lengths of zeros.
      <br/>
      The output of run length block 124 is coupled to the input of Huffman coder 125, which performs Huffman coding.
      <br/>
      The output of the Huffman coding block is coupled to the input of signaling block 126 which sets forth the signaling for the decoder to indicate to the decoder what type of quantization or decoding options were taken to enable the decoder to effectively decode the encoded data.
      <br/>
      In one embodiment, signaling block 126 generates a header that precedes the compressed data and indicates to the decoder the information to enable decoding.
      <br/>
      Optionally, quantization with scale factors may be applied after the reversible DCT block 122 and prior to zigzag ordering block 123.
      <br/>
      Such quantization with scale factors is described in more detail below.
    </p>
    <p num="32">
      FIG. 1C is a block diagram of an alternate embodiment of the compressor of the present invention Referring to FIG. 1C, color space/subsampling block 121 is coupled to reversible DCT 122.
      <br/>
      The output of reversible DCT 122 is coupled to an optional, quantization with scale factors block 127.
      <br/>
      The output of the quantization with scale factors block 127 is coupled to the input of context model 133.
      <br/>
      Context model 133 produces the context for the data.
      <br/>
      These contexts are forwarded to the probability estimation machine (PEM) 134. The PEM 134 generates probability estimates for the data based on contexts received.
      <br/>
      These probability estimates are output to bit stream generator (BG) 135 which generates the output bit stream based on the context from context model 133 and the probability estimates from PEM 134.
      <br/>
      The output of bit stream generator 135 is coupled to signaling block 126.
    </p>
    <p num="33">
      FIG. 2 is a block diagram of an example application of the present invention to a video authoring system.
      <br/>
      Referring to FIG. 2, one or more input devices, such as cameras 201, capture or obtain video images.
    </p>
    <p num="34">
      During capture, video is compressed losslessly by lossless compressor 202, which is coupled to camera(s) 201. In one embodiment, this allows approximately a factor of two savings in bandwidth and storage while not introducing any degradation.
      <br/>
      In other words, there are no artifacts.
      <br/>
      Although the eventual target compression ratio for video is typically 100:1 lossy compression, initial lossless compression preserves information for enhancement, digital effects and any frame to be a high quality I-frame (for video compression). I-frames are well-known in the art of video compression and are compressed like a still image according to such compression standards as MPEG and HDTV.
    </p>
    <p num="35">
      The output of compressor 202 is coupled to extraction block 203.
      <br/>
      For editing, quantized DCT coefficients can be extracted by extraction block 203, (transcoded if necessary) and fed to a motion JPEG decompressor 204 to which it is coupled.
      <br/>
      Extraction block 203 may operate by determining which frames are desired and/or selecting only a certain number of bits of each coefficient.
      <br/>
      For instance, Table 13 described below indicates the number of bits to discard, (in other words, which bits to keep).
      <br/>
      In another embodiment, extraction block 203 may only select some of the blocks, thereby clipping the image.
    </p>
    <p num="36">
      The motion JPEG decompressor 204 may be a low cost device or any legacy device.
      <br/>
      Because the compressed data is already in the DCT transform domain, the computation required to try different cuts and to experiment with different quantizations is reduced.
      <br/>
      Thus, this embodiment allows information to be viewed as video real-time, without very much extra processing.
      <br/>
      After the editor has decided what information to keep (e.g., what frames will be in the final version), a lossless decompressor, such as decompressor 205, can be used to recover the original data.
      <br/>
      Note that the data may be retrieved from a store that contains only the edited data or which contains all or some portion of the original input data.
      <br/>
      In this case, some logic or processing would be needed to access the correct information for decompression.
      <br/>
      This processing/logic would be well- known to one skilled in the art.
    </p>
    <p num="37">
      An enhancement mechanism 206 may be coupled to decompressor 205 to enhance or preprocess the original data, if necessary, without the possibility of compression artifacts being exaggerated.
      <br/>
      Examples of such enhancement or preprocessing include enlarging part of an image, interpolate between frames to do slow motion, sharpening, noise reduction, etc.
      <br/>
      These and other well-known enhancement mechanisms are well-known in the art.
    </p>
    <p num="38">
      After any enhancement, a compressor 207 performs a full MPEG compression with motion compensation to generate the final compressed data.
      <br/>
      Compressor 207 is well-known in the art.
    </p>
    <p num="39">
      While the reversible DCT could be used with any lossless decompression application, it is most useful when used with legacy lossy DCT based systems.
      <br/>
      Other unified lossy/lossless compression system such as compression with reversible wavelets might be used if legacy system compatibility is not important.
    </p>
    <p num="40">
      The present invention may be extended to any block based transform or any non-overlapped transform that can be decomposed into 2-point rotations.
      <br/>
      For example, the present invention may be used with the following transforms: DFT/unitary DFT, cosine, sine, Hadamard, Haar, Slant, Karhunen-Loeve, Fast KC, Sinusoidal transforms, a SVD transform, lapped orthogonal transform (LOT), as well as others.
      <br/>
      See Jain, Anil K., Fundamentals of Digital Processing, Prentice-Hall, Inc. 1989, pgs. 132-138. Given these examples and the examples described below, it would be apparent to one skilled in the art to implement other transforms.
    </p>
    <p num="41">Fast DCT Decompositions With the APT</p>
    <p num="42">
      The Allen Parametrized Transform (APT), formally referred to as the Generalized Chen Transform (GCT), reduces the DCT and a family of other related transforms to a cascade of "integer rotations".
      <br/>
      In one embodiment, each rotation comprises a transform with the absolute value for its determinant being 1.
      <br/>
      The present invention obtains a reversible DCT by decompressing the DCT into a multiple reversible components.
      <br/>
      Because the individual parts are reversible, the DCT is reversible.
    </p>
    <p num="43">
      FIG. 3A illustrates a block diagram of a 1D, 8-point forward APT.
      <br/>
      Most of the APT transform is composed of two point rotations which are labeled by the arc tangent of a rotation angle. (The rotations are shown as "clockwise" and with their determinant equal to -1.)
    </p>
    <p num="44">
      Referring to FIG. 3A, the 8-point transform can be grouped into four initial rotations by 45 (degree)  (arctan=1) 340, a 4-point APT 320, and a "subsidiary matrix" 330.
      <br/>
      The subsidiary matrix 330 contains two multiplications in addition to multiple 2-point rotations.
    </p>
    <p num="45">
      Thus, there are three sets of rotations that form the forward APT transform.
      <br/>
      First, a set of 2-point (2 * 2) rotations 301-304 provide an input stage.
      <br/>
      Outputs from each of rotations 301-304 are coupled to the inputs of four point APT block 320, which contains 2-point rotations 305-308, and subsidiary matrix 330, which contains 2-point rotations 309 and 312-315 and multipliers 310 and 311.
    </p>
    <p num="46">
      Specifically, rotation 301 receives inputs 0 and 7 corresponding to two input data samples and generates one output to an input of rotation 305 and another output to an input to rotation 312.
      <br/>
      Rotation 302 is coupled to receive input data samples 1 and 6 and provides two outputs, one coupled to an input of rotation 306 and one coupled to the input of rotation 309.
      <br/>
      Rotation 303 is coupled to receive input data samples 2 and 5 and generates two outputs, one of which is coupled to the other input to rotation 306 and another coupled to the other input to rotation 09.
    </p>
    <p num="47">Rotation 304 is coupled to receive input data samples 3 and 4 and generates two outputs, one of which is coupled to the other input of rotation 305 and an input to rotation 313.</p>
    <p num="48">Rotation 305 generates two outputs, one of which is coupled to an input of rotation 307 and the other is coupled to an input of rotation 308.</p>
    <p num="49">
      Rotation 306 generates two outputs, one of which is coupled to the other input of rotation 307 and the other of which is coupled to the other input to rotation 308.
      <br/>
      In response to these inputs, rotation 307 generates the 0 and 4 outputs, while rotation 308 generates the 2 and 6 outputs.
    </p>
    <p num="50">
      With respect to the subsidiary matrix, rotation 309 generates two outputs coupled to multiply-by-R blocks 310 and 311.
      <br/>
      The output of multiply-by-R block 310 is coupled to the other input of rotation 312, while the output of multiply-by-R block 311 is coupled to the other input to rotation 313.
      <br/>
      In response to its inputs, rotation 312 generates two outputs that are coupled to an input to rotations 314 and 315.
      <br/>
      Similarly, in response to its inputs, rotation 313 generates outputs which are coupled to an input to rotation 314 and input to rotation 315.
      <br/>
      In response to these outputs, rotations 314 and 315 generate the 1 and 7 outputs and the 3 and 5 outputs respectively.
      <br/>
      The A, B, and C rotations will be described in more detail below.
      <br/>
      In one embodiment, each of rotations 301-304 may be the S-transform.
      <br/>
      However, in such a case, mismatch may suffer.
    </p>
    <p num="51">
      The subsidiary matrix shown in FIG. 3A is the Chen form.
      <br/>
      An alternative due to Hein and Allen, J. Allen, and described by J. Allen in, "Generalized Chen Transform: A Fast Transform for Image Compression," Journal of Electronic Imaging, Vol. 3(4), October 1994, pgs. 341-347, is shown in FIG. 4.
      <br/>
      Referring to FIG. 4, the subsidiary matrix comprises six rotations (by angle).
      <br/>
      A pair of rotations by an angle of a rotation by 45 (degree)  (or arctan=1) are coupled to receive two inputs each and generate two outputs.
      <br/>
      One of the outputs of each of rotations 401 and 402 is coupled to the inputs of rotation 403, while the other two outputs of rotations 401 and 402 are coupled to the inputs to rotation 404.
      <br/>
      In response to these inputs, rotations 403 and 404 generate two outputs.
    </p>
    <p num="52">
      Rotations 403 and 404 comprise the B rotation.
      <br/>
      One of the outputs of each of rotations 403 and 404 is coupled to the inputs of rotation 405 while the other outputs of each of rotations 403 and 404 is coupled to the inputs to rotation 406.
      <br/>
      Rotations 405 and 406 comprise the A and C rotations respectively.
      <br/>
      Each of rotations 405 and 406 generate the two outputs, 1 and 7 and 5 and 3, respectively.
      <br/>
      In one embodiment, the rotations are 2 point (2 * 2) rotations.
      <br/>
      Each rotation may comprise a 2 point transform or filter.
    </p>
    <p num="53">
      The outputs are scaled to match the DCT.
      <br/>
      That is, the present invention generates outputs that require the use of scale factors to change the outputs to match those that would result had a floating-point DCT been used.
      <br/>
      For lossy compression/decompression, scale factors may be combined with quantization factors.
      <br/>
      The scale factor used for each output can be determined from the product of the individual scale factors for each 2-point rotation.
      <br/>
      For the 2-point rotation matrix of the form shown in FIG. 3A, the scale factor for both outputs of every rotation is given by the following equation:  (Equation image '1' not included in text)
    </p>
    <p num="54">For the following 2-point transforms:  (Equation image '2' not included in text)</p>
    <p num="55">the scale factor is  (Equation image '3' not included in text)</p>
    <p num="56">For the following 2-point transforms:  (Equation image '4' not included in text)</p>
    <p num="57">the scale factor is  (Equation image '5' not included in text)</p>
    <p num="58">for an output due to a,b and  (Equation image '6' not included in text)</p>
    <p num="59">for an</p>
    <p num="60">output corresponding to c,d.</p>
    <p num="61">The separable two dimensional (2D), 64 point DCT (APT) can be implemented with eight 1D, 8-point DCTs (APTs), a transpose, and another eight 1D, 8-point DCTs (APTs).</p>
    <p num="62">
      FIG. 3B illustrates intermediate values in the APT which have the same scale factor.
      <br/>
      Referring to FIG. 3B, each shaded lines indicates inputs that have the same scale factor.
      <br/>
      Using the same scale factors constrains the divisors in two-point transforms.
      <br/>
      For example, most rotations by 1 (all but 309) are not required to have the same scale factor for both outputs, so an unbalanced transform such as the S-transform could be used.
      <br/>
      In contrast, the cascade of a rotation by 1 followed by multiplication by R (309) must have the same scale factors on the output as the input.
    </p>
    <p num="63">
      Referring to FIG. 3B, the two inputs for rotation 307 have the same scale factors.
      <br/>
      The two inputs to rotation 308 have the same scale factors.
      <br/>
      The two inputs to rotation 314 have the same scale factors and the inputs to rotation 315 have the same scale factors.
      <br/>
      The inputs to rotations 305 and 306 are the same.
      <br/>
      In the case of rotation 305, this would constrain the upper branches from each of rotations 301 and 304.
      <br/>
      With respect to rotations 312 and 313, not only do their inputs have the same scale factors, but also all the lower branches from each of rotations 301 and 304 have the same scale factors.
      <br/>
      Because the scale factors of the lower branches output from rotations 301 and 304 have the same scale factors as the lower branch outputs of rotations 302 and 303, then the scale factors of all inputs to the subsidiary matrix are the same.
    </p>
    <p num="64">
      The product of the scale factors of two outputs is the amount of expansion.
      <br/>
      Therefore, to be efficient, the product of both scale factors must ideally be 1 to prevent expansion.
      <br/>
      In one embodiment, to be reversible, both scale factors are 1.
      <br/>
      In alternative embodiments, the scale factors can be slightly different.
      <br/>
      For example, both scale factors could 0.99.
    </p>
    <p num="65">
      Table 1 illustrates values for APT parameters for three different embodiments.
      <br/>
      The first set of parameters are the irrational numbers that result in the DCT.
      <br/>
      DCT implementations (APT or other) for compression cannot use the irrational values.
      <br/>
      All actual DCT implementations approximate irrational parameters, even if the approximations are very accurate high precision floating point approximations.
      <br/>
      The APT uses rational approximations with small integers, which leads to tractable reversible implementations.
    </p>
    <p num="66">
      -- TABLE 1
      <br/>
      -- APT parameters
      <br/>
      --      DCT                APT 1          APT 2          APT 3
      <br/>
      -- A    TAN 7  PI /16 .apprxeq. 5.0273 5/1 = 5.0000 5/1 = 5.0000 643/128 =
      <br/>
      --  5.0234
      <br/>
      -- B    TAN 6  PI /16 .apprxeq. 2.4142 12/5 = 2.4000 128/53 = 2.4000 128/53 =
      <br/>
      --  2.4151
      <br/>
      -- C    TAN 5  PI /16 .apprxeq. 1.4966 3/2 = 1.5000 3/2 = 1.5000 383/256 =
      <br/>
      --  1.4961
      <br/>
      -- R    SQRT 1/2 .apprxeq. 0.7071 128/181 = 0.7072 128/181 = 0.7072 128/181 =
      <br/>
      --  0.7072
    </p>
    <p num="67">
      Table 1 shows three sets of APT parameters which trade-off simplicity vs. mismatch.
      <br/>
      APT 1 is simple and good for compression.
      <br/>
      The other examples, APT 2 and APT 3, are closer approximations to the irrational transform.
      <br/>
      APT 3 meets the CCITT Rec. H.261 (IEEE std 1180-1990) accuracy test.
    </p>
    <p num="68">
      The choice of APT parameters is not the only source of mismatch in a reversible transform.
      <br/>
      Reversible, efficient transforms require careful (reversible) rounding to integers at each step of the transform.
      <br/>
      These rounding operations also cause mismatch.
      <br/>
      Some mismatch is unavoidable because methods that result in the same coefficients as a floating point implementation cannot be efficient, reversible.
      <br/>
      Since mismatch due to rounding usually dominates mismatch due to parameter choice, the APT 1 parameters may be a good choice.
      <br/>
      However, the techniques of the present invention could be applied to other parameters.
    </p>
    <p num="69">It should be noted that these APT parameters may be adjusted to obtain other transforms, which may or may not be reversible.</p>
    <p num="70">Reversible DCT Implementations</p>
    <p num="71">
      In the present invention, each 2-point rotation in the APT components are made reversible.
      <br/>
      By making each reversible, the entire APT is made reversible because each step may be reversed.
      <br/>
      In addition to efficiency, two other properties are desirable: balanced scale factors and no internal rounding.
    </p>
    <p num="72">
      A 2-point transform has "balanced" scale factors if the scale factors for both outputs are the same.
      <br/>
      For a transform to be efficient (or almost efficient), it's determinant is  +- 1 (or almost  +- 1).
      <br/>
      If the determinant is constrained to be  +- 1, the product of the scale factor for the two outputs is 1.
      <br/>
      Having both scale factors equal to 1 is desirable.
      <br/>
      In another embodiment, one scale factor is the reciprocal of the other.
      <br/>
      In this case, one scale factor is greater than 1.
      <br/>
      In this manner, the determinant will be  +- 1.
      <br/>
      A scale factor greater than 1 causes quantization, resulting in mismatch.
    </p>
    <p num="73">
      Note that the scale factors in the equation given above are for an APT that is not efficient so their product is not one.
      <br/>
      Having both scale factors less than 1 leads to good rounding allowing for low mismatch, but such a system is not reversible, efficient.
    </p>
    <p num="74">
      Rounding at each step allows reversibility.
      <br/>
      A 2-point rotation with "no internal rounding" indicates that at most only two rounding operations at the output of each step are performed.
      <br/>
      Some implementations have additional rounding operations inside the step, for example the ladder filter implementations described below.
      <br/>
      Extra rounding operations increase mismatch.
    </p>
    <p num="75">
      When used for lossy compression, the DCT is unitary so the same transform can be used for both the forward transform and the inverse transform.
      <br/>
      However, in the present invention, for reversible implementations, the inverse transform inverts the rounding.
    </p>
    <p num="76">Therefore, the inverse transform has the inverse data flow of FIG. 3 with each forward 2-point transform and multiplication replaced with the corresponding inverse transform.</p>
    <p num="77">Reversible Implementations Without Internal Rounding or Look Up Tables</p>
    <p num="78">
      In one embodiment, the present invention provides reversible implementations of 2-point rotations and multiplications that do not require internal rounding or look up tables.
      <br/>
      For parameters that have efficient, balanced 2-point rotations of this type, these are important building blocks.
      <br/>
      Some 2-point transforms are described below that are not balanced or only almost efficient.
      <br/>
      Ladder filter and look up table alternatives are provided.
    </p>
    <p num="79">
      The choice of offsets often controls achieving reversibility.
      <br/>
      A discussion of how only some offsets results in reversible transforms is given below.
    </p>
    <p num="80">"1": 1,1-transform, S-Transform--unbalanced</p>
    <p num="81">In one embodiment, the "1" blocks may be implemented with the following transform where a and b are the inputs to the forward transform and x and y are the outputs of the forward transform:  (Equation image '7' not included in text)</p>
    <p num="82">Note that the floor ((.left brkt-bot...right brkt-bot.)) and ceiling (.left brkt-top...right brkt-top.) functions mean to round towards negative infinity and positive infinity respectively.</p>
    <p num="83">In one embodiment, scale factors are 2 and 1/2 respectively.</p>
    <p num="84">"A":5,1-transform--unbalanced</p>
    <p num="85">The following is one embodiment of the "A" rotation.  (Equation image '8' not included in text)</p>
    <p num="86">
      where the recovered least significant bits are given by the equation (i.e., rounded away bits):
      <br/>
      DELTA .tbd.(5y-13)mod 26
    </p>
    <p num="87">In this embodiment, scale factors are 26 and 1/26 respectively.</p>
    <p num="88">"A":5,1-transform--balanced, inefficient</p>
    <p num="89">The following is an alternate embodiment of the A rotation.  (Equation image '9' not included in text)</p>
    <p num="90">
      where
      <br/>
      DELTA .tbd.(-(25x+5y-12))mod 26
      <br/>
      DELTA 1 = DELTA mod 5
      <br/>
      DELTA =.left brkt-bot.
      <br/>
      DELTA /5.right brkt-bot.
    </p>
    <p num="91">
      This transform has determinant 26/25=1.04. Therefore, the redundancy is log2 1.04=0.06 bits.
      <br/>
      It is inefficient, but close enough to efficient to be useful for lossless compression.
      <br/>
      Because it is balanced, it is more useful for lossy than the balanced efficient version.
    </p>
    <p num="92">In one embodiment, scale factors are both 5/26.</p>
    <p num="93">"A":60,11-transform-balanced, efficient</p>
    <p num="94">Another alternative embodiment of the "A" rotation is as follows:  (Equation image '10' not included in text)</p>
    <p num="95">
      This transform is balanced and efficient.
      <br/>
      This transform uses 11, 60, 61 which is a Pythagorean triplet a, b, c with b+1=c and a2 =2b+1.
      <br/>
      However, the result of 60/11 (congruent to) 5.4545, which is not a very good approximation for tan 7 PI /16 (congruent to) 5.0273. Here, the closeness to the DCT has been sacrificed for balanced, efficiency and simplicity in computation.
    </p>
    <p num="96">In this case, scale factors are both 1.</p>
    <p num="97">"B":12,5-transform</p>
    <p num="98">The following is one embodiment for the "B" rotation:  (Equation image '11' not included in text)</p>
    <p num="99">
      This is both balanced and efficient.
      <br/>
      The numbers 5, 12, 13 are a Pythagorean triplet a, b, c with b+1=c and a2=2 b+1.
      <br/>
      This leads to a very good 4point APT (DCT).
    </p>
    <p num="100">Scale factors are both 1.</p>
    <p num="101">
      Note that offsets are very important for reversibility.
      <br/>
      The choice of +6 for both offsets in the forward transform of the equation above results in a reversible transform, while other offsets do not.
      <br/>
      For example, if the offsets are both zero as in the first set of equations below, then the inputs a=0, b=0 and a=1, b=0 both result in x=0, y=0.  (Equation image '12' not included in text)
    </p>
    <p num="102">It is apparent from this result that the selection of the offset can control reversibility.</p>
    <p num="103">
      Another example is shown below where both offsets are +5.
      <br/>
      In this case, inputs a=4, b=0 and a=4, b=1, both result in x=4, y=1.  (Equation image '13' not included in text)
    </p>
    <p num="104">
      Most pairs offsets do not result in a reversible transform.
      <br/>
      Of the 169 possible pairs of offsets (offsets are 0 . . . 12), the only 13 pairs of offsets that result in reversibility are 0, 10; 1,5; 2,0; 3,8; 4,3; 5,11; 6,6; 7,1; 8,9; 9,4; 10,12; 11,7 and 12,2.
    </p>
    <p num="105">"C": 3,2-transform--unbalanced</p>
    <p num="106">One embodiment of the "C" rotation is as follows:  (Equation image '14' not included in text)</p>
    <p num="107">
      This is an efficient transform.
      <br/>
      In this case, scale factors are 13 and 1/13 respectively.
    </p>
    <p num="108">"C": 3,2-transform--unbalanced with growth in sum</p>
    <p num="109">An alternate embodiment of the "C" rotation, which is unbalanced with growth in the sum, yet efficient, is as follows:  (Equation image '15' not included in text)</p>
    <p num="110">In this case, scale factors are 113 and 13 respectively.</p>
    <p num="111">
      It is convenient in unbalanced transforms to divide the sum by the larger divisor.
      <br/>
      This leads to minimum growth in coefficient size.
      <br/>
      However, the sum leads to more visually relevant coefficients.
      <br/>
      Using the larger divisor on the difference and allowing more growth in the sum leads to lower mismatch in the more visually relevant coefficients.
    </p>
    <p num="112">"C" :4,3-transform-balanced</p>
    <p num="113">An alternate embodiment of the "C" rotation, which is balanced is as follows:  (Equation image '16' not included in text)</p>
    <p num="114">
      This transform is balanced and efficient.
      <br/>
      Again, the number set 3, 4, 5 is a Pythagorean triplet a, b, c with b+1=c and a2 =2b+1.
      <br/>
      However 4/3 (congruent to) 1.3333 is not a very good approximation for tan 5 PI /16 (congruent to) 1.4966.
    </p>
    <p num="115">Scale factors are both 1.</p>
    <p num="116">The Multiplier "R": 2</p>
    <p num="117">
      In one embodiment, the multiplication factor using an integer approximation of 2+L .
      <br/>
      The R factor normalizes the subsidiary matrix.  (Equation image '17' not included in text)
    </p>
    <p num="118">Non-DCT Transforms</p>
    <p num="119">
      FIG. 5A illustrates and 8-point Hadamard transform.
      <br/>
      Referring to FIG. 5A, rotations 501-512 comprise 2-point rotations by tan( PI /4)=1. Rotation 501 is coupled to receive input data samples 0 and 7 and generate outputs to rotations 505 and 507.
      <br/>
      Rotation 502 is coupled to receive input data samples 1 and 6 and generate outputs to rotations 506 and 508.
      <br/>
      Rotation 503 is coupled to receive input data samples 2 and 5 and provide outputs to rotations 506 and 508, while rotation 504 is coupled to receive input data samples 3 and 4 and provide outputs to rotation 505 and 508.
    </p>
    <p num="120">
      In response to its inputs, rotation 505 generates outputs to rotations 509 and 510.
      <br/>
      In response to its inputs, rotation 506 generates outputs to rotations 509 and 510 as well.
      <br/>
      In response to these inputs, rotation 509 generates output samples 0 and 4, and in response to its inputs, rotation 510 generates output samples 2 and 6.
    </p>
    <p num="121">
      Rotation 507 generates outputs to rotation 511 and 512.
      <br/>
      Rotation 508 also generates outputs to rotation 511 and 512.
      <br/>
      In response to these inputs, rotation 505 generates output samples 1 and 5, while rotation 512 generates output samples 3 and 7.
    </p>
    <p num="122">
      FIG. 5B shows an 8-point Haar transform.
      <br/>
      Referring to FIG. 5B, the Haar transform comprises rotations 520-526 which are each 2-point rotations by tan( PI /4)=1. Rotation 520 is coupled to receive input data samples 0 and 1 and generate output data sample 4 and one output to rotation to 524.
      <br/>
      Rotation 521 is coupled to receive input data samples 2 and 3 and generate outputs to rotation 524 and the output data sample 5.
    </p>
    <p num="123">
      Rotation 522 is coupled to receive input data samples 4 and 5 and generate outputs to rotation 525 and output data sample 6.
      <br/>
      Rotation 523 is coupled to receive input data samples 6 and 7 and generate outputs to rotation 525 and the output data sample 7.
      <br/>
      In response to its inputs, rotation 524 generates the output data sample 2 and an output to rotation 526.
      <br/>
      Rotation 525 generates an output to rotation 526 and generates output data sample 3.
      <br/>
      Rotation 526 outputs samples 0 and 1 in response to its inputs.
    </p>
    <p num="124">
      FIG. 5C illustrates on embodiment of the 4 point Sine transform.
      <br/>
      Referring to FIG. 5C, the Sine transform comprises rotations 531-534.
      <br/>
      Rotations 531 and 532 comprise 2-point rotations by tan( PI /4)=1, while rotations 533 and 534 comprise rotations by D which is set forth as the tan(0.1762 PI ).
    </p>
    <p num="125">
      Rotation 531 is coupled to receive the input data samples 0 and 3 and produce outputs to rotations 533 and 534, while rotation 532 is coupled to receive input data samples 2 and 1 and generate outputs to rotations 533 and 534.
      <br/>
      In response to their respective inputs, rotation 533 generates output data samples 0 and 2, while rotation 534 generates output samples 3 and 1.
    </p>
    <p num="126">
      FIG. 5D illustrates one embodiment of the 4-point Slant transform.
      <br/>
      Referring to FIG. 5D, the Slant transform comprises rotations 540-543.
      <br/>
      Rotations 540-542 comprise 2-point rotations by tan(n/4)=1, while rotation 543 comprises a 2-point rotation by tan(0.1024 PI ).
      <br/>
      Rotation 540 is coupled to receive input data samples 0 and 3 and provide outputs to rotations 542 and 543, while rotation 541 is coupled to receive input data samples 2 and 1 and generate outputs to rotations 542 and 543.
      <br/>
      In response to its inputs, rotations 542 generates output data samples 0 and 2, while rotation 543 generates output samples 3 and 1.
      <br/>
      Given these examples described above, one skilled in the art may implement other transforms as well.
    </p>
    <p num="127">Efficient, Reversible 2-point Rotations Using Ladder Filters</p>
    <p num="128">
      Ladder filters can be used to implement any 2-point rotation in a reversible, efficient, balanced fashion.
      <br/>
      Ladder filters have both scale factors equal to 1.
      <br/>
      The equation below is a ladder filter decomposition for a determinant 1 (counterclockwise) rotation.  (Equation image '18' not included in text)
    </p>
    <p num="129">
      To be reversible and efficient, each multiplication is followed by rounding to integer as shown in FIGS. 6 and 7.
      <br/>
      To be reversible, multiplications by irrationals are performed the same in the forward and inverse transforms.
    </p>
    <p num="130">
      Referring to FIG. 6, a ladder filter implementation is shown having inputs 610 and 611.
      <br/>
      Input 611 is coupled to a multiplier 602 which multiplies input 610 by the quantity of cos  THETA -1 divided by sin  THETA .
      <br/>
      The result of the multiplication is rounded to the nearest integer at block 603.
      <br/>
      The results of the rounding are added to input 611 by adder 604.
      <br/>
      The output of adder 604 is coupled to multiplier 606 which multiplies the output of adder 604 by sin  THETA .
      <br/>
      The result is rounded to integer at block 605.
      <br/>
      The results of the rounding are added to input 610 using adder 601.
      <br/>
      The output of adder 601 is one output of the ladder filter, output 612.
      <br/>
      The output of adder 601 is also input to multiplier 607 which multiplies the output of the adder 601 by the quantity of cos THETA -1 divided by sin THETA .
      <br/>
      The results of the multiplication are rounded to integer by block 608.
      <br/>
      The results of rounding are added to the output of adder 604 using adder 609.
      <br/>
      The output of adder 609 is the other output of the ladder filter, output 613.
    </p>
    <p num="131">
      Referring to FIG. 7, two inputs, inputs 701 and 702, are input into the ladder filter.
      <br/>
      Input 701 is input to multiplier 703 which multiplies input 701 by  (Equation image '19' not included in text)
    </p>
    <p num="132">
      The results of the multiplication are rounded to integer by block 704.
      <br/>
      The results of the rounding are subtracted from input 702 by subtractor 705.
      <br/>
      The output of subtractor 705 is coupled to the input of multiplier 706 which multiplies it by sine.
      <br/>
      The results of the multiplication are rounded to integer by block 707.
      <br/>
      The results of the rounding are subtracted from input 701 by subtractor 708.
      <br/>
      The output of subtractor 708 is one output of the ladder filter, output 712.
    </p>
    <p num="133">The output of subtractor 708 is also coupled to the input of multiplier 709 which multiplies it by  (Equation image '20' not included in text)</p>
    <p num="134">
      The results of the multiplication are rounded to integer by block 710.
      <br/>
      The results of the rounding are subtracted from the output of subtractor 705 by subtractor 711.
      <br/>
      The output of subtractor 711 is the other output of the ladder filter, output 713.
    </p>
    <p num="135">
      The effect of the three rounding operations and the effect of the precision of implementing the irrational multiplications causes mismatch error.
      <br/>
      Ladder filter implementations often have more mismatched error than other implementations.
    </p>
    <p num="136">
      Instead of decomposing the whole DCT into 2 * 2 rotations, larger ladder filters can be constructed.
      <br/>
      For example, the 4point DCT can be implemented as a ladder filter by decomposing into three matrices as shown below:  (Equation image '21' not included in text)
    </p>
    <p num="137">These matrices contain the following constants:  (Equation image '22' not included in text)</p>
    <p num="138">Thus the present invention provides a novel 4-point reversible, as well as performing an efficient, reversible 2 * 2 decomposition for the 4 point (4 * 4) rotation.</p>
    <p num="139">It should be noted that although in the above description the transform includes a 2-point DCT, 4-point APT and an 8-point * 8 non-trivial matrix, the present invention may be expanded to other sizes such as 16 * 16, for example.</p>
    <p num="140">Look Up Tables for Efficient Reversible 2-point Rotations</p>
    <p num="141">
      Ladder filters can be used to make an efficient, reversible implementation for any 2-point rotation.
      <br/>
      The present invention provides a look up table based method and apparatus for controlling rounding to create efficient, reversible transforms that have improved rounding.
      <br/>
      Improved rounding reduces mismatch error.
      <br/>
      Balanced transforms can be constructed, and if a transform is balanced, then both scale factors are 1.
    </p>
    <p num="142">
      Given a transform with determinant greater than or equal to 1, a one-to-one or one-to-many mapping input values to transformed values is possible.
      <br/>
      For reversible transforms, only a one-to-one mapping is of interest.
      <br/>
      For transforms with a determinant slightly greater than one, a small number of the possible transformed values can be unused and the mapping can be treated as one-to-one.
    </p>
    <p num="143">
      There are 2-point integer rotations that cannot be made reversible with any fixed choice of rounding offsets.
      <br/>
      For example, consider the following equations which is a 45 (degree)  rotation using the approximation given for APT parameter R in Table 1.  (Equation image '23' not included in text)
    </p>
    <p num="144">
      This is not reversible for any constant rounding offsets.
      <br/>
      However, if the rounding offsets are functions of the inputs, then the function can be made to be reversible.
      <br/>
      That is, the rounding varies as a function of the inputs.
      <br/>
      Furthermore, in this case, the rounding offsets are only functions of the sum and difference of the inputs modulo the divisor of 181.
      <br/>
      An example of the function is described below in conjunction with Table 2.
      <br/>
      Therefore, there are only 181*181=32761 pairs of rounding offsets.
    </p>
    <p num="145">In one embodiment, the modulo portion of the above equation is removed.</p>
    <p num="146">
      FIG. 8 shows a portion of the mapping of input values to output transformed values for the 45 (degree)  rotation.
      <br/>
      The above equality may be rewritten as  (Equation image '24' not included in text)
    </p>
    <p num="147">
      The sum and difference of the inputs are s and d respectively (s=a+b, d=a-b).
      <br/>
      Note the parity of the sum and difference are the same; that is, both are even or both are odd.
      <br/>
      The shaded squares indicate pairs of values that cannot occur since the parity is not the same.
      <br/>
      Only the unshaded pairs of values actually occur.
      <br/>
      Also shown is the s and d divided by 2 with normal rounding to integer.
      <br/>
      The heavy lines group pairs of values with the same s/2 and d/2+L .
      <br/>
      The mapping is one-to-one already for every heavy line region than has a single unshaded square.
      <br/>
      Regions with two unshaded squares indicate problems where "collisions" or "holes" occur, where normal rounding maps two possible inputs to the same transform values and they both would give the same answer.
      <br/>
      Regions with only a shaded square indicates "extras," i.e. transform output values that would not be used with normal rounding.
      <br/>
      The arrows show how with proper rounding, the mapping can be made to be one-to-one by using the output values for extras for the input values that are collisions.
    </p>
    <p num="148">
      For example, where the s and d inputs are 2 and 2, the output will not be 1,1.
      <br/>
      Instead, it will be 0,2 (see arrow 801).
      <br/>
      When performing the inverse, a look-up table entry for 0,2 would point to output 1,1.
      <br/>
      The determinant  &gt;= 1 condition guarantees that for each collision, there is at least one extra.
      <br/>
      If the collisions are represented by nearby extras, mismatch due to rounding is reduced and may be mininized.
    </p>
    <p num="149">
      FIG. 9 shows the collisions ("O") and extras ("+") for a 45 (degree)  rotation using the approximation 1/2 (congruent to) 29/41=0.7073. (The smaller denominator of 41 is used instead of 181 so all possibilities can be shown on the page.
      <br/>
      The corresponding figure for a denominator of 181 is similar.) In this example, the determinant is very close to 1(1.0006) and the number of extras is equal to the number of collisions.
    </p>
    <p num="150">The number of collisions or the number of extras that do not have a pair is indicative of the expansion of the transform.</p>
    <p num="151">Table 2 shows an example mapping for a 5 (degree)  rotation using the approximation 1/2 (congruent to) 5/7=0.7143.</p>
    <p num="152">
      -- TABLE 2
      <br/>
      -- Example Mapping
      <br/>
      -- sum,                                                sum of
      <br/>
      -- difference  floating point integer outputs rounding    squared
      <br/>
      -- inputs      outputs       for reversibility offset      error
      <br/>
      -- 0      0      0.00   0.00    0      0       0      0      0.000
      <br/>
      -- 2      0      1.41   0.00    1      0       0      0      0.172
      <br/>
      -- 4      0      2.83   0.00    3      0       0      0      0.029
      <br/>
      -- 6      0      4.24   0.00    4      0       0      0      0.059
      <br/>
      -- 1      1      0.71   0.71    1      1       0      0      0.172
      <br/>
      -- 3      1      2.12   0.71    2      1       0      0      0.101
      <br/>
      -- 5      1      3.54   0.71    4      1                     0.302
      <br/>
      -- 0      2      0.00   1.41    0      1       0      0      0.172
      <br/>
      -- 2      2      1.41   1.41    2      0       1      -1 2.343
      <br/>
      -- 4      2      2.83   1.41    3      1       0      0      0.201
      <br/>
      -- 6      2      4.24   1.41    3      2       -1 1      1.887
      <br/>
      -- 1      3      0.71   2.12    1      2       0      0      0.101
      <br/>
      -- 3      3      2.12   2.12    2      2       0      0      0.029
      <br/>
      -- 5      3      3.54   2.12    4      2       0      0      0.230
      <br/>
      -- 0      4      0.00   2.83    0      3       0      0      0.029
      <br/>
      -- 2      4      1.41   2.83    1      3       0      0      0.201
      <br/>
      -- 4      4      2.83   2.83    3      3       0      0      0.059
      <br/>
      -- 6      4      4.24   2.83    4      3       0      0      0.088
      <br/>
      -- 1      5      0.71   3.54    1      4       0      0      0.302
      <br/>
      -- 3      5      2.12   3.54    2      4       0      0      0.203
      <br/>
      -- 5      5      3.54   3.54    4      4       0      0      0.431
      <br/>
      -- 0      6      0.00   4.24    0      4       0      0      0.059
      <br/>
      -- 2      6      1.41   4.24    0      2       -1 -2 7.029
      <br/>
      -- 4      6      2.83   4.24    3      4       0      0      0.088
      <br/>
      -- 6      6      4.24   4.24    2      3       -2 -1 6.574
    </p>
    <p num="153">
      This is not very accurate, but the denominator is small enough the results of all possible (sum, difference) pairs of inputs can be d on a page.
      <br/>
      For each pair, the sum of the squared error is listed. that except when both inputs are 0, there is some error even if the rounding to integer is used.
      <br/>
      The average RMSE for rounding pairs to closest integer is 1/2.congruent 0 (slashed zero) 289.
      <br/>
      The 5/7 approximation has four collisions out of 25 possible input pairs.
      <br/>
      These four collisions increase the RMSE to 0.6529 for this approximation.
      <br/>
      The columns entitled "rounding offset" are the output of look up tables.
      <br/>
      For the forward transform, the columns "sum, difference inputs" are the inputs and for the inverse transform, the columns "integer output for reversibility" are the inputs.
    </p>
    <p num="154">
      The 128/181 approximation given in Table 1 is reasonably accurate.
      <br/>
      The numerator 128 is a power of 2 which is computationally useful.
      <br/>
      The determinant is 1.0002 (log2 1.0002=0.0003 bits) so it is very close to efficient.
      <br/>
      The average RMSE with a good look up table is 0.4434 and the peak error is 1.92.
    </p>
    <p num="155">Forward Computation</p>
    <p num="156">
      A complete forward computation of a rotation for the 2 * 2 DCT is accomplished as follows.
      <br/>
      The approximation 1/128/181 is assumed for this example.
      <br/>
      First, in order to compute the forward, the sum and difference of the inputs a and b are computed according to the following equations.
      <br/>
      sum=a+b
      <br/>
      difference=a-b
    </p>
    <p num="157">
      Next, the sum and difference are divided by 181, saving the remainder, according to the following equations. (Note that 128/181 (congruent to) 181/256 can be used in some implementations to speed up the division.)
      <br/>
      ss=sum/181
      <br/>
      dd=difference/181
      <br/>
      s=sum mod 181
      <br/>
      d=difference mod 181
    </p>
    <p num="158">
      The look up table assumes the pair of modulo 181 values s,d have the same parity (they are either both even or both odd).
      <br/>
      If ss and dd do not have the same parity, then the parity of one of the modulo values is changed.
      <br/>
      The change is made so values stay in the range 0 . . . 180. In the pseudo-code below, " " means exclusive OR.
      <br/>
      This step is needed for odd denominators, it is not needed for even denominators.
    </p>
    <p num="159">The pseudo code is as follows:</p>
    <p num="160">
      if (ss is odd and dd is even) or (ss is even and dd is odd) if (d==180)
      <br/>
      s'=s 1
    </p>
    <p num="161">
      - else
      <br/>
      d'=d 1
    </p>
    <p num="162">
      The square root of 1/2 multiplied by s and d can be determined using 128/181 (or 181/256) or a look up table.
      <br/>
      The rounding offset may be found in the look up table.
      <br/>
      In one embodiment, the rounding offsets are -1 . . . 1 so the data width of the look up tables can be two bits.
      <br/>
      The square root of the portion of the inputs represented by ss and dd is 128ss and 128dd respectively, which may be implemented as a shift.
      <br/>
      x=sqrt(1/2)*s'+LUT-- fs',d'+128*ss
      <br/>
      y=sqrt(1/2)*d'+LUT-- gs',d'+128*dd
    </p>
    <p num="163">for the equality:  (Equation image '25' not included in text)</p>
    <p num="164">
      Alternatively, the look up table may return both the square root of s (or d) and the rounding offset.
      <br/>
      In one embodiment, such look up tables have seven bits of data width.
      <br/>
      x=LUT_sqrt1/2-- fs',d'+128*ss
      <br/>
      y=LUT_sqrt1/2-- gs',d'+128*dd
    </p>
    <p num="165">
      The values of s and d vary from 0 to 180 but not all pairs occur.
      <br/>
      In some cases where f and g are dimensional (10) arrays, indexing a 1D look up table with s+181*d would waste almost half the memory locations.
      <br/>
      Because 181 is odd, using s'/2+181*d'/2 does not properly handle boundary conditions.
      <br/>
      The following indexing scheme may be used.
      <br/>
      index=s'/2+d'*90+(d+1)/2
    </p>
    <p num="166">
      FIG. 12 is a block diagram of one embodiment a rotation according to the present invention.
      <br/>
      Referring to FIG. 12, inputs a and b are added by adder 1201 to produce sum (s), while inputs a and b are input into subtractor 1201 which determines the difference (d) of a-b. The sum (s) is input to divider 1203 which divides it by 183.
      <br/>
      The remainder output of divider 1203 is coupled to the inputs of parity correction block 1205 and the quotient output is coupled to multiplier 1206.
      <br/>
      The difference output from subtractor 1202 is input to divider 1204 which divides it by 181 and outputs the remainder result to the other input of parity correction block 1205 and outputs the quotient to the input to multiplier 1207.
      <br/>
      Parity correction block 1205 performs the parity correction described above and outputs 's and d' which are coupled to two inputs of look-up table (LUT) 1208 and to multipliers 1209 and 1210 respectively.
    </p>
    <p num="167">
      Multiplier 1206 multiplies the ss output from divider 1203 by 128 and outputs the result to adder 1211.
      <br/>
      Multiplier 1207 multiplies the output of the dd output of divider 1204 by 128 and outputs the result to adder 1212.
      <br/>
      Multiplier 1209 multiplies s' by +fraction (1/2)} and outputs the result to adder 1211, while multiplier 1210 multiplies d' +fraction (1/2)} and outputs the result to adder 1212.
    </p>
    <p num="168">
      LUT 1208 generates the f and g values as described above and outputs them to adders 1211 and 1212, respectively.
      <br/>
      Adder 1211 adds the inputs together to produce the x output of the rotation, while adder 1212 adds its inputs to generate the y output.
    </p>
    <p num="169">Inverse Computation</p>
    <p num="170">In one embodiment, in order to compute the complete inverse, the approximation of 1/2 (congruent to) 128/181 is assumed.</p>
    <p num="171">
      First, the inputs x and y are divided by 128, while saving the remainder, according to the following:
      <br/>
      ss=x128
      <br/>
      dd=y/128
      <br/>
      i=x mod 128
      <br/>
      j=y mod 128
    </p>
    <p num="172">
      Next the modulo 128 values are multiplied by the square root of two and the rounding offsets are subtracted. (This can be combined into one LUT.) Because i and j may be any value from 0 to 127, all (or most if there are unused extras) look up table entries may be used without needing a fancy indexing scheme.
      <br/>
      s=sqrt(2)*i-LUT-- f_inversei,j
      <br/>
      d=sqrt(2)*j-LUT-- g_inversei,j
    </p>
    <p num="173">
      Afterwards, compensation is made for the case when the ss parity is not the same as the dd parity for odd denominators by using, in one embodiment, the following pseudo code:
      <br/>
      if (ss is odd and dd is even) or (ss is even and dd is odd)
      <br/>
      - if (d==180)
      <br/>
      s'=s 1
      <br/>
      else
      <br/>
      d'=d 1
    </p>
    <p num="174">
      The sum and difference are computed according to the following equations:
      <br/>
      sum=s'+181*ss
      <br/>
      difference=d'+181*dd
    </p>
    <p num="175">
      Lastly, the sum and difference are changed back into original values according to the following equations:
      <br/>
      a=sum/2+(difference+1)/2
      <br/>
      b=sum/2-difference/2
    </p>
    <p num="176">
      The inverse may be implemented in a manner similar to that shown in FIG. 12 except the direction is reversed.
      <br/>
      Such an implementation would be apparent to one skilled in the art in view of FIG. 12.
    </p>
    <p num="177">Creating Look Up Tables for Rounding Offsets</p>
    <p num="178">
      An extra is assigned to every hole.
      <br/>
      For very small look up tables, exhaustive search can be used to find the best mapping.
      <br/>
      For larger look up tables, there are several techniques that can be used to successively refine look up tables.
      <br/>
      The first technique is a deterministic assignment of extras to collisions.
      <br/>
      In one embodiment, the number of extras is no less than the number of collisions.
      <br/>
      The extras are spaced out with respect to the collisions to which they are assigned.
      <br/>
      This technique is fast and allows the process to be replicated at both ends.
      <br/>
      This technique also avoids having to transmit a look up table as one could be generated on the fly.
      <br/>
      for each collision_row
      <br/>
      - determine the number of extra_rows needed to provide an extra for every collision in the current collision row.
      <br/>
      - if a partial extra row is required, select the proper number of extras evenly spaced within the row
      <br/>
      - sort all the extras to be used in column order
      <br/>
      - assign extras to collisions in column order
    </p>
    <p num="179">
      The spacing that occurs is based on the number of collisions to extras.
      <br/>
      By dividing the number of collisions by the number of extras, an index factor is generated.
      <br/>
      Rounding to the next integer for each provides a set of integers indicative of which collisions to use.
    </p>
    <p num="180">
      For illustration, consider the pattern of collisions and extras shown in FIG. 9.
      <br/>
      There are 144 collisions in 12 rows of 12 each.
      <br/>
      There are 144 extras in 8 rows of 9 each and 9 rows of 8 each.
      <br/>
      The assignments for the first three rows of collisions are as follows, the remaining rows are assigned in a similar fashion.
      <br/>
      12 collisions in first row
      <br/>
      use first extra row which has 8 extras in columns 3, 7, 13, 17, 21, 27, 31, 37
      <br/>
      need 4 extras from second extra row, out of a total of 9, use the ones in columns 4, 14, 24, 34
      <br/>
      The assignments are (extra row, extra column --&gt; collision column) 1,3 --&gt; 2; 2,4 --&gt; 6; 1,7 --&gt; 8; 1,13 --&gt; 12; 2,14 --&gt; 16; 1,17 --&gt; 18; 1,21 --&gt; 22; 2,24 --&gt; 26; 1,27 --&gt; 30; 1,31 --&gt; 32; 2,34 --&gt; 36; 1,37 --&gt; 40
      <br/>
      12 collisions in second row
      <br/>
      use remaining 5 extras from second extra row, out of total of 8, use the ones in columns 0, 10, 20, 28, 38
      <br/>
      use 7 extras from the third row, out of a total of 8, use the ones in columns 3, 7, 13, 17, 21, 27, 31
      <br/>
      The assignments are (extra row, extra column --&gt; collision column) 2,0 --&gt; 2; 3,3 --&gt; 6; 3,7 --&gt; 8; 2,10 --&gt; 12; 3,13 --&gt; 16; 3,17 --&gt; 18; 2,20 --&gt; 22; 3,21 --&gt; 26; 3,27 --&gt; 30; 2,28 --&gt; 32; 3,31 --&gt; 36; 2,38 --&gt; 440
      <br/>
      12 collisions in third row
      <br/>
      use remaining 1 extra from third extra row, out of a total of 8, use the one in column 37
      <br/>
      use 9 extras from the fourth extra row in columns 0, 4, 10, 14, 20, 24, 28,34,38
      <br/>
      use 2 extras from fifth extra row, out of total of 8, use 3, 21
      <br/>
      The assignments are (extra row, extra column --&gt; collision column) 4,0 --&gt; 2; 5,3 --&gt; 6; 4,4 --&gt; 8; 4,10 --&gt; 12; 4,14 --&gt; 16; 4,20 --&gt; 18; 5,21 --&gt; 22; 4,24 --&gt; 26; 4,28 --&gt; 30; 4,34 --&gt; 32; 3,36; 4,40
    </p>
    <p num="181">Given a starting mapping, mappings can be improved by gradient decent (swap extra/collision assignments if mismatch is reduced) or similar optimization procedures (e.g., simulated annealing, etc.).</p>
    <p num="182">
      Another optimization procedure is described in B. Kerninghan, Lin, An Efficient Heuristic Procedure for Partitioning Graphics, Bell Syst.
      <br/>
      Tech. J., pp. 291-307, 1970.
      <br/>
      Optimization may be performed considering only collisions and extras or considering all input and output values.
      <br/>
      Optimization may be performed by swapping pairs of inputs and outputs or by rotating triplets of inputs and outputs.
      <br/>
      In one embodiment, swaps or rotations that reduce squared error are performed until no more improvements are possible.
    </p>
    <p num="183">
      The following pseudo code is one embodiment of a high level optimization method.
      <br/>
      This illustrates a refinement procedure.
      <br/>
      This method allows for swapping pairs (previous assignments).
      <br/>
      It allows for swapping an unassigned extra with the extra in an assigned collision-to- extra pair.
      <br/>
      It allows for swapping where the error does not change, i.e., where the direction of the error is the only issue.
      <br/>
      A swap that does not change the error is made when it allows a future swap to improve error, that is part of a triple-swap or rotation of three pairs.
      <br/>
      for each collision
      <br/>
      - compute squared error of current assignment
      <br/>
      do
      <br/>
      - for each extra
    </p>
    <p num="184">
      -  initialize extra pair swap to "not swapped yet" (eg. -1)
      <br/>
      -  initialize extra triple swap "not swapped yet" (eg. -1)
      <br/>
      -  initialize swap gain to zero
      <br/>
      - for k=first swap candidate extra (eg. 0) to last swap candidate extra (eg. number of extras -1)
      <br/>
      -  try an find a better assignment for extrak
      <br/>
      - if any better assignments are found
      <br/>
      -  perform swaps
      <br/>
      - while any better assignments are found
    </p>
    <p num="185">
      In order to calculate the squared error, with a rotation by an angle q, the following procedure may be used.
      <br/>
      let XC be first coordinate of collision
      <br/>
      let YC be second coordinate of collision
      <br/>
      let XE be first coordinate of extra
      <br/>
      let YE be second coordinate of extra
      <br/>
      let SIN=sin q
      <br/>
      let COS=cos q
      <br/>
      squared error=(COS*XC-round(COS*XE)) 2+(COS*YC-round (COS*YE)) 2
    </p>
    <p num="186">
      The pseudo code for one embodiment of the "try and find a better assignment for extrak" routine is as follows:
      <br/>
      initialize squared error best_improvement for best swap to zero
      <br/>
      search for best pair swap between extrak and extrasn, n&gt;k
      <br/>
      if best pair swap has same squared error as without swap
      <br/>
      - search for best triple swap between extrak, extran and extrasm,m&gt;n or n&gt;m&gt;k
      <br/>
      - if extran or extrak or extram have already been marked
    </p>
    <p num="187">
      for swapping ignore best triple swap
      <br/>
      - if the best swap reduces squared error
      <br/>
      -  if extran has already been marked for a pair swap
    </p>
    <p num="188">
      -    mark the extra to be swapped with extran as "not swapped yet"
      <br/>
      - if extran has already been marked for a triple swap
      <br/>
      -  mark the extras to be swapped with extran as "not swapped yet"
      <br/>
      - if extrak has already been marked for a triple swap
      <br/>
      -  mark the extras to be swapped with extrak as "not swapped yet"
      <br/>
      - if a triple swap is the best swap and extram has already been
      <br/>
      -  marked for a triple swap
      <br/>
      -  mark the extras to be swapped with extran as "not swapped yet"
      <br/>
      - if a pair swap is the best swap
      <br/>
      -  mark extran to be swapped with extrak
      <br/>
      -  mark extrak to be swapped with extran
      <br/>
      - else
      <br/>
      -  mark extran to be triple swapped
      <br/>
      -  mark extrak to be triple swapped
      <br/>
      -  mark extram to be triple swapped with extran and extrak
    </p>
    <p num="189">
      The pseudo code for one embodiment of the "search for best pair swap" routine is as follows:
      <br/>
      for each extran
      <br/>
      - calculate swap error=squared error for extran,collisionk+squared error for extrak,collisionn
      <br/>
      - calculate current error=the sum of squared error for the current assignments of extran,extrak
      <br/>
      - this_improvement=current error-swap error
      <br/>
      - if (this_improvement&gt;=0) and (this_improvement&gt;=best_improvement)
      <br/>
      -  best_improvement=this improvement
      <br/>
      -  best swap found so far is n
    </p>
    <p num="190">
      The pseudo code for one embodiment of the "search for best triple swap" routine is as follows:
      <br/>
      for each extran
      <br/>
      - calculate swap error=squared error for extram, collision k+squared error for extran, collisionm+squared error for extrak, collisionn
      <br/>
      - calculate current error=current error-swap error
      <br/>
      - if (this_improvement&gt;=0) and (this_improvement&gt;=
      <br/>
      - best_improvement)
      <br/>
      - best_improvement=this improvement
      <br/>
      - best swap found so far is n
    </p>
    <p num="191">
      The pseudo code for one embodiment of the "perform swaps" routine is as follows:
      <br/>
      for each extrak
      <br/>
      - if extrak marked
      <br/>
      -  n=extra to swap with extrak
      <br/>
      -  if n&lt;k
      <br/>
      -    swap extran and extrak
      <br/>
      -    calculate squared error of current assignment
    </p>
    <p num="192">An Almost Balanced DCT Implementation</p>
    <p num="193">
      Look up table based rounding allows implementation of arbitrary 2-point rotations with low mismatch.
      <br/>
      The present invention allows for creating transforms that are efficient and almost balanced and that can then be implemented reversibly with the look up table technique of the present invention (or some other technique).
    </p>
    <p num="194">
      A balanced efficient transform exists when the determinant of the transform is a perfect square.
      <br/>
      An almost balanced transform is created by multiplying all the values in the transform matrix by a constant.
      <br/>
      The constant is selected such that the determinant can be factored into two close equal factors.
      <br/>
      Table 3 shows some examples of almost balanced transforms.
    </p>
    <p num="195">
      -- TABLE 3
      <br/>
      -- Almost Balanced Transforms
      <br/>
      --                                                              balance
      <br/>
      -- transform determinant multiplier transform implementation     ratio
      <br/>
      --  LCM
      <br/>
      -- 5,1"A" 26           2   (10a + 2b)/13 (2a - 10b)/8 13/8 = 1.63  52
      <br/>
      -- 5,1"A" 26           3   (15a + 3b)/18 (3b - 15a)/13 18/13 = 1.38  78
      <br/>
      -- 5,1"A" 26           5   (25a + 5b)/26 (5a - 25b)/25 26/25 = 1.04 150
      <br/>
      -- 2,3"C" 13           4   (8a + 12b)/16 (12a - 8b)/13 16/13 = 1.23  52
      <br/>
      -- 2,3"C" 13          30        (60a + 90b)/117 (90a - 60b)/100 117/100 = 1.17
      <br/>
      --  390
      <br/>
      -- 2,3"C" 13          42        (84a + 126b)/156 (126a - 82b)/147 156/147 =
      <br/>
      --  1.06 182
    </p>
    <p num="196">
      The LCM column in Table 3 contains a least common multiple of the denominators, after any common factors in the numerators are removed.
      <br/>
      A look up table of size LCM2 is sufficient to implement the transform.
      <br/>
      Large values are broken into a quotient and a remainder after division by the LCD.
      <br/>
      All of the look up tables required for the transforms in Table 3 are too large to be easily understood examples.
      <br/>
      The 2,1 almost balanced transform with multiplier 2 is described as an example in the equation below.  (Equation image '26' not included in text)
    </p>
    <p num="197">The two divisors are 5 and 4, which has balance ratio 1.25. This example requires only a table size of 102 =100 and the table has a simple structure.</p>
    <p num="198">
      Table 4 is the look up table for the transform.
      <br/>
      All except the highlighted squares are determined using the following equation.
      <br/>
      The highlighted squares indicate collisions assigned to extras.  (Equation image '27' not included in text)
    </p>
    <p num="199">
      -- TABLE 4
      <br/>
      -- Look Up Table for 2,1 Almost Balanced Transform
      <br/>
      --   (Chemical Structure image '1' not included in text)
    </p>
    <p num="200">
      FIG. 10 is a plot of x,y pairs that occur from the equation above when a and b are in the range 0 . . . 10. The circles and arrows show the mapping of collisions to extras.
      <br/>
      Appendix A contains one embodiment of source code which implements this transform.
      <br/>
      It includes both the look up table and the quotient/remainder processing needed to handle arbitrarily large values
    </p>
    <p num="201">8 * 8 Transforms</p>
    <p num="202">
      A variety of the building blocks described above may be used in the various 8 * 8 reversible APTs, some of which are shown in Table 5.
      <br/>
      The Chen decomposition of the subsidiary matrix shown in FIG. 3 is used except for the APT labeled Hein which uses the subsidiary matrix shown in FIG. 4.
      <br/>
      The "efficient" and "efficient" Hein use the building blocks of the reversible implementations described above that do not have internal rounds or look up tables, except for the "1" and "R" in the subsidiary matrix that is done with a look up table.
      <br/>
      Another APT uses ladder filter building blocks.
      <br/>
      The "almost efficient" APT is closer to balanced which leads to good lossy performance.
      <br/>
      The "almost efficient" APT has determinant 1.04 (log2 1.04=0.06 bits of redundancy).
    </p>
    <p num="203">
      -- TABLE 5
      <br/>
      -- Building blocks used to create 8  *  8 reversible APTs
      <br/>
      -- APT         efficient     efficient Hein efficient "almost
      <br/>
      -- parameter                               Ladder  efficient"
      <br/>
      --                                         filter
      <br/>
      -- A           5,1 transform- 12,5 transform Ladder  5,1 transform
      <br/>
      --             unbalanced                          balanced,
      <br/>
      --                                                 inefficient
      <br/>
      -- B           12,5 transform 12,5 transform Ladder  12,5 transform
      <br/>
      -- C           3,2 transform 3,2 transform Ladder  3,2 transform
      <br/>
      --                                                 growth in
    </p>
    <p num="204">
      --                                                 sum
      <br/>
      -- 1 (outside  S-transform   S-transform   Ladder  LUT
      <br/>
      -- subsidiary
      <br/>
      -- matrix)
      <br/>
      -- 1 and R     LUT           LUT           Ladder  LUT
      <br/>
      -- (inside
      <br/>
      -- subsidiary
      <br/>
      -- matrix,
      <br/>
      -- before R)
      <br/>
      -- 1 (inside   S-transform   S-transform   Ladder  LUT
      <br/>
      -- subsidiary
      <br/>
      -- matrix,
      <br/>
      -- after R)
    </p>
    <p num="205">In one embodiment, a finite state machine (FSM) entropy coder and a trivial context model losslessly codes and decodes with the various transforms, such as shown in FIG. 1C. An example of an FSM coder is shown in U.S. Pat. Nos. 5,272,478, 5,363,099 and 5,475,388, each of which is incorporated by reference.</p>
    <p num="206">Table 6 shows the growth in the size of coefficients (number of bits) for the 1D 8-point efficient reversible APT.</p>
    <p num="207">
      -- TABLE 6
      <br/>
      -- Growth in size
      <br/>
      -- of coefficients for 8-point efficient reversible APT.
      <br/>
      -- INPUT          0  1  2  3  4  5  6  7
      <br/>
      -- GROWTH        +0 +0 +2 +2 +1 +6 +2 +5
    </p>
    <p num="208">
      As an example for this transform, if the inputs are 8 bits, the total of 64 bits of input would grow by 18 bits and would result in 82 bits of output.
      <br/>
      The growth for the 2D 8 * 8 transform can be determined by applying the 1D results horizontally and vertically.
      <br/>
      Table 7 shows the growth in the size of coefficients for the 1D 8-point "almost efficient" reversible APT.
    </p>
    <p num="209">
      -- TABLE 7
      <br/>
      -- Growth in size of
      <br/>
      -- coefficients for 8-point "almost efficient" reversible APT.
      <br/>
      -- INPUT          0  1  2  3  4  5  6  7
      <br/>
      -- GROWTH        +2 +2 +2 +8 +2 +1 +2 +2
    </p>
    <p num="210">
      As an example for this transform, if the inputs are 8 bits, the total of 64 bits of input would grow by 21 bits and would result in 85 bits of output (when adding the growth from all bits together).
      <br/>
      Also for example, in the 2-D case where 1D results are applied horizontally and vertically for the horizontal coefficient 2 and vertical coefficient 3, there is an additional 10 bits (as both are added 2+8=10).
      <br/>
      The good compression results are due to having no redundant least significant bits; the growth is mostly easy to compress more significant bits.
      <br/>
      To be reversible, an APT must output different coefficients than a floating point DCT, so some mismatch is unavoidable.
      <br/>
      However, a reversible APT is lossless without quantization.
      <br/>
      The lossless feature allows for no systemic error is the inverse transform is the inverse reversible APT.
      <br/>
      If required by an application, reversible APT coefficients could be inverse transformed to the original pixels and then forward transformed with a floating point DCT if exact DCT coefficients were needed.
      <br/>
      This would again lead to no mismatch.
    </p>
    <p num="211">
      Tables 8-10 show minimum quantization matrices for various 8 * 8 APTs.
      <br/>
      Minimum quantization matrices set forth an amount, or more, of quantization that if applied would result in the reversible APT coefficient differing from true DCT coefficients by no more than  +- 1.
      <br/>
      The smaller the minimum quantization values, the less mismatch error in the transform.
      <br/>
      The DC quantizer is shown in the upper left corner and the AC quantizers are in standard DCT (not zig-zag) order.
      <br/>
      The "8x8" efficient reversible APT and the ladder filter based APT both have relatively large minimum quantizers for DC and coefficients near DC.
      <br/>
      These transforms would therefore only approximate the DCT well at low compression/high quality.
      <br/>
      The "almost efficient" APT has smaller minimum values in general and has much smaller values for DC and near DC.
      <br/>
      This APT approximates the DCT well at typical JPEG compression ratios.
    </p>
    <p num="212">
      The "almost efficient" APT has the most mismatch (highest minimum quantizers) in coefficients generated with the "C" APT parameter.
      <br/>
      A look up table based "C" 2-point rotation might further reduce mismatch.
    </p>
    <p num="213">
      -- TABLE 8
      <br/>
      -- Minimum quantization matrix for 8  *  8
      <br/>
      -- efficient reversible APT
      <br/>
      --      16   25        5    9         7    2         6    2
      <br/>
      --      11   19        5    8         6    2         4    4
      <br/>
      --       5  9   2    4         4    1         2    2
      <br/>
      --       7 11        3    5         4    2         3    2
      <br/>
      --       7 10        3    5         4    2         3    2
      <br/>
      --       4  8   2    3         3    1         2    2
      <br/>
      --       6  9   2    4         4    2         2    2
      <br/>
      --       6 11        3    4         4    2         3    2
    </p>
    <p num="214">
      -- TABLE 9
      <br/>
      -- Minimum quantization matrix for 8  *  8
      <br/>
      -- efficient reversible APT using ladder filter
      <br/>
      --      20   11        7    13        7    11        7    15
      <br/>
      --       6  9   8     9   8     8   8     9
      <br/>
      --       6  8   6     8   6     6   7     8
      <br/>
      --       6  8   7     8   7     7   7     8
      <br/>
      --       6  7   7     8   6     7   7     8
      <br/>
      --       5  7   6     7   6     6   6     7
      <br/>
      --       6  6   6     7   6     6   6     6
      <br/>
      --       6  7   6     7   6     6   6     6
    </p>
    <p num="215">
      The structure of the minimum quantization matrices for some transforms are explained by the structure of the APT scale factor matrices.
      <br/>
      The ladder filter implementation is an exception, all values in it's scale factor matrix are 1.
      <br/>
      Tables 11 and 12 show the scale factors for the 8 * 8 efficient reversible APT and the "almost efficient" version.
      <br/>
      Large scale factors (greater than 1) result in large minimum quantization values.
    </p>
    <p num="216">
      -- TABLE 10
      <br/>
      -- Minimum quantization matrix for 8  *  8
      <br/>
      -- "almost efficient" reversible APT
      <br/>
      --      7    7         6    4         6    13        6    5
      <br/>
      --      5    6         6    4         6    15        6    5
      <br/>
      --      5    5         5    4         5    12        5    5
      <br/>
      --      5    6         5    4         6    13        5    5
      <br/>
      --      5    6         5    4         6    13        5    5
      <br/>
      --      6    6         6    4         6    16        6    6
      <br/>
      --      6    5         5    4         5    10        5    5
      <br/>
      --      6    5         5    4         6    11        5    5
    </p>
    <p num="217">
      -- TABLE 11
      <br/>
      -- Scale factors for 8  *  8 efficient reversible APT
      <br/>
      --  8.00 14.42     2.83   5.10      4.00   0.39    2.83   0.55
      <br/>
      -- 14.42  26.00     5.10   9.19      7.21   0.71    5.10   1.00
      <br/>
      --  2.83  5.10 1.00   1.80      1.41   0.14    1.00   0.20
      <br/>
      --  5.10  9.19 1.80   3.25      2.55   0.25    1.80   0.35
      <br/>
      --  4.00  7.21 1.41   2.55      2.00   0.20    1.41   0.28
      <br/>
      --  0.39  0.71 0.14   0.25      0.20   0.02    0.14   0.03
      <br/>
      --  2.83  5.10 1.00   1.80      1.41   0.14    1.00   0.20
      <br/>
      --  0.55  1.00 0.20   0.35      0.28   0.03    0.20   0.04
    </p>
    <p num="218">
      -- TABLE 12
      <br/>
      -- Scale factors for 8  *  8 "almost efficient" reversible APT
      <br/>
      -- 1.00   0.98    1.00   0.28      1.00   3.61      1.00   0.98
      <br/>
      -- 0.98   0.96    0.98   0.27      0.98   3.54      0.98   0.96
      <br/>
      -- 1.00   0.98    1.00   0.28      1.00   3.61      1.00   0.98
      <br/>
      -- 0.28   0.27    0.28   0.08      0.28   1.00      0.28   0.27
      <br/>
      -- 1.00   0.98    1.00   0.28      1.00   3.61      1.00   0.98
      <br/>
      -- 3.61   3.54    3.61   1.00      3.61   13.00  3.61   3.54
      <br/>
      -- 1.00   0.98    1.00   0.28      1.00   3.61      1.00   0.98
      <br/>
      -- 0.98   0.96    0.98   0.27      0.98   3.54      0.98   0.96
    </p>
    <p num="219">Lossy Coding</p>
    <p num="220">
      Lossy coding with the reversible APT starts with lossless encoding using the reversible APT.
      <br/>
      The decoding is lossy and may use a legacy DCT based decompressor such as a JPEG decoder.
    </p>
    <p num="221">
      Reversible APT coefficients may be used in a lossy compression system such as JPEG in the same manner as regular APT coefficients.
      <br/>
      A JPEG quantization matrix is chosen.
      <br/>
      Each quantizer is divided by the corresponding APT scale factor, resulting a new combined quantizer and scale factor.
      <br/>
      The APT and the combined quantization and scale factor matrix are used as a replacement for the DCT and quantization in JPEG.
      <br/>
      Any quantization matrix can be used; however, mismatch will occur if the scale factor is larger than the quantizer.
    </p>
    <p num="222">
      In an alternative embodiment, the quantization division/multiplication is replaced with shifting to select desired bits.
      <br/>
      This reduces computational cost.
      <br/>
      It allows an embedded or multi-use system were more bits can be selected for higher quality up to lossless when all bits are selected.
      <br/>
      The quantizers are chosen such that when they are divided by the corresponding scale factor, they are a power of 2 (or approximately a power of two).
    </p>
    <p num="223">
      JPEG has a progressive mode called successive approximation. (Although this mode is less well known and less frequently used than the baseline sequential mode of JPEG.) An alignment scheme can be chosen that results in a particular JPEG quantization.
      <br/>
      This can be used to generate coded data for the first stage of successive approximation which can be very similar to baseline sequential data if spectral selection is not used.
      <br/>
      Successive approximation allows the remaining data to be coded by bitplanes in an embedded fashion.
      <br/>
      The progressive JPEG also has spectral selection.
      <br/>
      Spectral selection allows bitplanes of only specified coefficients to be coded.
      <br/>
      Spectral selection can be used to specify which coefficients have bits in a bitplane versus coefficients which have already been fully described.
      <br/>
      If large quantization values were chosen for the first stage, all (or almost) all of the coefficients would be bitplane coded.
    </p>
    <p num="224">
      If using JPEG progressive mode was not desired, transcoding can be used to create sequential lossless JPEG codestreams of different fidelities.
      <br/>
      APT coefficients can be coded lossless with some method, not necessarily JPEG compatible.
      <br/>
      To create a stream, lossless decoding is performed, a desired quantization is performed either by division or shifting.
      <br/>
      The quantized coefficients can then be coded in a JPEG compatible way.
      <br/>
      There is a computational savings over lossless coding methods that do not use the reversible APT since no DCT is required during transcoding.
    </p>
    <p num="225">
      Table 13 shows an example of bits to shift right for each APT coefficient using the "almost efficient" 8 * 8 reversible APT.
      <br/>
      This corresponds to a quantizer/scale factor of 2n where n is the number of bits to shift right.
      <br/>
      Table 14 is the equivalent JPEG DCT quantization matrix that the shifts in Table 13 implement.
      <br/>
      Table 14 is similar to the psychophysically weighted luminance quantization tables typically used with JPEG.
    </p>
    <p num="226">Tables 15 and 16 show the bits to shift and corresponding quantizers for close to uniform quantization using the "almost efficient" 8 * 8 reversible APT.</p>
    <p num="227">
      -- TABLE 13
      <br/>
      -- Bits to shift right for "psychovisual" shift based quantization
      <br/>
      --      4    4         4    6         4    1         4    4
      <br/>
      --      4    4         4    6         4    2         5    5
      <br/>
      --      5    5         4    6         4    4         5    5
      <br/>
      --      7    7         8    9         8    6         8    8
      <br/>
      --      6    6         6    8         7    4         6    6
      <br/>
      --      5    4         4    6         4    8         4    4
      <br/>
      --      7    7         7    8         7    4         6    7
      <br/>
      --      7    7         7    9         7    5         7    7
    </p>
    <p num="228">
      -- TABLE 14
      <br/>
      -- Quantization matrix for "psychovisual" shifts
      <br/>
      --  16  16   16  18   16  7  16  16
      <br/>
      --  16  15   16  17   16  14  31  30
      <br/>
      --  32  31   16  18   16  58  32  31
      <br/>
      --  36  35   72  41   72  64  72  69
      <br/>
      --  64  63   64  72  128     58  64  63
      <br/>
      -- 115     57   58  64   58 104      58  57
      <br/>
      -- 128    125       128     72  128     58  64 125
      <br/>
      -- 125    123       125    138       125    113     125    123
    </p>
    <p num="229">Uniform quantization gives the best rate/distortion according to the mean squared error (MSE) metric.</p>
    <p num="230">
      -- TABLE 15
      <br/>
      -- Bits to shift right for "normalized" shift based quantization
      <br/>
      --      4    4         4    6         4    2         4    4
      <br/>
      --      4    4         4    6         4    2         4    4
      <br/>
      --      4    4         4    6         4    2         4    4
      <br/>
      --      6    6         6    8         6    4         6    6
      <br/>
      --      4    4         4    6         4    2         4    4
      <br/>
      --      2    2         2    4         2    0         2    2
      <br/>
      --      4    4         4    6         4    2         4    4
      <br/>
      --      4    4         4    6         4    2         4    4
    </p>
    <p num="231">
      -- TABLE 16
      <br/>
      -- Quantization matrix of "normalized" shifts
      <br/>
      --      16   16        16   18        16   14        16   16
      <br/>
      --      16   15        16   17        16   14        16   15
      <br/>
      --      16   16        16   18        16   14        16   16
      <br/>
      --      18   17        18   20        18   16        18   17
      <br/>
      --      16   16        16   18        16   14        16   16
      <br/>
      --      14   14        14   16        14   13        14   14
      <br/>
      --      16   16        16   18        16   14        16   16
      <br/>
      --      16   15        16   17        16   14        16   15
    </p>
    <p num="232">Implementations Issues</p>
    <p num="233">
      The reversible APT has a higher computation cost than a regular APT because scaling and rounding is performed at each step.
      <br/>
      To partially compensate for this disadvantage, the register width for the reversible APT is reduced at every step.
      <br/>
      Small register width and the simple parameters used in calculations aid implementation.
      <br/>
      In software, multiplication and division operations can be replaced by look up tables.
      <br/>
      In hardware, dedicated, low-hardware-cost multiply-by-N and divide-by-N circuits can be used.
    </p>
    <p num="234">For example, consider the implementation of part of the "B" 2-point rotation with two lookup tables described below and shown in FIG. 11. In hardware, the two look-up tables could be replaced with dedicated logic.  (Equation image '28' not included in text)</p>
    <p num="235">Referring to FIG. 11, the LUTs 1201 and 1202 operate as follows:</p>
    <p num="236">
      LUT1: given a, returns d1=  (Equation image '29' not included in text)
      <br/>
      and r1=(12a)mod 13
      <br/>
      LUT2: given b, returns d2=  (Equation image '30' not included in text)
      <br/>
      and r2=(5b+6)mod 13
    </p>
    <p num="237">
      This produces the following results:
      <br/>
      x=d1+d2 when r1+r2&lt;13
      <br/>
      x=d1+d2+1 when r1+r2 &gt;= 13
    </p>
    <p num="238">
      Reversible transforms for unified lossy and lossless compression are extended to include the discrete cosine transform (DCT), the most popular transform for image coded.
      <br/>
      The reversible Allen Parameterized Transform (APT) implements the DCT as a cascade of "integer rotations," each of which is implemented reversibly.
      <br/>
      The entropy of reversible APT coefficients was found to similar to the entropy of reversible wavelet coefficients.
      <br/>
      An "almost balanced" reversible APT sufficiently low mismatch to the floating point DCT so a legacy JPEG decoder can be used for lossy decompression.
    </p>
    <p num="239">
      Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description, it is to be understood that the particular embodiment shown and described by way of illustration is in no way intended to be considered limiting.
      <br/>
      Therefore, references to details of the preferred embodiment are not intended to limit the scope of the claims which in themselves recite only those features regarded as essential to the invention.
    </p>
    <p num="240">Thus, a reversible DCT-based system has been described.</p>
    <p num="241">Appendix A. Almost balanced 2,1 transform source code</p>
    <p num="242">The following "awk" source code implements the almost balanced 2,1 transform using a look up table as described above.</p>
    <p num="243">
      --
      <br/>
      -- -/usr/bin/nawk -f $0 S*
      <br/>
      -- - Copyright 1996, 1997 RICOH
      <br/>
      -- - integer division followed by "floor" rounding
      <br/>
      -- function mydiv (n,d) +
      <br/>
      --      m = int(n/d);
      <br/>
      --      if ((m*d =n) &amp;&amp; (n&lt;0)) +
      <br/>
      --        return m-1;
      <br/>
      --      } else
      <br/>
      --        return m;
      <br/>
      -- }
      <br/>
      -- BEGIN +
      <br/>
      --      for (a=0;a&lt;10;a++) +
      <br/>
      --        for (b=0;b&lt;10;b++) +
      <br/>
      --         x = mydiv(4*a=2*b=2,5);
      <br/>
      --         y = mydiv(2*a-4b+2,4);
      <br/>
      --         - fix up boundaries so it tiles correctly
      <br/>
      --         if ((x== 8) &amp;&amp; (y==4))
      <br/>
      --           x--;
      <br/>
      --         if ((x==2) &amp;&amp; (y==-6))
      <br/>
      --           x--;
      <br/>
      --         - match internal collisions and holes
      <br/>
      --         if (hitx y ==1) +
      <br/>
      --           x1 = x;
      <br/>
      --           x--;
      <br/>
      --           if (hitx y == 1) +
      <br/>
      --             print "ERROR";
      <br/>
      --             exit 1;
      <br/>
      --           }
      <br/>
      --           hit x y = 1;
      <br/>
      --           a1 = lut_ax1 y;
      <br/>
      --           b1 = lut_bx1 y;
      <br/>
      --           e1 = x1 - ((4.0*a1+2.0*b1) / 5.0);
      <br/>
      --           e0 = x - ((4.0*a+2.0*b) / 5.0);
      <br/>
      --           e1s = x - ((4.0*a1+2.0*b1) / 5.0);
      <br/>
      --           e0s = x1 - ((4.0*a+2.0*b) / 5.0);
      <br/>
      --           if (e1s*e1s+e0s*e0s &lt; e1*e1+e0*e0) +
      <br/>
      --           -swap assignments
      <br/>
      --             lut_ax y = a1;
      <br/>
      --             lut_bx y = b1;
      <br/>
      --             lut_xa1 b1 = x;
      <br/>
      --             lut_ya1 b1 = y;
      <br/>
      --             lut_ax1 y = a;
      <br/>
      --             lut_bx1 y = b;
      <br/>
      --             lut_xa b = x1;
      <br/>
      --             lut_ya b = y;
      <br/>
      --           }
      <br/>
      --         } else +
      <br/>
      --           hitx y = 1;
      <br/>
      --             lut_ax y = a;
      <br/>
      --             lut_bx y = b;
      <br/>
      --             lut_xa b = x;
      <br/>
      --             lut_ya b = y;
      <br/>
      --           }
      <br/>
      --         }
      <br/>
      --        }
      <br/>
      --        - print the mapping
      <br/>
      --        for (a=0; a&lt;10;a++) +
      <br/>
      --         for (b=0;b&lt;10;b++) +
      <br/>
      --           x = lut_xa b;
      <br/>
      --           y = lut_ya b;
      <br/>
      --           e1 = x - (4.0*a+2.0*b) / 5.0;
      <br/>
      --           e1 = y - (2.0*a-5.0*b) / 4.0;
      <br/>
      --           error = e1*e1+e2*e2;
      <br/>
      --           print x "," y ".backslash.t--&gt;" a"," b".backslash.t" error;
      <br/>
      --         }
      <br/>
      --         print " ";
      <br/>
      --        }
      <br/>
      -- - Check mapping for integers outside of 0..9
      <br/>
      --      lim = 25;
      <br/>
      --      for (a=-lim;a&lt;lim+1;a++) +
      <br/>
      --        ad = mydiv(a,10);
      <br/>
      --        am = a - ad*10;
      <br/>
      --        for (b=-lim;b&lt;lim+1;b++0) +
      <br/>
      --        bd + mydiv(b,10);
      <br/>
      --        bm = b - bd*10;
      <br/>
      --        xm + lut_xam bm;
      <br/>
      --        ym = lut_yam bm;
      <br/>
      --        x = 8*ad + 4*bd + xm;
      <br/>
      --        y = 5*ad - 10*bd + ym;
      <br/>
      --        print x ","y".backslash.t--&lt; "a","b;
      <br/>
      --        if (hit2x,y =" ") +
      <br/>
      --           print "ERROR: "x","y";"a", "b" &amp; hit2x,y;
      <br/>
      --        }
      <br/>
      --         hit2x,y = x ","y";"a","b;
      <br/>
      --        }
      <br/>
      --        print " ";
      <br/>
      --      }
      <br/>
      -- }
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>We claim:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A compressor comprising:</claim-text>
      <claim-text>an input; a reversible DCT having at least one transform comprising a look up table having a mapping of transform input values to transform output values, and wherein the mapping maps input values from a first group, in which rounding maps inputs to the same transform values, to transform output values that would not have been used with rounding.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The compressor defined in claim 1 wherein said at least one transform has a determinant greater than or equal to 1.</claim-text>
    </claim>
  </claims>
</questel-patent-document>