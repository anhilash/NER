<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182228B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182228</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182228</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22466555" extended-family-id="42109095">
      <document-id>
        <country>US</country>
        <doc-number>09135102</doc-number>
        <kind>A</kind>
        <date>19980817</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09135102</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165760</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>13510298</doc-number>
        <kind>A</kind>
        <date>19980817</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09135102</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H04L  12/56        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>12</main-group>
        <subgroup>56</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>H04L  29/06        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>29</main-group>
        <subgroup>06</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>726013000</text>
        <class>726</class>
        <subclass>013000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>709227000</text>
        <class>709</class>
        <subclass>227000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>713154000</text>
        <class>713</class>
        <subclass>154000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>713164000</text>
        <class>713</class>
        <subclass>164000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-045/00</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>45</main-group>
        <subgroup>00</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-045/742</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>45</main-group>
        <subgroup>742</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-063/0263</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>63</main-group>
        <subgroup>0263</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99939</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99939</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>10</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>3</number-of-drawing-sheets>
      <number-of-figures>4</number-of-figures>
      <image-key data-format="questel">US6182228</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">System and method for very fast IP packet filtering</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>SHWED GIL</text>
          <document-id>
            <country>US</country>
            <doc-number>5606668</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5606668</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>MARIA ARTURO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6092110</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6092110</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>AT &amp; T CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0854621</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-854621</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="4">
          <text>IVANOFF MARIO J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5517622</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5517622</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>MORRISON GORDON E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5517628</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5517628</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <text>SKEEN MARION D, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5557798</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5557798</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>CHANG PAUL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5634015</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5634015</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>ALFERNESS MERWIN H, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5701316</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5701316</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Boden, Edward B.</name>
            <address>
              <address-1>Vestal, NY, US</address-1>
              <city>Vestal</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Brzozowski, Wesley A.</name>
            <address>
              <address-1>Endicott, NY, US</address-1>
              <city>Endicott</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Gebler, Jr., Paul A.</name>
            <address>
              <address-1>Vestal, NY, US</address-1>
              <city>Vestal</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Beckstrand, Shelley M.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Beausoliel, Jr., Robert W.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Small, optimized sequences of binary 6-tuples representing filter rules achieve very fast IP packet filtering.
      <br/>
      Filtering IP packets received from a caller at the physical interface to an operating system kernel is accomplished by processing FILTER rule statements entered by a user in a rules file to generate 6-tuple filtering rules, each of the 6-tuple filtering rules including an operator index; resolving relative and symbolic indexes in these 6-tuples filtering rules to form resolved filtering rules and loading the resolved filtering rules to the operating system kernal; and interpreting the resolved filtering rules for each IP packet received at the physical interface.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS REFERENCE TO RELATED APPLICATIONS</heading>
    <p num="1">
      U.S. patent application Ser.
      <br/>
      No. 09/135,148, filed Aug. 17, 1998, entitled "SYSTEM AND METHOD FOR IP NETWORK ADDRESS TRANSLATION AND IP FILTERING WITH DYNAMIC ADDRESS RESOLUTION", assignee docket number EN998067, filed concurrently herewith is assigned to the same assignee hereof and contains subject matter related, in certain respect, to the subject matter of the present application.
      <br/>
      The above-identified patent application is incorporated herein by reference.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Technical Field of the Invention
    </p>
    <p num="3">
      This invention pertains to IP packet filtering.
      <br/>
      More specifically, it relates to a use of small, optimized sequences of binary 6-tuples representing filter rules to achieve very fast IP packet filtering.
    </p>
    <p num="4">2. Background Art</p>
    <p num="5">
      Internet protocol (IP) network address translation (NAT) and IP filtering are functions which provide firewall-type capability to an Internet gateway system.
      <br/>
      In one specific system, this is accomplished by providing means for the system administrator to specify specific NAT and filtering rules via an operational navigator graphical user interface (GUI).
    </p>
    <p num="6">
      IP packet filtering is the process of checking each Internet protocol (IP) packet that is going to be sent from or has just arrived at a gateway system, or node, in a communications network, and based upon that check of making a decision.
      <br/>
      The decision is (typically, and insofar as it relates to the preferred embodiment of this invention) whether the packet should be discarded or allowed to continue.
      <br/>
      These are termed the `deny` and `permit` actions.
      <br/>
      IP filtering is widely used in Internet firewall systems, by independent service providers (ISPs) and organizations connected to the Internet.
    </p>
    <p num="7">
      Filter rules are most commonly an ordered list of rules, processed sequentially from top to bottom (order is specified by the system administrator).
      <br/>
      Each rule permits a certain kind of IP traffic.
      <br/>
      Processing for an IP packet continues until the packet is permitted, explicitly denied, or there are no more rules, in which case it is denied.
      <br/>
      Usually a number of filter rules must be written for each protocol to be permitted.
    </p>
    <p num="8">
      It is important the IP filtering actions be particularly efficient and very fast because of the huge volume of IP packets a typical gateway system will handle each day, and because of the fairly large number of filter rules that might have to be processed for each IP packet.
      <br/>
      Typically, each IP packet that flows through the system must be processed by all the filter rules.
      <br/>
      A moderately busy system can easily be expected to process 10**6 packets per day.
      <br/>
      Hence, any unnecessary overhead might cause throughput problems.
    </p>
    <p num="9">It is an object of the invention to provide an improved IP packet filtering system and method.</p>
    <p num="10">It is a further object of the invention to provide a very fast IP packet filtering system and method.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="11">
      In accordance with the invention, a system and method for filtering IP packets received from a caller at the physical interface to an operating system kernel is provided.
      <br/>
      Filtering is accomplished by processing FILTER rule statements entered by a user in a rules file to generate 6-tuple filtering rules, each of the 6-tuple filtering rules including an operator index; resolving relative and symbolic indexes in these 6-tuples filtering rules to form resolved filtering rules and loading the resolved filtering rules to the operating system kernel; and interpreting the resolved filtering rules for each IP packet received at the physical interface.
    </p>
    <p num="12">Other features and advantages of this invention will become apparent from the following detailed description of the presently preferred embodiment of the invention, taken in conjunction with the accompanying drawings.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="13">
      FIG. 1 illustrates the data flow of a preferred embodiment of the invention.
      <br/>
      FIG. 2 illustrates an example set of IP filter rules.
      <br/>
      FIG. 3 illustrates the format of a 6-tuple in accordance with the preferred embodiment of the invention.
      <br/>
      FIG. 4 illustrates the logical structure of 6-tuples, for the example set of FIG. 2, following the load and resolution step of FIG. 1 in accordance with the preferred embodiment of the invention.
    </p>
    <heading>BEST MODE FOR CARRYING OUT THE INVENTION</heading>
    <p num="14">The problem solved by this invention is: how to generate filtering code that executes in the operating system (OS) kernel from customer-entered rules, that will function correctly and perform very well.</p>
    <p num="15">Referring to FIG. 1, the key elements of the invention and the logical relationships and data flow among them, are illustrated.</p>
    <p num="16">
      This invention is concerned with the translation of FILTER statements 100 to a 6-tuple representation 124, and the interpretation 126 of the 6-tuples 124 as IP datagrams flow through the OS kernel 120.
      <br/>
      FILTER (and other rule) statements 100 are processed by rule compiler 102.
      <br/>
      An output of a first invocation 104 of the rule compiler 102 is two sets of files, s-rule files 106 and i-rule files 108.
      <br/>
      These files 106, 108 contain the binary form of the rules in image format (in i-rule files 108) or retain some symbolic information (in s-rule files 106).
      <br/>
      An `i` or `s` rule file 106, 108 is generated for each physical interface for which there are rules.
      <br/>
      Later, when the interface is started in response to start TCP interface (STRTCPIFC) command processing 110, a second invocation 114 of rule compiler 102 completes resolution of s-rule files 106.
      <br/>
      As is represented by step 122, the resolved rules are loaded to OS kernel 120 in the form of 6-tuples.
      <br/>
      A key part of loading in the kernel is to resolve the various relative and symbolic addresses in 6-tuples to absolute addresses.
      <br/>
      Thereupon, 6-tuples 124 are ready to be used by filter interpreter 126 as IP datagrams enter and leave the system via device drivers 130 to input/output processor (IOP), not shown.
      <br/>
      In a specific embodiment, IOPs provide the actual physical interface to a system, and a network cable of some type plugs into an IOP.
      <br/>
      Each IOP is represented within the OS kernel by a physical interface control block.
      <br/>
      Filter interpreter 126 communicates with such IOPs through device driver code 130 residing within kernel 120.
      <br/>
      Transport protocols 128 (such as TCP, UDP) are accessed by filter interpreter 126 is processing 6-tuples 124.
    </p>
    <p num="17">
      Both image rules (irules) 108 and symbolic rules (srules) 106 are in 6-tuple form, which is the output of rule compiler invocation 104, which is further described hereafter in connection with Table 2.
      <br/>
      Both irules 108 and srules 106 go through an address resolution during load 122, of the first two elements of their tuples.
      <br/>
      However, the srules 106 have an additional resolution that occurs during the compiler call 114 in connection with 122 load, but outside of kernel 120.
      <br/>
      That additional resolution is required to change certain of their value1206 or value2208 elements from symbolic to actual values (IP addresses.)
    </p>
    <p num="18">
      FIG. 2 shows the FILTER rule statements 100 as entered by the system administrator and seen by rule compiler 102.
      <br/>
      Three example rules 140, 142 and 144 are shown.
      <br/>
      The first two, rules 140 and 142, are explicitly entered by the system administrator, and the last, rule 144, called the `default deny` rule, is generated automatically by rule compiler 102.
    </p>
    <p num="19">Rule 1140 for filter set f1 includes ACTION=PERMIT 150, and selectors DIRECTION=* 152(read * as "splat", where * means "any"), source address SRCADDR=* 154, destination address DESTADDR=* 156, and protocol PROTO=TCP 158.</p>
    <p num="20">Rule 2142 for filter set f1 includes ACTION=PERMIT 160, and selectors DIRECTION=* 162, SRCADDR=* 164, DESTADDR=* 166, PROTO=UDP 168, source port SRCPORT=+161,162} 170, destination port DESTPORT=+161,162} 172, and journal JRN=ON 174.</p>
    <p num="21">Rule n 144 for filter set f1 includes ACTION=DENY 180, and selectors DIRECTION=* 182, SRCADDR=* 184, DESTADDR=* 186, and PROTO=* 188.</p>
    <p num="22">
      Rules 140, 142 and 144 are logically processed top-to-bottom for each IP packet 128; so for each packet 128, if the IP packet matches the rules tests (all selectors for a rules filter set 140, 142 or 144), then the ACTION 150, 160 or 180 specified by the rule is taken (for rule 1140, the PERMIT action 150 means `allow the IP packet to continue`).
      <br/>
      If a given IP packet 128 does not match the first rule 140, it is checked against the next rule 142, and so on, until the last rule 144.
      <br/>
      The default deny rule 144 always matches any IP packet and has ACTION 180 of deny, which means the IP packet 128 is discarded (not allowed to continue).
    </p>
    <p num="23">
      So, the general approach in ordering FILTER rules 146, is to write rules which allowed desired IP traffic to continue.
      <br/>
      Any IP packets not matched by some explicit PERMIT rule 140, 142, will be discarded by the default deny rule 144.
    </p>
    <p num="24">
      In FIG. 2, first filter rule 140 will allow all TCP IP datagrams, from any source, to any destination; and second filter rule 142 will allow UDP traffic if the source port or destination port is 161 or 162.
      <br/>
      These are well-known ports for SNMP (Simple Network Management Protocol), so this rule allows SNMP traffic (as an example).
      <br/>
      The SET name (`f1`) is used to associate FILTER rule sets with specific physical interfaces via a FILTER_INTERFACE statement (not shown).
      <br/>
      With this statement, a specific physical interface (named as part of system configuration) is given one or more filter sets.
      <br/>
      Since only the sets named are loaded for a physical interface, there is an inherent performance advantage over the typical implementation where there is only a single set of rules for the entire system.
      <br/>
      This means a separate copy of the filter rules is made for each interface, but the physical size of these rules is tiny, relative to system memory and performance gains of having focused rules.
    </p>
    <p num="25">Referring to FIG. 3, the logical structure of each 6-tuple includes operator 200, nextrule 202, offset 204, value1206, value2208 and value3210:</p>
    <p num="26">(operator, nextrule, offset, value1, value2, value3)</p>
    <p num="27">
      Operator 200 represents a logical operation to be performed (e.g. tests such as `=`, `&lt;=`, etc.).
      <br/>
      As generated by compiler 102 during invocation 104, this is a function index, that is resolved to a function pointer during invocation 114 for loading to memory as 6-tuples 124 in OS kernel 120. (6-tuples 124 in FIG. 1 include some arbitrary number of 6-tuples 198, FIG. 3.) Operators 200 are specific to a given byte length.
      <br/>
      That is, a 1-byte equality and 2-byte equality are different operators.
    </p>
    <p num="28">
      Nextrule 202 is a pointer to the first 6-tuple of the next rule in sequence, which is another instance of 6-tuple 198.
      <br/>
      As generated by rule compiler 102 during invocation 114, this is an offset that is resolved to a physical memory location when loaded to memory.
    </p>
    <p num="29">Offset 204 is a number that is the byte offset into an IP packet to a field in that IP packet that will be checked by this 6-tuple.</p>
    <p num="30">
      Value1206 is the value to be compared against the field in the IP packet accessed by offset 204.
      <br/>
      With this tuple element, the logical operation of the 6-tuple can now be expressed as "operand1, operator, operand2".
      <br/>
      Operand1 is obtained from the tuple element `offset`, operator is tuple element `operator` and operand2 is tuple element `value1`. Hence, the tuple represents expressions such as these; `source IP address, equals?, test address`. The nextrule tuple-element is resolved to point to another 6-tuple.
    </p>
    <p num="31">
      Value2208 is used in some tuples to represent additional or special actions for the tuple.
      <br/>
      In this preferred embodiment, as an example of such actions, a special additional action implemented via value2 is journaling.
      <br/>
      If set to 1 in the rule's permit or deny tuple, then a journal entry is created outside kernel 120 that provides direct system administrator visibility to the filter action.
      <br/>
      This is used for debugging and verifying filter rules and for detecting penetration attacks.
      <br/>
      The key information contained in each journal entry is: action taken (permit or deny), direction of IP datagram (inbound or outbound), source and destination IP addresses, source and destination port numbers, and the filter rule number.
      <br/>
      This filter rule number is how the customer knows exactly which FILTER statement the journal entry applies to--the compiler 102 generates these numbers (not shown) and the GUI provides the system administrator access to this listing of all the rules with their numbers.
      <br/>
      The rule number is in value3210 of the tuple.
      <br/>
      Alternatively, value3210 may contain an IP subnet mask, applicable for some tuples.
      <br/>
      A common way of representing TCP/IP subnets is by an IP address with a subnet mask.
      <br/>
      The mask is `anded` (logically, bitwise) with the IP address.
      <br/>
      All IP addresses that are equal to the anded address after anding with the same mask are within the subnet.
      <br/>
      An example: 9.130.69.3, 255.255.255.* (sometimes written as 9.130.69.*) refers to this range of IP addresses: 9.130.69.1 through 9.130.69.255.
    </p>
    <p num="32">
      Referring to FIG. 4, the set of 6-tuples 220, 222, 224, 226, 230, 232, 234, 236 and 240 that correspond to the three filter rules 140, 142, 144 (FIG. 2), is shown.
      <br/>
      Table 1 presents a second, or alternative, representation of these 6-tuples.
    </p>
    <p num="33">
      -- TABLE 1
      <br/>
      -- 6-Tuples
      <br/>
      --        (1byte=,ptr1,9,6,,) (permit,,,,,) (1byte=,ptr2,9,20,,)
      <br/>
      --        (2byte=,ptr3,20,161,,) . . .
      <br/>
      --        (2byte=,ptr4,20,162,,) (2byte=,ptr5,22,161,,) (2byte=,ptr6,22,
      <br/>
      --        162,,) (permit,,,,1,) . . .
      <br/>
      --        (deny,,,,,)
    </p>
    <p num="34">All 6-tuples have six elements, some of which might be null (binary 0) or some other unused value.</p>
    <p num="35">In table 1, ptr1 corresponds to pointer 252 in FIG. 4, ptr2 corresponds to pointer 272, ptr3 to pointer 282, ptr4 to pointer 292, ptr5 to pointer 302, and ptr6 to pointer 312.</p>
    <p num="36">
      Of course, a direct in-memory form of 6-tuples does not contain ")" or ",", is not on separate lines, and is simply 28*n contiguous bytes of binary, where n is the number of 6-tuples and 28 is the size, in this specific example, in 8-bit bytes (aka octets) of a 6-tuple.
      <br/>
      There is no effective limit on the number of FILTER rules 140, 142, 144 customers may define, nor on the resulting size of 6-tuples (the total length in bytes of 6-tuples 124).
    </p>
    <p num="37">
      The diagram of Table 1 and FIG. 4 does not show the resolution of operators.
      <br/>
      Each of the operators shown (1 byte=250, 270, 2 bytes=280, 290, 300, 310, permit 260, deny 330) is actually a function pointer to a C++ entry point.
      <br/>
      The operator functions take as their single argument, a pointer to the 6-tuple that contains their function pointer and returns 1 (or, true--that is, the logical test specified by the 6-tuple is true), 0 (or, false--the logical test failed), 2 for permit and 3 for deny.
      <br/>
      Thus, the function argument is a pointer to the 6-tuple.
      <br/>
      Referring to the example of FIG. 4, the argument to 1 byte=(field 250) is 220 (or a pointer to 6-tuple 220.) The function argument for permit (field 260) is 222 (that is, a pointer to 6-tuple 222), and so forth.
      <br/>
      This neat scheme simplifies the definition and use of these functions 250, 260, . . . by filter interpreter 126, and keeps the interpreter small.
    </p>
    <p num="38">
      The point of resolving function 200 and nextrule 202 indexes upon 6-tuple load 122, is to improve performance.
      <br/>
      The resolution is done once, on load 122, and then does not need to be done for each IP packet 128 as it is processed.
    </p>
    <p num="39">
      In FIG. 4, the elipses following 6-tuples 226, and 236, denote that additional, arbitrary numbers of 6-tuples follow, and these elipses correspond to elipses in FIG. 2.
      <br/>
      Thus, 6-tuple representations are provided in FIG. 4 for all rules shown in FIG. 2.
      <br/>
      The correspondence between FILTER statements 140, 142, and 144 and the 6-tuples in FIG. 4 is as follows: 140 --&gt; 220, 222; 142 --&gt; 224, 226, 230, 234, 234, 236; and 144 --&gt; 240.
    </p>
    <p num="40">
      The values 9, 20, 22 in the offset tuple elements 254, 284 and 304, respectively, are the byte offset into an IP datagram at which the appropriate field is found. 9 corresponds to (is the offset to) the protocol field in an IP datagram.
      <br/>
      Similarly, 20 corresponds to source port and 22 corresponds to destination port.
      <br/>
      The values in tuple element value1 (fields 256, 276, 286, 296, 306 and 316) are 6 (TCP), 20 (UDP), and so forth.
    </p>
    <p num="41">
      Each FILTER statement 100 (examples including 140, 142, and 144) belongs to a named set.
      <br/>
      In this example, the only set shown is the set named `f1`. All rule statements 100 are partitioned by physical interface (IOP).
      <br/>
      The customer (system administrator) uses a FILTER_INTERFACE statement to bind a set of rules to a particular physical interface. (See FIG. 7 in U.S. patent application Ser.
      <br/>
      No. 09/135,148, filed Aug. 17, 1998, assignee docket number EN998067.) This gives an inherent performance advantage over having a single set of filter rules for the entire system, since only the required rules need be defined for each physical interface.
      <br/>
      In processing each datagram, filter interpreter 126 is given the filter rules that apply to a given physical interface.
      <br/>
      For outbound datagrams, the routing function has already determined what physical interface will be used.
      <br/>
      For inbound datagrams, the rules used are those associated with the physical interface that the datagram arrived on.
    </p>
    <p num="42">The key portions of the invention are:</p>
    <p num="43">First, processing the FILTER rule statements 146 to generate the 6-tuple form 198 of the filtering rule 100, 140 . . . .</p>
    <p num="44">Second, loading and resolving relative &amp; symbolic indexes 202, 204 in 6-tuples.</p>
    <p num="45">Third, interpreting the 6-tuples 124 for each IP datagram 128.</p>
    <p num="46">Fourth, operating filter rule interpreter 126 to call certain operator functions.</p>
    <p num="47">Tables 2-5 are pseudo-code (C++--like syntax) descriptions of these functional steps.</p>
    <p num="48">
      -- TABLE 2
      <br/>
      -- Processing FILTER Statements
      <br/>
      -- // Processing FILTER statements to generate 6-tuples
      <br/>
      --      create tuple buffer to hold constructed 6-tuples;
      <br/>
      --      set `nextbyte` to beginning of tuple buffer;
      <br/>
      --      while (more rule statements exist in file) +
      <br/>
      --         if (rule statement is a FILTER statement) +
      <br/>
      --             for (each logical condition in statement) +
      <br/>
      --                construct 6-tuple for condition;
      <br/>
      --                copy to `nextbyte` of tuple buffer;
      <br/>
      --                increment tuple buffer `nextbyte`;
      <br/>
      --                }
      <br/>
      --             construct final `action` 6-tuple;
      <br/>
      --             copy to `nextbyte` of tuple buffer;
      <br/>
      --             increment tuple buffer `nextbyte`;
      <br/>
      --             for (each 6-tuple generated for this FILTER rule) +
      <br/>
      --                set `nextrule` tuple element =
      <br/>
      --                    tuple buffer nextbyte`;
      <br/>
      --                }
      <br/>
      --             }
      <br/>
      --         else + /* process statement as usual*/ }
      <br/>
      --         }
      <br/>
      --      write s-rule or i-rule file for each physical interface;
    </p>
    <p num="49">
      -- TABLE 3
      <br/>
      -- Loading and Resolving 6-tuple Indexes
      <br/>
      -- // Load &amp; resolve 6-tuple indexes
      <br/>
      --      if (loading s-rule file) + // function in OS, above
      <br/>
      --                // kernel
      <br/>
      --         for (each Symbolic address) +
      <br/>
      --             get offset from index table;
      <br/>
      --             change offset to actual IP address;
      <br/>
      --             }
      <br/>
      --         }
      <br/>
      --      load rules to kernel;
      <br/>
      --      for ( every 6-tuple ) + // function in OS, in kernel
      <br/>
      --         replace operator index with pointer to function;
      <br/>
      --         compute pointer to next rule based on nextrule value;
      <br/>
      --         replace nextrule value with computed pointer;
      <br/>
      --         }
    </p>
    <p num="50">
      -- TABLE 4
      <br/>
      -- Interpreting 6-tuples
      <br/>
      -- // Interpreting 6-tuples
      <br/>
      -- // code is invoked for each IP datagram
      <br/>
      --      obtain tuple pointer to 1st 6-tuple;
      <br/>
      --      while (1) +
      <br/>
      --             result = call operator function ( 6-tuple, datagram );
      <br/>
      --             if ( result is false ) set tuple pointer to nextrule;
      <br/>
      --             else if ( result is true ) set tuple pointer to next
      <br/>
      --                tuple;
      <br/>
      --             else break; // leave while loop
      <br/>
      --             }
      <br/>
      --      if ( tuple value2 is 1 ) generate journal entry for IP
      <br/>
      --         packet;
      <br/>
      --      return result; // caller does actual permit or deny
      <br/>
      --                    // action
    </p>
    <p num="51">
      -- TABLE 5
      <br/>
      -- Representative Operator Functions
      <br/>
      --           bool 1byte=(6tuple,packet) +return byte at
      <br/>
      --               packet.6tuple.offset == byte 6tuple.value1;}
      <br/>
      --           bool permit(6tuple,packet) +return true;}
      <br/>
      --           bool 2byte=( 6tuple,packet) +return 2bytes at
      <br/>
      --               packet.6tuple.offsett== 2bytes at 6tuple.value1;}
      <br/>
      --           bool deny( 6tuple,packet) +return false; }
    </p>
    <heading>ADVANTAGES OVER PRIOR ART</heading>
    <p num="52">It is an advantage of the preferred embodiment of this invention that an improved, very fast IP packet filtering method and system is provided.</p>
    <heading>ALTERNATIVE EMBODIMENTS</heading>
    <p num="53">
      It will be appreciated that, although specific embodiments of the invention have been described herein for purposes of illustration, various modifications may be made without departing from the spirit and scope of the invention.
      <br/>
      In particular, it is within the scope of the invention to provide a memory device, such as a transmission medium, magnetic or optical tape or disc, or the like, for storing signals for controlling the operation of a computer according to the method of the invention and/or to structure its components in accordance with the system of the invention.
    </p>
    <p num="54">Accordingly, the scope of protection of this invention is limited only by the following claims and their equivalents.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>We claim:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for generating, from user-entered rules, filtering rules for execution in an operating system kernel to filter an IP packet received at a physical interface to said operating system kernel comprising the steps of:</claim-text>
      <claim-text>compiling said user-entered filtering rules into sets of binary symbolic and image files, with one said set for each said physical interface for which there exist said user-entered rules; upon starting said physical interface to said operating system kernel,</claim-text>
      <claim-text>- resolving filtering rules in said symbolic file to form resolved 6-tuple filtering rules in image format, and - loading to said operating system kernel said resolved 6-tuple filtering rules and 6-tuple filtering rules from said image file; said 6-tuple filtering rules in image format including an operator field and, selectively, a next rule field, an offset field and zero or more parameter value fields; said operator field comprising a function index that is resolved to a function pointer upon being loaded to memory in said operating system kernel; said next rule field selectively comprising a pointer to a first 6-tuple of a next rule; said offset field selectively representing an offset into an IP packet to be checked by said first 6-tuple;</claim-text>
      <claim-text>and a first said parameter value field comprising a value to be compared against a field in said IP packet accessed by said offset field.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1 wherein function and next rule indexes are resolved upon a 6-tuple load to said operating system kernel, whereby resolution is done once and need not be done for each IP packet as it is processed.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. Method for filtering IP packets received from a caller at a physical interface to an operating system kernel, comprising the steps of: processing FILTER rule statements entered by a user in a rules file to generate 6-tuple filtering rules, each of said 6-tuple filtering rule including an operator index; resolving relative and symbolic indexes in said 6-tuple filtering rules to form resolved filtering rules and loading said resolved filtering rules to said operating system kernel;</claim-text>
      <claim-text>and interpreting said resolved filtering rules for each IP packet received at said physical interface.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 3, said processing step comprising the further steps of: creating a tuple buffer to hold constructed 6-tuple filtering rules; setting a next byte pointer to the beginning of said tuple buffer; while more filter rule statements exist in said rules file, if a next rule is a filter statement, for each next logical condition in said filter statement, - constructing a 6-tuple for said next logical condition, copying said 6-tuple to said tuple buffer at the location set by said next byte pointer, and incrementing said next byte pointer; constructing a final action 6-tuple and copying said final action 6-tuple to said tuple buffer at the location set by said next byte pointer, and incrementing said next byte pointer;</claim-text>
      <claim-text>and for each 6-tuple generated for this filter rule, setting a next rule tuple element to point to the next 6-tuple in said tuple buffer.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 4, said resolving and loading steps further comprising the steps of: for each 6-tuple generated for this filter rule, - replacing said operator index with a pointer to a corresponding function; - computing a next rule pointer to the next rule based on said next rule tuple element;</claim-text>
      <claim-text>and - replacing said next rule tuple element with said next rule pointer.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 5, said interpreting step comprising the further steps of: obtaining a tuple pointer to a first 6-tuple; while an operator function returns a value of true, - calling the operator function of the tuple designated by said tuple pointer, and passing, as the parameters to said operator function, the 6-tuple pointed to by said tuple pointer; - responsive to said operator function returning a value of false, setting said tuple pointer to point to the next rule and leaving this while loop; - responsive to said operator function returning a value of true, setting said tuple pointer to the next 6-tuple and continuing this while loop.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 6, wherein the while loop of said interpreting step comprising the further steps of: responsive to the 6-tuple pointed to by said tuple pointer including a journal entry parameter which evaluates as true, generating a journal entry for said IP packet;</claim-text>
      <claim-text>and returning a result value to said caller selectively for permitting or denying the action requested in said IP packet.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A system for filtering IP packets received from a caller at a physical interface to an operating system kernel, comprising: a first compiler function for processing FILTER rule statements entered by a user in a rules file to generate 6-tuple filtering rules, each said 6-tuple filtering rule including an operator index; a second compiler function for resolving relative and symbolic indexes in said 6-tuples filtering rules to form resolved filtering rules and loading said resolved filtering rules to said operating system kernel;</claim-text>
      <claim-text>and said operating system kernel being operative for interpreting said resolved filtering rules for each IP packet received at said physical interface.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. A program storage device readable by a machine, tangibly embodying a program of instructions executable by a machine to perform method steps for filtering IP packets received from a caller at a physical interface to an operating system kernel, said method steps comprising: processing FILTER rule statements entered by a user in a rules file to generate 6-tuple filtering rules, each said 6-tuple filtering rule including an operator index; resolving relative and symbolic indexes in said 6-tuples filtering rules to form resolved filtering rules and loading said resolved filtering rules to said operating system kernel;</claim-text>
      <claim-text>and interpreting said resolved filtering rules for each IP packet received at said physical interface.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. An article of manufacture comprising: a computer useable medium having computer readable program code means embodied therein for filtering IP packets received from a caller at a physical interface to an operating system kernel, the computer readable program means in said article of manufacture comprising: computer readable program code means for causing a computer to effect processing FILTER rule statements entered by a user in a rules file to generate 6-tuple filtering rules, each said 6-tuple filtering rule including an operator index; computer readable program code means for causing a computer to effect resolving relative and symbolic indexes in said 6-tuple filtering rules to form resolved filtering rules and loading said resolved filtering rules to said operating system kernel;</claim-text>
      <claim-text>and computer readable program code means for causing a computer to effect interpreting said resolved filtering rules for each IP packet received at said physical interface.</claim-text>
    </claim>
  </claims>
</questel-patent-document>