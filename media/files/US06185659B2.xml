<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185659B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185659</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185659</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="23048040" extended-family-id="42113756">
      <document-id>
        <country>US</country>
        <doc-number>09274404</doc-number>
        <kind>A</kind>
        <date>19990323</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09274404</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43172102</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>27440499</doc-number>
        <kind>A</kind>
        <date>19990323</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09274404</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  12/08        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>08</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>711137000</text>
        <class>711</class>
        <subclass>137000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>710034000</text>
        <class>710</class>
        <subclass>034000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>710039000</text>
        <class>710</class>
        <subclass>039000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>711113000</text>
        <class>711</class>
        <subclass>113000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>711118000</text>
        <class>711</class>
        <subclass>118000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>711E12057</text>
        <class>711</class>
        <subclass>E12057</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>718105000</text>
        <class>718</class>
        <subclass>105000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-012/08B8</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>012</main-group>
        <subgroup>08B8</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-012/0862</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>0862</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-012/0866</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>0866</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-012/08B12</classification-symbol>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>22</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>2</number-of-drawing-sheets>
      <number-of-figures>5</number-of-figures>
      <image-key data-format="questel">US6185659</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Adapting resource use to improve performance in a caching memory system</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>VISHLITZKY NATAN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5737747</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5737747</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>CLINE LESLIE E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5826107</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5826107</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>SCHMUCK FRANK B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6023706</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6023706</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>PIROLLI PETER L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6098064</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6098064</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Storage Technology Corporation</orgname>
            <address>
              <address-1>Louisville, CO, US</address-1>
              <city>Louisville</city>
              <state>CO</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>STORAGE TECHNOLOGY</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Milillo, Michael Steven</name>
            <address>
              <address-1>Louisville, CO, US</address-1>
              <city>Louisville</city>
              <state>CO</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>West, Christopher J.</name>
            <address>
              <address-1>Boulder, CO, US</address-1>
              <city>Boulder</city>
              <state>CO</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Brooks &amp; Kushman P.C.</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Nguyen, Hiep T.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A memory system, and a method for controlling prestaging activities based upon the availability of resources within the memory system.
      <br/>
      Prestage requests are stored in a shared memory accessible to a resource controller and one or more memory controllers.
      <br/>
      When the resource controller determines that there are sufficient unused cache memory and sufficient unused memory device back-end bandwidth available to prestage at least one data track, a message is broadcast to all of the memory controllers.
      <br/>
      Those memory controllers with sufficient unused throughput accept the prestage requests and copy the associated data tracks from the memory devices to the cache memory.
      <br/>
      Counters are maintained in the shared memory to track the number of prestage requests in the process of being serviced, and the number of prestaged data tracks already buffered in cache memory and waiting to be accessed by an external host.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>TECHNICAL FIELD</heading>
    <p num="1">The present invention relates to the field of caching memory devices and methods of controlling data track prestaging based upon resource availability.</p>
    <heading>BACKGROUND ART</heading>
    <p num="2">
      The software controlling a cached disk array system is often unaware of how much work is being done.
      <br/>
      It is static in determining how much of the system's resources to devote to completing that work.
      <br/>
      Data is moved between the disk arrays and the cache memory based upon fixed algorithms that do not consider the workload.
      <br/>
      Consequently, disk array systems do not always use the available cache memory, back-end disk bandwidth, or disk controller processor cycle (throughput) resources to the fullest extent possible.
    </p>
    <p num="3">
      Static algorithms allocate system resources broadly to allow for many threads of work to operate simultaneously.
      <br/>
      Each thread being executed is given part of the cache memory with which to work.
      <br/>
      When a thread issues a request to access data, if that data is currently buffered in the cache memory (a cache hit) it is quickly provided and the thread continues with its work.
      <br/>
      If the data is not available in the cache memory (a cache miss) then a disk controller must take the request and retrieve the data from a disk drive.
      <br/>
      Accessing a disk drive consumes controller throughput and the back-end bandwidth of the disk drive array.
      <br/>
      It also takes considerably more time than accessing the same data from the cache memory.
    </p>
    <p num="4">
      Under light workload conditions the performance of the disk array system, as seen by the threads requesting access to the data, is governed mainly by the percentage of cache hits and cache misses.
      <br/>
      A thread that experiences a cache miss is delayed for a limited time as there is little competition for drive controller throughput or disk array bandwidth needed to access the data from the disk array.
      <br/>
      Competition for the throughput and bandwidth increases as the workload increases.
      <br/>
      Under heavy workloads, the average access time becomes limited by either the drive controller's ability to service cache misses or the disk array's bandwidth.
    </p>
    <p num="5">
      Disk array system performance can be improved under all workload conditions by increasing the size of the cache memory, increasing the drive controller throughput, adding more drive controllers, and increasing the back-end bandwidth of the disk array itself.
      <br/>
      Each of these improvements requires faster hardware which translates to increased cost and power consumption.
    </p>
    <p num="6">
      Changes to the controlling software cannot increase the speed or capacity of the hardware resources, but it can improve performance by using those resources more efficiently.
      <br/>
      The best way to improve a caching disk system's performance is to improve its cache utilization.
      <br/>
      A cache hit is a significant performance improvement over a cache miss.
      <br/>
      By adjusting the algorithms, underutilized resources can be reallocated to allow more data tracks to be prestaged from the disk array into the cache memory.
      <br/>
      More data in the cache memory increases the probability of cache hits, and thus improves the overall performance.
    </p>
    <heading>DISCLOSURE OF INVENTION</heading>
    <p num="7">
      The present invention is a memory system, and a method for controlling prestaging of data tracks to cache memory based upon the availability of resources within the memory system.
      <br/>
      The memory system comprises a cache memory, a resource controller, a shared memory, one or more memory devices, and one or more memory controllers.
      <br/>
      Prestage hints from an external host are provided to the resource controller that generates and stores prestage requests in the shared memory.
      <br/>
      The contents of the shared memory are also available to the memory controllers.
      <br/>
      When the resource controller determines that there is sufficient cache memory and sufficient memory device back-end bandwidth available to prestage at least one data track, it broadcasts a message to all of the memory controllers.
      <br/>
      Memory controllers not utilizing all of their throughput may accept the prestage requests from the shared memory then copy the associated data tracks from the memory devices to the cache memory.
      <br/>
      Counters are maintained in the shared memory to track the number of prestage requests in the process of being serviced, and the number of prestaged data tracks already buffered in cache memory and waiting to be accessed by the host.
    </p>
    <p num="8">
      This system and method provide improved performance during simple benchmark testing and during periods of low workload.
      <br/>
      The improved performance is achieved by increasing the use of cache memory, memory device back-end bandwidth, and memory controller throughput to increase the probability of a cache hit.
    </p>
    <p num="9">
      Accordingly, it is an object of the present invention to provide a memory system that has at least one memory device, at least one memory controller, cache memory and a resource controller.
      <br/>
      The resource controller determines when there is sufficient unused cache memory and/or unused memory device bandwidth available to service at least one prestage request.
      <br/>
      When either or both resources are available, the resource controller broadcasts a message to all of the memory controllers to service the prestage requests.
      <br/>
      Each memory controller with available throughput accepts one prestage request and then copies the associated data track from the memory devices to the cache memory.
    </p>
    <p num="10">
      Yet another object of the present invention is to provide a method for controlling prestaging requests in a caching memory system.
      <br/>
      The method involves calculating the available capacity of the cache memory and calculating the available bandwidth for the memory devices.
      <br/>
      When the calculated available capacity and/or bandwidth allow for at least one data track to be prestaged, a message is broadcast to all of the memory controllers in the system.
      <br/>
      When each memory controller receives the broadcast message, it determines its available throughput.
      <br/>
      When the throughput is sufficient to service at least one prestage request, the memory controller accepts one prestage request and then copies the associated data track from the memory devices to the cache memory.
    </p>
    <p num="11">These and other objects, features and advantages will be readily apparent upon consideration of the following detailed description in conjunction with the accompanying drawings.</p>
    <heading>BRIEF DESCRIPTION OF DRAWINGS</heading>
    <p num="12">
      FIG. 1 is a block diagram of the present invention;
      <br/>
      FIG. 2 is a flow diagram of the process for storing prestage requests in shared memory;
      <br/>
      FIG. 3 is a flow diagram of the process for determining when to broadcast the message to the memory controllers;
      <br/>
      FIG. 4 is a flow diagram of the process for accepting a prestage request; and
      <br/>
      FIG. 5 is a flow diagram of the process for accessing prestaged data tracks.
    </p>
    <heading>BEST MODE FOR CARRYING OUT THE INVENTION</heading>
    <p num="13">
      The present invention is a memory system, and a method for controlling prestage requests based upon resource availability within the system.
      <br/>
      The resources monitored are cache memory usage, memory device back-end bandwidth, and memory controller throughput.
      <br/>
      When there is sufficient cache memory, memory device bandwidth, and memory controller throughput available, then one or more data tracks identified by the one or more prestage requests are copied from the memory devices to the cache memory.
    </p>
    <p num="14">
      FIG. 1 is a block diagram of a memory system 100 that implements the present invention.
      <br/>
      A cache memory 102 provides a high speed interface 104 to a host 106 for rapid exchanges of data.
      <br/>
      Data written from the host 106 into the cache memory 102 is copied through a second interface 108 by one or more memory controllers 110.
      <br/>
      Memory controllers 110 write the data across a bus 112 into one or more memory devices 114.
      <br/>
      This process is referred to as a destaging activity.
      <br/>
      It allows the host to write data at high speeds into the memory system 100 without waiting for the propagation delays introduced by the memory controllers 110, bus 112, or memory devices 114.
    </p>
    <p num="15">
      The speed at which data can be supplied to the host 106 on demand is determined by presence or absence of that data in the cache memory 102.
      <br/>
      When the data is present in the cache memory 102, it is read quickly by the host 106 over the high speed interface 104.
      <br/>
      When the data is not present in the cache memory, one of the memory controllers 110 must copy the requested data from the proper data track in the proper memory device 114 into the cache memory 102.
      <br/>
      Once the requested data is in cache memory 102, it is supplied to the host 106 across the high speed interface 104.
      <br/>
      Copying the data from the memory devices 114 to the cache memory 102 after host 106 has attempted to read the data is referred to as a demand stage request.
    </p>
    <p num="16">
      To improve the probability that the desired data is available in the cache memory 102 for the host 106 to read, the host 106 issues prestage hints on interface 116 to the memory system 100 to have the data copied into the cache memory 102 before the host 106 attempts a read.
      <br/>
      The present invention provides a resource controller 118 to generate and store the prestage requests in a shared memory 120 through interface 122.
    </p>
    <p num="17">
      Resource controller 118 reads the contents of shared memory 120 when determining if there are sufficient resources available to service the prestage requests.
      <br/>
      When the resource controller 118 determines that at least one prestage request can be serviced, it broadcasts a message over interface 124 to memory controllers 110.
      <br/>
      This message instructs the memory controllers 110 to examine the contents of the shared memory 120 for prestage requests.
      <br/>
      Each memory controller 110 that has available throughput accepts one of the unaccepted prestage requests from shared memory 120 over interface 126.
      <br/>
      The accepting memory controller 110 then copies the data track associated with the accepted prestage request from one of the memory devices 114 to cache memory 102.
      <br/>
      Statuses of the prestage request activities are stored in shared memory 120 in the form of a prestage in-progress counter and a prestage waiting-access counter.
      <br/>
      These two counters are used by the resource controller 118 when determining resource availability.
    </p>
    <p num="18">
      A variety of technologies and configurations can be used in the present invention for memory devices 114, memory controllers 110, and resource controller 118.
      <br/>
      Memory technologies may include disk drives, tape drives, solid state memory devices, virtual storage managers and the like.
      <br/>
      Configuration of memory devices 114 may range from a single drive to large redundant arrays.
      <br/>
      Similarly, one or more memory controllers 110 may be employed between the memory devices 114 and cache memory 102.
      <br/>
      The preferred embodiment utilizes multiple memory controllers with an array of hard disk drives.
      <br/>
      Resource controller 118 may be software or firmware executed by a dedicated processor, executed by any other processor in the memory system 100, or it may be hardwired logic.
    </p>
    <p num="19">
      FIG. 2 is a flow diagram of the process executed by the resource controller 118 to store the prestage requests in shared memory 120.
      <br/>
      This function is initiated when resource controller 118 receives one or more prestage hints form host 106, as shown in block 200.
      <br/>
      Resource controller 118 writes the prestage requests generated into shared memory 120, as shown in block 202.
      <br/>
      FIG. 2 shows this function as event driven, with the starting event being the arrival of the prestage hints.
      <br/>
      Alternatively, this function may be periodic in nature with the resource controller 118 generating the new prestage requests at a fixed rate.
      <br/>
      Other methods of communication may also be used in transferring the prestage requests to shared memory 120.
    </p>
    <p num="20">
      FIG. 3 is a flow diagram of the decisions that resource controller 118 must make before broadcasting a message to memory controllers 110.
      <br/>
      The first decision made by the resource controller 118 is to determine, decision block 300, if there are any prestage requests in shared memory 120 that have not yet been accepted by any memory controller 110.
      <br/>
      If there are no prestage requests in shared memory 120 to service then resource controller 118 rechecks the shared memory 120 periodically, or waits for new prestage requests to be generated.
    </p>
    <p num="21">
      When at least one prestage request is in shared memory 120, then the available cache memory 102 is calculated to determine if there is sufficient room to buffer at least one data track from one of the memory devices 114, as shown by decision block 302.
      <br/>
      Cache memory availability is determined by the total capacity of cache memory 102 installed in the memory system 100, a portion of that total capacity allocated to prestage and demand stage activities (allocated capacity), a percentage of the allocated capacity reserved for prestage activities, the amount already consumed by prestaged data tracks waiting for access by the host 106, the amount being consumed by data tracks in the process of being prestaged, and by a cache free space threshold.
      <br/>
      Cache free space threshold defines the maximum amount of cache memory 102 that is required to buffer one data track from the memory devices 114.
      <br/>
      The product of the cache free space threshold and the prestage in-progress counter is the amount of cache memory 102 allocated to prestage requests in-progress.
      <br/>
      The product of the cache free space threshold and the prestage waiting-access counter is the amount of cache memory 102 consumed by prestaged data tracks waiting to be accessed by host 106.
      <br/>
      When the percentage of the allocated capacity reserved for prestage activities, minus the memory consumed by prestage waiting-access data tracks, and minus the memory allocated to prestage in-progress data tracks is greater than or equal to the cache free space threshold, then there is sufficient cache memory 102 available to service at least one more prestage request.
    </p>
    <p num="22">
      The allocated capacity of cache memory 102 varies from memory system to memory system 100 depending upon the users requirements and budget.
      <br/>
      This allocated capacity may either be embedded within the resource controller 118, or supplied to the resource controller 118 from an external source, usually host 106.
      <br/>
      In the preferred approach, resource controller 118 is designed to accept the allocated capacity from an external source.
      <br/>
      This allows the resource controller 118 to be installed in a variety of memory systems 100 without a need for customization to each memory system 100.
    </p>
    <p num="23">
      The percentage of the allocated capacity of cache memory 102 reserved for prestage activities may either be a fixed or dynamic value.
      <br/>
      Fixed values are suitable for situations where there is sufficient allocated capacity to handle all anticipated prestage workloads.
      <br/>
      Around 50% of the allocated capacity is reserved for prestage activities in typical applications.
      <br/>
      Higher or lower percentages may be suitable where the expected ratio of all activities to prestage activities is other than two-to-one.
    </p>
    <p num="24">
      In the preferred approach, the percentage of the allocated capacity reserved for prestaging activities is a dynamic variable to improve overall memory system 100 performance.
      <br/>
      During periods where the number of demand stage requests are low, a higher percentage of the allocated capacity is reserved for prestage activities.
      <br/>
      More prestaged data tracks in cache memory 102 increases the probability of a cache hit.
      <br/>
      During periods of high demand stage requests, the percentage reserved for prestage activities is decreased accordingly.
      <br/>
      Dynamic reservation of allocated capacity should also take into account a maximum expected demand stage burst rate.
      <br/>
      If all of the allocated capacity not used by demand stage requests is reserved for and consumed by prestage requests, then additional demand stage requests cause a contention.
      <br/>
      In such situations, the memory system 100 must either delay servicing the additional demand stage requests, or dump prestaged data tracks in-progress and/or waiting-access to make room for the demand stage data tracks.
      <br/>
      Delaying demand stage requests lowers performance.
      <br/>
      Prestaging data tracks and then deleting them before they are accessed by host 106 wastes resources.
      <br/>
      Reserving part of the unused allocated capacity for demand stage request bursts minimizes or eliminates the contention.
    </p>
    <p num="25">
      Resource controller 118 also checks the available back-end bandwidth of the memory devices 114, as shown by decision block 304, for sufficient bandwidth to read at least one additional data track.
      <br/>
      Bandwidth availability is a function of the total memory device bandwidth, a portion of the total memory device bandwidth allocated to servicing prestage requests, demand requests and destage requests (allocated bandwidth), a percentage of the allocated bandwidth reserved for prestage activities, the bandwidth currently consumed by prestage requests in-progress, and the bandwidth required to read one data track.
      <br/>
      The product of the bandwidth required to read one data track and the prestage in-progress counter is the amount of bandwidth currently consumed by the prestage requests in-progress.
      <br/>
      When the percentage of the memory device allocated bandwidth reserved for servicing prestage activities, minus the bandwidth currently consumed by prestage requests in-progress is greater than or equal to the bandwidth required to read one data track, then there is sufficient memory device bandwidth available to service at least one additional prestage request.
    </p>
    <p num="26">
      Allocated memory device bandwidth, like the allocated capacity of cache memory 102, varies from memory system to memory system 100.
      <br/>
      The allocated bandwidth may either be embedded within the resource controller 118, or supplied to the resource controller 118 from an external source, usually host 106.
      <br/>
      Here too, the preferred approach is to design resource controller 118 to accept the allocated bandwidth from an external source.
      <br/>
      This allows the resource controller 118 to be installed in a variety of memory systems 100 without a need for customization.
    </p>
    <p num="27">
      The percentage of memory device allocated bandwidth reserved for servicing prestage activities may either be a fixed or dynamic value.
      <br/>
      Fixed values are suitable for situations where there is sufficient allocated bandwidth to handle all anticipated prestage workloads.
      <br/>
      Around 20% to 80% of the allocated bandwidth may be reserved for prestage requests, with 50% being a nominal value.
      <br/>
      The remaining allocated bandwidth is reserved for demand stage and destage activities.
      <br/>
      In some applications, no allocated bandwidth reservations are made for the various activities.
      <br/>
      Prestage, demand stage and destage activities share all of the allocated bandwidth.
      <br/>
      Finally, in still other applications, the allocated bandwidth is the total bandwidth.
    </p>
    <p num="28">
      Where a percentage of the memory device allocated bandwidth is reserved for servicing prestage requests, it is preferential to adjust that percentage dynamically.
      <br/>
      The adjustment takes into account the allocated bandwidth consumed by active demand stage requests and active destage requests.
      <br/>
      During times of low demand stage and destage activities the percentage of allocated bandwidth reserved for prestage activities is increased.
      <br/>
      During times of higher demand stage and destage activities the percentage is decreased.
      <br/>
      As with dynamic cache memory allocation, dynamic bandwidth allocation should also take into account the maximum expected demand stage burst rate.
      <br/>
      This will help minimize or eliminate delays to demand stage requests caused by overloading the allocated bandwidth of the memory devices 114.
    </p>
    <p num="29">
      When the resource controller 118 determines that unaccepted prestage requests are waiting in shared memory 120, sufficient allocated capacity of the cache memory 102 is available, and sufficient memory device allocated bandwidth is available, it broadcasts a message to the memory controllers 110, as shown in block 306.
      <br/>
      This message informs the memory controllers 110 that there is work to be performed.
      <br/>
      Using this approach, memory controllers 110 are not required to consume any of their processor time to periodically check shared memory 120 for prestage requests.
    </p>
    <p num="30">
      In alternative arrangements, the sequence of decisions made by the resource controller 118 may be changed.
      <br/>
      For example, the memory device allocated bandwidth availability may be checked first, the presence of unaccepted prestage requests in shared memory 120 checked second, and cache memory allocated capacity availability checked third.
      <br/>
      In still other arrangements, resource controller 118 may only check for allocated capacity availability or allocated bandwidth availability, but not both.
      <br/>
      For example, the resource controller 118 may only check for unaccepted prestage requests and allocated capacity availability before broadcasting the message to the memory controllers 110.
      <br/>
      It would then be up to each memory controller 110 that accepts a prestage request from shared memory 120 to arbitrate with the other memory controllers 110 for memory device bandwidth.
    </p>
    <p num="31">
      FIG. 4 is a flow diagram of the process executed by the memory controllers 110 responding to the broadcast message.
      <br/>
      This function starts with the receipt of the broadcast message, as shown in block 400.
      <br/>
      Each memory controller 110 then determines if it has the available throughput (the unused portion of its total throughput) necessary to service one prestage request, as shown by decision block 402.
      <br/>
      If a memory controller 110 is busy, then it ignores the broadcast message.
      <br/>
      A memory controller 110 that has the time, accepts one of the unaccepted prestage requests from the shared memory 120 and increments the prestage in-progress counter, as shown in block 404.
      <br/>
      Incrementing the prestage in-progress counter informs the resource controller 118 that part of cache memory 102 and memory device bandwidth is being consumed by one more in-progress prestage activity.
      <br/>
      After a memory controller 110 has accepted a prestage request, it copies the data track associated with that prestage request from the appropriate memory device 114 to cache memory 102, as shown in block 406.
      <br/>
      When the data track has been copied, the memory controller 110 decrements the prestage in-progress counter and increments the prestage waiting-access counter in shared memory 120, as shown in block 408.
      <br/>
      The functions of block 408 inform the resource controller 118 that the memory device bandwidth consumed by the in-progress prestage activity is free, and the prestaged data track is buffered in the cache memory 102 waiting to be accessed by host 106.
    </p>
    <p num="32">
      FIG. 5 is a flow diagram of the procedure executed by the resource controller 118 responding to the host 106 accessing a prestaged data track.
      <br/>
      This function starts when the resource controller receives notification that host 106 accesses a prestaged data track from cache memory 102, as shown in block 500.
      <br/>
      Resource controller 118 then decrements the prestage waiting-access counter in shared memory 120, as indicated by block 502.
      <br/>
      At this point, the cache memory 102 partially emptied by the just accessed data track is now available to buffer another data track.
    </p>
    <p num="33">
      While embodiments of the invention have been illustrated and described, it is not intended that these embodiments illustrate and describe all possible forms of the invention.
      <br/>
      Rather, the words used in the specification are words of description rather than limitation, and it is understood that various changes may be made without departing from the spirit and scope of the invention.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A memory system for use by a host, the memory system comprising:</claim-text>
      <claim-text>at least one memory device having a plurality of data tracks and an allocated bandwidth of which an unused portion defines an available bandwidth; a cache memory in communication with the host and having an allocated capacity of which an unused portion defines an available capacity; at least one memory controller in communication with the at least one memory device and the cache memory, the at least one memory controller having a total throughput of which an unused portion defines an available throughput; a resource controller in communication with the at least one memory controller and the host, the resource controller is operative to generate a plurality of prestage requests, each prestage request of the plurality of prestage requests identifies a respective data track of the plurality of data tracks in the at least one memory device, wherein the resource controller is operative to broadcast a message to the at least one memory controller when there is at least one unaccepted prestage request of the plurality of prestage requests, and when at least one resource selected from the group of resources consisting of the available capacity of the cache memory and the available bandwidth of the at least one memory device is sufficient to copy one data track of the plurality of data tracks to the cache memory;</claim-text>
      <claim-text>and wherein the at least one memory controller receives the message from the resource controller, and each memory controller of the at least one memory controller having the available throughput sufficient to copy the one data track of the plurality of data tracks reads an accepted prestage request of the at least one unaccepted prestage request, and copies the respective data track of the plurality of data tracks to the cache memory.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The memory system of claim 1 further comprising: an in-progress counter indicating how many respective data tracks of the plurality of data tracks are in the process of being copied into the cache memory;</claim-text>
      <claim-text>and a waiting-access counter indicating how many respective data tracks of the plurality of data tracks are buffered by the cache memory and are waiting to be accessed by the host; wherein each memory controller of the at least one memory controller increments the in-progress counter for each accepted prestage request of the at least one unaccepted prestage request, and decrements the in-progress counter and increments the waiting-access counter for each respective data track of the plurality of data tracks it has copied to the cache memory;</claim-text>
      <claim-text>and wherein the resource controller decrements the waiting-access counter for each respective data track of the plurality of dat tracks buffered by the cache memory that is accessed by the host.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The memory system of claim 2 further comprising a shared memory in communication with the resource controller and the at least one memory controller, for holding the plurality of prestage requests, the in-progress counter, and the waiting access-counter.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The memory system of claim 2 wherein the resource controller calculates the available capacity of the cache memory based upon a first percentage of the allocated capacity of the cache memory, the in-progress counter, and the waiting-access counter.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The memory system of claim 4 wherein the first percentage is approximately 50%.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The memory system of claim 4 wherein the cache memory further buffers at least one data track of the plurality of data tracks associated with at least one non-prestage request, and the first percentage is calculated based upon the allocated capacity of the cache memory currently consumed by the at least one data track associated with the at least one non-prestage request and a burst rate.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The memory system of claim 2 wherein the resource controller calculates the available bandwidth of the at least one memory device based upon a second percentage of the allocated bandwidth of the at least one memory device, and the in-progress counter.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The memory system of claim 7 wherein the second percentage is approximately 50%.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The memory system of claim 7 wherein the allocated bandwidth further carries at least one data track of the plurality of data tracks associated with at least one non-prestage request, and the second percentage is calculated based upon the in-progress counter, the allocated bandwidth of the at least one memory device currently consumed by the at least one data track associated with the at least one non-prestage request, and a burst rate.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The memory system of claim 1 wherein the at least one memory device is at least one disk drive.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The memory system of claim 1 wherein the at least one memory device is at least one tape drive.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The memory system of claim 1 wherein the at least one memory device is at least one solid state memory drive.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The memory system of claim 1 wherein the at least one memory device is at least one virtual memory drive.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A method of prestaging a plurality of data tracks in a memory system having at least one memory device, a cache memory connected to a host, at least one memory controller connected between the at least one memory device and the cache memory, and a resource controller connected between the host and the at least one memory controller, the method comprising: generating a plurality of prestage requests by the resource controller, each prestage request of the plurality of prestage requests identifying a respective data track of a plurality of data tracks in the at least one memory device; calculating an available bandwidth of the at least one memory device by the resource controller in response to generating the plurality of prestage requests; calculating an available capacity of the cache memory by the resource controller in response to generating the plurality of prestage requests; broadcasting a message from the resource controller to the at least one memory controller in response to calculating the available capacity of the cache memory and the available bandwidth of the at least one memory device, and having at least one unaccepted prestage request of the plurality of prestage requests, and having at least one resource selected from the group of resources consisting of the available bandwidth of the at least one memory device and the available capacity of the cache memory sufficient to copy one data track of the plurality of data tracks to the cache memory; determining an available throughput for each memory controller of the at least one memory controller by each memory controller in response to receiving the message broadcast from the resource controller; reading an accepted prestage request of the at least one unaccepted prestage request by each memory controller having the available throughput sufficient to copy the one data track of the plurality of data tracks into the cache memory;</claim-text>
      <claim-text>and copying the respective data track of the plurality of data tracks into cache memory by each memory controller having the available throughput sufficient to copy one data track of the plurality of data tracks.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method of claim 14 further comprising: incrementing an in-progress counter by the at least one memory controller in response to reading each accepted prestage request; incrementing a waiting-access counter and decrementing the in-progress counter by the at least one memory controller in response to each respective data track that is copied to the cache memory;</claim-text>
      <claim-text>and decrementing the waiting-access counter by the resource controller in response to each respective data track buffered by the cache memory that is accessed by the host.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 15 wherein the plurality of prestage requests, the in-progress counter, and the waiting-access counter are held in a shared memory.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method of claim 15 wherein calculating the available capacity of the cache memory is based upon a first percentage of an allocated capacity of the cache memory, the in-progress counter, and the waiting-access counter.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method of claim 17 wherein the first percentage is approximately 50%.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method of claim 17 further comprising: buffering in the cache memory at least one data track of the plurality of data tracks associated with at least one non-prestage request;</claim-text>
      <claim-text>and calculating the first percentage based upon the allocated capacity of the cache memory currently consumed by the at least one data track associated with the at least one non-prestage request and a burst rate.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The method of claim 15 wherein calculating the available bandwidth of the at least one memory device is based upon a second percentage of an allocated bandwidth of the at least one memory device, and the in-progress counter.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The method of claim 20 wherein the second percentage is approximately 50%.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The method of claim 20 further comprising: carrying within the allocated bandwidth of the at least one memory device at least one data track associated with at least one non-prestage request;</claim-text>
      <claim-text>and calculating the second percentage based upon the in-progress counter, the allocated bandwidth of the at least one memory device currently consumed by the at least one data track associated with the at least one non-prestage request, and a burst rate.</claim-text>
    </claim>
  </claims>
</questel-patent-document>