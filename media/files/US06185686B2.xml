<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185686B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185686</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185686</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="26700571" extended-family-id="1368798">
      <document-id>
        <country>US</country>
        <doc-number>09545065</doc-number>
        <kind>A</kind>
        <date>20000407</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>2000US-09545065</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>1421158</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>54506500</doc-number>
        <kind>A</kind>
        <date>20000407</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>2000US-09545065</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>88772397</doc-number>
        <kind>A</kind>
        <date>19970703</date>
        <priority-linkage-type>1</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-08887723</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="3">
        <country>US</country>
        <doc-number>2599196</doc-number>
        <kind>P</kind>
        <date>19960912</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="3">
        <doc-number>1996US-60025991</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  12/14        20060101AFI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>14</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   1/00        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>1</main-group>
        <subgroup>00</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   9/445       20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>445</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="4">
        <text>G06F  21/00        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>00</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="5">
        <text>G06F  21/22        20060101ALI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>22</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="6">
        <text>G06F  21/24        20060101ALI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>24</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="7">
        <text>G09C   1/00        20060101ALI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>09</class>
        <subclass>C</subclass>
        <main-group>1</main-group>
        <subgroup>00</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>713190000</text>
        <class>713</class>
        <subclass>190000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>380255000</text>
        <class>380</class>
        <subclass>255000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>380264000</text>
        <class>380</class>
        <subclass>264000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>713193000</text>
        <class>713</class>
        <subclass>193000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-021/10</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>10</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-021/12A4A</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>021</main-group>
        <subgroup>12A4A</subgroup>
      </classification-ecla>
      <classification-ecla sequence="3">
        <text>G06F-021/54</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>54</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-021/10</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>10</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20151016</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-021/126</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>126</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20151016</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-021/54</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>21</main-group>
        <subgroup>54</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20151016</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-2211/007</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>2211</main-group>
        <subgroup>007</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20151016</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-2221/0737</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>2221</main-group>
        <subgroup>0737</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20151016</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="6">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-2221/2135</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>2221</main-group>
        <subgroup>2135</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20151016</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="7">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-2221/2147</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>2221</main-group>
        <subgroup>2147</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20151016</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="8">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-211/014B</classification-symbol>
      </patent-classification>
      <patent-classification sequence="9">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-221/07C4</classification-symbol>
      </patent-classification>
      <patent-classification sequence="10">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-221/2107</classification-symbol>
      </patent-classification>
      <patent-classification sequence="11">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-221/2135</classification-symbol>
      </patent-classification>
      <patent-classification sequence="12">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-221/2147</classification-symbol>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>12</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>8</number-of-drawing-sheets>
      <number-of-figures>9</number-of-figures>
      <image-key data-format="questel">US6185686</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Computer system and process for accessing an encrypted and self-decrypting digital information product while restricting access to decrypted digital information</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>BEST ROBERT M</text>
          <document-id>
            <country>US</country>
            <doc-number>4278837</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4278837</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>LUMLEY ROBERT M</text>
          <document-id>
            <country>US</country>
            <doc-number>4306289</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4306289</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>RIVEST RONALD L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4405829</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4405829</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>BEST ROBERT M</text>
          <document-id>
            <country>US</country>
            <doc-number>4433207</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4433207</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <related-documents>
      <continuation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>88772397</doc-number>
              <kind>A</kind>
              <date>19970703</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>6052780</doc-number>
              <kind>A</kind>
            </document-id>
          </parent-doc>
        </relation>
      </continuation>
      <related-publication>
        <document-id>
          <country>US</country>
          <doc-number>60/025,991</doc-number>
          <date>19960912</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/025991</doc-number>
          <date>19960912</date>
        </document-id>
      </related-publication>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Open Security Solutions, LLC</orgname>
            <address>
              <address-1>Waban, MA, US</address-1>
              <city>Waban</city>
              <state>MA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>OPEN SECURITY SOLUTIONS</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Glover, John J.</name>
            <address>
              <address-1>Medford, MA, US</address-1>
              <city>Medford</city>
              <state>MA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Wolf, Greenfield &amp; Sacks, P.C.</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Peeso, Thomas R.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Some of these problems with digital information protection systems may be overcome by providing a mechanism which allows a content provider to encrypt digital information without requiring either a hardware or platform manufacturer or a content consumer to provide support for the specific form of corresponding decryption.
      <br/>
      This mechanism can be provided in a manner which allows the digital information to be copied easily for back-up purposes and to be transferred easily for distribution, but which should not permit copying of the digital information in decrypted form.
      <br/>
      In particular, the encrypted digital information is stored as an executable computer program which includes a decryption program that decrypts the encrypted information to provide the desired digital information, upon successful completion of an authorization procedure by the user.
      <br/>
      In combination with other mechanisms that track distribution, enforce royalty payments and control access to decryption keys, the present invention provides an improved method for identifying and detecting sources of unauthorized copies.
      <br/>
      Suitable authorization procedures also enable the digital information to be distributed for a limited number of uses and/or users, thus enabling per-use fees to be charged for the digital information.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
    <p num="1">
      This application is a continuing application of U.S. patent application Ser.
      <br/>
      No. 08/887,723 filed Jul. 3, 1997, now U.S. Pat. No. 6,052,780 which claimed the benefit under 35 U.S.C. .sctn.119(e) of U.S. Provisional Application Ser.
      <br/>
      No. 60/025,991 filed Sep. 12, 1996 by John J. Glover and entitled A COMPUTER SYSTEM AND PROCESS FOR EXECUTING AN ENCRYPTED AND SELF-DECRYPTING COMPUTER PROGRAM PRODUCT WHILE PREVENTING ACCESS TO DECRYPTED EXECUTABLE CODE, which is hereby incorporated by reference.
    </p>
    <heading>MICROFICIIE APPENDIX</heading>
    <p num="2">
      Application Ser.
      <br/>
      No. 08/887,723 also contains a Microfiche Appendix pursuant to 37 C.F.R. 1.96(b) containing two (2) microfiche cards with ninety-eight (98) frames each and one (1) microfiche card with ninety-four (94) frames, which is hereby incorporated by reference.
    </p>
    <heading>COPYRIGHT NOTICE</heading>
    <p num="3">
      A portion of the disclosure of this patent document, in particular portions of the Microfiche Appendix, contains material which is subject to copyright protection.
      <br/>
      The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the U.S. Patent and Trademark Office, patent file or records, but otherwise reserves all copyright rights whatsoever.
    </p>
    <heading>FIELD OF THE INVENTION</heading>
    <p num="4">
      The present invention is related to mechanisms for protecting digital information from being copied.
      <br/>
      In particular, the present invention is related to mechanisms which permit authorized execution of computer program code or access to other digital information which is encrypted or otherwise encoded.
    </p>
    <heading>BACKGROUND</heading>
    <p num="5">
      A serious problem which faces the electronic publishing and software industries is the ease with which digital information can be copied without authorization from the publisher.
      <br/>
      Digital information also may be used or modified without authorization.
      <br/>
      For example, computer software may be reverse engineered or attacked by computer viruses.
    </p>
    <p num="6">
      There are many mechanisms available which may be used to limit or prevent access to digital information.
      <br/>
      Such mechanisms often either restrict the ability of the user to make back-up copies or involve the use of special purpose hardware to limit access to the digital information.
      <br/>
      For example, some mechanisms restrict the use of digital information to a particular machine.
      <br/>
      See, for example, U.S. Pat. No. 4,817,140. Other mechanisms require the digital information to be stored on a particular recording medium in order to be used.
      <br/>
      See, for example, U.S. Pat. No. 5,412,718. Yet other mechanisms allow only a certain number of uses of the digital information.
      <br/>
      See for example, U.S. Pat. No. 4,888,798. Many of these access control mechanisms cause distribution to be more costly.
    </p>
    <p num="7">Several other patents describe a variety of systems for encryption, compression, licensing and royalty control and software distribution such as: U.S. Pat. No. 4,405,829, U.S. Pat. No. 4,864,616, U.S. Pat. No. 4,888,800, U.S. Pat. No. 4,999,806, U.S. Pat. No. 5,021,997, U.S. Pat. No. 5,027,396, U.S. Pat. No. 5,033,084, U.S. Pat. No. 5,081,675, U.S. Pat. No. 5,155,847, U.S. Pat. No. 5,166,886, U.S. Pat. No. 5,191,611, U.S. Pat. No. 5,220,606, U.S. Pat. No. 5,222,133, U.S. Pat. No. 5,272,755, U.S. Pat. No. 5,287,407, U.S. Pat. No. 5,313,521, U.S. Pat. No. 5,325,433, U.S. Pat. No. 5,327,563, U.S. Pat. No. 5,337,357, U.S. Pat. No. 5,351,293, U.S. Pat. No. 5,341,429, U.S. Pat. No. 5,351,297, U.S. Pat. No. 5,361,359, U.S. Pat. No. 5,379,433, U.S. Pat. No. 5,392,351, U.S. Pat. No. 5,394,469, U.S. Pat. No. 5,414,850, U.S. Pat. No. 5,473,687, U.S. Pat. No. 5,490,216, U.S. Pat. No. 5,497,423, U.S. Pat. No. 5,509,074, U.S. Pat. No. 5,511,123, U.S. Pat. No. 5,524,072, U.S. Pat. No. 5,532,920, U.S. Pat. No. 5,555,304, U.S. Pat. No. 5,557,346, U.S. Pat. No. 5,557,765, U.S. Pat. No. 5,592,549, U.S. Pat. No. 5,615,264, U.S. Pat. No. 5,625,692, and U.S. Pat. No. 5,638,445.</p>
    <p num="8">
      Computer programs or other digital information also may be encrypted in order to prevent an individual from making a useful copy of the information or from reverse engineering a program.
      <br/>
      Even with such encryption, however, a computer program must be decrypted in order for a computer to load and execute the program.
      <br/>
      Similarly, other digital information must be decrypted before it can be accessed and used.
      <br/>
      Generally, digital information is decrypted to disk, and not to main memory of the computer which is more protected by the operating system, because decryption to main memory results in a significant loss of memory resources.
      <br/>
      If the purpose for using encryption is to prevent users from copying the digital information, then decryption of the information to accessible memory for use defeats this purpose.
    </p>
    <p num="9">
      One way to protect digital information using encryption has been made available by International Business Machines (IBM) and is called a "CRYPTOLOPE" information container.
      <br/>
      This technology is believed to be related to U.S. Pat. Nos. 5,563,946 and 5,598,470 (to Cooper et al.), and published European patent applications 0679977, 0679978, 0679979 and 0681233.
      <br/>
      The CRYPTOLOPE system requires a user to have a "helper application" and a key.
      <br/>
      The CRYPTOLOPE information container is generated by IBM.
      <br/>
      The content provider submits data to IBM, which in turn encrypts and packages the data in a CRYPTOLOPE information container.
      <br/>
      The helper application is a form of memory resident program, called a terminate and stay resident (TSR) program, which is a form of input/output (I/O) device driver installed in the operating system and which monitors requests from the operating system for files on specified drives and directories.
      <br/>
      Because the TSR program must know the directory, and/or file name to be accessed, that information also is available to other programs.
      <br/>
      Other programs could use that information to manipulate the operation of the TSR program in order to have access to decrypted contents of the information container.
      <br/>
      The encrypted information container includes an executable stub which is executed whenever the application is run without the installed TSR program or from a drive not monitored by the TSR program to prevent unpredictable activity from executing encrypted code.
      <br/>
      This stub may be used to install decryption and cause the application be executed a second time, or to communicate with the TSR program to instruct the TSR program to monitor the drive.
      <br/>
      It may be preferable from the point of view of the content provider however to maintain an encryption process and keys independently of any third party.
    </p>
    <p num="10">
      Multimedia content, such as a movie or hypertext presentation also may be stored on a digital versatile disk (DVD), sometimes called a digital video disk, compact disk read-only memory (CD-ROM), rewriteable compact disks (CD-RW) or other medium in an encrypted digital format for use with special-purpose devices.
      <br/>
      For example, concern about illegal copying of content from digital video disks or other digital media has resulted in a limited amount of content being available for such devices.
      <br/>
      This problem has caused representatives of both multimedia providers and digital video disk manufacturers to negotiate an agreement on an encryption format for information stored on DVDs.
      <br/>
      This copy protection scheme is licensed through an organization called the CSS Interim Licensing organization.
      <br/>
      However, in this arrangement, the content provider is limited to using the agreed upon encryption format and a device manufacturer is limited to using a predetermined decryption system.
    </p>
    <p num="11">
      Encryption has also been used to protect and hide computer viruses.
      <br/>
      Such viruses are typically polymorphic, i.e., they change every time they infect a new program, and are encrypted.
      <br/>
      The virus includes a decryption program that executes to decrypt the virus every time the infected program is run.
      <br/>
      Such viruses are described, for example, in "Computer Virus-Antivirus Coevolution" by Carey Nachenberg, Communications of the ACM, Vol. 40, No. 1, (January 1997), p. 46 et seq. Such viruses include decryption keys within them since, clearly, their execution is not carried out by the user and a user would not be asked for authorization keys to permit execution of the viruses.
      <br/>
      Additionally, such viruses are typically only executed once at the start of execution of an infected program and permanently return control to the infected program after execution.
    </p>
    <heading>SUMMARY</heading>
    <p num="12">
      Some of these problems with digital information protection systems may be overcome by providing a mechanism which allows a content provider to encrypt digital information without requiring either a hardware or platform manufacturer or a content consumer to provide support for the specific form of corresponding decryption.
      <br/>
      This mechanism can be provided in a manner which allows the digital information to be copied easily for back-up purposes and to be transferred easily for distribution, but which should not permit copying of the digital information in decrypted form.
      <br/>
      In particular, the encrypted digital information is stored as an executable computer program which includes a decryption program that decrypts the encrypted information to provide the desired digital information, upon successful completion of an authorization procedure by the user.
    </p>
    <p num="13">
      In one embodiment, the decryption program is executed as a process within a given operating system and decrypts the digital information within the memory area assigned to that process.
      <br/>
      This memory area is protected by the operating system from copying or access by other processes.
      <br/>
      Even if access to the memory area could be obtained, for example through the operating system, when the digital information is a very large application program or a large data file, a copy of the entire decrypted digital information is not likely to exist in the memory area in complete form.
    </p>
    <p num="14">
      By encrypting information in this manner, a platform provider merely provides a computer system with an operating system that has adequate security to define a protected memory area for a process and adequate functionality to execute a decryption program.
      <br/>
      The content provider in turn may use any desired encryption program.
      <br/>
      In addition, by having a process decrypt information within a protected memory area provided by the operating system, the decrypted information does not pass through any device driver, memory resident program or other known logical entity in the computer system whose behavior may be controlled to provide unauthorized access to the data.
      <br/>
      The ability to reverse engineer or attack a computer program with a computer virus also may be reduced.
    </p>
    <p num="15">
      In another embodiment, the decryption program is part of a dynamically loaded device driver that responds to requests for data from the file containing the encrypted data.
      <br/>
      When the digital information product is first executed, this device driver is extracted from the file and is loaded into the operating system.
      <br/>
      The executed digital information product then informs the loaded device driver of the location of the hidden information in the file, any keys or other passwords, and the name of a phantom directory and file to be called that only the digital information product and the device driver know about.
      <br/>
      The name of this directory may be generated randomly.
      <br/>
      Each segment of hidden information in the digital information product may be assigned its own unique file name in the phantom directory.
      <br/>
      The digital information product then makes a call to the operating system to execute one of the files in the phantom directory.
      <br/>
      The loaded driver traps these calls to the operating system, accesses the original file, decrypts the desired information and outputs the desired information to the operating system.
    </p>
    <p num="16">
      In combination with other mechanisms that track distribution, enforce royalty payments and control access to decryption keys, the present invention provides an improved method for identifying and detecting sources of unauthorized copies.
      <br/>
      Suitable authorization procedures also enable the digital information to be distributed for a limited number of uses and/or users, thus enabling per-use fees to be charged for the digital information.
    </p>
    <p num="17">
      Accordingly, one aspect of the invention is a digital information product including a computer-readable medium with digital information stored thereon.
      <br/>
      The digital information includes computer program logic having a first portion of executable computer program logic and a second portion of digital information.
      <br/>
      The first portion of executable program logic, when executed, defines a mechanism for responding to requests for digital information from an operating system of a computer.
      <br/>
      This mechanism, when used to access the second portion of the encrypted digital information, decrypts the encrypted digital information, and provides the encrypted digital information to the operating system.
    </p>
    <p num="18">
      In the foregoing aspect of the invention, the digital information may be executable computer program logic.
      <br/>
      Hence, one aspect of the invention is a computer program product, including a computer readable medium with computer program logic stored thereon.
      <br/>
      The computer program logic includes a first portion of executable computer program logic and a second portion of encrypted computer program logic.
      <br/>
      The first portion of executable computer program logic, when executed, defines a mechanism for responding to requests for computer program logic from an operating system of a computer.
      <br/>
      This mechanism accesses the second portion of encrypted computer program logic, decrypts the encrypted computer program logic, and provides the decrypted computer program logic to the operating system.
    </p>
    <p num="19">Another aspect of the present invention is a computer program product, a computer system and a process which produce a computer program or digital information product in accordance with other aspects of the invention, using executable program code for the first and second portions of the desired computer program product.</p>
    <p num="20">
      Another aspect of the present invention is a computer program product including a self-decrypting encrypted executable computer program.
      <br/>
      The product includes a computer readable medium having computer program logic stored thereon.
      <br/>
      The computer program logic defines first, second and third modules, wherein the third module defines the encrypted executable computer program.
      <br/>
      The first module, when executed by a computer, defines a mechanism for loading the second module into memory of the computer.
      <br/>
      The second module, when executed by a computer, defines a mechanism for communicating with an operating system of the computer to receive requests for program code from the encrypted executable computer program from the third module, and for processing the requests to access and decrypt the encrypted executable computer program and for providing the decrypted executable code from the third module to the operating system.
    </p>
    <p num="21">
      Another aspect of the invention is a process for executing encrypted executable computer programs on a computer system having a processor, memory and operating system.
      <br/>
      The process involves receiving computer program logic having a first module defining a start up routine, a second module, and a third module containing the encrypted executable computer program.
      <br/>
      The first module of the received computer program logic is executed using the processor.
      <br/>
      When the first module is executed, the second module is caused to be loaded into the memory of the computer system.
      <br/>
      Requests are generated from the operating system for data from the encrypted executable computer program and are received by the second module.
      <br/>
      The second module accesses and decrypts the encrypted executable computer program in response to these requests and returns the decrypted executable computer program to the operating system.
    </p>
    <p num="22">These and other aspects, advantages and features of the present invention and its embodiments will be more apparent given the following detailed description.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="23">
      FIG. 1 is a block diagram of a typical computer system with which the present invention may be implemented;
      <br/>
      FIG. 2 is a block diagram of a memory system in the computer system of FIG. 1;
      <br/>
      FIG. 3 is a diagram of a computer program or digital information product which may be recorded on a computer readable and writable medium, such as a magnetic disc;
      <br/>
      FIG. 4 is a flowchart describing how the computer program or digital information product of FIG. 3 is used;
      <br/>
      FIG. 5 is a flowchart describing operation of an example unwrap procedure as shown in FIG. 3 in one embodiment of the invention;
      <br/>
      FIG. 6 is a flowchart describing operation of an example device driver as shown in FIG. 3 in one embodiment of the invention;
      <br/>
      FIG. 7 is a block diagram of a computer system in the process of executing a computer program product in accordance with one embodiment of the invention;
      <br/>
      FIG. 8 is a flowchart describing operation of an example unwrap procedure in another embodiment of the invention; and
      <br/>
      FIG. 9 is a flowchart describing how a computer program product such as shown in FIG. 3 is constructed.
    </p>
    <heading>DETAILED DESCRIPTION</heading>
    <p num="24">The present invention will be more completely understood through the following detailed description which should be read in conjunction with the attached drawing in which similar reference numbers indicate similar structures.</p>
    <p num="25">
      Embodiments of the present invention may be implemented using a general purpose digital computer or may be implemented for use with a digital computer or digital processing circuit.
      <br/>
      A typical computer system 20 is shown in FIG. 1, and includes a processor 22 connected to a memory system 24 via an interconnection mechanism 26.
      <br/>
      An input device 28 also is connected to the processor and memory system via the interconnection mechanism, as is an output device 30.
      <br/>
      The interconnection mechanism 26 is typically a combination of one or more buses and one or more switches.
      <br/>
      The output device 30 may be a display and the input device may be a keyboard and/or a mouse or other cursor control device.
    </p>
    <p num="26">
      It should be understood that one or more output devices 30 may be connected to the computer system.
      <br/>
      Example output devices include a cathode ray tube (CRT) display, liquid crystal display (LCD), television signal encoder for connection to a television or video tape recorder, printers, communication devices, such as a modem, and audio output.
      <br/>
      It also should be understood that one or more input devices 28 may be connected to the computer system.
      <br/>
      Example input devices include a keyboard, keypad, trackball, mouse, pen and tablet, communication device, audio or video input and scanner.
      <br/>
      It should be understood that the invention is not limited to the particular input or output devices used in combination with the computer system or to those described herein.
    </p>
    <p num="27">
      The computer system 20 may be a general purpose computer system, which is programmable using a high level computer programming language, such as "C++," "Pascal," "VisualBasic." The computer system also may be implemented using specially programmed, special purpose hardware.
      <br/>
      In a general purpose computer system, the processor is typically a commercially available processor, such as the Pentium processor from Intel Corporation.
      <br/>
      Many other processors are also available.
      <br/>
      Such a processor executes a program called an operating system, such as Windows 95 or Windows NT 4.0, both available from Microsoft Corporation, which controls the execution of other computer programs and provides scheduling, debugging, input output control, accounting compilation, storage assignment, data management and memory management, and communication control and related services.
      <br/>
      Other examples of operating systems include: MacOS System 7 from Apple Computer, OS/2 from IBM, VMS from Digital Equipment Corporation, MS-DOS from Microsoft Corporation, UNIX from AT&amp;T, and IRIX from Silicon Graphics, Inc.
    </p>
    <p num="28">
      The computer system 20 also may be a special purpose computer system such as a digital versatile disk or digital video disk (DVD) player.
      <br/>
      In a DVD player, there is typically a decoder controlled by some general processor which decodes an incoming stream of data from a DVD.
      <br/>
      In some instances, the DVD player includes a highly integrated DVD decoder engine.
      <br/>
      Such devices generally have a simple operating system which may be modified to include the capabilities described and used herein in connection with the typical operating systems in a general purpose computer.
      <br/>
      In particular, some operating systems are designed to be small enough for installation in an embedded system such as a DVD player, including the WindowsCE operating system from Microsoft Corporation and the JavaOS operating system from SunSoft Corporation.
      <br/>
      The operating system allows a content provider to provide its own programs that define some of the content, which is particularly useful for interactive multimedia.
      <br/>
      This capability also can be used to provide encryption and decryption, in accordance with the invention.
    </p>
    <p num="29">
      The processor and operating system define a computer platform for which application programs in a programming language such as an assembly language or a high level programming language are written.
      <br/>
      It should be understood that the invention is not limited to a particular computer platform, operating system, processor, or programming language.
      <br/>
      Additionally, the computer system 20 may be a multi-processor computer system or may include multiple computers connected over a computer network.
    </p>
    <p num="30">
      An example memory system 24 will now be described in more detail in connection with FIG. 2.
      <br/>
      A memory system typically includes a computer readable and writable non-volatile recording medium 40, of which a magnetic disk, a flash memory, rewriteable compact disk (CD-RW) and tape are examples.
      <br/>
      The recording medium 40 also may be a read only medium such as a compact disc-read only memory (CD-ROM) or DVD.
      <br/>
      A magnetic disk may be removable, such as a "floppy disk" or "optical disk," and/or permanent, such as a "hard drive." The disk, which is shown in FIG. 2, has a number of tracks, as indicated at 42, in which signals are stored, in binary form, i.e., a form interpreted as a sequence of 1's and 0's, as shown at 44.
      <br/>
      Such signals may define an application program to be executed by the microprocessor, or information stored on the disk to be processed by the application program.
      <br/>
      Typically, in the operation of a general purpose computer, the processor 22 causes data to be read from the non-volatile recording medium 40 into an integrated circuit memory element 46, which is typically a volatile random access memory, such as a dynamic random access memory (DRAM) or static random access memory (SRAM).
      <br/>
      The integrated circuit memory element 46 allows for faster access to the information by the processor than disk 40, and is typically called the system or host memory.
      <br/>
      The processor generally causes the data to be manipulated within the integrated circuit memory 46 and may copy the data to the disk 40, if modified, when processing is completed.
      <br/>
      A variety of mechanisms are known for managing data movement between the disk 40 and the integrated circuit memory 46, and the invention is not limited thereto.
      <br/>
      It should also be understood that the invention is not limited to a particular memory system.
    </p>
    <p num="31">
      The file system of a computer generally is the mechanism by which an operating system manages manipulation of data between primary and secondary storage, using files.
      <br/>
      A file is a named logical construct which is defined and implemented by the operating system to map the name and a sequence of logical records of data to physical storage media.
      <br/>
      An operating system may specifically support various record types or may leave them undefined to be interpreted or controlled by application programs.
      <br/>
      A file is referred to by its name by application programs and is accessed through the operating system using commands defined by the operating system.
      <br/>
      An operating system provides basic file operations provided by for creating a file, opening a file, writing a file, reading a file and closing a file.
    </p>
    <p num="32">
      In order to create a file, the operating system first identifies space in the storage media which is controlled by the file system.
      <br/>
      An entry for the new file is then made in a directory which includes entries indicating the names of the available files and their locations in the file system.
      <br/>
      Creation of a file may include allocating certain available space to the file.
      <br/>
      Opening a file returns a handle to the application program which it uses to access the file.
      <br/>
      Closing a file invalidates the handle.
    </p>
    <p num="33">
      In order to write data to a file, an application program issues a command to the operating system which specifies both an indicator of the file, such as a file name, handle or other descriptor, and the information to be written to the file.
      <br/>
      Given the indicator of the file, the operating system searches the directory to find the location of the file.
      <br/>
      The directory entry stores a pointer, called the write pointer, to the current end of the file.
      <br/>
      Using this pointer, the physical location of the next available block of storage is computed and the information is written to that block.
      <br/>
      The write pointer is updated in the directory to indicate the new end of the file.
    </p>
    <p num="34">
      In order to read data from a file, an application program issues a command to the operating system specifying the indicator of the file and the memory locations assigned to the application where the next block of data should be placed.
      <br/>
      The operating system searches its directory for the associated entry given the indicator of the file.
      <br/>
      The directory may provide a pointer to a next block of data to be read, or the application may program or specify some offset from the beginning of the file to be used.
    </p>
    <p num="35">A primary advantage of using a file system is that, for an application program, the file is a logical construct which can be created, opened, written to, read from and closed without any concern for the physical storage used by the operating system.</p>
    <p num="36">
      The operating system also allows for the definition of another logical construct called a process.
      <br/>
      A process is a program in execution.
      <br/>
      Each process, depending on the operating system, generally has a process identifier and is represented in an operating system by a data structure which includes information associated with the process, such as the state of the process, a program counter indicating the address of the next instruction to be executed for the process, other registers used by process and memory management information including base and bounds registers.
      <br/>
      Other information also may be provided.
      <br/>
      The base and bounds registers specified for a process contain values representing the largest and smallest addresses that can be generated and accessed by an individual program.
      <br/>
      Where an operating system is the sole entity able to modify these memory management registers, adequate protection from access to the memory locations of one process from another process is provided.
      <br/>
      As a result, this memory management information is used by the operating system to provide a protected memory area for the process.
      <br/>
      A process generally uses the file system of the operating system to access files.
    </p>
    <p num="37">
      The present invention involves storing encrypted digital information, such an audio, video, text or an executable computer program, on a computer readable medium such that it can be copied easily for back-up purposes and transferred easily for distribution, but also such that it cannot be copied readily in decrypted form during use.
      <br/>
      In particular, the digital information is stored as a computer program that decrypts itself while it is used to provide the digital information, e.g., to provide executable operation code to the operating system of a computer, as the digital information is needed.
      <br/>
      Any kind of encryption or decryption may be used and also may include authorization mechanisms and data compression and decompression.
      <br/>
      In one embodiment of the present invention, decrypted digital information exists only in memory accessible to the operating system and processes authorized by the operating system.
      <br/>
      When the digital information is a large application program, a copy of the entire decrypted application program is not likely to exist in the main memory at any given time, further reducing the likelihood that a useful copy of decrypted code could be made.
      <br/>
      The decryption operation also is performed only if some predetermined authorization procedure is completed successfully.
    </p>
    <p num="38">
      One embodiment of the invention, in which the decryption program is a form of dynamically loaded device driver, will first be described.
      <br/>
      FIG. 3 illustrates the structure of digital information as stored in accordance with one embodiment of the present invention, which may be stored on a computer readable medium such as a magnetic disc or compact disc read only memory (CD-ROM) to form a computer program product.
      <br/>
      The digital information includes a first portion 50, herein called an unwrap procedure or application, which is generally unencrypted executable program code.
      <br/>
      The purpose of the unwrap procedure is to identify the locations of the other portions of the digital information, and may perform other operations such as verification.
      <br/>
      In particular, the unwrap procedure identifies and extracts a program which will communicate with the operating system, herein called a virtual device driver 52.
      <br/>
      The unwrap procedure may include decryption and decompression procedures to enable it to decrypt/decompress the driver, and/or other content of this file.
      <br/>
      The program 52 need not be a device driver.
      <br/>
      The virtual device driver 52 typically follows the unwrap procedure 50 in the file container, the digital information.
      <br/>
      The virtual device driver, when executed, decrypts and decodes the desired digital information such as an executable computer program code from hidden information 54, which may be either encrypted and/or encoded (compressed).
      <br/>
      It is the decrypted hidden information which is the desired digital information to be accessed.
      <br/>
      This hidden information may be any kind of digital data, such as audio, video, text, and computer program code including linked libraries or other device drivers.
    </p>
    <p num="39">
      In this embodiment of the computer program product, labels delineate the boundaries between the device driver and the hidden files.
      <br/>
      These labels may or may not be encrypted.
      <br/>
      A first label 56 indicates the beginning of the code for the virtual device driver 52.
      <br/>
      A second label 58 indicates the end of the virtual device driver code.
      <br/>
      Another label 60 indicates the beginning of the hidden information and a label 62 indicates the end of that application.
      <br/>
      There may be one or more blocks of such hidden information, each of which can be given a different name.
      <br/>
      It may be advantageous to use the name of the block of information in its begin and end tags.
      <br/>
      This computer program product thus contains and is both executable computer program code and one or more blocks of digital information.
      <br/>
      A table of locations specifying the location of each portion of the product could be used instead of labels.
      <br/>
      Such a table could be stored in a predetermined location and also may be encrypted.
    </p>
    <p num="40">
      The overall process performed using this computer program product in one embodiment of the invention will now be described in connection with FIG. 4.
      <br/>
      This embodiment may be implemented for use with the Windows95 operating system and is described in more detail in connection with FIGS. 5-7. An embodiment which may be implemented for use on the WindowsNT 4.0 operating system is described in more detail below in connection with FIG. 8.
      <br/>
      In both of these described embodiments, the digital information is an executable computer program which is read by the operating system as data from this file and is executed.
      <br/>
      The same principle of operation would apply if the data were merely audio, video, text or other information to be conveyed by a user.
      <br/>
      In the embodiment of FIG. 4, the computer program is first loaded into memory in step 70, and the unwrap procedure 50 is executed by the operating system, as any typical executable computer program is executed.
      <br/>
      The unwrap procedure may perform authorization, for example by checking for a required password or authentication code, and may receive any data needed for decryption or decompression, for example keys or passwords, in step 72.
      <br/>
      Suitable authorization procedures may provide the ability to distribute software for single use.
      <br/>
      The unwrap procedure locates the virtual device driver 52 within the computer program in step 74, and then locates the hidden application in step 76.
      <br/>
      The virtual device driver 52 is then extracted by the unwrap procedure from the computer program, copied to another memory location and loaded for use by the operating system in step 78.
      <br/>
      An advantage of an operating system like Windows95 is that it allows such device drivers to be loaded dynamically without restarting the computer.
    </p>
    <p num="41">
      The executed unwrap procedure 50, in step 80, informs the loaded virtual device driver 52 of the location of the hidden information in the file, any keys or other passwords, and a name of a phantom directory and file to be called that only the unwrap procedure and the virtual device driver know about.
      <br/>
      The name of this phantom directory may be generated randomly.
      <br/>
      Each segment information hidden in the digital information product may be assigned its own unique file name in the phantom directory.
    </p>
    <p num="42">
      After the loaded virtual device driver 52 receives all communications from the unwrap procedure, it opens the original application file for read only access in step 82.
      <br/>
      The unwrap procedure then makes a call to the operating system in step 84 to execute the file in the phantom directory for which the name was transmitted to the loaded virtual device driver.
      <br/>
      One function of the loaded virtual device driver 52 is to trap all calls from the operating system to access files in step 86.
      <br/>
      Any calls made by the operating system to access files in the phantom directory are processed by the virtual device driver, whereas calls to access files in other directories are allowed to proceed to their original destination.
      <br/>
      In response to each call from the operating system, the virtual device driver obtains the bytes of data requested by the operating system from the original computer program file in step 88.
      <br/>
      These bytes of data are then decrypted or decompressed in step 90 and returned to the operating system.
      <br/>
      When processing is complete, the phantom application is unloaded from the operating system in step 92, and may be deleted from the memory.
    </p>
    <p num="43">
      A more detailed description of the process of FIG. 4 will now be described in connection with FIGS. 5-7. FIG. 5 is a flowchart describing the operation of one embodiment of the unwrap procedure in more detail.
      <br/>
      The first step performed by this procedure is identifying the operating system being used, in step 100.
      <br/>
      This step is useful because different methods may be used with different operating systems.
      <br/>
      All code that may be used to run in various operating systems may be placed in this unwrap procedure.
      <br/>
      This procedure also may contain the decompression/decryption code, for example or any other computer program code to be executed.
    </p>
    <p num="44">
      The executed application then opens the original executable file as a data file and searches for the begin and end tags of the device driver and hidden files in step 102.
      <br/>
      The device driver code is copied into memory and loaded into the operating system in step 104.
      <br/>
      The unwrap procedure then informs the device driver of the name of the original application file, offsets of the hidden files and the name of a phantom directory, which is typically randomly generated (step 106).
      <br/>
      This communication may be performed using a "DeviceIOControl" function call in the Windows95 operating system.
      <br/>
      The unwrap procedure then makes a call to the operating system to execute the hidden file in the phantom directory, in step 108.
    </p>
    <p num="45">
      The operation of one embodiment of a device driver will now be described in connection with FIG. 6.
      <br/>
      After the device driver is loaded into the operating system, it hooks into a position between the operating system and a file system driver (FSD), in step 110, to intercept calls made by the operating system to the FSD for data from files in the phantom directory.
      <br/>
      The FSD is the code within the operating system that performs physical reading and writing of data to disk drives.
      <br/>
      The operating system makes requests to the FSD for data from files in directories on the disk drives.
      <br/>
      The driver then receives information from the unwrap procedure including the name of the original file, the location of hidden files within the original file, and the name of the phantom directory created by the unwrap procedure (step 112).
      <br/>
      The device driver opens the original file as a read only data file.
      <br/>
      The device driver now traps calls, in step 114, made from the operating system for files in the phantom directory.
      <br/>
      Calls to other directories are ignored and passed on to the original destination.
      <br/>
      The device driver then reads the data from the original data file, decrypts and decompresses it, and returns the decrypted/decompressed data to the operating system in step 116.
    </p>
    <p num="46">
      For example, if the offset for the hidden application in the original data file is 266,270 bytes and the operating system asks for 64 bytes starting at offset 0 of the hidden application in the phantom directory, the device driver reads 64 bytes from the original file starting at offset 266,270, decrypts/decompresses those 64 bytes, and returns the first 64 decrypted/decompressed bytes back to the operating system.
      <br/>
      From the point of view of the operating system, the 64 bytes appear to have come from the file in the phantom directory.
      <br/>
      Steps 114 and 116 are performed on demand in response to the operating system.
    </p>
    <p num="47">
      A block diagram of the computer system in this embodiment, with a device driver loaded and in operation, will now be described in more detail in connection with FIG. 7.
      <br/>
      FIG. 7 illustrates the operating system 120, the loaded device driver 122, a file system driver 124, the original executable file 126 as it may appear on disk and the unwrap procedure 128.
      <br/>
      The executable file may in fact be on a remote computer and accessed through a network by the device driver.
      <br/>
      The unwrap procedure causes the operating system to begin execution of the hidden file by issuing an instruction to execute the file in the phantom directory, as indicated at 130.
      <br/>
      This command is issued after the device driver 122 is informed of the file name of the original executable file 126, offsets of the hidden files within that file and the name of the phantom directory, as indicated at 132.
      <br/>
      The operating system then starts making calls to the phantom directory as indicated at 134.
      <br/>
      The device driver 122 traps these calls and turns them into requests 136 to the file system driver to access the original executable file 126.
      <br/>
      Such requests actually are made to the operating system 120, through the device driver 122 to the file system driver 124.
      <br/>
      The file system driver 124 returns encrypted code 138 to the device driver 122.
      <br/>
      The encrypted code 138 actually passes back through the device driver 122 to the operating system 120 which in turn provides the encrypted code 138 to the device driver 122 as the reply to the request 136 for the original file.
      <br/>
      The device driver 122 then decrypts the code to provide decrypted code 140 to the operating system 120.
    </p>
    <p num="48">
      The microfiche appendix contains sample source code that may be used to implement this first embodiment of the invention.
      <br/>
      In particular, source code modules listed in the "vxd" and "res" and "hello" directories are used in this embodiment.
      <br/>
      Source code modules for creating a file (FIG. 9) are in the "combine" directories.
    </p>
    <p num="49">
      Another embodiment of the invention will now be described in connection with FIG. 8.
      <br/>
      This embodiment may be implemented using the WindowsNT 4.0 operating system, for example.
      <br/>
      In this embodiment, the device driver portion 52 of the computer program product is not used.
      <br/>
      The unwrap procedure for this embodiment begins by identifying the operating system being used similar, which is step 100 in FIG. 5.
      <br/>
      If the operating system is Windows NT 4.0, for example, a different unwrap procedure for this embodiment is performed.
      <br/>
      Before describing this unwrap procedure, a brief description of some of the available operating system commands will be provided.
    </p>
    <p num="50">
      Currently, under all versions of the Window operating system or operating environment from Microsoft Corporation (such as Windows 3.1, Windows 95 and Windows NT 3.51 and 4.0) all executable files (.exe) or dynamic link library (.dll and .ocx) files, which are executable files with different header and loading requirements than .exe files, that are loaded into memory by the operating system must reside as a file either locally, e.g., on a disk drive or remotely, e.g., over a network or communications port.
      <br/>
      All further references herein to loading an executable will be using the Win32 function calls used in Windows 95 and NT 3.51 and 4.0 operating systems.
      <br/>
      The CreateProcess( ) function which loads files with an .exe extension takes ten parameters:
    </p>
    <p num="51">
      --
      <br/>
      -- BOOL CreateProcess(//Prototype from Microsoft Visual
      <br/>
      -- C++Help Documentation
      <br/>
      -- LPCTSTR lpApplicationName, // pointer to name of executable module
      <br/>
      -- LPTSTR lpCommandLine,     // pointer to command line string
      <br/>
      -- LPSECURITY_ATTRIBUTES     // pointer to process security attributes
      <br/>
      -- lpProcessAttributes,
      <br/>
      -- LPSECURITY_ATTRIBUTES     // pointer to thread security attributes
      <br/>
      -- lpThreadAttributes,
      <br/>
      -- BOOL bInheritHandles,     // handle inheritance flag
      <br/>
      -- DWORD dwCreationFlags,    // creation flags
      <br/>
      -- LPVOID lpEnvironment,     // pointer to new environment block
      <br/>
      -- LPCTSTR lpCurrentDirectory, // pointer to current directory name
      <br/>
      -- LPSTARTUPINFO             // pointer to STARTUPINFO
      <br/>
      -- lpStartupInfo,
      <br/>
      -- LPPROCESS_INFORMATION     // pointer to PROCESS--
      <br/>
      -- lpProcessInformation      INFORMATION
    </p>
    <p num="52">
      Three of these parameters are pointers to strings that contain an application file name, command line parameters, and the current directory.
      <br/>
      The other parameters are security, environmental, and process information.
      <br/>
      The LoadLibrary( ) function takes one parameter that is a pointer to a string that contains the application file name:
    </p>
    <p num="53">
      --
      <br/>
      -- HINSTANCE LoadLibrary(/I Prototype from Microsoft
      <br/>
      -- Visual C++Help Documentation
      <br/>
      -- LPCTSTR lpLibFileName // address of filename of executable module
      <br/>
      -- );
    </p>
    <p num="54">The LoadLibraryEx( ) function takes three parameters the first being the same as LoadLibrary( ), the second parameter must be null, and the third tells the operating system whether to load the file as an executable or as a data file in order to retrieve resources such as icons or string table data from it and not load it as an executable:</p>
    <p num="55">
      --
      <br/>
      -- HINSTANCE LoadLibraryEx(// Prototype from Microsoft
      <br/>
      -- Visual C++Help Documentation
      <br/>
      -- LPCTSTR lpLibFileName,  // points to name of executable module
      <br/>
      -- HANDLE hFile,           // reserved, must be NULL
      <br/>
      -- DWORD dwFlags           // entry-point execution flag
      <br/>
      -- );
    </p>
    <p num="56">
      The CreateFile( ) function is used to create and open files and to load files such as device drivers.
      <br/>
      This function also requires a pointer to a string that contains the name of a physical file:
    </p>
    <p num="57">
      --
      <br/>
      -- HANDLE CreateFile(// Prototype from Microsoft Visual C++
      <br/>
      -- Help Documentation
      <br/>
      -- LPCTSTR lpFileName,       // pointer to name of the file
      <br/>
      -- DWORD dwDesiredAccess,    // access (read-write) mode
      <br/>
      -- DWORD dwShateMode,        // share mode
      <br/>
      -- LPSECURITY_ATTRIBUTES     // pointer to security descriptor
      <br/>
      -- lpSecurityAttributes,
      <br/>
      -- DWORD                     // how to create
      <br/>
      -- dwCreationDistribution,
      <br/>
      -- DWORD                     // file attributes
      <br/>
      -- dwFlagsAndAttributes,
      <br/>
      -- HANDLE hTemplateFile      // handle to file with attributes to copy
      <br/>
      -- );
    </p>
    <p num="58">
      There are other functions such as MapViewOfFile( ) and MapViewOfFileEx( ) that map areas of memory to an already opened physical file through a handle to that file.
      <br/>
      They have the following parameters:
    </p>
    <p num="59">
      --
      <br/>
      -- LPVOID MapViewOfFile(/I Prototype from Microsoft Visual
      <br/>
      -- C++Help Documentation
      <br/>
      -- HANDLE hFileMappingObject,   // file-mapping object to map
      <br/>
      --                              into address space
      <br/>
      -- DWORD dwDesiredAccess,       // access mode
      <br/>
      -- DWORD dwFileOffsetHigh,      // high-order 32 bits of file offset
      <br/>
      -- DWORD dwFileOffsetLow,       // low-order 32 bits of file offset
      <br/>
      -- DWORD dwNumberOfBytesToMap   // number of bytes to map
      <br/>
      -- );
    </p>
    <p num="60">
      --
      <br/>
      -- LPVOID MapViewOfFileEx(// Prototype from Microsoft Visual
      <br/>
      -- C++Help Documentation
      <br/>
      -- HANDLE hFileMappingObject,   // file-mapping object to map
      <br/>
      --                              into address space
      <br/>
      -- DWORD dwDesiredAccess,       // access mode
      <br/>
      -- DWORD dwFileOffsetHigh,      // high-order 32 bits of file offset
      <br/>
      -- DWORD dwFileOffsetLow,       // low-order 32 bits of file offset
      <br/>
      -- DWORD dwNumberOfBytesToMap,  // number of bytes to map
      <br/>
      -- LPVOID lpBaseAddress         // suggested starting address
      <br/>
      --                              for mapped view
      <br/>
      -- );
    </p>
    <p num="61">
      All of the foregoing functions directly use a pointer to a string that is a physical file.
      <br/>
      The only file functions that do not directly use a physical filename are functions like CreateNamedPipe( ), which has the following parameters:
    </p>
    <p num="62">
      --
      <br/>
      -- HANDLE CreateNamedPipe(// Prototype from Microsoft Visual
      <br/>
      -- C++Help Documentation
      <br/>
      -- LPCTSTR lpName,           // pointer to pipe name
      <br/>
      -- DWORD dwOpenMode,         // pipe open mode
      <br/>
      -- DWORD dwPipeMode,         // pipe-specific modes
      <br/>
      -- DWORD nMaxInstances,      // maximum number of instances
      <br/>
      -- DWORD nOutBufferSize,     // output buffer size, in bytes
      <br/>
      -- DWORD nInBufferSize,      // input buffer size, in bytes
      <br/>
      -- DWORD nDefaultTimeOut,    // time-out time, in milliseconds
      <br/>
      -- LPSECURITY_ATTRIBUTES     // pointer to security attributes structure
      <br/>
      -- lpSecurityAttributes
      <br/>
      -- );
    </p>
    <p num="63">
      The string to which CreateNamedPipe( ) points using the first parameter is a string that both an existing executable and the operating system know about and does not exist physically.
      <br/>
      Unfortunately both of the executables that "know" this private name could only be loaded using one of the other procedures that required a physical file.
      <br/>
      Currently it is not possible to load an executable using a "named pipe" name.
      <br/>
      Both of or any executables that use the name of the "named pipe" already must have been loaded into memory.
    </p>
    <p num="64">
      All of the foregoing functions require a physical file because all of them use "file mapping" processes.
      <br/>
      File mapping allows large executable files to appear to be loaded rapidly since they are rarely completely loaded into memory but rather are mapped into memory.
      <br/>
      The detriment to this mapping capability is that executable code must remain in physical memory in a file in unencrypted form in order to be loaded, unless there is a middle layer or file system driver that the operating system uses as a physical layer and that decrypts the executable code to the operating system on demand.
      <br/>
      The potential weakness here is that another file system driver can hook into the operating system to monitor traffic between the operating system and all file system drivers and capture decrypted executable code passing from the file system driver to the operating system.
      <br/>
      Some operating systems allow such monitoring more than others.
      <br/>
      Many anti-viral software packages use this technique to prevent computer virus attacks.
    </p>
    <p num="65">
      One method of loading and executing encrypted executable computer program code is to use a stub executable having two parts.
      <br/>
      The first part is the normal front end loader code that all executables have.
      <br/>
      In addition, the first part would perform any authorization which may include receiving a password from the user, then allocate enough memory to hold hidden encrypted code when it is decrypted, either in its entirety or a portion of it, copy the encrypted code into that area of protected (and preferably locked so no disk swapping occurs) memory, decrypt it once it is in memory and only in memory, and then have the operating system load the code only from memory therefore bypassing any file system drivers or TSRs so they have access to only encrypted code.
    </p>
    <p num="66">
      Some of the file functions listed above and similar functions on other operating systems could be modified easily by a programmer having access to source code for those operating systems, or a new operating system may be made to provide functions which allow direct loading of executable code from memory rather than physical files.
      <br/>
      For example, in the Win32 commands, a command similar to CreateProcess( ) command could be provided.
      <br/>
      The command should have a few extra parameters including the process identifier of the process that contains the now decrypted executable code, the memory address of the start of the decrypted code, and the size of the decrypted code.
      <br/>
      The command could also contain a parameter specifying a "call back" function within the first process that would provide decrypted code on demand directly to the operating system through a protected buffer, therefore allowing only a portion of the encrypted code to be decrypted at any one time instead of in its entirety, for better protection and less memory use.
      <br/>
      The second parameter of the LoadLibraryEx( ) command that now needs to be NULL could be expanded to hold a structure that contained the same information.
      <br/>
      Both of these and other similar functions could be changed or created to allow loading executable code either as an .exe, .dll, or other extensions or identifiers, such as by using a "named pipe" name that only the operating system and process that holds decrypted code know about and having the operating system load from the named pipe.
    </p>
    <p num="67">
      Alternatively, without having such additional capabilities in the operating system, an application program can be divided into two parts.
      <br/>
      The first part is code that is common to all applications such as code for allocating memory off the heap and code that provides some interaction with the user.
      <br/>
      This kind of code is generally not code that the content provider is concerned about copying.
      <br/>
      The second part is the code that the content provider believes is valuable.
      <br/>
      Typically this valuable code is a business logic code or what would be considered a middle tier of a three-tier environment.
      <br/>
      A content provider would like to protect this second part of the code, at least much more that the first part of the code.
      <br/>
      The content provider would place all of the important code to be protected inside a dynamic link library and the code that is not that important would reside in the front end "stub" executable.
      <br/>
      Both of these would be combined into another executable containing the .dll in encrypted form only, along with any other files, data, information, and/or tables for holding, for example, hardware identifiers.
      <br/>
      This other executable is the final digital information product.
    </p>
    <p num="68">
      The first part of the digital information product, i.e., the executable stub, would load and execute normally like any other application.
      <br/>
      It then would perform any authorization procedures.
      <br/>
      Once the proper authorization or password was completed successfully, an unwrap procedure would be performed as will now be described in connection with FIG. 8, it would then allocate enough protected memory using a function like VirtualAlloc( ) as shown in step 150:
    </p>
    <p num="69">
      DWORD nFileSize=0;
      <br/>
      DWORD nPhantomFileSize=0;
      <br/>
      DWORD exeOffset=0;
      <br/>
      DWORD nPreferredLoadAddress=GetPreCompiledLoadAddress( );
      <br/>
      CString cCommandFile=UnwrapGetNTCommandFile( );
      <br/>
      exeOffset=UnwrapGetDllOffset(cCommandFile);
      <br/>
      nFileSize=UnwrapGetDllSize(cCommandFile);
      <br/>
      nPhantomFileSize=nFileSize+0x3000; // add any needed extra space
      <br/>
      // Increase buffer size to account for page size (currently Intel page size).
    </p>
    <p num="70">
      DWORD nPageSize=GetPageSize( );
      <br/>
      nPhantomFileSize+=(nPageSize-(nPhantomFileSize % nPageSize));
      <br/>
      // Allocate the memory to hold the decrypted executable.
    </p>
    <p num="71">
      --
      <br/>
      -- LPVOID lpvBlock = VirtualAlloc((LPVOID) nPreferredLoadAddress,
      <br/>
      --                  nPhantomFileSize,
      <br/>
      --                  MBM_RBSERVE .vertline.
      <br/>
      MEM_COMMIT, PAGE--
      <br/>
      --                  READWRITE);
    </p>
    <p num="72">
      This function can request a particular address space.
      <br/>
      Preferably, this address space is the preferred load address space to which the .dll was linked in order to minimize any needed relocation and fix up code.
      <br/>
      The stub executable may lock that area of memory in step 152, for example by using VirtualLock( ) to prevent any memory writes to a swap file, depending on the operating system, as shown below:
      <br/>
      BOOL bVLock=VirtualLock((LPVOID) nPreferredLoadAddress, nPhantomFileSize);
    </p>
    <p num="73">The memory area still should be secure even without this preventive step since the Windows 95 and NT operating systems do not allow any user access to swap files.</p>
    <p num="74">
      The encrypted code is then copied from the digital information product into the allocated protected memory in step 154, for example by using the following command:
      <br/>
      UnwrapCopyHiddenExeToMem(cCommandFile, exeOffset, nFileSize, (char *) lpvBlock);
    </p>
    <p num="75">
      Once in memory, the stub would then decrypt the code to that same portion of memory in step 156, for example by using the following commands:
      <br/>
      CwrapDecryptSeed(cPassword.GetBuffer(0), cPassword.GetLength( ));
      <br/>
      CwrapDecrypt((unsigned char *) lpvBlock, 0, nFileSize);
    </p>
    <p num="76">
      Any "fix up and relocation" type services would then be performed in step 158, for example by using the following command:
      <br/>
      UnwrapFixUpAndRelocateDll(lpvBlock);
    </p>
    <p num="77">Possibly, the memory protection may be changed to execute only in step 160, for example by using the VirtualProtect( ) command as follows:</p>
    <p num="78">
      Function calls then can be made into that area of memory that now contains the decrypted code:
      <br/>
      UnwrapDoDllAlgorithms( );
    </p>
    <p num="79">
      Some of the "fix up" operations to be performed above include placing the addresses of external or stub.exe functions into the address place holders of the decrypted .dll or internal code, by using commands similar to the following:
      <br/>
      WriteAddress((char*) 0x0a406104, (DWORD) &amp;CallBackFunction1);
      <br/>
      WriteAddress((char*) 0x0a406100, (DWORD) &amp;CallBackFunction2);
    </p>
    <p num="80">
      For instance a wrapper function could be created in the outer stub.exe that received a size parameter, allocated that amount of memory off of the heap, and passed back the starting address of that block of memory.
      <br/>
      Another example would be to have encrypted algorithms within the hidden, encrypted .dll which would be called at run time from the front end stub once decrypted within protected memory.
      <br/>
      The dynamic link library would be compiled and linked to expect a pointer to a function that took that parameter and/or returned a value by including prototypes in the header file as follows:
      <br/>
      void (*lpCallBackFunc1)( );
      <br/>
      void (*lpCallBackFunc2)(unsigned long);
    </p>
    <p num="81">
      Function calls to "external" functions also could be added as follows:
      <br/>
      (*lpCallBackFunc1)( );
      <br/>
      unsigned long z=x * x;
      <br/>
      (*lpCallBackFunc2)(z);
    </p>
    <p num="82">
      At run time the "fix up" code would take the run time address of that "wrapper function" and place it into the pointer address within the .dll block of code as follows:
      <br/>
      WriteAddress((char*) 0x0a40604, (DWORD) &amp;CallBackFunction1);
      <br/>
      WriteAddress((char*) 0x0a406100, (DWORD) &amp;CallBackFunction2);
    </p>
    <p num="83">This information is readily available using the cod output files from the compiler, an example of which follows:</p>
    <p num="84">
      --
      <br/>
      -- _TestSum PROC NEAR                           ; COMDAT
      <br/>
      -- ; Line 8
      <br/>
      -- 00000       56  push esi
      <br/>
      -- ; Line 23
      <br/>
      --  00001 ff15 000000
      <br/>
      --  00     call DWORD PTR_lpCallBackFunc1
      <br/>
      -- ; Line 24
      <br/>
      --  00007 8b 44 24 08 mov eax, DWORD PTR_a$�esp�
      <br/>
      --  0000b 50  push eax
      <br/>
      --  0000c e8 00 00 00 00 call _TestSquare
      <br/>
      --  00011 83 c4 04 add esp,4
      <br/>
      --  00014 8bf0 mov esi, eax
      <br/>
      -- ; Line 25
      <br/>
      --  00016 8b 44 24 0c mov eax, DWORD PTR_b$�esp�
      <br/>
      --  00014 50    push eax
      <br/>
      --  0001b e8 00 00 00 00 call _TestSquare
      <br/>
      --  00020 83 c4 04  add esp, 4
      <br/>
      --  00023 03 c6   add eax, esi
      <br/>
      -- ; Line 28
      <br/>
      --  00025 5e    pop esi
      <br/>
      --  00026 c3    ret 0
      <br/>
      -- _TestSum ENDP
      <br/>
      -- _TEXT       ENDS
      <br/>
      -- ;  COMDAT_TestSquare
      <br/>
      -- _TEXT       SEGMENT
      <br/>
      -- _x$ = 8
      <br/>
      -- _TestSquare PROC NEAR                        ; COMDAT
      <br/>
      -- ; Line 30
      <br/>
      --  00000 56     push esi
      <br/>
      -- ; Line 32
      <br/>
      --  00001 8b 74 24 08 mov esi, DWORD PTR _x$�esp�
      <br/>
      --  00005 Of af f6  imul esi, esi
      <br/>
      -- ; Line 34
      <br/>
      --  00008 56    push esi
      <br/>
      --  00009 ff 15 00 00 00
      <br/>
      --    00    call DWORD PTR_lpCallBackFunc2
      <br/>
      --  0000f83 c4 04 add esp,4
      <br/>
      --  00012 8b c6  mov eax, esi
      <br/>
      -- ; Line 36
      <br/>
      --  00014 5e    pop esi
      <br/>
      --  00015 c3    ret 0
      <br/>
      -- _TestSquare ENDP
      <br/>
      -- DWORD lpflOldProtect; // variable to get old protection
      <br/>
      -- BOOL bVProtect = VirtualProtect((LPVOID) nPreferredLoadAddress,
      <br/>
      --   nPhantomFileSize,
      <br/>
      -- PAGE_EXECUTE,
      <br/>
      -- &amp;lpflOldProtect);
    </p>
    <p num="85">Such information also is available from map output files from the linker where the "f" between the address (i.e., 0a406100) and the object file (i.e. Algorithms.obj) means it is a "flat" address (i.e., hard coded by the linker) and the lack of an "f" means that it is an address pointer to be supplied at run time (load time) where the address that is contained in that address location is used and not the actual address location (i.e., the address that is contained at address location 0a406100 and not 0a406100 itself):</p>
    <p num="86">
      --
      <br/>
      -- 0001:00000000  _TestSum             0a401000 f Algorithms.obj
      <br/>
      -- 0001:00000030  _TestSquare          0a401030 f Algorithms.obj
      <br/>
      -- 0003:00001100  _lpCallBackFunc2     0a406100 Algorithms.obj
      <br/>
      -- 0003:00001104  _lpCallBackFunc1     0a406104 Algorithms.obj
    </p>
    <p num="87">
      When the code inside the .dll makes a "call" to a dereferenced pointer, it would jump to the correct function in the outer code and return the expected return value (if any).
      <br/>
      For example:
      <br/>
      void CallBackFunction1( )+
      <br/>
      // This is the first function that exists in the Stub executable
      <br/>
      // whose address has been placed at the appropriate location inside the "dll" code
      <br/>
      // that has now been decrypted in a block of memory.
      <br/>
      The code inside the "dll"
      <br/>
      // makes a function call to this function.
      <br/>
      In its encrypted state, the "dll" does not contain
      <br/>
      // this address, but merely has a placeholder for the address.
      <br/>
      The "dll" has enough space allocated to hold an
      <br/>
      // address of this size.
      <br/>
      After the "dll" has been decrypted at run time, its address is
      <br/>
      // placed in that location so the code inside the "dll" that references (or more
      <br/>
      // appropriately dereferences) that address can jump (which is function call) to this
      <br/>
      // address.
    </p>
    <p num="88">
      AfxMessageBox(
      <br/>
      _("This is the FIRST Stub.exe call back function being called from the dll."));
    </p>
    <p num="89">
      return;
      <br/>
      void CallBackFunction2(DWORD nNumber)+
      <br/>
      // See comment for CallBackFunctionl except this function receives a parameter off
      <br/>
      // of the stack.
      <br/>
      It could also return a value as well.
    </p>
    <p num="90">
      CString
      <br/>
      cString(
      <br/>
      T("This is the SECOND Stub.exe call back function being called from the dll"));
      <br/>
      har buffer�20�;
      <br/>
      ltoa(nNumber, buffer, 10);
      <br/>
      cString+=_T("with a parameter of");
      <br/>
      cString+=buffer;
      <br/>
      cString+=_T(".");
      <br/>
      AfxMessageBox(cString.GetBuffer(0));
      <br/>
      return;
      <br/>
      }
    </p>
    <p num="91">
      The outer stub.exe would make the same kinds of jumps or function calls into the now protected decrypted code block as follows:
      <br/>
      DWORD c;
      <br/>
      // This command declares a function pointer.
      <br/>
      This command is different for different function
      <br/>
      // calls.
      <br/>
      Here the called function takes two integer parameters and
      <br/>
      // passes back a DWORD.
    </p>
    <p num="92">
      DWORD (*lpFunc)(DWORD,DWORD);
      <br/>
      // The function pointer is then pointed to the starting address of the function in the
      <br/>
      // block of memory that now holds the decrypted DLL.
      <br/>
      lpFunc=(DWORD (*)(DWORD,DWORD)) UnwrapFixUpAndRelocateDll( );
      <br/>
      // Now call that "function" which is really like all function calls, i.e., a jump to
      <br/>
      // the address where that function exists.
      <br/>
      In this case, two
      <br/>
      // variables are passed to that function and returning a value from that function.
      <br/>
      This function illustrates that the function call
      <br/>
      // can be more complicated than merely a simple jump
      <br/>
      // to an address.
      <br/>
      Inline assembler code may be used to push the variables onto
      <br/>
      // the stack frame and return the variable from the eax register, but this function enables
      <br/>
      // the C++compiler to do the same function.
      <br/>
      c=(DWORD) (*lpFunc)(a, b); ps This mechanism requires the unwrap procedure and the now decrypted code to have intimate knowledge about procedural interfaces of each other but no knowledge about each other's implementation.
      <br/>
      This is the way most executable .exe files and .dll files behave but with the addition of a series of "wrapper" functions on either side for communication.
      <br/>
      This method works under Windows 95 and Windows NT 4.0 operating systems and should work under Windows NT 3.51 and other operating systems.
    </p>
    <p num="93">
      Another modified version of this mechanism that works under the Windows NT 4.0 operating system because of functions specific to Windows NT 4.0 would be to have another hidden and/or encrypted executable within the digital information product.
      <br/>
      This executable would be copied to a physical disk in an unencrypted form, launched or loaded with the CreateProcess( ) command in its current form but called with a parameter to load the executable in suspended mode:
      <br/>
      BOOL success=CreateProcess(cFrontEndExe.GetBuffer(0), 0, 0, 0, TRUE, CREATE_NEW_CONSOLE .vertline.
      <br/>
      CREATE_SUSPENDED, 0, 0, &amp;startUpInfo, &amp;processInfo);
    </p>
    <p num="94">Then the first process would copy the encrypted dll into its own process and decrypt it, allocate enough memory using VirtualAllocEx( ) in its current form in the second process that has just loaded the expendable front end executable in a suspended state as follows:</p>
    <p num="95">
      --
      <br/>
      -- LPVOID lpvBlockEx = VirtualAllocEx(processInfo.hProcess,
      <br/>
      --         (LPVOID) nPreferredLoadAddress, nPhantomFileSize,
      <br/>
      --               MEM_RESERVE.vertline.MEM_COMMIT,
      <br/>
      --                  PAGE_READWRITE);
    </p>
    <p num="96">
      The decrypted code is copied from the first process to the second suspended process using WriteProcessMemory( ) in its current form:
      <br/>
      BOOL bWriteProcessMemory=WriteProcessMemory((HANDLE) processInfo.hProcess, (LPVOID) lpvBlockEx, (LPVOID) nPreferredAddress, (DWORD) nPhantomFileSize, (LPDWORD) &amp;nBytesWritten);
    </p>
    <p num="97">
      The primary thread of the previously launched second process is then resumed:
      <br/>
      DWORD nResumed=ResumeThread(processInfo.hThread);
    </p>
    <p num="98">
      Any necessary function pointers are then placed in the correct locations by the second process, the area of memory is locked to prevent any writes to a swap file, and the memory protection is changed to execute only as follows:
      <br/>
      WriteAddress((char*) 0x0a406104, (DWORD) &amp;CallBackFunction1);
      <br/>
      WriteAddress((char*) 0x0a406100, (DWORD) &amp;CallBackFunction2);
      <br/>
      BOOL bVLock=VirtualLock((LPVOID) nPreferredLoadAddress, nPhantomFileSize);
      <br/>
      DWORD lpflOldProtect; // variable to get old protection
      <br/>
      BOOL bVProtect=VirtualProtect((LPVOID) nPreferredLoadAddress, nPhantomFileSize, PAGE_EXECUTE, &amp;IpflOldProtect);
    </p>
    <p num="99">
      The program can continue running by making and receiving calls to and from the decrypted dynamic link library that now resides in the protected memory of its process using commands such as the following:
      <br/>
      DWORD c;
      <br/>
      DWORD (*lpFunc)(DWORD,DWORD);
      <br/>
      lpFunc=(DWORD (*)(DWORD,DWORD)) EpendableGetEntryAddress( );
      <br/>
      c=(DWORD) (*lpFunc)(a, b);
    </p>
    <p num="100">The first process can either close down or launch another instance of that same process.</p>
    <p num="101">
      In either of these implementations using the same process or launching into a second process, the hidden encrypted code never passes through a file system driver or memory resident program in decrypted form.
      <br/>
      Code can be split up among different dynamic link libraries so that no two would reside in memory at the same time in order to protect code further.
      <br/>
      Both of these systems can be implemented using the Win32 function calls.
      <br/>
      If additional functions, similar to a CreateProcess( ) command or a LoadLibrary( ) command but that take a process identifier and address location in memory to load in an executable instead of a physical file, are provided in an operating system then the entire executable and dynamic link library can be hidden, encrypted, and protected on the physical disk and then decrypted within protected memory and use the operating system loader to load it directly to the operating system from memory without residing in decrypted form on any physical medium.
    </p>
    <p num="102">
      The microfiche appendix contains a sample source code that may be used to implement this second embodiment of the invention.
      <br/>
      In particular, source code modules the "expendable end," "algorithms" and "stub" directories are used in this embodiment.
      <br/>
      Source code modules in the "unwrap" directory are used in either or both embodiments as indicated.
    </p>
    <p num="103">
      Having described the operation and use of the computer program product in accordance with the invention, embodiments of which are described above in connection with FIGS. 3-8, and the operation of the unwrap procedure and device driver it contains, the process of constructing such a computer program product will now be described in more detail.
      <br/>
      Referring now to FIG. 9, an embodiment of this process for creating a computer program product is shown.
      <br/>
      This process can be applied to any digital information including an arbitrary executable computer program, dynamic link libraries and related files of data.
      <br/>
      All digital information is treated as mere data by this process.
      <br/>
      Each separate data file is combined into a single file by this process, with an executable program for performing the unwrap procedure, and optionally executable program code for a virtual device driver, into the computer program product.
      <br/>
      Each file of hidden information has a unique location and is identified by its own begin and end markers as shown in FIG. 3.
      <br/>
      The first step of this process is opening a new data file for the computer program using a name that will be used to indicate an executable file (step 200).
      <br/>
      For example, an executable word processing program may be named "word rocessor.exe" in the Windows95 operating system.
    </p>
    <p num="104">
      The three portions of the computer program product are then inserted into the open data file.
      <br/>
      First, the unwrap procedure is inserted at the beginning of the file in an executable format in step 202.
      <br/>
      The begin tag for the optional device driver is then inserted in step 204.
      <br/>
      The executable device driver program code is then inserted in step 206, followed by its corresponding end tag in step 208.
      <br/>
      For each hidden file to be inserted into this computer program product, steps 210 to 216 are performed.
      <br/>
      First, the begin tag is inserted in step 210.
      <br/>
      The begin tag also may include an indication of a unique name of the file which will be used as its name in the phantom directory created by the unwrap procedure.
      <br/>
      The hidden file is then encrypted and/or compressed in step 212 and inserted into the data file in step 214.
      <br/>
      The end tag for the hidden file is then inserted in step 216.
      <br/>
      The device driver and all of the tags may be encrypted also if the unwrap procedure has suitable decryption procedures.
      <br/>
      The computer program file is closed when the last hidden file is processed.
    </p>
    <p num="105">
      Using the present invention digital information, such as executable program code or various kinds of data, is loaded and unloaded as needed, and thus does not take up any more memory than is necessary.
      <br/>
      At no time does unencrypted digital information, such as computer program code, exist on disk in accessible and complete decrypted form.
      <br/>
      Because the original digital information is available as a read only file in one embodiment of the invention accessible only to the device driver, the digital information may be accessed over networks, from a CD-ROM or from a DVD, and can be made to have a limited number of uses.
      <br/>
      This mechanism is particularly useful for controlling distribution of computer programs, digitized movies or other information while reducing the cost of such distribution and control.
      <br/>
      For example, software may be distributed over a network on a single use basis, and charges may be levied on a per use basis.
      <br/>
      The ability to reverse engineer an application program also may be reduced.
    </p>
    <p num="106">
      One benefit with this system over some other systems for preventing unauthorized access to digital information is that the content provider maintains control of the encryption applied to the information how it may be decrypted.
      <br/>
      Any need for either a centralized facility or a predetermined decryption program is eliminated.
      <br/>
      An operating systems manufacturer or other platform vendor merely provides the capability for the information to be accessed and decrypted on the fly.
      <br/>
      Since the valuable information and any other tables of authorization codes, passwords, or hardware identifiers that the content provider may use to secure the information resides in one large encrypted file, it becomes difficult, if not impossible, for someone to determine just where any of this information exists.
    </p>
    <p num="107">
      A potential scenario with authorization procedure in which the present invention may be used is the following.
      <br/>
      A consumer purchases a DVD disk containing a movie.
      <br/>
      The user puts the disk into the player.
      <br/>
      This is the first time the disk is installed.
      <br/>
      The content provider's functions are loaded into the DVD chip, which looks in the encrypted table and sees that this is the first time this disk is being played.
      <br/>
      The player then displays on a screen a numeric identifier and toll free phone number.
      <br/>
      The consumer calls the toll free phone number and inputs the numeric identifier that was displayed on the screen.
      <br/>
      The content provider provides a numeric password based on the numeric identifier that the user inputs into the DVD.
      <br/>
      The content provider may develop a database of information about its consumers that also may be used to detect pirating of the digital information product.
      <br/>
      Now that this authorization has taken place, the software that the content provider wrote, and is now in the DVD chip, takes a hardware identifier from the DVD and encrypts it and puts it in the encrypted and buried table on the disk.
      <br/>
      Alteratively, the data may be decrypted in memory and re-encrypted back onto the disk using the hardware identifier as part of a key.
      <br/>
      Now that disk will run and show the movie and will only run on that DVD and no other.
      <br/>
      The content provider could allow for a table of hardware id's so they could limit the number of DVD's that disk would run on or a limited number of times it can be shown.
      <br/>
      It should be understood that many other authorization procedures may be used.
    </p>
    <p num="108">
      In the foregoing scenario, the movie is encrypted on the same disk inside of the encrypted file that contains the table and functions the content provider distributed.
      <br/>
      The movie is decrypted by the decryption functions contained in the file directly to the DVD chip.
      <br/>
      At no time does the movie reside anywhere in decrypted form.
      <br/>
      The content provider can protect the movie with any desired level of security (for both encryption and authorization).
    </p>
    <p num="109">
      In the present invention, the onus of protection of content does not reside with a hardware manufacturer or platform provider but in the hands of the content provider.
      <br/>
      The hardware manufacturer only provides the mechanism to protect the digital information through the operating system.
      <br/>
      The technique and implementation of protection resides in the hands of the content provider.
      <br/>
      This mechanism allows the content providers to change the level of security as needed without any modifications to the hardware.
      <br/>
      The security of the content is provided by the encryption/decryption algorithms, public/private keys, and authorization methods which are determined by the content provider.
      <br/>
      Even each individual product can have its own encryption/decryption algorithms and/or public/private keys.
      <br/>
      All of these can be changed and enhanced as the market demands.
    </p>
    <p num="110">
      The present invention also could be used for on-line or live use of digital information.
      <br/>
      For example, a movie could be retrieved on demand and recorded by a consumer.
      <br/>
      A set top box could receive the digital information, decrypt it, and then re-encrypt and store the information using, for example, a hardware identifier of the set top box.
      <br/>
      Since home movies digitally recorded would be encrypted using the hardware identifier of the device used in recording, that home movie could not be played on another or only on a limited number of other devices and/or for only a specified number of times depending on the wishes of the content provider.
      <br/>
      Since the algorithms are downloaded at the time of recording from a service provider, e.g., the cable company, the content provider (movie company) would provide the encrypted data to the service provider to present to their customers.
      <br/>
      The service provider need not be concerned with the encryption/decryption and authorization functions used by the content provider.
      <br/>
      Similar uses are possible with other data transmission systems including, but not limited to, telephone, cellular communications, audio transmission including communication and the like.
    </p>
    <p num="111">
      In another embodiment, the stub executable program is a first process that is implemented similar to a debugging tool such as the SoftIce debugger from NuMega Technologies or the WinDebug debugger from Microsoft Corporation for Ring 0 kernel level debugging for an Intel processor based architecture, or the CodeView debugger for ring 3 application level debugging.
      <br/>
      Such a debugger controls execution of a program to be debugged as a second process and steps through each program statement or opcode of the debugged program.
      <br/>
      The debugging tool could be modified to monitor each opcode that indicates a jump to a program fragment, such as each instruction or a block code.
      <br/>
      If the program fragment to be executed is not decrypted, the modified debugger decrypts the program fragment before the jump command is allowed to execute.
      <br/>
      Each program fragment may be re-encrypted after execution.
      <br/>
      Clearly, unnecessary debugging commands may be omitted from the modified debugger.
    </p>
    <p num="112">
      Having now described a few embodiments of the invention, it should be apparent to those skilled in the art that the foregoing is merely illustrative and not limiting, having been presented by way of example only.
      <br/>
      Numerous modifications and other embodiments are within the scope of one of ordinary skill in the art and are contemplated as falling within the scope of the invention as defined by the appended claims and equivalent thereto.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A computer-implemented process for executing encrypted computer program logic while maintaining protection against copying of corresponding decrypted executable computer program logic, wherein the encrypted computer program logic is stored in association with first executable computer program logic, the process comprising the steps of:</claim-text>
      <claim-text>through an operating system of a computer, reading, loading and executing the first executable computer program logic as a first process having a protected memory area defined by the operating system; the first process decrypting the encrypted computer program logic into second executable computer program logic and storing the second executable computer program logic in the protected memory area;</claim-text>
      <claim-text>and the first process causing loading and execution of the decrypted second computer program logic in the protected memory area.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The process of claim 1, wherein the encrypted computer program logic and the first executable computer program logic are stored in a single data file accessible through the operating system.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The process of claim 1, wherein the execution of the decrypted second computer program logic is performed as a second process having a second protected memory area defined by the operating system.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A digital information product including a computer readable medium having digital information stored thereon, the digital information including computer program logic defining first executable computer program logic, wherein the first executable computer program logic when executed performs the following steps: storing the encrypted computer program logic in a data file accessible through an operating system of a computer, wherein the data file also includes first executable computer program logic; through the operating system, reading, loading and executing the first executable computer program logic from the data file as a first process having a protected memory area; the first process decrypting the encrypted computer program logic into second executable computer program logic and storing the second executable computer program logic in the protected memory area;</claim-text>
      <claim-text>and the first process causing loading and execution of the decrypted second computer program logic in the protected memory area.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. A computer system comprising: a processor for executing computer program logic; a main memory operatively connected to the processor for storing digital information including executable computer program logic at memory locations addressed by the processor;</claim-text>
      <claim-text>and an operating system defined by executable computer program logic stored in the memory and executed by the processor and having a command which when executed by the processor defines means for creating a process in response to a request specifying a process identifier and a memory location in the main memory, wherein the process identifier indicates the process making the request and the memory location stores executable computer program logic which when executed defines the process.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. A computer system having an operating system, for decrypting digital information, comprising: means for storing the encrypted computer program logic in a data file accessible through the operating system, wherein the data file also includes first executable computer program logic; means, invokable through the operating system, for reading, loading and executing the first executable computer program logic from the data file as a first process having a protected memory area; the first process defining means for decrypting the encrypted computer program logic into second executable computer program logic and storing the second executable computer program logic in the protected memory area;</claim-text>
      <claim-text>and the first process defining means for causing loading and execution of the decrypted second computer program logic in the protected memory area.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The computer system of claim 6, wherein the encrypted computer program logic and the first executable computer program logic are stored in a single data file accessible through the operating system.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The computer system of claim 6, wherein the execution of the decrypted second computer program logic is performed as a second process having a second protected memory area defined by the operating system.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. A digital information product, including a computer readable medium with computer readable information stored thereon, wherein the computer readable information comprises: a first portion of executable computer program logic;</claim-text>
      <claim-text>and a second portion of encrypted digital information;</claim-text>
      <claim-text>and wherein the first portion of executable program logic, when executed, defines means, operative in response to requests for digital information, for accessing the second portion of encrypted digital information, for decrypting the encrypted digital information, and for outputting the decrypted digital information.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The digital information product of claim 9, wherein the encrypted digital information is encrypted executable computer program logic.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A computer program product including a self-decrypting encrypted executable computer program, comprising: a computer readable medium having computer program logic stored thereon, wherein the computer program logic defines: a first module, a second module, wherein the first module, when executed by a computer, defines means for loading the second module into memory of the computer, and a third module defining the encrypted executable computer program, wherein the second module, when executed by a computer, defines means for communicating with an operating system of the computer to receive requests for program code from the encrypted executable computer program from the third module, and for processing the requests to access and decrypt the encrypted executable computer program and for providing the decrypted executable code from the third module to the operating system.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A process for executing encrypted executable computer programs on a computer system having a processor, memory and operating system, comprising the steps of: receiving computer program logic having a first module defining a start up routine, a second module, and a third module containing the encrypted executable computer program; executing the first module of the received computer program logic using the processor, wherein the step of executing causes the second module to be loaded into the memory of the computer system, and generating requests from the operating system for data from the encrypted executable computer program which are received by the second module, and accessing and decrypting the encrypted executable computer program and returning the decrypted executable computer program to the operating system.</claim-text>
    </claim>
  </claims>
</questel-patent-document>