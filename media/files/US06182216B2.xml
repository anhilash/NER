<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182216B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182216</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182216</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="27574419" extended-family-id="1556039">
      <document-id>
        <country>US</country>
        <doc-number>09154391</doc-number>
        <kind>A</kind>
        <date>19980916</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09154391</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>1620247</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>15439198</doc-number>
        <kind>A</kind>
        <date>19980916</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09154391</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>5914297</doc-number>
        <kind>P</kind>
        <date>19970917</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-60059142</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="3">
        <country>US</country>
        <doc-number>6299297</doc-number>
        <kind>P</kind>
        <date>19971023</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="3">
        <doc-number>1997US-60062992</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="4">
        <country>US</country>
        <doc-number>6433197</doc-number>
        <kind>P</kind>
        <date>19971030</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="4">
        <doc-number>1997US-60064331</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="5">
        <country>US</country>
        <doc-number>9463298</doc-number>
        <kind>P</kind>
        <date>19980730</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="5">
        <doc-number>1998US-60094632</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="6">
        <country>US</country>
        <doc-number>9678898</doc-number>
        <kind>P</kind>
        <date>19980817</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="6">
        <doc-number>1998US-60096788</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="7">
        <country>US</country>
        <doc-number>9692198</doc-number>
        <kind>P</kind>
        <date>19980818</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="7">
        <doc-number>1998US-60096921</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="8">
        <country>US</country>
        <doc-number>9890598</doc-number>
        <kind>P</kind>
        <date>19980902</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="8">
        <doc-number>1998US-60098905</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H04L   9/06        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>06</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>713168000</text>
        <class>713</class>
        <subclass>168000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>380028000</text>
        <class>380</class>
        <subclass>028000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>380044000</text>
        <class>380</class>
        <subclass>044000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>713171000</text>
        <class>713</class>
        <subclass>171000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-009/002</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>002</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130701</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-009/0625</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>0625</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130701</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-2209/08</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>2209</main-group>
        <subgroup>08</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130701</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-2209/125</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>2209</main-group>
        <subgroup>125</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130701</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-2209/24</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>2209</main-group>
        <subgroup>24</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130701</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>40</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>14</number-of-drawing-sheets>
      <number-of-figures>14</number-of-figures>
      <image-key data-format="questel">US6182216</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Block cipher method</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>BECKER WOLFRAM</text>
          <document-id>
            <country>US</country>
            <doc-number>4157454</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4157454</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>BARNES VERA L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4160120</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4160120</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>BEST ROBERT M</text>
          <document-id>
            <country>US</country>
            <doc-number>4168396</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4168396</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>LU SHYUE-CHING, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4306111</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4306111</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>GERMAN JR EDGAR H</text>
          <document-id>
            <country>US</country>
            <doc-number>4308617</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4308617</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>DAVIDA GEORGE I, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4375579</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4375579</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>TUCKERMAN III LOUIS BRYANT</text>
          <document-id>
            <country>US</country>
            <doc-number>4078152</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4078152</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>EBERLE GERNOT, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4249180</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4249180</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>ADLER ROY L</text>
          <document-id>
            <country>US</country>
            <doc-number>4255811</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4255811</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>MALLICK BRIAN C</text>
          <document-id>
            <country>US</country>
            <doc-number>4724541</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4724541</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>TAKARAGI KAZUO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4982429</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4982429</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>WOOD MICHAEL C</text>
          <document-id>
            <country>US</country>
            <doc-number>5003596</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5003596</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="13">
          <text>MERKLE RALPH C</text>
          <document-id>
            <country>US</country>
            <doc-number>5003597</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5003597</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="14">
          <text>MORONEY PAUL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5054067</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5054067</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="15">
          <text>TAKARAGI KAZUO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5103479</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5103479</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="16">
          <text>MITTENTHAL LOTHROP</text>
          <document-id>
            <country>US</country>
            <doc-number>5214704</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5214704</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="17">
          <text>KAO CHANG Y, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5317638</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5317638</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="18">
          <text>MATSUZAKI NATSUME, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5351299</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5351299</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="19">
          <text>BUTTER ADRIAN S, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5381480</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5381480</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="20">
          <text>COPPERSMITH DON, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5454039</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5454039</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="21">
          <text>RIVEST RONALD L</text>
          <document-id>
            <country>US</country>
            <doc-number>5835600</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5835600</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="22">
          <text>RSA DATA SECURITY INC</text>
          <document-id>
            <country>WO</country>
            <doc-number>9966669</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>WO9966669</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>AES-A Crypto Algorithm for the Twenty-first Century-The First Advanced Encryption Standard Candidate Conference Aug. 20-22, 1998 Sponsored by: Information Technology Laboratory National Institute of Standards and Technology.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>Burton S. Kaliski Jr. and Yiqun Lisa Yin, On Differential and Linear Cryptanalysis of the RC5 Encryption Algorithm, Lecture Notes in Computer Science, vol. 963, pp. 171-184, Aug. 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>Ronald L. Rivest, The RC5 Encryption Algorithm, Lecture Notes in Computer Science, vol. 1008, pp. 86-96, Dec. 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>Lars R. Knudsen and Willi Meier, Improved Differential Attacks on RC5, Lecture Notes in Computer Science, vol. 1109, pp. 216-228, Aug. 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>Bruce Schneier and Doug Whiting, Fast Software Encryption: Designing Encryption Algorithms for Optimal Software Speed on the Intel Pentium Processor, Lecture Notes in Computer Science, vol. 1267, pp. 242-259, Jan. 1997.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="6">
          <text>Lars R. Knudsen &amp; Willi Meier; Differential Cryptanalysis of RC5 (1), Pub. European Transactions on Telecommunication, vol. 8, No. 5, Sep. 23, 1997.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="7">
          <text>W.E. Madryga; A high Performance Encryption Algorithm, Pub. 1984.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="8">
          <text>Ronald L. Rivest, M.J.B. Robshaw, R. Sidney and Y.L. Yin; The RC6 Block Cipher, Pub. Aug. 20, 1998.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="9">
          <text>John Kelsey, Bruce Schneir and David Wagner; Key-Schedule Cryptanalysis of IDEA, G-DES, GOST, SAFER, and Triple-DES.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <related-publication>
        <document-id>
          <country>US</country>
          <doc-number>60/059,142</doc-number>
          <date>19970917</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/062,992</doc-number>
          <date>19971023</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/064,331</doc-number>
          <date>19971030</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/094,632</doc-number>
          <date>19980730</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/096,788</doc-number>
          <date>19980817</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/096,921</doc-number>
          <date>19980818</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/098,905</doc-number>
          <date>19980902</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/059142</doc-number>
          <date>19970917</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/062992</doc-number>
          <date>19971023</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/064331</doc-number>
          <date>19971030</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/094632</doc-number>
          <date>19980730</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/096788</doc-number>
          <date>19980817</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/096921</doc-number>
          <date>19980818</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/098905</doc-number>
          <date>19980902</date>
        </document-id>
      </related-publication>
    </related-documents>
    <parties>
      <applicants>
        <applicant app-type="applicant" sequence="1">
          <addressbook lang="en">
            <name>LUYSTER FRANK C.</name>
          </addressbook>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Luyster, Frank C.</name>
            <address>
              <address-1>Riverside, CT, 06878, US</address-1>
              <city>Riverside</city>
              <state>CT</state>
              <postcode>06878</postcode>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Cantor Colburn LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Peeso, Thomas R.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A data encryption system for encrypting an n-bit block of input in a plurality of rounds is presented, where n is preferably 128 bits or more.
      <br/>
      The data encryption system includes a computing unit for the execution of each round; memory for storing and loading segments; a bit-moving function capable of rotating, shifting, or bit-permute round segments by predetermined numbers of bits preferably to achieve active and effective fixed rotation; a linear combination function which provides new one-to-one round segments using a round operator generally from one algebraic group to combine two different one-to-one round segments taken from one one-to-one round segment set; and a nonlinear function which affects a one-to-one round segment from a particular one-to-one round segment set based on a value which depends on a preselected number of bits in a preselected location from a different one-to-one round segment from the same one-to-one round segment set.
      <br/>
      The nonlinear function is a variable rotation function or an s-box.
      <br/>
      A subkey combining function is generally employed in each round to provide new round segments by combining a round segment typically linearly with a subkey segment.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
    <p num="1">This application claims priority to Provisional Application No. 60/059,142 entitled "IMPROVED BLOCK CIPHER METHOD", filed on Sep. 17, 1997; Provisional Application No. 60/062,992 entitled "IMPROVED BLOCK CIPHER METHOD" filed on Oct. 23, 1997; Provisional Application No. 60/064,331 entitled "IMPROVED BLOCK CIPHER METHOD" filed Oct. 30, 1997; Provisional Application No. 60/094,632 entitled "IMPROVED BLOCK CIPHER METHOD" filed Jul. 30, 1998, Provisional Application No. 60/096,788 entitled "THE STEELTALON ENCRYPTION ALGORITHM" filed Aug. 17, 1998; Provisional Application No. 60/096,921 entitled "IMPROVED BLOCK CIPHER METHOD" filed Aug. 18, 1998; and Provisional Application No. 60/098,905 entitled "IMPROVED BLOCK CIPHER METHOD" filed Sep. 2, 1998 by the same inventor hereof.</p>
    <heading>FIELD OF INVENTION</heading>
    <p num="2">
      This invention relates to block cipher secret-key cryptographic systems and methods.
      <br/>
      More particularly, the invention relates to improvements in a secret-key cryptographic system and method which uses data-dependent variable rotations.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="3">
      Cryptography is the science of securing communications and information.
      <br/>
      In recent years, the importance of cryptographic systems has been magnified by the explosive growth and deployment of telecommunications technology.
      <br/>
      Increasing volumes of confidential data are being transmitted across telecommunications channels and are being stored in file servers, where such data ranges from financial information to electronic votes.
      <br/>
      It is desired that systems provide security from unsanctioned or illicit interception or modification of such confidential information.
    </p>
    <p num="4">
      There are two basic operations used in secret-key or symmetric block cipher cryptography.
      <br/>
      Encryption or encipherment is the process of disguising a communication to hide its content.
      <br/>
      During encryption, the communication which is known as plaintext is encrypted into what is known as ciphertext.
      <br/>
      Decryption or decipherment is the inverse process of using the same secret-key values to recover the plaintext from the ciphertext output.
      <br/>
      While the two basic operations of encryption and decryption may be distinguished in practice, there is in general no necessary mathematical difference between the two operations, other than that they are inverse transformations of each other.
    </p>
    <p num="5">
      Ciphertext output of a secure block cipher has little or no statistical relation to its corresponding plaintext input.
      <br/>
      The output (or input) is uncorrelated to the input (or output).
      <br/>
      Every bit of ciphertext output reflects every bit of the plaintext input and every bit of the key in a complex uncorrelated manner, just as every bit of recovered plaintext input reflects every bit of the ciphertext output and every bit of the key in a complex uncorrelated manner.
    </p>
    <p num="6">
      Block ciphers, generally, are binary ciphers receiving inputs consisting of a fixed number of bits (a block n of bits), and have outputs of the same fixed number of bits (an equal sized block of n bits).
      <br/>
      The input and output of such ciphers are one-to-one mappings: each ordered n-bit input is transformed by the block cipher into only one ordered n-bit output; and further, when the transformation is computed in reverse each ordered n-bit output may be transformed back into only one ordered n-bit input.
    </p>
    <p num="7">
      Secret key values are the values which influence the mapping of input to output provided by the block cipher.
      <br/>
      It is useful to divide secret keys into two categories: secret input keys and secret keys.
      <br/>
      Secret input keys may be based on varied input from a user or the encryption system which may be of fixed or variable length, and a secret key is often a transformed secret key input.
      <br/>
      A secret key is usually of fixed length.
      <br/>
      A block cipher usually operates on a secret key, but in some cases may operate on an secret input key.
      <br/>
      If a block cipher first operates on a secret input key, potentially it may use some algorithm to transform the secret input key into a secret key in a standard format.
      <br/>
      Then, a block cipher expands the secret key to form subkeys whose length or number of bits exceeds that of the secret key.
    </p>
    <p num="8">
      Block ciphers and have many rounds the same operations are performed iteratively in the same manner.
      <br/>
      The n-bit input into the block cipher may be called n-bit cipher input.
      <br/>
      After encryption, the result may be called n-bit cipher output.
      <br/>
      In each of these rounds, the ordered binary input may be called n-bit cipher round input, and the n-bit ordered binary output may be called n-bit cipher round output.
      <br/>
      An n-bit cipher input or n-bit cipher output refers to the variable n-bit binary input or variable n-bit binary output of a binary block cipher.
      <br/>
      Such n-bit cipher input and n-bit cipher output are typically plaintext input and ciphertext output.
      <br/>
      By contrast, key inputs or subkey values used by a binary block cipher are not variable binary inputs, but are generally fixed or predetermined values for a given use of the block cipher.
      <br/>
      An n-bit cipher round input or n-bit cipher round output refers to the variable n-bit binary input or variable n-bit binary output of one (and typically of one operative round) round of a binary block cipher.
    </p>
    <p num="9">
      An operative round of a binary block cipher is an iterative round which calculates new values for each of x primary segments in the round, where x may vary in different operative rounds, where there are a total of n-bits in the x primary segments, and where the new values of the x primary segments determine the n-bit round output.
      <br/>
      Operative rounds of a binary block cipher refer to iterative rounds which calculate new values for each of x primary segments in a given round, where x may vary in different rounds, where the n-bit cipher round output consists of these x segments of new values, and where the total of all bits of the x segments equals n bits.
      <br/>
      Binary block ciphers are ciphers receiving inputs consisting of n ordered bits of input and have outputs of the same number of ordered bits (n bits).
      <br/>
      A mapping of block cipher inputs to outputs reveals that every possible combination of n input bits from 2 n possible combinations has only one corresponding combination of n output bits, and likewise every combination of n output bits from 2 n possible combinations has only one corresponding combination of n input bits.
      <br/>
      In other words, binary block ciphers transform input values to output values in a manner such that the mapping of this transformation relates the members of the set of all possible ordered input values of n-bits in a one-to-one manner with the members of the set of all possible ordered output values of n-bits.
    </p>
    <p num="10">
      While a segment is defined simply as a plurality of ordered bits, it is also possible to classify types of segments.
      <br/>
      There are also round segments and one-to-one round segments.
    </p>
    <p num="11">
      A round segment is a segment within a round (and typically an operative round) of a binary block cipher which is part of n-bit cipher input or n-bit cipher output, or is calculated within a round or operative round the operative round and is intermediate between input and output; is affected by n-bit cipher round input; and affects n-bit cipher round output.
      <br/>
      For example, a first value in a calculation is said to affect a second value if, after taking into account the specifics of the particular calculation, a random change in all bits of the first value is likely to change at least one bit of the second value with a chance of at least one in three.
    </p>
    <p num="12">
      A one-to-one round segment is defined as a member of a one-to-one round segment set.
      <br/>
      A one-to-one round segment set is defined as a set of ordered round segments in an operative round of a binary block cipher where it is true that each n-bit round input corresponds with only one possible result or group of particular values of the ordered segments of that set, and that any group of particular values of the ordered segments of that set correspond with only one possible n-bit round input.
      <br/>
      For example, the set of segments in the n-bit cipher output are a one-to-one round segment set.
      <br/>
      The set of segments in any of the n-bit round input or the n-bit round output of each operative round are also one-to-one round segment sets.
      <br/>
      Where one-to-one round segment sets are calculated in a binary block cipher which operates on n-bits of input or output, it obviously follows that all such one-to-one round segment sets consist of exactly n-bits.
    </p>
    <p num="13">
      Note that in general there are usually more one-to-one round segment sets than the examples just mentioned.
      <br/>
      For example, in most binary block ciphers it is possible to form one-to-one round segment sets by combining particular round segments which are determined consecutively even though they are determined in different rounds.
    </p>
    <p num="14">
      There is a term-of-art in which one speaks of the n-bit data or bits (which for block ciphers can be called text or plaintext or cipher data) of a calculation method from encryption.
      <br/>
      Such data is generally dependent on any variable input into the method from plaintext.
      <br/>
      If so, such data is, in another term-of-art, also called variable as opposed to predetermined or fixed.
      <br/>
      Consequently, one can speak of all the n-bit data (all the bits) in one-to-one round segment sets as being variable; and such data is different than the predetermined secret subkey data which is also part of block ciphers.
      <br/>
      Such subkey data is dependent on the secret key, and is fixed and often precalculated relative to any variable plaintext input of the block cipher.
    </p>
    <p num="15">
      One can observe further that in a well designed block cipher most bits of variable round segments are variable.
      <br/>
      This observation is true for efficient block ciphers since any non-variable bits can be wasteful or inefficient.
      <br/>
      For example, although a round segment may be called variable as if it has at least one variable bit within it by definition, in a well designed block cipher if a round segment is variable in general, a substantial portion (such as 50 out of 64) of the bits within that round segment will also be variable.
    </p>
    <p num="16">Further, block ciphers may linearly combine one-to-one round segments with subkeys, or rotate them by a predetermined number of bits, or rotate them by a data- dependent number of bits determined by some bits of another unrelated one-to-one round segment, or even combine them linearly with other unrelated one-to-one round segments, and generally such resulting output segments, which are sometimes intermediate values that do not affect n-bit output directly, are also one-to-one round segments.</p>
    <p num="17">
      Finally, the preceding description of primary segment values while sufficient for understanding the scope of the prior art is incomplete.
      <br/>
      Typically, primary segment values are more than just calculated round segment values which determine a n-bit round output.
      <br/>
      Typically, a n-bit round input contains old or prior values of primary segments which are replaced over the course of an operative round.
      <br/>
      Typically, each such replacement value of a primary segment is a one-to-one function of the prior value, if all subkey values and all other primary segments are constant.
      <br/>
      Generally, all primary segment values are one-to-one round segments.
    </p>
    <p num="18">
      To increase security each operative round typically interacts one-to-one round segments and secret subkey values.
      <br/>
      In each operative round, each of the x primary segments is typically a function of its prior segment modified by the combined interaction of at least one other one-to-one round segment and in some cases by a subkey segment for that round.
    </p>
    <p num="19">
      In practice, execution of block ciphers in microprocessors generally takes place using registers, which typically are the data locations in a microprocessor which are quickest at loading and storing data.
      <br/>
      Often, binary block ciphers are configured such that the usual segment operated on by the rounds of the block cipher is equal in size to the 32-bit or 64-bit registers of microprocessors which may compute the block cipher.
    </p>
    <p num="20">
      Increasingly, not only do binary block ciphers use algorithms optimized for 32-bit or 64-bit registers but also they use algorithms which are optimized for the microprocessors of network servers, which are typically internet or intranet nodes.
      <br/>
      Such network nodes usually must be capable of more than just encryption or decryption.
      <br/>
      In fact, the majority of time and resources of such servers is allocated to other tasks.
      <br/>
      As a result, it is critical that a block cipher well suited to this task be capable of quick bootup or startup and make minimal use of on-chip cache, which is one of the most critical resources of a server's microprocessor.
    </p>
    <p num="21">
      Another type of encryption which may not require as much optimization as node encryption on network servers is bulk encryption of large files.
      <br/>
      Calculation of block ciphers, well suited to bulk encryption, typically takes place in registers.
      <br/>
      However, as the amount of data to be encrypted is larger in bulk encryption, quick startup is not essential.
      <br/>
      Such startup time becomes a small percentage of the total time spent encrypting a large file.
    </p>
    <p num="22">
      A good example of perhaps the first historically significant symmetric cryptographic system (i.e., when the same key is used in the encipherment and decipherment transformations) is the Data Encryption Standard ("DES"), which is a U.S. Government standard.
      <br/>
      DES uses small "s-boxes" to provide security.
      <br/>
      These so-called s-boxes are substitution boxes or, simply, look-up tables.
    </p>
    <p num="23">
      S-boxes provide output which is a nonlinear function of the input, based on a lookup table.
      <br/>
      Small s-boxes are lookup tables with a small number of possible inputs.
      <br/>
      Often, small s-boxes have a small number of output bits as well.
      <br/>
      For example, each s-box of DES has 6-bit inputs or 64 possible inputs and 4-bit outputs or 16 possible output values.
      <br/>
      They do not require much memory; nor does it take long to load them in microprocessor memory. S-boxes are generally stored in on-chip cache, generally the next quickest form of microprocessor memory after registers.
    </p>
    <p num="24">
      DES was the first significant example of a Feistel block cipher.
      <br/>
      Such block ciphers are named after Horst Feistel.
      <br/>
      Feistel block ciphers perform repetitive operations on a left half and right half of a block, respectively.
      <br/>
      This is convenient for execution in hardware and software when the number of registers is limited.
    </p>
    <p num="25">
      One aspect of DES which is particularly relevant to the defined terms used herein is the fact it swaps its primary segments, also known in DES as cipher block halves.
      <br/>
      If the swaps are included, some equations which describe in a general way both segments being recalculated are as follows, where LH means the left half, and RH means the right half: increment i by +1  (Equation image '1' not included in text)
    </p>
    <p num="26">This sequence of calculation is mathematically equivalent to the simpler equations and the operative round below:  (Equation image '2' not included in text)</p>
    <p num="27">
      The approach used herein is to discuss ciphers and their round equations in general using terms developed for those particular ciphers which are expressed without any obscuring primary segment swaps or other similar operators which might have a similar effect, in order to focus on the internal mathematical structure and logic of each round of each cipher.
      <br/>
      This discussion while simplified is meant to apply also to all ciphers even if they are expressed in a complicated manner using such primary segment swaps or other obscuring operators.
    </p>
    <p num="28">
      What is relevant about the above simplified presentation of DES is that each such operative round calculates two new values of the primary segments which are part of a n-bit round output.
      <br/>
      Further, DES applies its nonlinear function to each of the primary segments LH and RH which are part of a n-bit round output.
      <br/>
      This general structure of DES in which all functions are applied to each of the primary segments is copied in almost all other block ciphers.
    </p>
    <p num="29">
      Another common feature of most efficient implementations of DES which is copied elsewhere is to place each block half or primary segment in the register of a microprocessor.
      <br/>
      This feature allows certain desired cryptographic operations to be performed quickly.
      <br/>
      For example, it becomes possible to add a block half with a subkey, or to xor block halves together, in only one operation (typically in one microprocessor clock cycle).
      <br/>
      As is well known, xor indicates bitwise exclusive-or.
      <br/>
      It is an operator which interacts bits in identical positions.
      <br/>
      If Z equals X xor Y, the result of each bit in a given position in Z equals the exclusive-or of the two bits in the same positions in X and Y.
    </p>
    <p num="30">
      Unfortunately, small s-boxes generally do not permit ciphers that are efficient, i.e., both fast and secure.
      <br/>
      Larger s-boxes are typically consistent with more efficient block ciphers.
      <br/>
      However, large s-boxes either use a significant percentage of on-chip cache (competing with other desired uses of on-chip cache), or they must be loaded prior to each use (which is time consuming).
      <br/>
      While use of larger s-boxes might increase the efficiency and speed of DES, it would also increase startup time and the use of on-chip cache.
    </p>
    <p num="31">
      Two interesting examples of Feistel block ciphers which use large s-boxes are the two ciphers referred to as Khufu and Khafre, see, e.g., U.S. Pat. No. 5,003,597. These block ciphers use s-boxes where the 8-bit inputs are considerably smaller than their 32-bit outputs.
      <br/>
      This approach is consistent with the fact that modem microprocessors take an equal number of clock cycles to compute s-boxes with 32-bit output as they do s-boxes with 8-bit output.
      <br/>
      So while the output size of the s-box increases, so too does the strength and efficiency of the cipher given a constant number or rounds or clock cycles.
      <br/>
      Khufu and Khafre are both Feistel block ciphers having many varied details which are not directly relevant here.
    </p>
    <p num="32">In general, Khufu and Khafre ciphers have the following structural characteristics:</p>
    <p num="33">
      First, similar to other Feistel block ciphers, it is convenient to compute the ciphers using two registers which contain the bit-values of the left and right halves.
      <br/>
      In each round of the block cipher, each register of cipher data is recalculated.
      <br/>
      This process updates and modifies the initial value of each register, which is the old primary segment, and substitutes a new register value, which is a new primary segment.
      <br/>
      In this approach, each new primary segment is mapped one-to-one with its old primary segment, all subkey segments and other primary segments being equal.
    </p>
    <p num="34">
      Second, each new primary segment reflects not only the corresponding old primary segment but also a small number of bits which are the least significant bits ("lsb") of the other register.
      <br/>
      The lsb affect the new one-to-one round segment in a non-linear manner using s-boxes.
      <br/>
      The s-boxes of Khufu and Khafre have 8-bit inputs and 32-bit outputs.
      <br/>
      They accept 8-bit inputs from the last calculated register, and their 32-bit outputs affect the new primary segment in the register currently being computed.
    </p>
    <p num="35">
      Khufu and Khafre ciphers are unlike most other Feistel block ciphers in that there is only one non-linear operation (i.e., an s-box operation) in each round; it accepts input from only a small fraction or small section of the one-to-one round segment (8 bits), and that non-linear operator potentially affects all the bits of the other one-to-one round segment.
      <br/>
      This small section is generally less than thirty-five percent of the one-to-one segment which contains the small section.
      <br/>
      This process of using in each round a small section of a recently calculated one-to-one round segment to affect the new one-to-one round segment in a non-linear manner may be called bit expansion of a small section.
    </p>
    <p num="36">
      Third and finally, Khufui and Khafre use rotation as an efficient means to move bits.
      <br/>
      This operation may be necessary in some form when the only nonlinear operation of each round is an s-box operation which uses only a small fraction of bits from one-to-one round segment.
      <br/>
      Rotation can ensure that all bits eventually become input of the non-linear operation, and thus have some nonlinear effect on the cipher data.
    </p>
    <p num="37">
      Khufu requires considerable time to generate its s-boxes, and is a complex block cipher.
      <br/>
      On the other hand, up to this point in time popular adoption of block ciphers historically has followed quick startup time and simplicity.
      <br/>
      To date it appears that no significant software packages appear to have embraced this block cipher.
      <br/>
      Khafre uses fixed s-boxes and is simpler than Khufu, but it appears it may use many large s-boxes and it is designed only to compute a 64-bit block cipher.
      <br/>
      Unfortunately, 64-bit block ciphers are generally insecure due to small block size.
      <br/>
      It appears that Khafre may use different s-boxes for succeeding rounds in order to avoid certain weaknesses which occur when an s-box is used in the same way to encrypt different cipher data.
      <br/>
      However, this significantly increases the amount of memory necessary to accommodate its s-boxes.
    </p>
    <p num="38">
      Due to the complexity of these ciphers, their security has not been evaluated thoroughly by many cryptanalysts.
      <br/>
      However, it is readily apparent that given a reasonable number of rounds or clock cycles computed, Khafre is not adequately secure.
    </p>
    <p num="39">
      Another more recent cipher has certain general properties of Khufui and Khafre and was published as a springboard for further investigation and research.
      <br/>
      This algorithm is called "Test1" (see, Bruce Schneier and Doug Whiting, "Fast Software Encryption: Designing Encryption Algorithms for Optimal Software Speed on the Intel Pentium Processor".
      <br/>
      Fast Software Encryption--Fourth International Workshop, Leuven, Belgium, 1997, referred to herein as Schneier et al.).
      <br/>
      The algorithm was designed as part of a testbed of ideas about fast software rather than as a secure, simple, or practical block cipher.
    </p>
    <p num="40">
      The block cipher Test1 uses four registers of 32 bits, each of which contains a primary segment.
      <br/>
      In it each new primary round segment, Rt0, is a function of the last four previously calculated primary segments (Rt-1 thru Rt-4).
      <br/>
      Its round equations vary significantly in various rounds to inject some irregularity into the algorithm.
      <br/>
      However, a typical round equation (Equation 3) of the cipher is as follows:  (Equation image '3' not included in text)
    </p>
    <p num="41">
      In this round equation of this cipher the s-box receives input bits from the least significant bits ("lsb") of R-2. The new primary segment R0 reflects the linear combination of other values and the s-box output using generally non-commutative operators and using round-and-register dependent rotation.
      <br/>
      Nevertheless, use of non-commutative operators does not appear to be structured efficiently; further, the register size of 32 bits each is too small to gain significant cryptologic strength from use of non-commutative operators; and finally, the sbox is not optimized and may be random and such sbox may have, given all possible input differences, a minimum number of output bit-differences which is too small to provide adequate differential strength.
    </p>
    <p num="42">
      Of course, in this equation there are four primary round segments.
      <br/>
      As value R-4 is the old primary segment, the value of the new primary round segment R0 is an invertible one-to-one function of the one-to-one round segment R-4 assuming all other inputs including other one-to-one round segments are constant.
      <br/>
      Although this property is true for this segment, when the property is repeated throughout the operative rounds, it makes possible the property for the cipher globally that its ordered n-bit inputs map one-to-one with its ordered n-bit outputs.
    </p>
    <p num="43">
      In practice, use of four registers to encrypt cipher data may be too many registers to achieve good security efficiently.
      <br/>
      Testl also appears too complicated to be adopted as a mainstream block cipher.
      <br/>
      Further, Testl uses only one s-box to conserve on-chip cache.
      <br/>
      It is not adequately clear that this approach is secure.
      <br/>
      Repetitive use of the same s-box in the same manner is usually insecure.
      <br/>
      While use of non-commutative operations does alleviate this concern somewhat, the registers are too small (only 32 bits) for the non-commutative operators to provide much additional strength.
      <br/>
      The cipher's use of round-dependent rotation as specified in its F-table also alleviates this concern somewhat.
      <br/>
      Nevertheless, the round-dependent rotation schedule is fixed and known and hence may not provide adequate security given reuse of the same s-box in successive rounds if the s-box is known.
    </p>
    <p num="44">
      On the other hand, if the a s-box is generated in a key-dependent random manner prior to encryption as intended by Schneier et al., the bootup time of the cipher is increased substantially.
      <br/>
      Further, if such an s-box is generated randomly and hence not optimized to avoid potential flaws, there is also a potential risk of weak s-boxes.
    </p>
    <p num="45">
      By contrast, a symmetric encryptional method known as "RC5" (see R. Rivest. "The RC5 Encryption Algorithm".
      <br/>
      Fast Software Encryption--Second International Workshop, Leuven, Belgium, pages 86-96.
      <br/>
      Springer-Verlag, 1995) is based on a different paradigm.
      <br/>
      Unlike DES, Khufu and Khafre, RC5 uses no s-boxes.
      <br/>
      This fact eliminates the need to reserve large segments of on-chip cache in order to store the s-boxes.
      <br/>
      Thus, RC5 may be more practical to encrypt or decrypt standard packets of data, usually only 48 bytes each, received from the internet or other digitized phone networks.
      <br/>
      Such encryption or decryption may take place without having to allocate any time to transferring large s-boxes into on-chip cache.
    </p>
    <p num="46">
      RC5 is a Feistel block cipher which appears to be the first to use data-dependent rotation in a relatively efficient manner.
      <br/>
      A primary distinguishing feature of RC5 is the way in which, to calculate new one-to-one round segments, it rotates that segment in a variable, i.e., data-dependent, manner depending on particular bit-values in another one-to-one round segment.
      <br/>
      This data-dependent rotation is the operation which provides the cryptographic strength of RC5.
      <br/>
      It permits RC5 to eliminate s-boxes. S-boxes are nonlinear and may act in a complex data-dependent manner.
      <br/>
      For example, an s-box may affect some bits in a nonlinear manner based on the values of some other bits.
      <br/>
      If RC5 did not use rotation in a data-dependent manner, it appears it would need s-boxes or some other operation which acts in a data-dependent manner.
    </p>
    <p num="47">
      Referring herein to prior art FIG. 1, an algorithmic flow chart of the RC5 enciphering process is shown.
      <br/>
      A first block 10 contains plaintext input consisting of n bits at the start of the iterative enciphering process.
      <br/>
      Each plaintext input block is divided up into two primary segments, 12 (R0) and 14 (R1), each of which contain n/2 bits.
      <br/>
      For example, a 64-bit version of RC5 divides its input into two 32-bit block halves.
      <br/>
      Typically, in calculating a 64-bit version of RC5 each such block half or one-to-one primary round segment is to be contained in one 32-bit microprocessor register, which is the register size of most modem microprocessors.
    </p>
    <p num="48">
      Prior to beginning the iterative process, RC5 adds (blocks 16 and 18) one subkey value, K1 and K2, to each primary segment, R0 and R1.
      <br/>
      Each value of K1 and K2 can be the same or different.
      <br/>
      Similar to the one-to-one round segments, each such key value contains n/2 bits.
      <br/>
      Next, RC5 performs the first of many rounds of encryption.
      <br/>
      Each round of encryption computes new values of the primary segments R0 and R1.
      <br/>
      Each computation of the two primary segments is similar in form, even though it has different inputs and outputs and is stored in different registers.
    </p>
    <p num="49">
      To compute in the first half round the new primary segment R0, the following procedure is used.
      <br/>
      The half round uses xor (block 20) to combine the segments R0 and R1.
      <br/>
      Next, it extracts (block 24) a given number of bits ("f" bits) from the least significant bits of the right primary segment R1.
      <br/>
      For example, if f is 5 bits, it would extract the 5 least significant bits ("lsb") of R1 in order to provide one input used by the variable rotation.
    </p>
    <p num="50">
      The number of lsb in a one-to-one round segment (the lsb contain "f" bits) is that number which permits as many different rotations as are possible for a primary segment.
      <br/>
      For example, a 64-bit block has two primary segments of 32 bits each.
      <br/>
      The 32 possible rotations of these halves may be selected using f=5 bits, as 2 5=32.
      <br/>
      Hence, for each potential block size there is an associated number of bits "f" which permits all potential rotations of the primary segments.
      <br/>
      Thus, the total number of different values of V extracted from the lsb of R1 may be as many 2 f, or in this example 2 5, possible values.
      <br/>
      It will be noted that the "least significant bits" which affect a rotation are crytographically speaking the most significant bits of each round.
    </p>
    <p num="51">
      Then, the xored values in the left primary segment R0 are rotated (block 26) by V, i.e., the value of the lsb.
      <br/>
      Finally, to this result is added (block 28) a subkey K3 for this half round.
      <br/>
      The resulting one-to-one primary round segment is the new value of R0 (block 30) from the first round.
    </p>
    <p num="52">
      This process is then repeated in the second half round to calculate the right primary segment R1 using the new value of R0.
      <br/>
      To compute in the second half round the new primary segment R1, the following procedure is used.
      <br/>
      The round uses xor (block 22) to combine the values of its primary segment R1 with that of the other primary segment R0.
      <br/>
      Next, it extracts the given number of bits ("f" bits) from the least significant bits of R0.
      <br/>
      Again, if f is 5 bits, it would extract (block 32) the 5 least significant bits ("lsb") of R0 in order to provide one input used by the variable rotation.
      <br/>
      Then, the xored values in the right segment R1 are rotated (block 34) by V, i.e., the value of the lsb.
      <br/>
      Finally, to this result is added (block 36) a subkey K4 for this half round.
      <br/>
      The resulting one-to-one primary round segment is the new value of R1 (block 38) from the first round.
    </p>
    <p num="53">
      Each round of RC5 is only part of a complete encryption of one plaintext block.
      <br/>
      Many rounds are generally necessary depending on block size.
      <br/>
      This number of rounds selected depends on block size and the users desire for security, but is typically greater than 8 and less than 64.
      <br/>
      After all rounds are completed the resulting ciphertext values of segments R0 (block 40) and R1 (block 42) are generated, which are then combined to generate ciphertext consisting of n bits (block 44).
    </p>
    <p num="54">
      Each round of RC5 in FIG. 1 may also be expressed as two equations, Equations 4 and 5 below, where each equation determines the bit-values of one primary segment and where each such segment corresponds to half an n-bit block of data.
      <br/>
      This description follows, where i is the iterative index of the round and where i is incremented by two between rounds (these equations ignore the initial addition of the subkeys K0, K1 to the plaintext):  (Equation image '4' not included in text)
    </p>
    <p num="55">
      Unlike DES, RC5 does not swap its one-to-one primary round segments between calculating each such segment.
      <br/>
      Consequently, RC5 requires fewer clock cycles for a given number of new segment values and also it is easier to understand.
    </p>
    <p num="56">
      Similar to DES, in RC5 each new value of a primary segment is a one-to-one function of its prior value given that the other one-to-one round segment and the subkeys are constant.
      <br/>
      Incidentally, in RC5 every round segment calculated in each round, with the possible exception of the value V which controls the data-dependent rotation, is a one-to-one round segment.
    </p>
    <p num="57">It will be noted that similar to the simplified structure of DES using no round segment swaps, the structure of RC5 ensures that the same operations affect each primary round segment: (1) the nonlinear operation of data-dependent rotation affects each primary segment R0 and R1 based on the small section bits of the other primary segment, (2) the linear combination of the two primary segments using xor affects each primary segments R0 and R1, and (3) modification by a new subkey value affects each primary segment R0 and R1.</p>
    <p num="58">
      Again, decryption is the inverse of encryption.
      <br/>
      All the same steps are repeated but in reverse order.
      <br/>
      Decryption uses ciphertext output as input and recovers the values of the plaintext inputs.
      <br/>
      The decryption round equations (Equations 6 and 7) of RC5 are simply the inverse of the encryption round equations:  (Equation image '5' not included in text)
    </p>
    <p num="59">
      It should be apparent to one skilled in the art that the choice of which equations are used for encryption or decryption is a convention.
      <br/>
      Hence, it is possible to build a cryptographic system in which what is herein called the RC5 inverse equations are used for encryption, and what is herein called the RC5 encryption equations are used for decryption.
    </p>
    <p num="60">
      It is useful to define a quantitative measure called good bits which indicates the degree to which cumulative linear combination (i.e., the process of combining round segments in a linear manner to produce a new round segment) of round segments does or does not introduce good bits to affect a rotation.
      <br/>
      Good bits are those bits from cipher input which affect the small section of the segment which controls second round nonlinear activity but which do not affect the small section of the segment which controls first round nonlinear activity.
      <br/>
      Of course, it is useful to keep in mind that when this bit-tracing calculation of good bits is applied to decryption equations such input may be ciphertext which is ordinarily thought of cipher output, just as the output of the last round may be plaintext.
      <br/>
      Generally, the definition of good bits measures the number of small section bits which definitely control the nonlinear activities of each round which do not in general also control the nonlinear activities of the preceding round.
      <br/>
      For this reason, the number of good bits measures the inflow in each round of fresh or new data from linear diffusion which influence the nonlinear activities.
      <br/>
      When the number of good bits is at least half as large as the total use of small section bits to affect nonlinear activity in each round, or greater, then the block cipher has a property which may be called new small section data in successive rounds.
    </p>
    <p num="61">
      It is difficult to evaluate the good bits of two consecutive rounds of encryption of RC5 because during encryption all segment bits are rotated, hence it is uncertain rather than definite which input bits affect the nonlinear activity of the subsequent two rounds.
      <br/>
      Similarly, the use of addition or subtraction in encryption or decryption makes it uncertain rather than definite which bits affect which due to "carry" bits in addition and subtraction which allow some input bits to affect more or less significant bits though often with a low probability.
    </p>
    <p num="62">
      In the case of ambiguity due to variable data-dependent rotation of all segments which are combined linearly, the total number of calculated good bits is zero since those segments should be excluded from the calculation of good bits.
      <br/>
      After first discarding any such bits from the determination of good bits, the calculation of good bits is based on whichever equation (encryption or decryption) generates a greater number of good bits.
      <br/>
      This greatest number of good bits provides a rough measure of the strength of the block cipher in the area of data-dependence and bit-diffusion.
    </p>
    <p num="63">
      Evaluation of good bits is done therefore using the decryption equations, eliminating any values which have been rotated by a variable operator, and converting all linear operators other than xor to xor.
      <br/>
      After making these changes it is possible with simplicity and consistency to trace which input bits of any n-bit round input definitely affect the first and second of two consecutive rounds in a nonlinear manner.
    </p>
    <p num="64">
      In the case of RC5, the input bits which affect its variable rotations in the second round due to linear diffusion are the same that do in the first round.
      <br/>
      These bits come from the lsb of the cipher input segments R0 and R1.
      <br/>
      Hence, there are no non-overlapping input bits which definitely control the small section nonlinear activity of the cipher in a second round but not in a first round, and the number of good bits in each round is zero.
      <br/>
      As the number of good bits (0) are much fewer than the number of bits which affect rotations in each round (2f), RC5 does not have the property of new small section data in successive rounds.
    </p>
    <p num="65">
      To understand a possible effect of inadequate new small section data in successive rounds, it is useful to understand the differential analysis of data-dependent rotation in RC5, and to examine a particular example.
      <br/>
      A typical differential attack on a block cipher relies on the fact that some bit inputs fail to affect other bit values in a block cipher.
      <br/>
      A good example of block cipher encryption may therefore illustrate in simplified manner how a typical differential attack might work.
    </p>
    <p num="66">
      Typically, differential attacks are effective because they use self-cancellation to extend the power of the differential method over multiple rounds.
      <br/>
      It turns out in most cases that there exist certain input differences between two related encryptions called differential characteristics which have a high probability of self-cancellation in the operative rounds of the block cipher, where after several rounds of encryption there is a high probability that the output bit-difference between the two encryptions equals the initial bit-difference.
    </p>
    <p num="67">For example, consider the following simple inputs into the RC5 block cipher in P FIG. 1:</p>
    <p num="68">
      For Plaintext Input -1 let, R0=+0 0 0 0 0 0 0 0 . . . };R1=+0 0 0 0 0 0 0 0 . . . }
      <br/>
      For Plaintext Input -2 let, R0'=+0 0 0 0 1 0 0 0 . . . };R1'=+0 0 0 0 1 0 0 0 . . . }
      <br/>
      The difference between these registers is, D0=+0 0 0 0 1 0 0 0 . . . };D1=+0 0 0 0 1 0 0 0 . . . }
    </p>
    <p num="69">
      In the above example, the only bit that is different in the two sets of one-to-one round segments is the fifth bit from the left.
      <br/>
      As the fifth bit in each segment is different, when xored together in the above RC5 equation (1) the difference in the inputs cancels out.
      <br/>
      Cryptanalysts are generally able to use such self-cancellation of input differences between two related encryptions to find differential characteristics that can with a certain probability pass through multiple rounds unaffected by the block cipher.
      <br/>
      It turns out that when assuming the bit input differences shown above the best probability of bits canceling out is seen in every third new register value (R0 in the 1 st round, R1 in the 2nd round, R0 in the 4th round, R1 in the fifth round, etc.).
    </p>
    <p num="70">
      It is possible to examine a simplified example which illustrates this type of differential analysis.
      <br/>
      First, it is useful to calculate a base case using RC5 in which nothing of cryptographic interest occurs.
      <br/>
      Using the plaintext input shown above where all bits equal 0, it is useful to assume that all subkey bit values also equal 0.
      <br/>
      These inputs result in potentially an infinite number of rounds of encryption in which all bits of each new one-to-one round segment equal 0.
      <br/>
      Of course, given these assumptions, the ciphertext output bits of RC5 also equal zero.
      <br/>
      This result is not surprising and reflects the simplified assumptions concerning subkey values.
    </p>
    <p num="71">
      Second, the interesting step in creating a useful illustration of the behavior of RC5 is to allow certain non-zero input bits.
      <br/>
      Using this approach, the new one-to-one round segments in succeeding rounds of this example based on an input or input-difference which has some non-zero bits illustrate the differential behavior of the cipher.
    </p>
    <p num="72">
      Referring herein to prior art FIG. 2 (wherein the blocks are numbered as in FIG. 1, with the numbers in the second round being designated with a prime), a simple example in which given input values where some bits are modified from the base case to non-zero bits, and the non-zero bits pass through two rounds of RC5 encryption with little or no effect upon the other bits is shown.
      <br/>
      As stated above, for simplicity and ease of explanation, all key values and most of the input values are equal to 0.
      <br/>
      This example is similar to the differential input difference shown above.
      <br/>
      Only the fifth bit of each register, i.e., each block half, has a value of 1.
      <br/>
      Note also that in this example, which is similar to a typical differential attack on a Feistel block cipher, every third primary segment or half round of RC5 contains bits in which any non-zero input bits have canceled out and all bits are equal to 0.
      <br/>
      In a differential attack on RC5 by a cryptanalyst, this self-cancellation property reduces the effort required to break the cipher.
    </p>
    <p num="73">
      It will be appreciated with RC5 encryption, that even with an infinite number of rounds a particular bit may not be affected.
      <br/>
      With these assumptions, it turns out that the fifth input bit in these registers with a value of 1 cannot ever affect a rotation.
      <br/>
      In other words, an infinite number of rounds are required until the input bit affects a rotation.
    </p>
    <p num="74">
      Of course, this example is only possible due to weak subkey values.
      <br/>
      All values of the subkeys equal zero.
      <br/>
      In this example, the weak rotations which permitted this result to come about depend primarily on certain subkey values; and the rotations in the example shown above are affected by a total of only 8 plaintext bits.
      <br/>
      In FIG. 2, the data values which affect the rotations are the initial least significant 4 bits of each plaintext block half.
    </p>
    <p num="75">
      It is worth noting that this block cipher may iterate through potentially a large number of rounds, and yet the output may depend primarily on only eight plaintext bits and on those subkeys which influence the one-to-one round segments associated with those plaintext bits.
      <br/>
      This suggests that this block cipher violates a requirement of a secure block cipher in that every output bit depends on every bit of plaintext input and on every bit of key input.
    </p>
    <p num="76">
      The primary weakness shown in this example of RC5 is that, assuming worst case variable data dependent rotations, the variable cipher data circulate in such a manner such that in certain rounds (where in general one round is a number of steps large enough that the number of data-dependent rotations is at least as great as the number of primary round segments in the block cipher) there exists a small set of potentially stagnant or isolated stationary variable bits in specified bit-positions which control the number of bits of all data-dependent rotations ("specified isolated bits") where by definition a) only that set of specified isolated bits in the specified bit-positions can control the data-dependent rotations, and b) only that set of specified isolated bits in the specified bit-positions can affect the values of the specified isolated bits in the same specified bit-positions.
      <br/>
      By definition, the number of specified isolated bits is the smallest number possible assuming any possible data-dependent rotations.
      <br/>
      This means, assuming that those data-dependent rotations occur, there is a minimum number of specified isolated bits where only those bits can control the degree of data-dependent rotations in the block cipher, and only those specified isolated bits can affect their own values.
    </p>
    <p num="77">
      In the case of RC5-32 (i.e., using the example shown above and in FIG. 2 which has a 32-bit block size and two 16-bit halves), in one round there are 8 specified isolated bits, which are the least significant 4-bits of each of the two round segments of the block halves, where in that round only the 8 specified isolated bits affect data-dependent rotations, and assuming a data-dependent rotation of zero bits the specified isolated bits are affected only by the specified isolated bits in that round.
      <br/>
      As previously stated, this number of specified isolated bits is invariant as the number of rounds increases.
      <br/>
      In other words, given an infinite number of rounds, it is still theoretically possible that in RC5 an input bit might not affect a data-dependent rotation.
      <br/>
      Further, the number of specified isolated bits is a small fraction of the number of bits in the n-bit variable cipher data block (in this example, the 8 specified isolated bits are only 25 percent of the total of 32-bits in the total data block).
    </p>
    <p num="78">
      The weakness of RC5-32 can be seen using Equations 4 and 5.
      <br/>
      The specified isolated bits are in the least significant 4 bits in bit-positions 0 through 3 of each of the block halves R0 and R1.
      <br/>
      Only bits in these positions can affect the data-dependent rotations.
      <br/>
      The xor of the block halves combines the bit-positions 0 through 3 in each of the block halves, to produce a result where its least significant 4 bits in bit-positions 0 through 3 depend only on the specified isolated bits.
      <br/>
      Assume data-dependent rotations of zero bits.
      <br/>
      If so, the new bit-values of the 4 least significant bits of R0 and R1, in the positions of the specified isolated bits, depend only on values of the specified isolated bits.
      <br/>
      Assuming these data-dependent rotations are always zero, even given an infinite number of rounds there is no way that other bits which are not specified isolated bits can influence the specified isolated bits, nor is there any way that the other bits can influence value V, which determines the data-dependent rotations.
    </p>
    <p num="79">
      The existence of a small number of specified isolated bits in a round which cannot be influenced by other bits subject to certain assumptions about variable rotations is a sign that a cipher round or rounds are inadequately secure.
      <br/>
      The question of whether there exists a subset of the n-bit data block of a block cipher which satisfies this cryptographic property of being specified isolated bits is a logical question applicable to a specific round and also to consecutive rounds of each block cipher.
    </p>
    <p num="80">
      In analyzing the RC5 equations using block sizes of 64-bits and 128-bits, there are specified isolated bits where the total number of such bits is similarly low.
      <br/>
      The total numbers of specified isolated bits is only 10 bits out of 64, and 12 bits out of 128 respectively for these block sizes.
    </p>
    <p num="81">Further, when analyzing RC5 by replacing all use of addition or subtraction with xor for analytical simplicity (RC5 after this substitution of operators is roughly as strong analytically), it is clear that other more complicated subkey schedules can result in larger possible sets of specified isolated bits where those sets of specified isolated bits are still a small number of bits, i.e., are a subset of the possible maximum, and often are 50 percent or less of the possible maximum number of variable bits in the cipher data block.</p>
    <p num="82">
      This potential problem in which the data-dependent rotations of RC5 depend after many rounds primarily on a small number of bits of the subkey and on a small number of input bits appears to be related to having inadequate small section data in successive rounds.
      <br/>
      In particular, in RC5 there seems to be a correlation or coincidence of weakness.
      <br/>
      In the instances in which RC5 is weak differentially, it is also weak in diffusing input bits and any changes in input bits.
      <br/>
      Calculating the number of bits of new small section data in successive rounds in fact gives us a crude way of estimating the degree of linear diffusion of input differences in one-to-one round segments when the variable data-dependent rotation is otherwise unable to provide adequate diffusion.
      <br/>
      It appears that this coincidence of weakness reduces the potential diffusive and differential strength of data-dependent rotation significantly.
    </p>
    <p num="83">
      Cipher attacks which limit their analysis of RC5 to plaintext inputs which prevent rotations from occurring in the initial rounds are said to take advantage of weak subkeys.
      <br/>
      All subkeys of ciphers depending on data-dependent rotation have some plaintext inputs for which this is true, though it is easier to use this type of attack when the rotations depend on as few plaintext inputs as possible.
      <br/>
      Similarly, cipher attacks which limit their analysis of RC5 to input values which provide rotations which cancel out some input differences with a high probability are said to take advantage of differentially weak subkeys.
      <br/>
      It may be that all subkeys of ciphers using data-dependent rotations have plaintext inputs for which this is true, though it is easier to use this type of attack when such rotations depend on as few plaintext inputs as possible.
    </p>
    <p num="84">The example above in FIG. 2 in which all subkeys equal 0 illustrates both weak subkeys and differentially weak subkeys given inputs of 0 in the least significant 4 bits of both plaintext inputs.</p>
    <p num="85">
      While most subkeys in RC5 do not provide results as weak as the example above, there are in fact a multitude of potential examples of weak subkeys.
      <br/>
      Increasingly, it seems that the most effective attacks on RC5 take advantage of such weak subkeys.
      <br/>
      It would seem preferred then not to use RC5 without a way of screening out either weak subkeys, or at a minimum differentially weak subkeys.
      <br/>
      However, as a practical matter the generation of subkeys in RC5 is already slow and to additionally screen out or eliminate weak subkey values would be time consuming and complex.
    </p>
    <p num="86">
      The most significant recent cryptanalytic study of RC5 was written by Knudsen and Meier (Lars R. Knudsen and Willi Meier, Improved Differential Attacks on RC5, Advances in Cryptology--Crypto '96, pages 216-228.
      <br/>
      Springer-Verlag, 1996).
      <br/>
      This study fine-tuned a differential attack first discussed by Kaliski and Yin (B.
      <br/>
      Kaliski and Y.L. Yin, On Differential and Linear Analysis of the RC5 Encryption Algorithm, Advances in Cryptology --Crypto '95, pages 171-184.
      <br/>
      Springer-Verlag, 1995).
    </p>
    <p num="87">
      While the study of Kaliski and Yin suggested that sixteen (16) rounds of RC5 might be sufficient for a 128-bit RC5 block cipher to resist differential attack, the attacks by Knudsen and Meier obtain better results by detecting and taking advantage of weak subkeys.
      <br/>
      As a result, they are potentially able to penetrate many more rounds of RC5.
      <br/>
      Due to the increasing progress that is being made in such attacks, the security of RC5 is uncertain.
      <br/>
      It is clear that RC5 has some weaknesses which may make it too insecure for widespread use.
    </p>
    <p num="88">
      In order to block this type of attack it would be necessary to increase the work required to detect and to take advantage of weak subkeys.
      <br/>
      It appears that the reason such weak subkey attacks penetrate many more rounds than the more general attack by Kaliski and Yin is that the data-dependent rotations of RC5 may depend primarily on only some subkey values and some cipher input bits.
    </p>
    <p num="89">
      An unrelated potential weakness of RC5 is that it has a complex and somewhat slow key expansion method.
      <br/>
      This method requires roughly nine operations per subkey, or eighteen operations per round, in order to expand RC5's input key.
      <br/>
      Efficient encryption and decryption of standard 48-byte digital network packets requires quick key expansion.
    </p>
    <p num="90">
      It should be noted it is not accidental that the key expansion method in RC5 is somewhat slow.
      <br/>
      In particular, RC5 uses a complex nonlinear method using key data-dependent rotations to expand its key.
    </p>
    <p num="91">
      The use in RC5 of a complex slow means of generating the key is consistent with the perspective of cipher designers that the key expansion method "should maximize avalanche in the subkeys and avoid linear key schedules" (see `Key Schedule Cryptanalysis of IDEA, G-DES, GOST, SAFER, and Triple-DES`, by John Kelsey, Bruce Schneier, David Wagner, in Advances in Cryptology, Crypto '96, pp. 248-249).
      <br/>
      The RC5 key expansion method is nonlinear and maximizes avalanche and as a result it is considered secure; and use in RC5 or other block ciphers of an alternative linear key expansion would be perceived by cryptographers as weak.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="92">The above-discussed and other drawbacks and deficiencies of the prior art are overcome or alleviated by the improved block cipher method of the present invention, wherein it is an object of the invention to provide cryptographic systems and methods which are secure.</p>
    <p num="93">
      It is another object of the invention to provide a cryptographic system and method which uses data-dependent rotation with a novel iterative calculation which is robust.
      <br/>
      The robust quality of encryption using this method resists attacks by sophisticated algorithms which detect and take advantage of weak subkeys to determine the keys of the cryptographic system.
    </p>
    <p num="94">It is another object to provide a novel mechanism and method for quick key expansion, particularly for encryption rounds with data-dependent rotation, which decreases the time required to prepare a block cipher to encrypt or decrypt digital packets of bytes.</p>
    <p num="95">
      It is still another object of the invention to provide a cryptographic system and method of the above character which uses minimal numbers of s-boxes with a novel iterative calculation where the block cipher does not require an excessive startup time, yet is simple, secure and efficient for bulk encryption.
      <br/>
      The block cipher of the present invention uses no more on-chip cache than necessary, and uses its s-boxes in a secure manner.
    </p>
    <p num="96">It is yet another object to provide a novel mechanism and method for complex key expansion, which uses a minimum amount of time to prepare a block cipher to encrypt or decrypt a large file and which nevertheless ensures that the subkeys generated by the method reflect every bit of the key in a complex uncorrelated manner.</p>
    <p num="97">
      The foregoing objects, and others, are accomplished by the data encryption system for encrypting an n-bit block of input in a plurality of rounds of the present invention, where n is preferably 128 bits or more.
      <br/>
      The data encryption system includes a computing unit for the execution of each round; memory for storing and loading segments; a bit-moving function capable of rotating bits (or of otherwise moving bits into different positions) of one-to-one round segments by predetermined numbers of bits; a linear combination function which provides new round segments using a round operator generally from a first algebraic group to combine two different round segments; and a nonlinear function which affects a round segment based on a value which depends on bits from another round segment, where both round segments are different round segments from the same one-to-one round segment set.
      <br/>
      A round operator is a mathematical operation capable of being carried out in a microprocessor in computing an operative round, such as addition, subtraction, bitwise exclusive-or, or rotation.
    </p>
    <p num="98">
      Both embodiments of the present invention are block ciphers with cipher data blocks preferably of at least 128 bits, which are either Feistel ciphers or near-Feistal ciphers.
      <br/>
      The Feistal ciphers divide the data block up into no more than two block halves of SZ bits, wherein the halves are primary round segments and SZ is a value as small as 64 and as large as 128.
      <br/>
      The near-Feistel block ciphers divide the data block into no more than two large segments, each containing 64 or 128 bits, and a third typically small primary round segment typically not to exceed 20 bits.
      <br/>
      In practice, this means that both embodiments of the current invention use mathematical operations computable on a microprocessor which act on either a 64-bit or a 128-bit segment of cipher data.
    </p>
    <p num="99">
      This use of the Feistel approach with no more than two large data segments is a critical aspect of the invented block cipher as it permits the block cipher to be efficient, secure, and also practical in a range of modern processors.
      <br/>
      Embodiments of this Feistel or near-Feistel approach generally modify each of the primary round segments in each round of calculation in the same way, typically using operations which modify all the bits of the large primary round segments in single linear operations.
      <br/>
      While the present invention is not restricted to use of a Feistel or near-Feistel approach, this approach is generally beneficial to the security of the cipher.
    </p>
    <p num="100">
      On the other hand, certain operations such as 64-bit data-dependent rotations are not yet implemented with maximum efficiency on 32-bit processors such as Pentium MMX chips.
      <br/>
      This means that block ciphers with block sizes in excess of 64-bits and which use data-dependent rotations may end up using from 4 to 8 data segments of 32-bits each.
    </p>
    <p num="101">
      For other block ciphers, especially those using sboxes implemented using MMX instructions, there do not appear to be any special efficiency constraints encountered as a result of using only two large data segments of 64-bits or larger.
      <br/>
      Although it is possible to implement a block cipher of the present invention which uses sboxes and which has more than two large data segments of 64-bits or greater (and may use between 2 and 4 such large data segments), it is strongly preferred to use only two such large primary round segments.
    </p>
    <p num="102">
      Despite the fact that efficiency constraints may compel use of up to 8 primary round segments in a block cipher using data-dependent rotation, it is preferred for reasons of maximizing security and efficiency that no more than 4 primary round segments are used.
      <br/>
      It is also preferable for reasons of maximizing security and efficiency that the block size is at least 128 bits, that such block size be predetermined (rather than of variable or perhaps text-dependent size), and related to these points, it is preferred that the minimum size of the round segments rotated by the a data-dependent variable rotation function is at least 32 bits.
    </p>
    <p num="103">
      While it is not obvious how best to achieve various mathematical properties in a Feistel block cipher or even which properties are most important, designers of secure block ciphers continue to focus on inventing new Feistel block ciphers.
      <br/>
      Good design of Feistel block ciphers is difficult because the structure is so simple that designers cannot randomly insert into a cipher "everything but the kitchen sink" and hope that something encrypts the cipher data in a secure manner.
      <br/>
      The simplicity of Feistel block ciphers permits purest expression of good encryption methods.
      <br/>
      Use of a Feistel block cipher structure by itself does not promote secure encryption, but the structure is synergistic with good encryption methods.
      <br/>
      Good Feistel ciphers are not randomly designed, but have regularly repeating rounds in which identical operations occur in a similar manner.
    </p>
    <p num="104">
      Such Feistel block ciphers have the best record of security and popularity in the field of encryption.
      <br/>
      DES is an aging, but still viable encryption standard which is a Feistel block cipher. "RC5" is a new paradigm using data-dependent rotations in a Feistel block cipher.
      <br/>
      As a further example of a secure new encryption standard, one embodiment of this invention uses relatively non-commutative operators for sbox output combination and for linear diffusion in a Feistel or near-Feistel block cipher.
    </p>
    <p num="105">In one embodiment of the present invention, the nonlinear function is a variable rotation function executable on the computing unit which generally rotates a one-to-one round segment by a value which depends on a preselected number of bits from a preselected location of a different one-to-one round segment from the same one-to-one round segment set.</p>
    <p num="106">In another embodiment of the present invention, the nonlinear function is an s-box and the system generally includes a s-box linear combination function which uses a round operator generally from a second algebraic group executable on the computing unit which combines a one-to-one round segment with the output of an s-box lookup of a value which depends on a preselected number of bits from a preselected location in a different one-to-one round segment from the same one-to-one round segment set, wherein the first algebraic group is preferably non-commutative with the second algebraic group.</p>
    <p num="107">
      Generally, all embodiments of the system of the present invention have a subkey combining function in each round which provides new round segments by combining a round segment typically linearly with a subkey segment, where the number of times the subkey function is used in the rounds of the cipher is roughly equal to the number of times in such rounds the nonlinear function is used, or in any case is at least half of the number of times in such rounds the nonlinear function is used.
      <br/>
      Qualified operative rounds of a binary block cipher refer to such rounds of the block cipher which exhibit some particular, generally good, cryptographic properties.
    </p>
    <p num="108">The key expansion method applicable to data-dependent ciphers of the present invention detailed herein provides a rapid subkey generation method which permits control of the differences between subkeys using fixed table values and given well-chosen fixed table values could help to limit problems related to differentially weak subkeys, and to weak subkeys in general.</p>
    <p num="109">The above-discussed and other features and advantages of the present invention will be appreciated and understood by those skilled in the art from the following detailed description and drawings.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="110">
      Referring now to the drawings wherein like elements are numbered alike in the numerous FIGURES:
      <br/>
      FIG. 1 is an algorithmic flow chart of RC5 encryption in accordance with the prior art;
      <br/>
      FIG. 2 is an example illustrating two rounds of RC5 encryption assuming particular plaintext input and subkey values in accordance with the prior art;
      <br/>
      FIG. 3 is an algorithmic flow chart of an encryption method using data-dependent rotation in accordance with the present invention;
      <br/>
      FIG. 4 is an example which illustrates two rounds of the encryption method of FIG. 3, assuming input and subkey values used in FIG. 2, in accordance with the present invention;
      <br/>
      FIG. 5 is an algorithmic flow chart of a method for subkey generation for block ciphers using data-dependent rotation in accordance with the present invention;
      <br/>
      FIG. 6 is an algorithmic flow chart of an encryption method using data-dependent rotation in accordance with an alternate embodiment of the present invention;
      <br/>
      FIG. 7 is an algorithmic flow chart of an encryption method using an s-box in accordance with another alternate embodiment of the present invention;
      <br/>
      FIG. 8 is an example illustrating two rounds of the encryption method of FIG. 7;
      <br/>
      FIG. 9 is an algorithmic flow chart of an encryption method using an s-box in accordance with still another alternate embodiment of the present invention;
      <br/>
      FIG. 10 is an algorithmic flow chart of a method for complex subkey generation in accordance with the present invention;
      <br/>
      FIG. 11 is an algorithmic flow chart of a method for complex subkey generation to a generative block cipher using s-boxes in accordance with the present invention;
      <br/>
      FIG. 12 is a column listing of examples of ineffective and effective fixed rotation as it applies to data-dependent rotation in accordance with the present invention;
      <br/>
      FIG. 13 is a block diagram of a hardware embodiment of the method of the encryption method using data-dependent rotation in accordance with the algorithmic flow chart of FIG. 6; and
      <br/>
      FIG. 14 is an algorithmic flow chart of an encryption method using an s-box in accordance with another alternate embodiment of the present invention.
    </p>
    <heading>DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="111">
      Referring to FIG. 3, an algorithmic flow chart for one round of the cryptographic system of the present invention is generally shown.
      <br/>
      The present invention is primarily intended to be practiced in a computing unit, such as a microprocessor, and the primary segments stored in memory.
    </p>
    <p num="112">
      A first block 50 contains a n-bit cipher input (e.g., plaintext) at the start of the iterative enciphering process.
      <br/>
      Each input block is divided up into x, in the present example x equals 2, primary round segments 52 (R0) and 54 (R1), where typically each contain nix bits.
      <br/>
      The value of x may vary in each round, but it is generally preferred that x be the same in all operative rounds.
      <br/>
      The value of x can be any integer of at least two, preferably an integer of from 2 to 4.
      <br/>
      Preferably, x equals 2 in all rounds; for the purposes of this example, x will be assumed to be 2.
      <br/>
      For example, a 128-bit version of the cryptographic system divides its input into two 64-bit primary round segments or block halves.
      <br/>
      In the present example, each block half is computed in one 64-bit register.
    </p>
    <p num="113">
      In the present example many linear combination operators are used and they are designated herein as L1,L2,L3,L4, etc.
      <br/>
      Such linear operators are, at a minimum, round operators, i.e., operators computable using mathematical operators capable of being carried out on most microprocessors.
      <br/>
      Linear Operators are drawn from the list of all operators computed as part of the instruction set of a typical microprocessor which have two inputs, and examples of linear operators include addition, subtraction, SIMD addition, SIMD subtraction, and bit-wise exclusive-or, either addition or subtraction executed in parallel (e.g., MMX-style addition of 2 segments of 32-bits each from two 64-bit registers).
      <br/>
      Linear Operators are restricted to those operators computed as part of the instruction set of a typical microprocessor which have the properties that (1) given two inputs with an equal probability of containing 0's and 1's, the output of the operator contains generally an equal probability of 0's and 1's, and (2) given that either input is constant, the output is a one-to-one function of the other input.
      <br/>
      More specifically, they are instructions executable on a computing unit having two input segments typically of unsigned integers and one output segment which is typically an unsigned integer, such as addition, xor, addition or subtraction in parallel (such as MMX-style addition of two 64-bit segments, each consisting of 2 values of 32-bits each).
      <br/>
      A segment is a fixed number of ordered bits, where that number is an integer of at least 2.
    </p>
    <p num="114">
      Linear combination operators, which are called for simplicity linear operators, are restricted to mathematical operations where: (1) given two input segments with an equal probability that each input bit of the segments may be 0 or 1, the output segment has generally an equal probability that each of its output bits may be a 0 or 1, and (2) given that either input is constant, the output is a one-to-one function of the other input which is not constant.
      <br/>
      Of necessity, linear combination operators used in block ciphers are computed almost without exception using modular arithmetic, where the modulus of the calculation usually reflects the number of bits in the segment being computed.
    </p>
    <p num="115">
      In the present invention, any linear operation may be substituted for any other linear operation in any round, and no round must use the same linear operators in the same way as the preceding round.
      <br/>
      Nevertheless, for simplicity and in some cases to optimize the security of the cipher to defend against certain attacks, it is preferred to select linear operators from certain algebraic groups where the same linear operators are used for the same purposes in each round.
    </p>
    <p num="116">Where not otherwise specified, it is generally assumed that whichever round operators are described as typical of a round of a cipher, are meant to apply to all rounds of the cipher, where if a given linear operator is addition, for example, it is meant to be applied in the same way in all rounds of the block cipher.</p>
    <p num="117">
      As has been explained so far, it should be clear what is the meaning of direct linear combination by a linear operator.
      <br/>
      Yet, there may still be some degree of semantic confusion in understanding the difference between direct and indirect linear combination.
    </p>
    <p num="118">
      In the mind of the lay public, there may be a belief that indirect linear combinations of segments might only require use of linear combination operators.
      <br/>
      This interpretation is not very flexible for crytographic purposes as there are some predetermined operations which are essentially linear such as predetermined bit-rotation, or predetermined bit-diffusion which have few if any cryptographic consequences by themselves.
    </p>
    <p num="119">
      In this document, indirect linear combination will encompass both linear combination and predetermined 1:1 operations.
      <br/>
      To be more precise about this approach, it is useful first to define the meaning of a 1-to-1 predetermined linear transformation ("1:1 PLT").
    </p>
    <p num="120">
      A 1:1 predetermined linear transformation ("1:1 PLT") is a predetermined operation from the 1:1 transformation group consisting of +predetermined direct linear combination, predetermined bit-rotation, predetermined bit-permutation, and predetermined 1:1 reversible bit-diffusion} on a particular variable value of cipher data such that its output is mapped 1-to-1 with its input value.
      <br/>
      For example, a fixed rotation of a variable segment by a predetermined number of bits (i.e., by a number of bits that is not data-dependent) is a 1:1 PLT.
      <br/>
      Similarly, a linear combination of a particular variable value with a predetermined key value is a 1:1 PLT.
      <br/>
      Applying a 1:1 PLT to a primary round segment of block cipher does not change the bit-data of the primary round segment in a non-linear manner.
    </p>
    <p num="121">
      To put in perspective the cryptographic significance of both linear combinations and 1:1 PLT's, Claude Shannon, an early cryptographic pioneer, said many years ago that all secure ciphers must have some combination of "confusion" and "diffusion" to be secure.
      <br/>
      Linear combinations and 1:1 PLT's by themselves do not result in any significant increase in crytographic security because such functions lack the non-linear aspect of "confusion".
    </p>
    <p num="122">
      Linear combination of a first and second variable value can mean the direct combination of the values using linear operators.
      <br/>
      Direct examples of such combination usually involve use of certain linear combination operators (such as xor, addition, subtraction, SIMD addition, SIMD subtraction).
    </p>
    <p num="123">
      By contrast, indirect linear combination means a calculation which involves a combination of direct linear combinations and 1:1 PLT's, subject to three conditions.
      <br/>
      It is required that there are at least two variable input segments, where each input segment into the calculation is of equal size (an equal number of bits) and where that segment and all 1:1 PLT's of that segment typically affect the output of the calculation one time only (as an input into a direct linear combination).
      <br/>
      Indirect linear combination is like the root of a tree.
      <br/>
      It typically does not feed into the tree in two different places.
    </p>
    <p num="124">
      This description of the three conditions may sound complicated, but in fact it is quite simple.
      <br/>
      These conditions are the logical equivalent of a direct linear combination of equal-sized variable segments with the proviso that at any preselected point(s) in the calculation, prior to output of the final result, any variable segment may be operated on any number of times by 1:1 PLT's (and each time the segment value replaced by the output of the 1:1 PLT).
    </p>
    <p num="125">
      It should be acknowledged that while in theory indirect linear combination may use any number of 1:1 PLT's, in practice well-designed block ciphers using indirect linear combination of Q variable segments limit the use of 1:1 PLT's per such linear combination to a number no greater than (Q+1).
      <br/>
      For example, even though in an efficient block cipher an indirect linear combination of 2 variable segments could use any number of 1:1 PLT operations to achieve such linear combination, in practice such linear combination will not use more than 3 1:1 PLT operations.
    </p>
    <p num="126">
      An example of indirect linear combination includes (1) operating on a first variable segment with a fixed rotation and (2) on a second segment by adding to it a predetermined subkey value, prior to combining the results of these two predetermined operations using a linear combination operator.
      <br/>
      Another example is a direct linear combination of a first variable segment with a second variable segment where the resulting sum is an input into a predetermined bit-permutation, where the output of the calculation is the output of the bit-permutation.
    </p>
    <p num="127">
      The following is not an example of indirect linear combination.
      <br/>
      A first variable segment is added to a predetermined rotation of a second variable segment and then xored with a bit-permutation of the first variable segment, where the output of the calculation is the final xor result.
      <br/>
      In this case, one input segment affects the output is two different ways.
      <br/>
      Hence, there is a violation of one of the three conditions.
    </p>
    <p num="128">When there is an indirect linear combination of two variable segments previously operated by 1:1 PLT's, the linear operator which is said to combine the two values is that linear combination operator which combines the two results of the 1:1 PLT operations.</p>
    <p num="129">In both the case of direct linear combination and indirect linear combination of two variable segments, the result of the process has the two properties that (1) given two inputs with an equal probability of containing 0's and 1's, the result of the process contains generally an equal probability of 0's and 1's, (2) given that either input is constant, the output is a 1:1 function of the other input.</p>
    <p num="130">If two variable values are said to be linearly combined, such a statement by definition does not require that the values be directly combined as they may be indirectly combined; however, it does make clear that the combination of the two variable values takes place without using any non-linear operations (such as data-dependent sbox use, data-dependent rotates, data-dependent-shifts, or data-dependent multiplication).</p>
    <p num="131">For clarity, however, it shall be assumed in general throughout this discussion that terms such as "linear combination" and being "linearly combined" refer to direct linear combination, unless it is stated or implied that indirect linear combination is also a possibility.</p>
    <p num="132">
      There also may be direct or indirect linear combination of three variable values.
      <br/>
      As before, if this is an indirect example of linear combination, it means that at least one variable segment in the calculation was operated on by a 1:1 PLT.
      <br/>
      Of course, two linear combination operators are generally required to combine three variable values.
      <br/>
      Thus, in indirect linear combination of three variable values, the three variable values would generally be operated on (after any initial 1:1 PLT operations) by two linear operators in order to produce a combined single linear result.
    </p>
    <p num="133">
      Such indirect linear combination of three variables values may occur even though one of the variable values may be a nonlinear function of the other variable values.
      <br/>
      The combination of values can be a linear combination of the three potential input values even though the source of one of the three variable values may in fact be a nonlinear function of another.
    </p>
    <p num="134">
      For example, a linear combination of a substitution box result, with two block halves, is a linear combination of its three input values even though the substitution box result may reflect certain bits in one of the block halves in a non-linear manner.
      <br/>
      In summary, the description of a calculation as a direct or indirect linear combination refers to the details inside the calculation and does not inform us whether the inputs into the calculation are biased, correlated, or are a nonlinear function of other inputs into the calculation.
    </p>
    <p num="135">Similar to the linear combination of two segments, in the case of the linear combination of three variable segments, the result of the process has the two properties that (1) given three inputs with an equal probability of containing 0's and 1's, the result of the process contains generally an equal probability of 0's and 1's, (2) given that any two of the three inputs are constant, the output is a 1:1 function of the variable input.</p>
    <p num="136">
      Prior to beginning the iterative process, the present invention linearly combines (block 56) using operator L1 at the right primary round segment, R1, with a first subkey value, K1.
      <br/>
      Next, the present invention performs the first of many rounds of encryption.
      <br/>
      Each round of encryption computes new values for its primary segments R0 and R1.
      <br/>
      Each computation of the two values is similar in form, even though it has different inputs, outputs, subkeys, and uses different registers.
      <br/>
      Subkeys are an expansion of a cipher key.
      <br/>
      Typically, the expansion transforms a given fixed number of bits to a much greater number of bits.
      <br/>
      Such subkey values are used often in predetermined particular rounds of a block cipher.
      <br/>
      A round segment is a segment which is a segment of bits of n-bit round input, or a segment of bits of n-bit round output, or a segment of bits calculated in a cipher round which is affected by n-bit round input, and which affects n-bit round output, where for example the word affect or affected indicates that when a first segment affects a second segment, a random change in all bits of the first segment will change at least one bit in the second segment with a chance of at least one in three.
    </p>
    <p num="137">
      Both R0 and R1 are primary segments, and are also one-to-one round segments.
      <br/>
      In fact, except for the small sections of bits which determines the data-dependent rotation, all variable segments in each round of this embodiment are one-to-one round segments.
    </p>
    <p num="138">
      To compute the first new primary round segment R0, the following procedure is used.
      <br/>
      The round calculates (block 58) a new value from a rotation of the right round segment R1 by a predetermined number of bits (typically rotation to the right by "f" bits), referred to as fixed rotation.
      <br/>
      It linearly combines (block 60) using operator L2, this intermediate round segment with subkey K2 for this half round to produce a new intermediate round segment.
      <br/>
      It then linearly combines (block 62) using operator L3, the round segment R0 and the new intermediate round segment to provide a replacement value for the primary round segment R0.
    </p>
    <p num="139">
      Next, a given number of bits (typically it is preferred if that number is "f" bits where "f" preferably is a number of bits which is a logarithm base 2 of the size of the round segments) is extracted (block 64) from the least significant bits of the right round segment R1.
      <br/>
      For example, a 128-bit block cipher would use 6 least significant bits (f=6 permits all possible rotations of the one-to-one round segments, as generally 2 f=n/x, and in this case 2 6=128/2).
      <br/>
      It would extract the 6 least significant bits ("lsb") of the right one-to-one round segment, R1, in order to provide one input value, V, used by the variable, i.e., data-dependent rotation.
      <br/>
      A one-to-one round segment set is a set of ordered round segments in an operative round where it is true that each n-bit round input corresponds with only one possible ordered result insofar as the particular values of the ordered segments of that set are concerned, and that any particular ordered result insofar as the particular values of the segments are concerned corresponds with only one n-bit round input.
      <br/>
      Further, a one-to-one round segment is a round segment which is part of a one-to-one round segment set.
      <br/>
      Then, the left primary round segment R0 is rotated (block 66) by V, the value determined by the lsb to provide a replacement value for the primary round segment R0 (block 68) which is also a one-to-one round segment.
    </p>
    <p num="140">
      This process is then repeated to calculate the primary round segment R1.
      <br/>
      To compute the right primary round segment, R1, the following procedure is used.
      <br/>
      The round calculates (block 70) an intermediate round segment from a rotation of the other register R0 by f. It linearly combines (block 72) using the operator L4, this intermediate segment with subkey K3 for this half round to produce a new intermediate round segment.
      <br/>
      It linearly combines (block 74) the right primary round segment, R1, and the new intermediate round segment to produce a replacement value for the primary segment R1.
      <br/>
      A primary segment of an operative round is a segment, the new value of which is calculated to be part of its n-bit round output, and where typically the n-bit round input contains an old or prior value of the same segment, where throughout the round there are one or more new replacement values of the primary segment calculated where each new replacement value is a one-to-one function of its prior value, if all subkey values and all other primary segments are constant.
      <br/>
      Generally, all primary segment values are one-to-one round segments.
      <br/>
      Next, it extracts (block 76) a given number of bits ("f" bits) from the least significant bits of the left one-to-one round segment, R0.
      <br/>
      For example, a 128-bit block cipher would use 6 least significant bits (f=6).
      <br/>
      It would extract the 6 least significant bits ("lsb") of the left primary round segment R0 in order to provide one input, V, used by the variable rotation.
      <br/>
      Then, the right primary round segment, R1, is rotated (block 78) by V, the value determined by the lsb to provide a replacement value for the primary round segment R1 (block 80).
    </p>
    <p num="141">
      Each such round in which replacement round segments for R0 and R1 are computed is only part of the process.
      <br/>
      Many rounds are necessary depending on block size and the users desire for security, but this number of rounds is typically between 8 and 64 rounds, with at least 5 of such rounds incorporating the described process, and such rounds are herein called qualified operative rounds; some users may select a larger number of rounds, such as 128 rounds.
      <br/>
      Indeed, there is no true upper limit to the number of rounds which can be employed, with the tradeoff being that more rounds reduce the speed of calculation.
    </p>
    <p num="142">
      After completion of the last round, the system linearly combines (block 82) using the last linear operator of the rounds the left primary round segment R0, with the last subkey value, Klast.
      <br/>
      The ciphertext value for segments R0 (block 84) and R1 (block 86) are complete, and are then combined to provide ciphertext consisting of n bits, i.e., a n-bit cipher output (block 88).
    </p>
    <p num="143">There are four important and beneficial mathematical properties of this embodiment in calculating in each round the two primary segments R0 and R1 which maintain the security of the block cipher:</p>
    <p num="144">
      (1) Related to the calculation of each new primary one-to-one round segment R0 and R1, there is a nonlinear function, which in this case is data-dependent rotation, which calculates a new one-to-one round segment by modifying a one-to-one round segment from a particular one-to-one segment set based on a value which depends on preselected bits in a preselected location of a different one-to-one round segment from the same one-to-one segment set.
      <br/>
      As the value depends on a number of bits less than thirty-five percent of the size of the one-to-one round segment in the chain, i.e., a small section of the segment, this embodiment of the invention has a property referred to herein as bit expansion of a small section.
      <br/>
      (2) Related to the calculation of each new primary one-to-one round segment R0 and R1, there is a linear combining function, which uses a linear operator typically from a certain algebraic group, which provides a new or modified one-to-one round segment by linearly combining a one-to-one round segment from a particular one-to-one segment set with a different one-to-one round segment from the same one-to-one segment set.
      <br/>
      Hence this embodiment of the invention has a property referred to herein as cumulative linear combination.
      <br/>
      (3) Related to the calculation of each new primary one-to-one round segment R0 and R1, the modifications of and operations performed on the one-to-one round segments which takes place in properties (1) and (2) above, where these modified segments are typically primary round segments, are non-commutative with respect to each other.
      <br/>
      Hence, this embodiment of the invention has a property referred to herein as non-commutative one-to-one round segment interactions.
      <br/>
      (4) Related to the calculation of each primary round segment R0 and R1, there is a subkey combining function, which produces a modified round segment from a round segment.
      <br/>
      As the subkey has generally the same number of bits as the round segment being modified, this embodiment of the invention has a property referred to herein as adjustment by a full-sized subkey.
      <br/>
      Achieving this fourth property appears beneficial and perhaps necessary for block ciphers using data-dependent rotation.
    </p>
    <p num="145">
      As previously discussed, the linear operators in this embodiment of the invention may be any linear operator.
      <br/>
      Further, the linear operators may differ in different rounds, and thus be round dependent.
      <br/>
      It will be appreciated that when the nonlinear operator of the bit expansion of a small section property (1) is data-dependent rotation, use of any linear operator to accomplish the cumulative linear combination property (2) ensures the achievement of the non-commutative one-to-one round segment interactions property (3).
      <br/>
      Consequently, all linear operators should be adequately secure.
    </p>
    <p num="146">
      Certain linear operators may be more secure than others.
      <br/>
      In particular, use of operators from mixed algebraic groups is consistent with cryptographic practice in other block ciphers and seems to provide good security here.
      <br/>
      For example, L2 could be xor, L3 could be addition (in the modulus of the round segment), L4 could be xor, L5 could be addition (in the modulus of the round segment), which one can represent as +L2:xor, L3:+, L4:xor, L5:+} in each round.
    </p>
    <p num="147">
      Ideally, it appears simplest and most self-consistent to use linear operators in such a way that in each round when a given linear function is used for a particular function, the linear operator used is always the same.
      <br/>
      For example, addition might be used as the operator which does all linear combination of one-to-one round segments, and xor is used as the operator which does all linear combination of round segments and subkeys.
      <br/>
      This is the specific approach adopted in the preferred embodiment of the invention.
      <br/>
      However, use of addition for all linear combinations in the round is also believed to be secure.
      <br/>
      Also, while all linear operators could be xor, this option may be less secure.
      <br/>
      For the balance of the present example, the linear operators of this embodiment are assumed to be +L2:xor, L3:+, L4:xor, L5:+}, although this may not be the most secure configuration for each round.
    </p>
    <p num="148">
      It should be noted that in this embodiment, the value of each primary segment is an indirect linear combination of two primary segments.
      <br/>
      The new value of each primary segment is an indirect combination of its value with another primary segment, where that other segment is combined linearly with a subkey prior to the linear combination of round segments.
      <br/>
      The combination with a predetermined subkey is an example of a 1:1 PLT.
      <br/>
      As has been stated elsewhere in this specification, placement of the subkey values is flexible; it could have been placed anywhere in the round where it would affect a round segment.
      <br/>
      Related with this, it does not seem to matter cryptographically whether the linear combination of round segments to produce a new round segment is a direct or indirect combination.
    </p>
    <p num="149">
      More generally, in this embodiment the new round segment value is typically a linear combination of round segments derived from other round segments.
      <br/>
      Such derivation can involve a 1:1 PLT such as combination with a subkey as shown above.
      <br/>
      Or it may be simpler or more complex.
    </p>
    <p num="150">A general statement of the embodiment is to observe that it calculates a new value of a particular primary round segment which is a direct or indirect linear combination of round segments derived from two round segments, one of which is the current value of the particular primary round segment, and the other is most of the bits of some other primary round segment.</p>
    <p num="151">
      Such derivations can be a direct identity transformations of the two input round segments, or they can be more complex.
      <br/>
      If the derivations are not a 1:1 PLT of the input round segments, it is preferred generally that each such derivation be solely from its input round segment, or perhaps that each such derivation be solely a 1:1 function of its input round segment.
    </p>
    <p num="152">
      It is useful to understand several definitions applicable to such derivations discussed herein.
      <br/>
      These definitions apply to particular uses herein of the words derivation, derive, etc.: (1) a derivation of a second value from a first value means that the first value is at least one of the variable and predetermined data sources which may affect the calculation of the second value, (2) a derivation of a second value solely from a first value means that the first value is the only variable data source which affects the calculation of the second value, even though there may be multiple predetermined values such as subkey values which also affect the calculation of the second value, (3) a derivation of a second value as a 1:1 function of a first value means that the first value is the only variable data source which affects the calculation of the second value, and that the second value is a 1:1 function of the first value, (4) a derivation of a second value as a 1:1 PLT of a first value, means that a predetermined number of 1:1 PLTs, which may be equal to zero or any number greater than zero but is generally less than three, transform the first value into the second value.
    </p>
    <p num="153">Note that by definition, derivation of a second value from a first value under definition -4 is a subset of definition -3; similarly, definition -3 is a subset of definition -2; similarly, definition -2 is a subset of definition -1.</p>
    <p num="154">
      Each round of this embodiment may also be expressed as two iterated equations, where each equation determines the value of one primary round segment, and where i is the index of the round and is incremented by x between rounds, e.g., incremented by 2.
      <br/>
      These round equations (Equations 8 and 9) ignore the first and final xors of the subkeys K1 and Klast to the plaintext input and ciphertext output.  (Equation image '6' not included in text)
    </p>
    <p num="155">
      Decryption is the inverse of encryption.
      <br/>
      In the present invention all the same steps are repeated but in reverse order.
      <br/>
      Decryption uses ciphertext output as input and recovers the values of the plaintext inputs.
      <br/>
      Of course, as noted above, what is herein called the decryption operation can be used for encryption, and vice versa.
    </p>
    <p num="156">The decryption equations (Equations 8 and 9) of the present invention are the inverse of the encryption equations:  (Equation image '7' not included in text)</p>
    <p num="157">In order to analyze the impact of the inclusion of the fixed rotation on the strength of the block cipher, it is useful to ask first, does the inclusion of the fixed rotation in the block cipher with data dependent rotations increase the number of specified isolated bits?</p>
    <p num="158">
      Analysis of the present invention demonstrates that (when using a fixed rotation value not equal to zero), even if all addition and subtraction operations are replaced by xor operations for analytical simplicity, there is no set of specified isolated bits as small as it would be for the comparable version of RC5 using the same block size.
      <br/>
      Further, it can be shown that for many fixed rotations no set of specific isolated bits exists which is a subset of fewer than n-bits if the cipher data block contains n-bits.
    </p>
    <p num="159">This result can be true even if the number of bits of fixed rotation is badly chosen (such as being equal to a fixed rotation of only 1 bit).</p>
    <p num="160">
      Despite the good test result which is shown below for fixed rotations as small as 1 bit, it is preferable that the number of bits of fixed rotation, f, is as large as the size of the number of bits which determine the data-dependent rotation, which equals the log base 2 of the bit-size of the round segment (such as 5 bits if there are two primary segments and the size of each such round segment is 32 bits, or 6 bits if the size of each rotated round segment is 64 bits).
      <br/>
      Of course, good results can be obtained as well using a number of bits of fixed rotation either 1 bit more or less than this preferred number.
      <br/>
      Hence, if z is the number of bits which determine the data-dependent rotation, it may be preferred that the number of bits of fixed rotation, rotated either to the left or to the right, is (z-1),z, or (z+1) bits.
    </p>
    <p num="161">
      Of course, the number of bits of fixed rotation can be implemented as either fixed rotation of a round segment of certain bit-size ("BIT-SIZE") to the left or right.
      <br/>
      So when it is stated that the preferred number of bits of fixed rotation equals the log base 2 of the bit-size of the round segment, this also means generally the preferred fixed rotation is by a number of bits A in one direction which equals log(base 2) of BIT-SIZE or by an equivalent number of bits B with rotation in the opposite direction which equals (BIT-SIZE--log(base 2) BIT-SIZE).
      <br/>
      For example, in the present embodiment using a block size of 128 bits and a round segment size of 64 bits, these equivalent preferred values of fixed rotation would be either 6 bits (A=6) or 58 bits (B=58).
    </p>
    <p num="162">
      It is possible to show that using even a weak fixed rotation of 1 bit the number of specified isolated bits includes all bits of the variable data block.
      <br/>
      This is easily proved by contradiction.
      <br/>
      First recall from prior definition of the term that if there is a subset of fewer than n-bits in the n-bits of the data block which contains the specified isolated bits, then there exist potential cipher interactions where such specified isolated bits a) affect the data dependent rotations, and b) the specified isolated bits affect only themselves for all variable rotation amounts.
    </p>
    <p num="163">
      Assume that a particular group of bits, say on a little-endian processor the least significant bits at positions 0 through bit-position 5 in each block half, are specified isolated bits.
      <br/>
      What happens in a round using Equation 8 when such bits are combined with the other block half linearly? If in Equation 8, we look at the specified isolated bits of the input R0, those must be variably rotated by a value of zero bits in order that the specified isolated bits affect no output bits in bit-positions which are not part of the assumed specified isolated bits (in bit positions other than 0 through 5).
    </p>
    <p num="164">
      But if the variable rotation is zero, then the specified isolated bits in the same initial bit-positions (0 through 5) in the input R1, after a fixed bit rotation by 1 bit to the right, occupy bit-positions (4,3,2,1,0,63).
      <br/>
      And, further the output bit of Equation 8 in bit 5, is now being affected by a bit-value of R1 which formerly was in bit-position 6.
      <br/>
      Bit-position 6 is not one of the assumed specified isolated bits, and yet it is affecting the specified bit-positions in bits 0 through bit 5.
      <br/>
      This contradicts the definition of the term specified isolated bits as it demonstrates that the bits are not isolated but are affected by other bits for all possible variable data-dependent rotations.
    </p>
    <p num="165">
      By extending this type of analysis, it is possible to show that there are no specified isolated bits which are a subset of the n-bit data block given most fixed rotation values.
      <br/>
      This is true for a fixed rotation of 1; it is true for a preferred fixed rotation of log base 2 of BIT-SIZE; it is also true for a relatively prime fixed rotation of 25 bits.
    </p>
    <p num="166">
      On the other hand, there are some generally weak fixed rotations such as rotations by half the size of the round segments, where in some variations of this block cipher it is possible to have specific isolated bits which are a subset of the n-bit data block.
      <br/>
      It is possible to produce a similar cipher in which one substitutes for any linear operations of the rounds of the cipher which use addition, subtraction, multiplication, division, similar operations which use no carry operations.
      <br/>
      The resulting alternative cipher is a slightly weaker but cryptographically similar variation which may be tested for the existence of specified isolated bits.
      <br/>
      For example, in this instance if the round segment size is 64 bits each, a fixed rotation of 32 bits would not add much security.
      <br/>
      In such a case, using the embodiment shown in FIG. 3, but with the operation xor replacing use of addition/subtraction there would be specific isolated bits at bit positions (0 through 5, and 32 through 37).
      <br/>
      It is evident that if a variation on a cipher using data-dependent rotation, in which there is a substitution of xor for addition or subtraction, has specific isolated bits which are a subset of the n-bit data block, it is generally best to modify the use of fixed rotation in the cipher because of weakness in the cryptographically similar variation.
    </p>
    <p num="167">
      Incidentally, it should be noted what is achieved by such use of the fixed rotation or predetermined bit-moving operation in this embodiment.
      <br/>
      By guaranteeing that the specified isolated bits of the n-bit data block are as large as the n-bit data block, use of the predetermined bit-moving operations generally ensures that every input bit of the block cipher can affect a rotation within 10 or 20 rounds regardless of what variable data-dependent rotations may occur.
    </p>
    <p num="168">
      In summary, while in the present invention predetermined bit-moving operators may be inserted anywhere into a block cipher, one may test for an indication that the placement of the bit-moving operations is beneficial.
      <br/>
      When the number of specified isolated bits is equal or nearly equal to the bit-size of the variable cipher data block, one has confirmation that the structure or placement of the predetermined operations in the block cipher is appropriate.
    </p>
    <p num="169">
      To summarize the usefulness of testing for specified isolated bits, it is useful to evaluate each iterative round of a block cipher using data-dependent rotations for the number of specified isolated bits.
      <br/>
      The preferred contribution of the fixed rotation in such rounds is to increase the number of specified isolated bits in a given number of rounds.
      <br/>
      In the case of the preferred embodiment shown in FIG. 3, the number of specified isolated bits equals the size of the n-bit variable data block, which is to say there is no small subset of isolated bits in the cipher.
    </p>
    <p num="170">
      In order for the use of fixed rotation or other predetermined bit-moving operations in the block cipher to achieve a certain minimal standard, it is preferred that use of such predetermined operation permits the block cipher to increase its number of specified isolated bits to a minimum number of bits which is greater than 50 percent of the size of the n-bit variable data block.
      <br/>
      It is better still if the number of specified isolated bits is greater than 80 percent of the bit-size of the n-bit variable data block.
      <br/>
      Both of these conditions are achieved in FIG. 3.
    </p>
    <p num="171">
      When examining the embodiment in FIG. 3, it is clear that the fixed rotation has an input which is a round segment, and that the output of the fixed rotation is a round segment.
      <br/>
      Further, some of the bits of the input to the fixed rotation are variable; and at least some of the bits of its output affect n-bit round output.
      <br/>
      Generally, it appears that in order for fixed rotation or other predetermined bit-moving operation(s) in a block cipher using data-dependent rotation in its iterative rounds to increase the number of specified isolated bits or to have other beneficial results for the security of the block cipher, it is necessary: a) for the operation to have a round segment input (where it has some bits affected by n-bit round input), and b) the operation must have output bits where at least some of its output bits affect n-bit round output.
      <br/>
      These three conditions related to input bits, output bits, and result concerning increases in specified isolated bits, help to ensure that the fixed rotation or other predetermined bit-moving operation serves its purpose in improving the security of a block cipher using data dependent rotations in its round function.
    </p>
    <p num="172">
      Further, it should be noted that the fixed rotation by a non-zero number of bits may generally be placed anywhere in the round function without reducing its benefits to security.
      <br/>
      And as noted elsewhere in the specification, fixed rotation is just one type of bit-moving operation.
      <br/>
      Fixed rotations are just one type of predetermined bit-permutation.
      <br/>
      The benefits of fixed rotation by non-zero numbers of bits to the security of block ciphers using data dependent rotation is not restricted to fixed rotations, but rather such security benefits can result from use of all predetermined bit-moving operations in general, including predetermined non-identity bit-permutations.
      <br/>
      And hence the function used need not be a fixed rotation, and may instead be any kind of non-identity predetermined bit-moving operations.
    </p>
    <p num="173">
      The bit-moving operation or function may also be a logical or arithmetic bit-shift operation.
      <br/>
      Predetermined circular bit rotation operations and predetermined bit-shift operators both use predetermined rotation.
      <br/>
      However, unlike circular rotations, logical or arithmetic shift operations drop or discard bits when they are rotated over the start or end of a round segment.
      <br/>
      For example, a predetermined logical shift operation is equal to a combination of a predetermined bit-rotation with a predetermined bitwise AND operation with a constant value also called a bit-mask operation.
      <br/>
      The additional masking or discarding of bits implicit in a fixed bit-shift operation compared with a fixed rotation offers no significant cryptographic advantage to the cipher, and can in fact offer significant disadvantages.
      <br/>
      However, in some processors fixed bit-shifts may be executed faster than fixed bit-rotations, especially if the bits discarded are not needed.
      <br/>
      Hence, it is typically appreciated by programmers skilled in the art that when writing a program which requires some form of fixed bit-rotation the choice of whether to use circular bit-rotation or bit-shifts is based on convenience and sometimes depends on the details of the particular microprocessor on which the program is intended to run.
      <br/>
      The embodiments shown herein which use circular bit-rotation as a means of bit-moving to improve the security of a block cipher which uses data-dependent rotations exist in parallel with alternative generally equivalent versions which use bit-shift operations, where such bit-shift operations may be a perfect or imperfect substitute for such circular fixed rotation.
    </p>
    <p num="174">
      Of course, it is worth keeping in mind that in many cases use of logical (or even arithmetic) shift operations are slower than fixed rotate operations.
      <br/>
      For example, when bits input into the bit-moving function may not be discarded, two logical shifts and one xor operation are required to achieve a perfect substitute for one fixed rotate operation.
    </p>
    <p num="175">
      The above discussion helps to show that from predetermined circular rotations may be derived a class of predetermined non-identity rotation operators which include not only predetermined circular rotations but also logical bit-shift and arithmetic bit-shift.
      <br/>
      Similarly, discussion to follow helps to show that from predetermined non-identity bit-permutations may be derived a class of predetermined bit-moving operators which includes not only non-identity bit-permutations but also modified bit-permutations where, for example, not all input bits affect output bits.
      <br/>
      Incidentally, predetermined circular rotations are a member of both such classes, and also the class of predetermined non-identity rotation operators is a subset of the class of predetermined bit-moving operators.
    </p>
    <p num="176">These two classes of operators may be expressed mathematically in various ways, and can often provide inputs and outputs equivalent to operators discussed herein without being calculated in an identical manner.</p>
    <p num="177">
      Herein the word bit-moving is used generally to describe operations executed in software or hardware which move bits, by which it is meant that a given input bit in a given position is "moved", e.g., that input bit solely determines the value an output bit in a different position.
      <br/>
      A variable rotation is also a type of a bit-moving operation (particularly when the number of bits of the variable rotation is non-zero).
      <br/>
      Variable rotations can be classified as variable bit-moving operations.
    </p>
    <p num="178">
      It is important for this discussion of the present invention concerning block ciphers which use data-dependent rotations to define a predetermined or "fixed" bit-moving operator and operation.
      <br/>
      It can be defined as a predetermined operator which moves at least 1 input bit in a given bit-position in a predetermined manner to a different bit-position in its output executable in software or in hardware which: a) typically includes or comprises some type of a predetermined non-identity bit-permutation as a way to move one or more bits, and b) may optionally include use of the operators predetermined bit-concatenation, predetermined bit-discarding, and partial masking using bitwise AND and bitwise OR.
    </p>
    <p num="179">
      A predetermined non-identity bit-permutation, by definition, is a bit-permutation which has at least one input bit in a given bit-position which determines the value of an output bit in a different bit-position.
      <br/>
      Predetermined non-identity bit-permutations do not operate on or combine their bits and only permute the order of their bits, and they are predetermined 1:1 transformations where each input bit solely determines one output bit, and when calculated or traced backwards, each output bit solely determines one input bit.
    </p>
    <p num="180">
      It should be noted that this definition does not in all cases require that a predetermined bit-moving operation must use a predetermined non-identity permutation as part of its calculation, as alternative ways of expressing the calculation may exist which do not require use of a predetermined non-identity permutation.
      <br/>
      In such cases, there will exist a mathematically or cryptographically equivalent expression which does use a predetermined non-identity bit-permutation functionally as a means to move one or more bits.
    </p>
    <p num="181">
      Note also that it is preferred that a predetermined bit-moving operation move more than 1 bit into a new bit-position; moving only 1 bit would be either inefficient or insecure.
      <br/>
      It is preferred that it move a minimum of fbits into new positions, where f is the log base 2 of the bit-size of the round segment being variably rotated.
      <br/>
      Even better, it is preferred that it move a number of bits into new positions which equals the bit-size of a round segment being variably rotated.
    </p>
    <p num="182">
      It is within the scope of the present invention in which predetermined bit-moving operators or predetermined non-identity rotation operators are used to improve the security of bit-diffusion such that all bits in the data block can affect a variable data-dependent rotation, to make use of only a small number of bits of the output of the predetermined bit-moving operator.
      <br/>
      For example, assume that there is a derivative round segment in which certain most significant bits can reflect the values of all bits of a primary round segment.
      <br/>
      If so, given reasonable implementation by one skilled in the art, use of fixed rotation to move these most significant bits into the least significant bits where they affect or control variable data-dependent rotation should increase the number of specified isolated bits to equal the bit-size of the variable data block.
      <br/>
      Consequently, in this case the bit-moving operator is used in a manner to improve the security of bit-diffusion such that all bits in the data block can affect a variable data-dependent rotation consistent with the present invention.
    </p>
    <p num="183">
      A predetermined bit-permutation has an equal number of input bits and output bits.
      <br/>
      But a predetermined bit-moving operator might be a predetermined bit-permutation with a variable input where that variable input is concatenated with an invariant empty field filled with zeros using a bit-concatenation operator, such that the output includes those zeros and is larger than the variable input.
      <br/>
      On the other hand, some of the output bits from a bit-permutation might be discarded using a bit-discarding operator, and thus the output of a predetermined bit-moving operation might be smaller than its input.
      <br/>
      Further, it is possible to combine the input or output of non-identity bit-permutations with bit-wise AND and bit-wise OR operations such that some but not all bits are "masked out" and their values are replaced by constant values such as 0 or 1.
    </p>
    <p num="184">Examples of predetermined bit-moving operations include the rotation operators, which include predetermined circular bit-rotation by non-zero numbers of bits and predetermined bit-shifting by non-zero numbers of bits (either logical or arithmetic bit-shift, although generally logical bit-shift is preferred to arithmetic bit-shift), predetermined non-identity bit-permutation operators such as predetermined non-identity byte-permutations, byte-order reversal operations.</p>
    <p num="185">Examples of operations which are not predetermined bit-moving operations include variable bit-rotation, variable bit-shift, addition, subtraction, multiplication, bitwise-AND, bitwise-OR, xor.</p>
    <p num="186">
      Note also that predetermined bit-moving operations all have inverses and may be xored with their "bit-moving inverses" to cancel out the effect of any bit-movement, and provide an identity transformation of their inputs as a result.
      <br/>
      Hence, while it is possible to place a bit-moving operator in different places a block cipher, even appropriate placement of such an operator in a block cipher may be canceled out by other inappropriate placement.
      <br/>
      Hence, after the design process is complete, the block cipher must be examined in its totality using some test such as testing for specified isolated bits.
    </p>
    <p num="187">
      As suggested previously, use of fixed, i.e., predetermined, circular bit-rotation (or its mathematical or cryptographic equivalent using other operators such as bit-shift operators) is generally preferred to use of other predetermined non-identity rotation operators.
      <br/>
      And use of predetermined non-identity rotation operators (or its mathematical or cryptographic equivalent using other operators) is generally preferred to use of predetermined bit-moving operators.
    </p>
    <p num="188">
      Regardless of which bit-moving operators or operations are ultimately adopted for a block cipher, it is believed that use of predetermined bit-moving operations is critical.
      <br/>
      It is believed that there will be few if any secure and efficient variations of block ciphers, which in iterative rounds use data-dependent rotation, which do not also use fixed or predetermined bit-moving operations in some form in those iterative rounds to ensure secure bit-diffusion in which all bits in the data block can affect a variable data-dependent rotation.
      <br/>
      Such predetermine bit-moving operators or related mathematically equivalent operators are derived from use either of fixed circular bit-rotation or of predetermined non-identity bit-permutation.
    </p>
    <p num="189">
      Concerning use in the present invention of fixed rotation in block ciphers with data-dependent rotation of two to four primary round segments, there are two beneficial traits called effective and active fixed rotation (which are not yet defined).
      <br/>
      It is preferred that the fixed rotation is effective fixed rotation; it is also preferred that the fixed rotation is active and has output bits where most of the output bits affect n-bit round output.
    </p>
    <p num="190">
      In the present invention, for one skilled in the art there are innumerable ways of implementing the use of fixed rotation or other bit-moving operations to ensure adequate bit-diffusion and an adequate number of specified isolated bits.
      <br/>
      One test for correct use of predetermined bit-moving operations is whether the use of fixed rotation or other predetermined bit-moving operator increases the number of specified isolated bits from what it would be without fixed rotations or other predetermined bit-moving operations.
      <br/>
      As a result of such verification, we can say that use of fixed rotation or of other predetermined bit-moving operators is mathematically necessary for without it, the cipher is either insecure or inefficient.
      <br/>
      The fixed rotation directly or indirectly affects the size of the set of bits which control the data-dependent rotations.
      <br/>
      By increasing the number of specified isolated bits, which is the minimum size of the set of bits which controls the data-dependent rotation, the fixed rotation helps to provide adequate linear diffusion.
    </p>
    <p num="191">
      The embodiments shown herein of this invention all demonstrate effective and active fixed rotation.
      <br/>
      This preference does not mean that fixed rotation to be secure must be active for all embodiments.
      <br/>
      The preference for fixed or predetermined rotation does not mean that predetermined logical or arithmetic shift operations or other predetermined bit-permutations cannot accomplish an equivalent effect.
      <br/>
      Finally, it appears that the preference for use of effective fixed rotation does not mean that all such bit-moving operations must be effective.
    </p>
    <p num="192">
      It is true that historically fixed rotation has been used in various block ciphers for various reasons.
      <br/>
      In Khufu, fixed rotation was used to ensure that all output bits eventually effect an sbox input, and hence controls a nonlinear activity.
      <br/>
      This reason is similar to the use of fixed rotation in the present invention.
      <br/>
      The structure of Khufu which uses larger sboxes with more output bits than input bits, and uses fixed rotation as a novel means of ensuring all sbox output bits eventually become an sbox input was a novel and ingenious design which took advantage of the strengths of the microprocessor for efficient, secure encryption.
    </p>
    <p num="193">
      In DES, use of fixed rotation is more complicated.
      <br/>
      Fixed rotation is not technically part of the DES specification or structure.
      <br/>
      Actually, DES was designed for hardware, and uses bit-permutation.
      <br/>
      Its bit-permutation is a way of ensuring in general that at least one bit from each different sbox is assigned to each sbox input in the next round.
      <br/>
      When implemented in software, fixed rotation or equivalent logical shifts combined with mask operations can achieve the same effect as bit-permutations.
      <br/>
      This use of bit-permutation is sophisticated and reflects the insights of IBM and the NSA in the 1970's.
    </p>
    <p num="194">When Ron Rivest published RC5, it seemed clear that this was a simple block cipher that did not require use of either sboxes or of any form of predetermined bit-moving operations such as fixed bit-permutations, fixed rotations or fixed shift operations.</p>
    <p num="195">
      This is because the apparently random nature of the data-dependent rotation combined with some form of cumulative linear mixing of the other round segments appeared to ensure that all bits affected all bits in a small number of rounds.
      <br/>
      Due to such apparently random mixing of bits, it would seem pointless and foolish to add fixed rotations or logical shifts or other predetermined bit-moving operators to this type of block cipher.
      <br/>
      It was not at all obvious to the designers of RC5 or to the public when RC5 was presented that use of the fixed rotation would cause any significant change to the security of the algorithm, good or bad.
    </p>
    <p num="196">In the article published by Ron Rivest describing RC5 (Fast Software Encryption, Lecture Notes in Computer Science, December 1994, Belgium, Springer), there is no mention of use of fixed rotations, and the article said that in only eight rounds of RC5 every message input bit would affect one rotation.</p>
    <p num="197">
      By contrast, in the present invention a new and better variation of block ciphers using data-dependent rotation in their iterative rounds is presented.
      <br/>
      It is asserted that by introducing into such block ciphers the use of fixed rotation (or the equivalent use of logical bit-shift) it is possible to fix a weakness of such block ciphers.
      <br/>
      It is also stated that the weakness which is fixed is the existence of certain inputs where the input bits do not affect a rotation after many rounds.
      <br/>
      It is asserted that such combination of data-dependent rotation with fixed rotation permits all plaintext or ciphertext data to affect a rotation in a smaller number of rounds.
    </p>
    <p num="198">The following discussion helps to review the number of good bits of this embodiment which refers to the linear diffusion of fresh data into the data-dependent rotation operator and understanding good bits is a way of appreciating one potential benefit of fixed rotation, and this discussion defines the meaning of active and effective rotation, which are preferred ways of implementing block ciphers with data-dependent rotation.</p>
    <p num="199">
      To understand an aspect of FIG. 3, analysis of the inverse equations (Equations 10 and 11) permits one to appreciate the bit-diffusion of data through the embodiment.
      <br/>
      It is possible to trace the n-bit round input of two consecutive rounds to show that there appear to be 2f (i.e., x times f) input bits which affect the nonlinear activity of a second round of the embodiment which do not affect the nonlinear activity of the first round.
      <br/>
      Of course, such bits are called good bits and they control the number of bits of data-dependent rotation in the given round.
      <br/>
      This number of good bits (2f) is more than half of the 2f-bits which affect the variable rotations of each round.
      <br/>
      Consequently, the system of the present invention has the property called new small section data in successive rounds.
    </p>
    <p num="200">
      One feature of this embodiment which permits a number of good bits greater than zero (i.e., greater than the number of good bits of RC5) is its use of active and effective fixed rotation in its iterative rounds.
      <br/>
      It is important to understand that use of the term active fixed rotation does not mean fixed rotation passively as means of accessing a small number of bits.
      <br/>
      Active fixed rotation is fixed rotation where if the output of a fixed rotation round operator produces z bits, most bits of the output and preferably at least (z-2) bits affect the n-bit round output of that round.
    </p>
    <p num="201">
      Effective fixed rotation has a different meaning.
      <br/>
      It refers to use of fixed rotation in an effective manner.
      <br/>
      Effective use of fixed rotation in the iterative rounds of a block cipher using data-dependent rotation is use which is not commutative with use of data dependent rotation.
      <br/>
      In other words, it is ineffective use of fixed rotation if it occurs on top of or in sequence with rotation of a similar one-to-one round segment using data-dependent rotation.
    </p>
    <p num="202">Of course, use of fixed rotation may be round or segment dependent as long as the number of bits of rotation is predetermined prior to operating on the variable data in the block cipher.</p>
    <p num="203">
      Referring to FIG. 12, column A shows a simple example illustrating ineffective fixed rotation.
      <br/>
      It will be noted that column A is an example of an unproductive one-to-one segment rotation chain.
      <br/>
      An unproductive one-to-one segment rotation chain is a chain of at least three round segments wherein the following properties are true without regard to whether the block cipher (encryption) or its inverse (decryption) is calculated: (1) each round segment except for the last segment in the chain affects the next round segment in the chain and no other round segments, (2) each round segment except for the first one is determined by a round operator whose input sources are selected from the group consisting of the previous round segment in the chain, subkey values, any data-dependent values which determine the rotation of the data-dependent operators in the chain, and (3) the chain includes the input round segments and output round segments of particular instances of each of two functions, a fixed rotation function and a data-dependent rotation function.
      <br/>
      An unproductive one-to-one segment rotation chain is defined herein as a chain of at least three round segments 200, 202, 204 wherein the following properties are true without regard to whether the block cipher is computed normally (often called encryption) or in its inverse mode (often called decryption): (1) each round segment of the chain except for the last segment of the chain affects the next round segment of the chain and affects no other round segments, (2) each round segment of the chain except for the first round segment of the chain is determined by a round operator whose inputs are selected from a group consisting of and limited to the previous round segment in the chain, subkey values, and any values which determine the degree of data-dependent rotation, and (3) the chain includes both the input round segments and the output round segments of particular instances of each of two functions, a fixed rotation function and a data-dependent rotation function.
      <br/>
      Any fixed rotation where its output segment (or its input segment) is a round segment in an unproductive one-to-one segment rotation chain is ineffective fixed rotation.
    </p>
    <p num="204">
      Of course, by definition and for clarity, a few observations are in order.
      <br/>
      First, predetermined rotations by non-zero numbers of bits are ineffective fixed rotation if they are part of an unproductive one-to-one segment rotation chain.
      <br/>
      Further, if non-identity bit-permutations or logical bit-shifts are used in a manner equivalent with bit-rotations, they may classified as ineffective if they are part of an unproductive one-to-one segment rotation chain.
      <br/>
      All other uses of predetermined bit-rotations by non-zero numbers of bits, non-identity bit-permutations, and bit-shifts are classified as effective bit-rotation (even if the predetermined bit-moving operation is not, strictly speaking, bit-rotation).
    </p>
    <p num="205">
      Turning to column B in FIG. 12, there is an external input into a chain of segments 206, 208, 210, 212, while the input is from a subkey value.
      <br/>
      Hence, column B is also an unproductive one-to-one segment rotation chain and any fixed rotation with an output round segment in this chain is ineffective fixed rotation.
    </p>
    <p num="206">
      Turning to column C in FIG. 12, the input into the middle of the chain of segments 214, 216, 218, 220 is a round segment not from within the chain.
      <br/>
      Therefore, the chain is not an unproductive one-to-one segment rotation chain and the fixed rotation in the chain is effective.
    </p>
    <p num="207">
      Turning to column D in FIG. 12, there is an output in the middle of the chain of segments 222, 224, 226, 228 which affects some other round segment other than the next link in the chain.
      <br/>
      Therefore, the chain is not an unproductive one-to-one segment rotation chain and the fixed rotation in the chain is effective.
    </p>
    <p num="208">
      The use of fixed rotation in a block cipher where such fixed rotation is used in an active and effective manner is the fifth desired property of the present invention, and it is associated with generally measurable benefits such as an increase in the number of good bits.
      <br/>
      As used herein, the term fixed rotation is interpreted broadly to include round and segment dependent fixed rotation, where the number of bits of fixed rotation varies according to the round or the segment of the round or both.
    </p>
    <p num="209">
      The following proposition illustrates that the use of active and effective fixed rotation can increase the strength of block ciphers using data-dependent rotation.
      <br/>
      In general, the ability of a cryptanalyst to detect and then to take advantage of weak subkeys in data-dependent block ciphers requires weak data-dependence and weak bit-diffusion.
      <br/>
      By ensuring that a new small section of data is inputted into the variable rotation in succeeding rounds, the cryptographic system and method increase data-dependence and bit-diffusion; the method increases the randomness of the ciphertext output; and thus weak key values become more difficult to detect and harder to take advantage of.
      <br/>
      Regardless of the source of the prior art's shortcomings, the present system and method provides more secure encryption.
    </p>
    <p num="210">
      Another indirect or tentative way to confirm the increase in strength associated with the present invention is to compare different indicators in two different scenarios.
      <br/>
      In the first scenario, the number of bits of fixed rotation equals zero.
      <br/>
      In this case, the number of good bits equals zero, and in general not all input bits affect a rotation given any number of rounds for some subkeys.
      <br/>
      In the second scenario, the number of bits of fixed rotation equals f. In this second case, the number of good bits is 2f, and, not taking into account any possible self-cancellation of input bits, all plaintext input bits affect a rotation regardless of the values of the subkeys after roughly n/xf rounds.
      <br/>
      Unfortunately, while it is useful to calculate the number of rounds which ensures that each input generally affects a rotation, the calculation can be very time-consuming except when it is determined in scaled-down models using block ciphers where the block size is 16 bits or less.
      <br/>
      Hence, while the discussion herein has focused on the benefits associated with increasing the number of good bits which is possible to calculate, the benefits of the present invention are not so limited.
    </p>
    <p num="211">
      It should be noted, as has been stated elsewhere in this document, that use of fixed rotation to benefit the strength of a block cipher using data-dependent rotation is a special case.
      <br/>
      The most general case involves use not merely of fixed rotation (i.e. predetermined rotations by non-zero numbers of bits), but rather involves the use of bit-permutations other than the identity permutation.
      <br/>
      Fixed rotations by non-zero numbers of bits are a subset of the possible bit-permutations, and unlike most bit-permutations, have the advantage of generally being executed in one clock cycle on a microprocessor.
      <br/>
      When executed in hardware, any type of bit-permutation may be used with no penalty in speed.
      <br/>
      One should understand the use of fixed rotations to improve the security of data-dependent rotation is not limited merely to fixed rotations.
      <br/>
      In fact, it is possible to achieve the security gains associated with fixed rotations by carefully selecting appropriate bit-permutations.
      <br/>
      However, many bit-permutations are not as secure as properly implemented fixed bit-rotation, in which the fixed numbers of bits of rotation, "f", is set equal to the number of bits which in that round control the data-dependent rotation of a data-dependent rotation operator.
    </p>
    <p num="212">
      Referring to FIG. 4 (wherein the blocks are numbered as in FIG. 3, with the numbers in the second round being designated with a prime), a simple example is shown in which a given input passes through two rounds and is modified by it despite simple subkeys in which all values equal 0.
      <br/>
      It will be appreciated that the bits which determine rotations in this example are not based solely on the initial 1sb of the plaintext input segments.
      <br/>
      This example reflects a cryptographic system in which the variable rotations depend on many different subkey and input values.
    </p>
    <p num="213">
      It appears that the security and efficiency of the cryptographic system and method of this invention may depend primarily on achieving the five properties discussed above.
      <br/>
      There are many variations on this general method which are secure.
      <br/>
      The variations appear to be secure in general so long as the changes made do not nullify the above described preferred properties.
    </p>
    <p num="214">
      It will be appreciated that the system as heretofore described utilizes active fixed rotation and other functions to affect the one-to-one primary segment variables of each R0 and R1 in each operative round.
      <br/>
      It will further be appreciated, however, that it is not always required for a secure block cipher that each primary round segment R0 and R1 be affected by each of those functions at some point in each operative round.
    </p>
    <p num="215">
      Apart from this general observation, variations in the present invention include using values of x other than 2 in certain or in all rounds (i.e., more than 2 primary segments), and using linear combination operators other than those shown above in the preferred embodiment.
      <br/>
      There are many other variations which also result in secure binary block ciphers including but not limited to: (1) the source of bits affecting non-linear activity, (2) changes in the number of bits of fixed rotation, (3) reversing the direction of the data-dependent rotation, (4) a different order of computing primary round segments (5) new or different key expansion methods, (6) different key placement in the equations, (7) alternative placement of the fixed rotation, (8) achieving nonlinear bit expansion with an s-box instead of data-dependent rotation, (9) other key expansion methods associated with more complex subkey generation.
    </p>
    <p num="216">
      First, although the embodiment of FIG. 3 is shown having certain bits extracted from the least significant bits of one-to-one round segments for purposes of obtaining f bits to affect a variable rotation, extraction of bits from the least significant bits may not always be preferred.
      <br/>
      Currently, it is much quicker to extract a given number of bits from the least significant bits of a register than from anywhere else on the register.
      <br/>
      Such an extraction of bits from the least significant bits generally requires nothing more than one mask operation (in those processors requiring mask operations prior to a rotate instruction).
      <br/>
      By contrast to extract bits from anywhere else in a register generally requires a fixed rotation and in some instances a mask operation.
      <br/>
      However, the present invention may not be so limited as microprocessor technology advances.
      <br/>
      Intel MMX operations may permit extraction of bits from preselected locations in certain registers other than the 1sb as efficiently as extraction of bits from the 1sb.
      <br/>
      Consequently, in the present invention it is preferred to extract bits which have nonlinear effects from the 1sb or from other bit locations from which bits may be extracted efficiently.
    </p>
    <p num="217">
      Second, although the embodiment of FIG. 3 is shown with fixed rotation to the right by f bits (where f is generally equal to 6 bits given a 128-bit block cipher), it will be appreciated that the rotation can also function by rotating to the left.
      <br/>
      In the present system, the fixed rotation is typically based in the number of bits, f, required to select a new position for a data-dependent segment (e.g., 6 bits permits 2 6 possible rotations, which is the segment size for a 128-bit block with 2 block half primary segments of 64-bits each).
      <br/>
      For such a block cipher, a fixed rotation rightward or leftward by a number of bits less than f (e.g., rotation rightward by less than 6 or by more than 58, for a 128-bit block with 2 primary segments) is generally less secure than rotation by 6.
      <br/>
      It will be noted that fixed rotation by an intermediate value greater than 6 or less than 58 appears in some cases to be less secure than fixed rotation by 6, although it may in some cases be as secure or perhaps even more secure than fixed rotation by 6.
      <br/>
      For example, for such a block cipher, fixed rotation by 32 bits would generally be less secure than fixed rotation by 6 bits.
      <br/>
      More generally, as mentioned previously, such number of bits of such predetermined or fixed rotation may vary according to each round and to the particular segment being calculated in each round.
    </p>
    <p num="218">
      Third, the direction of data-dependent rotation in the preferred embodiment is to the right by a number of bits determined by the data-dependent value.
      <br/>
      However, it will be appreciated that such data-dependent value can also determine data-dependent rotation to the left.
      <br/>
      Neither leftward or rightward data-dependent rotation is believed to be more secure than the other.
    </p>
    <p num="219">
      Fourth, in embodiment of FIG. 3, a system is shown in which in the first half of each round the round operators modify the left primary round segment R0, and then in the second half of each round the round operators modify the right primary round segment R1.
      <br/>
      Clearly, the order of computing new primary round segments could be reversed with no adverse consequences.
      <br/>
      The first half round might modify the right primary round segment R1, and the second half round might modify the left primary round segment R0.
      <br/>
      There is no requirement in general in any round as to what is the preferred order of modification of primary round segments.
      <br/>
      On the other hand, generally the present invention is most effective if in a given round at any point the primary round segment being modified currently is different than the primary round segment which was last modified (i.e., it is preferred not to modify the same primary round segment twice in the same way without first modifying the other primary round segment in that way at least once).
    </p>
    <p num="220">
      Fifth, a good block cipher using data-dependent rotation is attainable with a quick start-up.
      <br/>
      As data-dependent block ciphers have no s-boxes, they offer potentially a much faster bootup or startup than other block ciphers.
      <br/>
      Any slow or complex key expansion process will increase the start-up time.
      <br/>
      A problem with the prior art RC5 encryption method, as previously noted, is that its key expansion process is slow.
    </p>
    <p num="221">
      Further, there is an opportunity for a new fast key expansion when using data-dependent rotation in the rounds.
      <br/>
      Related key attacks generally involve a cryptanalyst selecting various plaintext inputs to a block cipher as well as selecting certain differences in key inputs.
      <br/>
      While these attacks are highly theoretical, they can indicate an underlying weakness in a block cipher.
      <br/>
      Certain block ciphers using data-dependent rotation as part of the block cipher are more resistant to related key attacks when using certain subkey generation methods.
    </p>
    <p num="222">
      In particular, the prevailing view in the field that it is necessary to use a key expansion method which maximizes avalanche in the subkeys and avoids linear key schedules is entirely wrong concerning key expansion for block ciphers with either round-dependent rotation in the block cipher or data-dependent rotation of round segments.
      <br/>
      In such block ciphers simple quick linear key expansion with no avalanche is perfectly secure.
      <br/>
      This is a novel and surprising innovation in this field.
    </p>
    <p num="223">
      Hence, there is an opportunity to adopt a new method of key expansion which is fast and simple and secure, where this method has these advantages for two categories of block ciphers.
      <br/>
      In general, this method can benefit block ciphers using fixed rotation where such fixed rotation is round-dependent.
      <br/>
      This method also and in particular benefits block ciphers using data-dependent rotation, especially where such data-dependent rotation uses active effective fixed rotation.
    </p>
    <p num="224">
      Referring to FIG. 5, an algorithmic flow chart is shown which demonstrates this novel simple and secure linear method which calculates the subkeys for each round of the block cipher using data-dependent rotation in its operative rounds shown in FIG. 3 or FIG. 6.
      <br/>
      Since this subkey generation method is well suited for block cipher using data-dependent rotation (as in FIGS. 3 and 6), it is for the same reasons well suited for subkey generation in RC5 (as it is also a block cipher using data-dependent rotation).
    </p>
    <p num="225">
      A fixed key size of k bits (block 90) which may be a function of an input key is defined.
      <br/>
      An input key is ordered bits determined by a user or system, which are typically secret, i.e. non-public, which are input to a cipher and are in general to influence the behavior of the cipher.
      <br/>
      An input key may be of variable length, and sometimes it is necessary to compress, or condense or even to expand an input key prior to use by a cipher.
      <br/>
      Such compression of a large input key into a cipher key used by the cipher can be particularly helpful when the input key bits may not be entirely random and may be auto-correlated.
      <br/>
      A cipher key is ordered bits, often called key bits, which are a transformed input key, using any particular transformation which may be specified by a cipher.
      <br/>
      The key is usually of fixed length or a fixed number of bits, but may be of variable length.
      <br/>
      But in any case, this key expansion method starts with key bits, and does not restrict any operations which may convert key input bits to key bits.
      <br/>
      It divides the key bits up into y registers, where y most often equals two, and assigns k/y bits into each of the key segments, e.g., KA (block 92) and KB (block 94).
      <br/>
      Using this linear key expansion method, there are successive rounds in which each of the subkeys is the sum of one of the key segments and of a round and segment dependent predetermined value typically from a fixed table ("fixed table"), shown as blocks 96 and 98.
    </p>
    <p num="226">
      It will be noted that as there are in this example two key segments and two primary round segments in the block cipher, when the subkeys are used in the block cipher, those subkeys reflecting the value of KA have a direct effect on the right primary round segment R1 calculated in various rounds, and subkeys reflecting the value of KB have a direct effect on the left primary round segment R0 calculated in various rounds.
      <br/>
      Due to linear mixing of cipher data in the block cipher (the property of cumulative linear combination), both key segments KA and KB also have indirect effects on the primary round segments of R0 and R1.
    </p>
    <p num="227">
      If there are y key segments, sorting the fixed table or predetermined values into y sets of values permits each set to contain only those fixed table or predetermined values which are combined with a given key segment.
      <br/>
      For example, if y=2, sort the fixed table values into two distinct sets, one of which is those fixed table values which are combined with key segment KA to produce subkey values, and the other which is those fixed table values which are combined with key segment KB to produce subkey values.
      <br/>
      In general, it is preferred to require a few minimal guidelines to ensure the security of this method.
      <br/>
      The y sets of values of the fixed table should be checked to assure that the fixed table values in each set are not all the same.
    </p>
    <p num="228">
      Varying the fixed table values ensures that, when using the approach shown in FIG. 5, there is an adequate number of distinct or different values in the resulting subkey values.
      <br/>
      By contrast, if for example all subkey values were equal to, in hexadecimal, 0123456789abcdef, potentially every round of the block cipher might act the same given identical round inputs.
      <br/>
      This would indicate a weak subkey schedule.
      <br/>
      In this example with inadequate variation, there is only one distinct subkey value of 64-bits, and all subkeys are equal to that value.
      <br/>
      Accordingly, it may be preferred to design the key expansion system in such a manner and with a list of predetermined values which contain many distinct values or which are otherwise selected such that for randomly provided keys (and for randomly provided key inputs) there is a 99 percent chance or better that a minimal standard is achieved in which the key expansion system produces a list of at least 10 subkeys in total which are used in the operative rounds of the block cipher, where such resulting subkeys are not all the same value, and if fact there are at least 5 distinct, i.e. different, subkey values in that list of subkeys (where such subkey values are as small as 16 bits and as large as 64 bits).
      <br/>
      The key expansion system shown in FIG. 5 achieves this minimal standard 100 percent of the time given at least 5 distinct predetermined values in the fixed table; virtually all other secure key expansion methods used by other block ciphers also achieve this minimal standard; other ways of achieving this minimal standard may be apparent to one of ordinary skill in the art.
    </p>
    <p num="229">
      If the number of primary segments which provide n-bit round output, where there are x such primary round segments, and the number of key segments, where there are y key segments, are the same (e.g., there are 2 of each), then it is useful to compute the difference of each fixed table value in each set from the prior fixed table value in the same set.
      <br/>
      These differences between specific set members form new sets of fixed table difference values.
    </p>
    <p num="230">
      If there is one linear operator which combined the key segments and fixed table values to produce subkeys and if that operator is addition, then any differences computed from a set of fixed table values should ideally be based on subtracting each fixed table value from its prior value.
      <br/>
      By contrast, if there is one linear operator which combined the key segments and fixed table values to produce subkeys and if that operator is xor, then ideally any differences computed from a set of fixed table values should be based on xoring each fixed table value and its prior value.
      <br/>
      If no such prior value exists, the difference value should be excluded from the appropriate set of difference values.
    </p>
    <p num="231">
      By way of example, if x=y, when each set of difference values is evaluated individually not all the values of that set should have identical values.
      <br/>
      This avoids concerns when simple relationships between successive values where a given input key +KA,KB} may produce identical subkeys as another key +KA',KB'} where the identical subkeys produced by the two keys are in different rounds.
      <br/>
      For example, the subkeys in round i produced by +KA,KB} may be identical to the subkeys in round i+k produced by +KA',KB'}. In such a case, it is generally possible for a related key attack on the block cipher to succeed.
    </p>
    <p num="232">
      This method does not require the number of cipher data registers which form the block ("x") to equal the number of key segments ("y").
      <br/>
      It is not required that they be added together or even that the values be stored in fixed tables.
      <br/>
      It is also not required that the key segments and predetermined values are always combined using the same round operator, or that they are combined using a linear operator.
    </p>
    <p num="233">
      This method requires generally the combination of particular key segments and predetermined values using generally any mathematical operations capable of being carried out in a microprocessor in order to produce subkey values, where the predetermined values are typically stored in fixed table values.
      <br/>
      The combination of segments and values may for example occur using subtraction or xor in various rounds applied to various segments to calculate the subkey values.
      <br/>
      This combination of key segments and predetermined values to produce subkey values using various linear operators may be preferred to a combination using various operators for which the number of bits of the two inputs of the operator are unequal (e.g., variable rotation).
      <br/>
      As shown in FIG. 5, it may be preferred to use just one linear combination operator, rather than using various round-and-segment dependent operators.
      <br/>
      Further, it may be preferred, in some circumstances, that the linear operator which combines the key segments and fixed table values is non-commutative with the linear operator in the block cipher which combines round segments with the subkeys.
      <br/>
      Still further, it may be preferred that such a linear combination operator which provides subkeys under this method provides all the subkeys used by the block cipher for which the subkeys are generated.
    </p>
    <p num="234">
      In accordance with this method, the above specific method subkeys, may in general be expressed as the output of an operator having two inputs, where one such input is a key segment and the other input is a predetermined value.
      <br/>
      Defined mathematically, this arrangement is one in which one input is a key-dependent segment, and another input is a predetermined value or constant value.
      <br/>
      Hence, it is not strictly necessary for the subkey value to be a combination using some operator applied to a key segment and a predetermined value.
      <br/>
      Rather, using this method, it is acceptable if the new subkey value is affected by a combination, using some operator, of some other previously calculated subkey and a new predetermined value, as long the value of the previously calculated subkey is key-dependent.
      <br/>
      This method then, produces a new subkey value affected by an operator output, where such operator has two inputs, one input is a key-dependent segment and the other operator is a new predetermined value.
      <br/>
      Accordingly, it may be preferred that the new predetermined value does not affect a previously calculated subkey value on which the new subkey value depends.
      <br/>
      Further, it may be preferred that each such operator has two inputs with an equal number of bits, and that such operators are linear.
    </p>
    <p num="235">
      The general formula in the preceding paragraph gives a general summary of this iterative key expansion method for block ciphers with data-dependent rotations which generates the subkeys as follows: a) take key dependent segments (where most of the bits are variable and depend on the key bits), b) linearly combine them with predetermined segments, c) use the resulting linearly combined segments as near-to-final segments, in that either preferably the linearly combined segments are the final subkey segments, or else alternatively the final subkey segments are affected by the linearly combined segments (and preferably would be affected directly).
      <br/>
      And, note that this general summary of the method requires minimization of the total number of mathematical operations as detailed below.
    </p>
    <p num="236">
      The number of bits of output of operators and the number of bits of subkeys generated from the k-bit key, is approximately one bit of mathematical operator output per bit of subkeys generated (e.g., such as the one linear combination operation per subkey generated in FIG. 5).
      <br/>
      A minimal number of mathematical operations, including any operations to convert the input key to the k-bit key is desired.
      <br/>
      The ratio of bits of mathematical operation output to bits of subkeys generated is generally less than 2 to 1 and is preferably a ratio close to 1 to 1, to provide simple, fast, and secure subkey generation.
      <br/>
      A maximum ratio of 3.5 to 1 is contemplated by the present invention, whereby higher ratios are not believed to provide the advantages of the present invention.
      <br/>
      These ratios of mathematical operation bits to subkey bits, excludes from the numerator those operations such as loading or storing a value to or from memory which are not mathematical operations.
      <br/>
      Of course, mathematical operations are such operations as linear operations, bit-wise "and" and "or" operations, and bit-wise rotations.
      <br/>
      The method is a significant improvement over the prior art due to its sparseness and limited number of operations, and the fact that such a simple and fast method would not ordinarily be secure when implemented for a block cipher which does not use data-dependent rotations as part of its operative rounds.
    </p>
    <p num="237">
      It should be noted that the erroneous belief that it is necessary to have subkey schedules using maximum avalanche and nonlinear interaction generally results in key expansion methods with a ratio of mathematical operation output bits to subkey bits of greater than 4 to 1.
      <br/>
      The key expansion method of RC5 seems to have a ratio of roughly 9 to 1.
      <br/>
      Some of these operations are linear and some nonlinear.
      <br/>
      By contrast, the key expansion method described herein for block ciphers using data-dependent rotation in its iterative rounds is able to provide fast secure key expansion and has a ratio as low as 1 to 1, using predominantly linear operators.
    </p>
    <p num="238">The innovative aspect of the key expansion method described herein is the surprising result that using the combination of: a) a simple generally linear subkey generation method, and b)a block cipher using data-dependent rotation of round segments, it is possible to produce secure subkey segments from a key in spite of very low ratios of operation output bits to subkey bits.</p>
    <p num="239">
      As mentioned above, this method does not assume use of any particular method to convert key input bits to key segments.
      <br/>
      Such conversion may involve either expansion or compression of the key input values.
      <br/>
      Such conversion may for example accept variable size key inputs.
      <br/>
      Once such key inputs are converted into the appropriate size key block by whatever method, then this key expansion method as specified above divides the key data up into y segments and expands the key segments into subkeys using predetermined values which typically are from a fixed table.
    </p>
    <p num="240">Finally, it is preferred that there is no simple linear or affine or other non-random statistical relationship between the bits of the predetermined values or fixed table, and that the such bits have roughly equal probabilities, i.e., are unbiased.</p>
    <p num="241">
      The flow chart of FIG. 5 is the equivalent of the subkey equations below.
      <br/>
      These equations may provide the values of all subkeys used in the main embodiment from key segments KA and KB.
      <br/>
      Such subkeys identified below as Subkeyi or Subkeyi+1, are generally in the equations of the block cipher which uses such subkeys identified as Keyi or Keyi+1. The equations use an index value i, where i is incremented by x (i.e., by 2) between each iteration or round, similar to the other equations previously discussed:  (Equation image '8' not included in text)
    </p>
    <p num="242">
      This method requires only 1 mathematical operation per subkey, and should be over three times as fast as most key expansion methods in generating subkeys.
      <br/>
      Assuming that subkeys are not precalculated and stored in cache for packet encryption, typical subkey expansion may require 30 percent or more of the time required to encrypt a standard packet of 48 bytes.
      <br/>
      This method for key-expansion may increase the combined speed of key-expansion and encryption for each 48-byte packet by roughly 20 percent.
    </p>
    <p num="243">
      As to what varied source of numbers should be used in the fixed table, there are many possibilities.
      <br/>
      It might be preferred to use well known, trusted random numbers to load the fixed table, such as from the RAND tables which contain a million random numbers which were published in 1955.
      <br/>
      Or perhaps using the value of pi (3.14159, etc.).
      <br/>
      Alternatively, it might be preferred to fill the fixed table with optimized values, which should minimize the chance of any differentially weak subkeys.
    </p>
    <p num="244">
      Sixth, the embodiment of FIG. 3 shows the segments xored with subkey values after they are rotated by a fixed amount.
      <br/>
      There are many other places in the block cipher where modification by subkey values could have taken place.
      <br/>
      It is believed that the exact placement of the subkey segments in the algorithm is not critical to the security of the block cipher.
      <br/>
      For example, instead of the placement of the subkeys as shown in FIG. 3, a different approach may be adopted, as described in the following encryption equations,  (Equation image '9' not included in text)
    </p>
    <p num="245">
      In accordance with the preferred embodiment, the main reason subkey value is combined with an intermediate one-to-one round segment rather than with a primary round segment directly is not to increase the security of the block cipher, but rather to accommodate the pipelining of modem microprocessors.
      <br/>
      There can be a delay in microprocessors between obtaining the 1sb of a register and using it to affect a nonlinear activity.
      <br/>
      Extracting a subkey from a list and combining it linearly with a round segment are useful steps to take while waiting for a nonlinear result from a microprocessor.
    </p>
    <p num="246">
      Seventh, there are alternative places in this general method in which to locate the fixed rotation.
      <br/>
      And, the following example is not intended to limit the placement, or the use of predetermined bit-moving operators in the block cipher.
    </p>
    <p num="247">
      Referring to FIG. 6, another embodiment of the cryptographic system and method in which there is a different placement of the active, effective fixed rotation is shown.
      <br/>
      A block 110 of plaintext input of n bits is divided up into two equal size primary round segments or half blocks of n/2 bits, R0 (block 112) and R1 (block 114).
      <br/>
      Prior to beginning the iterative process, this alternative embodiment linearly combines (block 116) using the operator L1 the right segment R1 with the first subkey segment K1.
      <br/>
      Next, the first of a plurality of rounds of encryption (preferably in excess of 8 rounds) are performed.
      <br/>
      Each round of encryption computes new values of the primary segments R0 and R1.
      <br/>
      Each computation of the two primary segments in each encryption round is similar in form, even though it has different inputs and outputs, uses different subkeys, and uses different registers.
    </p>
    <p num="248">
      Both R0 and R1 are primary segments, and are also one-to-one round segments.
      <br/>
      Except for the small sections of bits which determines the data-dependent rotation, all variable segments in each round of this alternative embodiment are one-to-one round segments.
    </p>
    <p num="249">
      To compute the primary round segments R0 and R1 in the first half round, the following procedure is used.
      <br/>
      First, combine (block 118) linearly using the operator L2 the register R1 with the subkey K2 to produce an intermediate segment value.
      <br/>
      Combine (block 120) linearly using operator L3 that intermediate segment with R0 producing a replacement value of primary segment R0.
      <br/>
      Then, extract (block 122) a value V from R1 by taking f of the 1sb bits of register R1.
      <br/>
      Rotate (block 124) the replacement value of R0 by the value V just extracted.
      <br/>
      This resulting value of R0 after the rotation is the new value of R0 (block 126).
      <br/>
      Then rotate (block 128) the value of R1 rightward by fbits.
      <br/>
      The resulting value of R1 is the new value of R1.
      <br/>
      Then repeat this process to compute the second half round, but where the roles of R0 and R1 are switched, and where the subkey segment used is K3.
    </p>
    <p num="250">
      To compute the primary round segments R0 and R1 in the second half round, the following procedure is used.
      <br/>
      First, linearly combine (block 130) using the operator L4 the primary segment R0 with the subkey K3 to produce an intermediate round segment.
      <br/>
      Linearly combine (block 132) using the operator L5 that intermediate segment and R1 producing a replacement value of R1.
      <br/>
      Then, extract (block 134) a value V from R0 by taking f of the 1sb bits of register R0.
      <br/>
      Rotate (block 136) the replacement value of R1 by the value V just extracted.
      <br/>
      This resulting value of R1 after said rotation is the new value of R1 (block 138).
      <br/>
      Then rotate (block 140) the value of R0 rightward by f bits.
      <br/>
      The resulting value of R0 is the new value of R0.
    </p>
    <p num="251">
      Each such round in which new one-to-one round segments for R0 and R1 are computed is only part of the process.
      <br/>
      Many rounds are necessary depending on block size and the users desire for security, but this number of rounds is typically between 8 and 64 rounds, with at least 5 of such rounds incorporating the described process, and such rounds are herein called qualified operative rounds; some users may select a larger number of rounds, such as 128 rounds.
      <br/>
      Indeed, there is no true upper limit to the number of rounds which can be employed, with the tradeoff being that more rounds reduce the speed of calculation.
    </p>
    <p num="252">
      After completion of the last round, the systems adds (combines) (block 142) the left segment R0 with the last subkey value, Klast.
      <br/>
      The ciphertext value for segments R0 (block 144) and R1 (block 146) are complete, and are then transferred as ciphertext consisting of n bits, i.e., a n-bit cipher output (block 148).
    </p>
    <p num="253">
      For simplicity, the equations related to FIG. 6 below which represent this alternative embodiment assume linear combination functions in which one-to-one segments are combined together in cumulative linear combination using the operator of addition in the modulus of the segment, and that the subkey combination function uses xor.
      <br/>
      As stated previously, there are other acceptable linear operators which can perform these functions.
    </p>
    <p num="254">The equations which represent the alternative embodiment shown in FIG. 6 are,  (Equation image '10' not included in text)</p>
    <p num="255">The equations which represent the inverse (i.e., decryption) of FIG. 6 are,  (Equation image '11' not included in text)</p>
    <p num="256">As in the preferred embodiment, this alternate embodiment also has the properties of: (1) bit expansion of a small section, (2) adjustment by a full sized subkey, (3) cumulative linear combination, and (4) non-commutative one-to-one round segment interactions.</p>
    <p num="257">
      The fixed rotation provides a significant number of good bits, e.g., 2f good bits, and that number of good bits is roughly equal to the number of input bits which control the nonlinear activities in each round (2f).
      <br/>
      The block cipher has the property of new small section data in successive rounds.
    </p>
    <p num="258">Eighth a highly secure block cipher for bulk encryption of large files using s-boxes is presented.</p>
    <p num="259">
      Unlike encryption using data-dependent rotation which extracts fbits from the 1sb of each register in order to affect the degree of rotation, this variation and method of encryption extracts g bits from a preselected location such as the 1sb of each segment as input into a nonlinear s-box.
      <br/>
      Unlike encryption using data-dependent rotation, therefore, in this method the number of bits which control the non-linear process is g bits.
      <br/>
      Further, it may be preferred when using this method to select a number of bits of fixed rotation equal to g bits.
    </p>
    <p num="260">
      Referring to FIG. 7, an algorithmic flow chart for one round of the cryptographic system and method using s-boxes is generally shown.
      <br/>
      An initial block 150 of n input bits is plaintext input.
      <br/>
      Each plaintext input block 150 is divided up into two one-to-one primary round segments 152 and 154, i.e., block halves, each of which contain n/2 bits.
      <br/>
      For example, a 128-bit version of the cryptographic system divides up its input into two 64-bit one-to-one round segments, R0 (block 152) and R1 (block 154) respectively.
    </p>
    <p num="261">
      Both R0 and R1 are primary segments, and are also one-to-one round segments.
      <br/>
      In fact, except for the small sections of bits which are s-box input, the round segments of s-box output, all variable segments in each round of this embodiment are one-to-one round segments.
    </p>
    <p num="262">
      Prior to beginning the iterative process, the method shown in FIG. 7 takes the right primary round segment R1 and linearly combines (block 156) it using operator L1 with a subkey segment K1.
      <br/>
      Next, the first of a plurality of rounds of encryption (preferably equal to or exceeding 5 rounds) are performed.
      <br/>
      Each round of encryption computes new values of the one-to-one primary round segments R0 and R1.
      <br/>
      Each computation of the two primary segments is similar in form, even though it has different inputs and outputs and uses different registers.
    </p>
    <p num="263">
      To compute the first half round, i.e., to compute the primary round segment R0, the following procedure is used.
      <br/>
      Extract (block 158) the least significant g bits of R1.
      <br/>
      Use these as input into the s-box lookup table.
      <br/>
      Assign the value of the s-box output to register V. Linearly combine (block 160) using operator L2 segment R0 with segment V to produce a replacement primary round segment R0.
      <br/>
      Then compute an intermediate one-to-one segment by rotating (block 162) the register R1 rightward by g bits.
      <br/>
      Linearly combine (block 164) using operator L3 this intermediate segment with K2 to form a new intermediate segment.
      <br/>
      Then linearly combine (block 166) using operator L4 this new intermediate segment with R0 (where R0 now reflects segment V).
      <br/>
      The result is the new value of primary segment R0 (block 168).
    </p>
    <p num="264">
      Then repeat this process to compute the second half round, but where the roles of R0 and R1 are switched, and where the subkey segment used is K3.
      <br/>
      To compute the second half round, i.e., to compute a replacement primary round segment R1, the following procedure is used.
      <br/>
      Extract (block 170) the least significant g bits of R0.
      <br/>
      Use these as input into the s-box lookup table.
      <br/>
      Assign the value of the s-box output to register V. Linearly combine (block 172) using operator L5 primary segment R1 with value V to produce a replacement round segment R1.
      <br/>
      Then compute an intermediate one-to-one segment by rotating (block 174) the register R0 rightward by g bits.
      <br/>
      Linearly combine (block 176) using operator L6 this intermediate segment with K3 to form a new one-to-one intermediate segment.
      <br/>
      Then linearly combine (block 178) using the operator L7 this new intermediate segment with R1 (where R1 now reflects the segment V).
      <br/>
      The result is the new value of primary segment R1 (block 180).
    </p>
    <p num="265">
      Each such round in which new primary round segments R0 and R1 are computed is only part of the process.
      <br/>
      Many rounds may be necessary depending on block size and the users desire for security, but this number of rounds is typically between 8 and 64 rounds, with at least 5 of such rounds incorporating the described process, and such rounds are herein called qualified operative rounds; some users may select a larger number of rounds, such as 128 rounds.
      <br/>
      Indeed, there is no true upper limit to the number of rounds which can be employed, with the tradeoff being that more rounds reduce the speed of calculation.
    </p>
    <p num="266">
      After completion of the last round, this alternative embodiment linearly combines (block 182) the left one-to-one round segment R0 with the last subkey segment, Klast.
      <br/>
      Then the ciphertext value for segments R0 (block 184) and R1 (block 186) are complete and are transferred as ciphertext consisting of n bits, i.e., a n-bit cipher output (block 188).
    </p>
    <p num="267">
      To ensure secure encryption, it is preferred that the operators which linearly combine the one-to-one round segments with each other should in general be non-commutative with the operators which combine the s-box output with one-to-one round segments.
      <br/>
      The following equations are a practical implementation of this approach and they use the algebraic group of addition to linearly combine one-to-one round segments with each other, and xor to linearly combine s-box output with one-to-one round segments,  (Equation image '12' not included in text)
    </p>
    <p num="268">
      Again, decryption is the inverse of encryption.
      <br/>
      All the same steps are repeated but in reverse order.
      <br/>
      Decryption uses ciphertext output as input and recovers the values of the plaintext inputs.
      <br/>
      As in the preferred embodiment, this alternate embodiment using an s-box also has the properties of: (1) bit expansion of a small section, (2) adjustment by a full sized key, (3) cumulative linear combination, and (4) non-commutative one-to-one round segment interactions.
    </p>
    <p num="269">
      Even though this method uses no data-dependent rotations, the calculation of the number of good bits determined from the encryption or decryption equations is still a useful means of testing whether fixed rotation is active and effective.
      <br/>
      There are numerous good bits (i.e., 4g in total) which exceed the 2g of input bits used by the s-boxes each round.
      <br/>
      This is consistent with the use of active and effective fixed rotation in the block cipher, and this s-box variation of the block cipher has a sufficient number of good bits.
    </p>
    <p num="270">Variations of this cipher exist that are believed to be weaker than those variations shown as the preferred variations where potentially: (1) an sbox output determined by some bits of one block half is combined with that block half linearly prior to linear combination with the other half, and (2) logical shift instructions may be used instead of rotate instructions.</p>
    <p num="271">The following set of equations demonstrates a round as an example of potentially weak variation -1:  (Equation image '13' not included in text)</p>
    <p num="272">The following set of equations demonstrates a round as an example of potentially weak variation -2:  (Equation image '14' not included in text)</p>
    <p num="273">Note first of all that the above equations show an example in which fixed logical shift operations may be used as a bit-moving operation in a manner similar to fixed rotation operations, as they are fundamentally similar operations, as would be appreciated by those with ordinary skill in the art.</p>
    <p num="274">
      Note additionally that these alternative encryption equations are similar to the preferred embodiments in certain ways.
      <br/>
      Stated in general, this present invention when using sbox lookups is one which is a block cipher which recalculates the value of each primary round segment as a generally linear combination of itself, which we may call the prior round segment value, the value of another round segment, which may be called the other round segment, and an sbox value.
      <br/>
      This statement makes no restrictions on the order of linear operations, or which generally linear operations are performed, or any restrictions on what additional operations including nonlinear operations are performed.
    </p>
    <p num="275">
      Most variations of this cipher using sboxes illustrate this general structure in which values of each primary round segment are modified with indirect or direct linear combinations of three values: (1) a round segment which is generally 64 bits or more and contains at least 50 variable bits (over 75 percent of the bits) which are from or are derived from a 1:1 PLT of the prior round segment value, (2) another round segment which is generally 64 bits or more and contains at least 50 variable bits (over 75 percent) which are from or are derived from a 1:1 PLT of the other round segment value, (3) the sbox output or a 1:1 PLT of it or derived from a 1:1 PLT of it, which is dependent on data from the n-bit cipher data block, and the sbox output generally contains 64 bits or more.
      <br/>
      Note that in practice when there is a 1:1 PLT of a value such a block half, an efficient implementation generally does no extra operations and so uses an identity PLT.
      <br/>
      Of course, a 1:1 identity PLT of a round segment is simply the value of that round segment.
    </p>
    <p num="276">
      Incidentally, a similar general statement about the invention using data dependent rotations may be made.
      <br/>
      We can say that most variations of the block cipher using data-dependent rotations (preferably with active predetermined bit-permutation or rotation) modify each primary round segment with indirect or direct linear combination of two values: (1) a round segment where substantially all of its bits are variable bits which are from or are derived from a 1:1 PLT of the prior round segment value, (2) a round segment where at least 75 percent of its bits are variable and are from or are derived from a 1:1 PLT of the other round segment value.
    </p>
    <p num="277">
      Referring to FIG. 8 (wherein the blocks are numbered as in FIG. 7, with the numbers in the second round being designated with a prime), an example in which two rounds using an s-box is shown in which a given input passes through two rounds of the invention and is modified by it despite simple subkeys in which all values equal 0.
      <br/>
      It will be appreciated that the bits which determine s-box output in this example are not based solely on the initial 1sb of the plaintext input segments.
      <br/>
      This example reflects a cryptographic system in which the s-box outputs depend on many different subkey and input values.
    </p>
    <p num="278">
      The s-box cipher method minimizes problems such as pipeline optimization in microprocessor chips and "address generation interlock".
      <br/>
      In particular, a certain amount of time is required between loading a pointer and using it.
      <br/>
      For example, a pointer is an address in an s-box or lookup table.
      <br/>
      Hence, it is an advantage that three intermediate operations are computed between determining the input into the s-box and using the s-box output.
      <br/>
      These operations are: rotating a one-to-one round segment by a fixed number of bits, reading a subkey segment from a table, and xoring the rotated segment by the subkey value.
      <br/>
      As a result, there should be little down time in the microprocessor, and the processor is kept busy computing useful intermediate segments as it waits for the output of the s-box table.
    </p>
    <p num="279">
      It may be preferable when using this s-box cipher method to ensure that the sizes of the s-box input (g bits) and its fixed rotation (which may also equal g bits) are relatively prime to the segment size.
      <br/>
      In particular, it may be preferred that both are odd (as the segment size is typically even, and a power of 2).
      <br/>
      Further, it may also be preferable if the segment size divided by s-box input size g is nearly equal to an odd number, or in any case that the register size is not exactly divisible by g. For current microprocessors, a preferred block configuration might use an s-box input size of 9-bits or 11-bits, with a fixed rotation of an equal number of bits, and with a block size of either 64 bits or 128 bits.
    </p>
    <p num="280">
      On the other hand, if the present method is used for a cipher computed on 8-bit processors or smart cards or economical signal processing chips, it may be preferred if the size of the s-box input (g bits) and its fixed rotation (typically g bits) equals 8 bits.
      <br/>
      The loss in potential theoretical efficiency of using values not necessarily prime to the register size may be offset by the speed and practicality of 8-bit rotations on certain processors.
      <br/>
      If such an s-box input size and rotation are adopted which are not relatively prime to the segment size, it may be preferable to use an alternative fixed rotation method as shown in FIG. 9, which is discussed hereinafter.
    </p>
    <p num="281">
      In most block ciphers using s-boxes, use of the same s-box to compute all nonlinear results is considered weak.
      <br/>
      For example, DES uses different s-boxes for each 6-bit input received from its half-block of input.
      <br/>
      By contrast, the present invention reuses the same s-box multiple times without risk of compromising security.
      <br/>
      To appreciate why this method of using s-boxes is secure, it is useful to analyze the calculation of each round.
      <br/>
      Each s-box output affects an entire round segment where each such round segment is ideally 64-bits or larger.
      <br/>
      This is the property of bit expansion of a small section discussed hereinbefore.
    </p>
    <p num="282">
      To cryptanalyze block ciphers it is generally necessary to find a way of canceling any differences in the output of an s-box with a given input difference with a high probability.
      <br/>
      Such cancellation might be easy if any s-box outputs are identical to one another, or even if the minimum total number of bit-differences between any two s-box outputs is small (or perhaps if the number of contiguous bit-differences is small).
      <br/>
      But given that the s-box output is much larger than its input, it is generally possible to optimize the s-box such that for an s-box with a 32-bit output, or even better a 64+-bit output, for all possible s-box outputs the minimum number of bit differences is roughly one quarter or more of the s-box output size.
    </p>
    <p num="283">
      Note further that the optimization of the sboxes used with this method is based on permutations.
      <br/>
      This method ensures that each of 8 output bytes (each of the bytes is a contiguous or consecutive section of 8 bits) provides an output change of at least 1 bit for any and all sbox input differences.
      <br/>
      This method of building the sbox, either using permutations or any sbox generation method with the same easily measurable property, wherein such that contiguous or consecutive sections of bits (of 20 bits or less) have a bit-output difference of at least 1 bit for any 1 bit input-difference, ensures the block cipher has considerable differential strength when the sbox output is 64-bits or more.
      <br/>
      Such differential strength is also increased if the sbox optimization method also guarantees a minimum number of output bit-differences for any input difference, preferably where that minimum is greater than that expected by chance (as seen in the embodiment SteelTalon with a minimum output bit difference of about 18 bits).
    </p>
    <p num="284">These sbox optimization methods which generally guarantee a minimum number of output bit-differences for all possible input differences which is better than that expected by chance, or which guarantee a minimum output difference of at least 1 bit in consecutive or contiguous sections of 20 bits or fewer, are synergistic with the structure of a block cipher in which new values of a first primary round segment are calculated based on the direct or indirect linear combination of three values: a) a first variable segment reflecting or derived solely from the value of the first primary round segment, b) a second variable segment reflecting or derived from the value of another different primary round segment, and c) an sbox value of at least 64 bits whose input is dependent on some bits from the n-bit cipher data.</p>
    <p num="285">
      Any bit-differences of any s-box outputs affect potential carry operations related to addition or subtraction by the time any round segments affected by the s-box are linearly combined with other round segments.
      <br/>
      These carry operations are data-dependent and are non-commutative with xor, which is another operator affected by the s-box output.
      <br/>
      The property of non-commutative one-to-one round segment interactions which makes this possible is generally associated with the property of cumulative linear combination of segments discussed hereinbefore.
    </p>
    <p num="286">
      Generally, it appears that the security of this s-box method is optimized by using two non-commutative operators to: (a) linearly combine one-to-one round segments with each other, and (b) linearly combine one-to-one round segments with s-box output.
      <br/>
      As a result of such non-commutative linear operations, the probability of any s-box canceling out is very small.
      <br/>
      Not only would certain s-box inputs be necessary for self-cancellation of s-box outputs, but also all bits modified by a carry operation would need to be canceled out.
      <br/>
      As a result, both linear and differential analysis of this method using an s-box becomes difficult.
    </p>
    <p num="287">Of course, this alternative embodiment may in general be changed in the same ways as the preferred embodiment, and in general it appears that as long as the aforementioned preferred properties of the present invention are valid, the resulting block cipher should be secure assuming a reasonable number of rounds.</p>
    <p num="288">Variations in this s-box alternative embodiment which in general should not affect the security adversely in a significant way includes but is not limited to: some changes in the number of bits of active fixed rotation, alternative linear combination operators, new or different key expansion methods, different key placement in the equations, and alternative placement of the fixed rotation.</p>
    <p num="289">
      Referring to FIG. 9, an algorithmic flow chart for one round of the cryptographic system and method using s-boxes in accordance with an alternate embodiment is generally shown.
      <br/>
      The system and method is similar to that shown and described with reference to FIG. 7, however the fixed rotation is relocated.
      <br/>
      An initial block 190 of n input bits is plaintext input.
      <br/>
      Each plaintext input block 190 is divided up into two one-to-one primary round segments, 192 and 194, i.e., block halves, each of which contains n/2 bits.
      <br/>
      For example, a 128-bit version of the cryptographic system divides up its input into two 64-bit one-to-one round segments, R0 (block 192) and R1 (block 194) respectively.
    </p>
    <p num="290">
      Both R0 and R1 are primary segments, and are also one-to-one round segments.
      <br/>
      In fact, except for the small sections of bits which are s-box input, the round segments of s-box output, all variable segments in each round of this embodiment are one-to-one round segments.
    </p>
    <p num="291">
      Prior to beginning the iterative process, the method shown in FIG. 9 takes the right primary round segment R1 and linearly combines (block 196) it using operator L1 with a subkey segment K1.
      <br/>
      Next, the first of a plurality of rounds of encryption (preferably equal to or exceeding 5 rounds) are performed.
      <br/>
      Each round of encryption computes new values of the one-to-one primary round segments R0 and R1.
      <br/>
      Each computation of the two primary segments is similar in form, even though it has different inputs and outputs and uses different registers.
    </p>
    <p num="292">
      To compute the first half round, i.e., to compute the primary round segment R0, the following procedure is used.
      <br/>
      Extract (block 198) the least significant g bits of R1.
      <br/>
      Use these as input into the s-box lookup table.
      <br/>
      Assign the value of the s-box output to register V. Linearly combine (block 200) using operator L2 segment R0 with segment V to produce a replacement primary round segment R0.
      <br/>
      Linearly combine (block 202) using operator L3 the right round segment with K2 to form a new intermediate segment.
      <br/>
      Then linearly combine (block 204) using operator L4 this new intermediate segment with R0 (where R0 now reflects segment V (block 210)).
      <br/>
      Then compute a one-to-one segment by rotating (block 214) the register R1 rightward by g bits.
      <br/>
      The result is the new value of primary segment R1 (block 214).
    </p>
    <p num="293">
      Then repeat this process to compute the second half round, but where the roles of R0 and R1 are switched, and where the subkey segment used is K3.
      <br/>
      To compute the second half round, i.e., to compute a replacement primary round segment R1, the following procedure is used.
      <br/>
      Extract (block 212) the least significant g bits of R0.
      <br/>
      Use these as input into the s-box lookup table.
      <br/>
      Assign the value of the s-box output to register V. Linearly combine (block 216) using operator L5 segment R1 with value V to produce a replacement round segment R1.
      <br/>
      Linearly combine (block 218) using operator L6 intermediate segment R0 with K3 to form a new one-to-one intermediate segment.
      <br/>
      Then linearly combine (block 220) using the operator L7 this new intermediate segment with R1 (where R1 now reflects the segment V).
      <br/>
      The result is the new value of primary segment R1 (block 222).
      <br/>
      Then rotate (block 206) R0 by "g" to produce a replacement value of R0.
    </p>
    <p num="294">
      Each such round in which new primary round segments R0 and R1 are computed is only part of the process.
      <br/>
      Many rounds may be necessary depending on block size and the users desire for security, but this number of rounds is typically between 8 and 64 rounds, with at least 5 of such rounds incorporating the described process, and such rounds are herein called qualified operative rounds; some users may select a larger number of rounds, such as 128 rounds.
      <br/>
      Indeed, there is no true upper limit to the number of rounds which can be employed, with the tradeoff being that more rounds reduce the speed of calculation.
    </p>
    <p num="295">
      After completion of the last round, this alternative embodiment linearly combines (block 224) the left one-to-one segment R0 with the last subkey segment, Klast.
      <br/>
      Then the ciphertext value for segments R0 (block 226) and R1 (block 228) are complete and are transferred as ciphertext consisting of n bits, i.e., a n-bit cipher output (block 230).
    </p>
    <p num="296">
      Referring to FIG. 10, another alternative embodiment providing a key expansion method is shown.
      <br/>
      This expansion method is applicable to all block ciphers in general.
      <br/>
      It is particularly appropriate to block ciphers for bulk encryption where attaining the quickest possible bootup time is not generally necessary.
    </p>
    <p num="297">
      In this method, subkeys for use in a block cipher are generated from the one-to-one round segments of various rounds 240-242 of a generative block cipher in which key segments are input into the generative block cipher as if they are plaintext input.
      <br/>
      Subkeys generated using this method are mapped one-to-one with the secret key segments, but are complex uncorrelated functions of such secret key segments.
      <br/>
      As a result, it will be futile to apply related key attacks or similar key-based analytical methods to attack a block cipher using the subkeys output from this subkey generation method.
    </p>
    <p num="298">
      In particular, in this method the key segments input into the generative block cipher contain n bits.
      <br/>
      The key is input into the generative block cipher as n-bit cipher input.
      <br/>
      Typically, this generative block cipher is similar in form to the block cipher which uses the subkeys produced by this key expansion method.
      <br/>
      The key expansion block cipher typically uses as input 2 segments of n/2-bits each.
      <br/>
      The key value mentioned above determines the values of these two round segments.
      <br/>
      The generative block cipher also uses known but generally random values from a fixed table 244 to modify one-to-one round segments in order to provide some necessary irregularity in each round.
      <br/>
      Such known values (e.g., respective FTi-i+5q values) affect the segments of the generative block cipher the same in general as subkeys would in a secret key block cipher.
      <br/>
      The injection of adequate irregularity into each round 240-242 makes related-key attacks impossible and makes the resulting key expansion more secure.
      <br/>
      It is preferred in calculating this key expansion that the ratio of the number of known typically random segments to the number of subkeys calculated is 1 to 1 or greater.
    </p>
    <p num="299">
      The fixed table of known values should be as large or larger than the table of calculated subkeys called the subkey expansion table.
      <br/>
      While the fixed table is initially loaded with constant values prior to key expansion, it may in fact be stored in the same memory space in the microprocessor as the key expansion table and may use the same variable name.
    </p>
    <p num="300">Other alternatives include: (1) using any fixed s-box tables as a fixed table of known values to inject adequate irregularity into the subkey generation process where the calculation of new subkey values may replace the known s-box table such that each new subkey is also a new s-box output segment, and (2) any such known or predetermined values which inject irregularity into the subkey generation process need not be from a fixed table, but may for example be calculated by a linear feedback shift register or other mathematical expansion method.</p>
    <p num="301">
      In each round, if the fixed table and subkey expansion table are equal in size, using a common index position to load or store any segments in either table will speed up calculation.
      <br/>
      For example, two consecutive segments may be taken from the fixed table in positions (i+(n * q) and (i+((n+1) * q).
      <br/>
      The subkey segments when calculated may be placed into the subkey expansion table at the same relative locations (i+(n * q) and (i+((n+1) * q).
      <br/>
      This use of one incremented position value to access segments in both tables speeds up the calculation.
      <br/>
      Of course, q would have to be calculated in the modulus of the size of the fixed table and subkey expansion table in order to avoid any positions being accessed which are outside of the fixed table or subkey expansion table.
    </p>
    <p num="302">
      The use of q as shown above is simply a constant increment which is typically chosen to ensure that after generation when the subkey segment results are accessed during block encryption using a different increment, such as 1, each successive subkey segment accessed (or each pair of subkeys) is generally uncorrelated to the previous subkey value (or to the previous pair of subkeys).
      <br/>
      If the subkey segments are read from the subkey expansion table using an increment of 1, it may be preferred if q is an integer which equals roughly plus or minus the square root of the size of the fixed table, but where q is relatively prime to the size of the fixed table.
    </p>
    <p num="303">
      Referring to FIG. 11, an example of key expansion is shown using the method of FIG. 10 using the generative block cipher, which uses an s-box.
      <br/>
      In will be noted that each input of a fixed table value has a corresponding output subkey value which is taken from a primary round segment in the generative block cipher.
    </p>
    <p num="304">This key expansion method involves a generative block cipher with x primary segments (x=2) which generally uses x fixed table segments per round and produces x=2 subkey values per round, where over the course of a generative subkey expansion in total there are segments which may be loaded from a fixed table and storage available for S segments in the subkey expansion table.</p>
    <p num="305">
      An initial key block 250 of n input bits is key input.
      <br/>
      Each key input block is divided up into two one-to-one primary round segments 252 (K0) and 254 (K1), i.e., block halves, each of which contain n/2 bits.
      <br/>
      The first of a plurality of rounds are performed.
      <br/>
      Each round computes new subkey values of the one-to-one primary round segments K0 and K1.
      <br/>
      Each computation of the two primary segments is similar in form, even though it has different inputs and outputs and uses different registers.
    </p>
    <p num="306">
      To compute the first half round, i.e., to compute the primary round segment K0, the following procedure is used.
      <br/>
      Extract (block 256) the least significant g bits of K1.
      <br/>
      Use these as input into the s-box lookup table.
      <br/>
      Assign the value of the s-box output to register V. Linearly combine (block 258) using operator L1 segment K0 with segment V to produce a replacement primary round segment K0.
      <br/>
      Linearly combine (block 260) using operator L2 the right segment with Fi to form a new intermediate segment.
      <br/>
      Then linearly combine (block 262) using operator L3 this new intermediate segment with K0.
      <br/>
      Then compute a one-to-one segment by rotating (block 264) the register K0 rightward by g bits.
      <br/>
      The result is the new subkey value i from segment K0.
    </p>
    <p num="307">
      Then repeat this process to compute the second half round, but where the roles of K0 and K1 are switched.
      <br/>
      To compute the second half round, i.e., to compute a replacement primary round segment K1, the following procedure is used.
      <br/>
      Extract (block 266) the least significant g bits of the replacement segment of K0.
      <br/>
      Use these as input into the s-box lookup table.
      <br/>
      Assign the value of the s-box output to register V. Linearly combine (block 268) using operator L4 primary segment K1 with value V to produce a replacement round segment K1.
      <br/>
      Linearly combine (block 270) using operator L5 the left segment with Fi+q to form a new intermediate segment.
      <br/>
      Then linearly combine (block 272) using the operator L6 this new intermediate segment with K1.
      <br/>
      Then compute a one-to-one segment by rotating (block 274) the register K1 rightward by g bits.
      <br/>
      The result is the new subkey value i+q from segment K1.
    </p>
    <p num="308">Each such round generates two subkey values whereby the number of rounds is dependent the requirement for subkey values, which is itself dictated by the number of rounds in the encryption system.</p>
    <p num="309">
      It is possible to generalize this key expansion method to generate subkeys from a variable number of secret key segments.
      <br/>
      In this generalized version the number of generative primary segments is at least 2, and may be as large as desired but ideally is between 2 and 4.
      <br/>
      This generalized method for the generative block cipher calculates a new primary segment for registerj from a prior segment of registerj where j is an index which increments from 0 to (x-1) before repeating.
      <br/>
      S is the number of fixed table segments used per generative subkey expansion, and it is typically the number of subkey segments output per generative subkey expansion from new primary round segments. Fi is the table of constant values, and Subkeyi is the resulting subkey expansion table, where i is an index incremented from 0 to (s-1) before repeating.
    </p>
    <p num="310">A register Cxor is a cumulative xor of all other primary segments or registers except for the current primary segment being calculated at registerj. Note in the equations below that the equation for Cxor updates its value for each new value of index j. The initialization equations are not discussed for the following equations for they are readily determined by one skilled in the art.</p>
    <p num="311">The following loop computes such new primary segment, also called new register values, using this generalized key expansion method, where NewRv is such a new segment value or new register value:  (Equation image '15' not included in text)</p>
    <p num="312">
      The flexibility of this method may result in a reduction of cipher speed and efficiency.
      <br/>
      Yet it is still capable of expanding an input key faster than many other methods used by bulk encryption ciphers and satisfying the preferred properties of the present invention.
    </p>
    <p num="313">
      Referring to FIG. 14, an algorithmic flow chart for one round of the cryptographic system and method using relatively non-commutative linear operators, in which an s-box affects the block data with an operator that is non-commutative with an operator used to achieve robust linear diffusion in accordance with an alternate embodiment is generally shown.
      <br/>
      The algorithm is a symmetric Feistel block cipher which allows a variable number of rounds to permit variable security levels, and a block size of at least 128 bits.
    </p>
    <p num="314">
      An initial block 300 of n input bits is plaintext input, wherein the n is at least 128 bits.
      <br/>
      Each plaintext input block 300 is divided up into two one-to-one primary round segments, 302 and 304, i.e., block halves, each of which contains n/2 bits.
      <br/>
      For example, a 128-bit version of the cryptographic system divides up its input into two 64-bit one-to-one round segments, R0 (block 302) and R1 (block 304) respectively.
    </p>
    <p num="315">
      Both R0 and R1 are primary segments, and are also one-to-one round segments.
      <br/>
      In fact, except for the small sections of bits which are s-box input, the round segments of s-box output, all variable segments in each round of this embodiment are one-to-one round segments.
    </p>
    <p num="316">
      The method shown in FIG. 14 next performs the first of a plurality of rounds of encryption (preferably equal to or exceeding 5 rounds).
      <br/>
      Each round of encryption computes new values of the one-to-one primary round segments R0 and R1.
      <br/>
      Each computation of the two primary segments is similar in form, even though it has different inputs and outputs and uses different registers.
    </p>
    <p num="317">
      To compute the first half round, i.e., to compute the primary round segment R0, the following procedure is used.
      <br/>
      Extract (block 306) the least significant 8 bits of R1.
      <br/>
      Exclusive-or (block 308) the right round segment with subkey segment K2R (block 311) to form a new intermediate segment.
      <br/>
      Use the new intermediate segment as input into the s-box lookup table (block 310).
      <br/>
      Assign the 64 bit value of the s-box output to register V. SIMD add (block 312) segment V with segment R0 that is rotated rightward by 8 bits (block 314) to produce a replacement primary round segment R0.
      <br/>
      Exclusive-or (block 316) the round segment R1 with the replacement primary round segment R0 to form a new intermediate segment.
      <br/>
      Periodically, in only even rounds as shown at 317, shift (block 318) the round segment R1 leftward by 1 bit and then exclusive-or (block 320) this shifted round segment R1 with the new intermediate segment R0.
      <br/>
      The result is the new value of primary segment R0 (block 322).
    </p>
    <p num="318">
      The extra diffusion steps (block 317 and 335) every other round improves the thoroughness of linear diffusion.
      <br/>
      Consequently, even rounds of the method are different than the odd rounds.
      <br/>
      These extra diffusion steps also increases significantly the resistance of the cipher to linear cryptanalysis and differential analysis.
    </p>
    <p num="319">
      Then repeat this process to compute the second half round, but where the roles of R0 and R1 are switched, and where the subkey segment used is K(2R)+1 and the round segment R0 is shifted leftward by 2 bits every even round.
      <br/>
      To compute the second half round, i.e., to compute a replacement primary round segment R1, the following procedure is used.
      <br/>
      Extract (block 321) the least significant 8 bits of the new primary round segment R0 (block 322).
      <br/>
      Exclusive-or (block 324) the least significant 8 bits of new round segment R0 with subkey segment K(2R)+1 (block 326) to form a new intermediate segment.
      <br/>
      Use the new intermediate segment as input into the s-box lookup table (block 328).
      <br/>
      Assign the 64 bit value of the s-box output to register V. SIMD add (block 330) segment V with new segment R1 that is rotated rightward by 8 bits (block 332) to produce a replacement primary round segment R1.
      <br/>
      Exclusive-or (block 334) the new round segment R0 with the replacement primary round segment R1 to form a new R1.
      <br/>
      Periodically, in only even rounds as shown at 335, shift leftward (block 336) the new round segment R0 leftward by 2 bits and then exclusive-or (block 338) this shifted round segment R0 with the new segment R1.
      <br/>
      The result is the new value of primary segment R1 (block 340).
    </p>
    <p num="320">
      Each such round in which new primary round segments R0 and R1 are computed is only part of the process.
      <br/>
      Many rounds may be necessary depending on block size and the users desire for security, but this number of rounds is typically between 8 and 64 rounds, with at least 5 of such rounds incorporating the described process, and such rounds are herein called qualified operative rounds; some users may select a larger number of rounds, such as 128 rounds.
      <br/>
      Indeed, there is no true upper limit to the number of rounds which can be employed, with the tradeoff being that more rounds reduce the speed of calculation.
    </p>
    <p num="321">After completion of the last round, the values of segments R0 (block 342) and R1 (block 344) are ciphertext consisting of n bits, i.e., a n-bit cipher output (block 346).</p>
    <p num="322">The equations which represent two rounds of the alternative embodiment shown in FIG. 14 are,  (Equation image '16' not included in text)</p>
    <p num="323">The equations which represent the inverse (i.e., decryption) of FIG. 14 are,  (Equation image '17' not included in text)</p>
    <p num="324">
      Note that, as discussed elsewhere in the specification, it is possible to add extra key combinations, for example to combine the left half and right half with secret key data prior to and after such rounds of encryption and decryption.
      <br/>
      Further, it may be convenient to xor the left and right block halves with secret key data prior to and after such rounds of encryption and decryption (rather than combining the values using addition).
    </p>
    <p num="325">
      The variation of this embodiment shown below as encryption equations demonstrates not only use of extra key combinations prior to and after the rounds of encryption, it also helps to demonstrate that the additional shift operations used in the even rounds for extra diffusion can of course be used in the odd rounds as well (and generally in any round in the cipher).
      <br/>
      In this embodiment, which is more compact than the version shown in FIG. 14 the initial and final session key values are 64-bit key values and are called Skey2,  (Equation image '18' not included in text)
    </p>
    <p num="326">It is assumed that Skey2 would typically be an output of the same key expansion which generates Skey1 (although Skey2 contains 64 output bits in each word which is larger than the 8 output bits in each byte of Skey), which is to say that the values of Skey2 may for example be the encrypted output of a two-step master key expansion process where the encryption used in such key expansion has fixed inputs and has session key values which in general are generated by a linear key expansion process using round-dependent shift operations, and where the variation shown immediately above could be used to compute the encryption used in the key expansion process.</p>
    <p num="327">Another variation on FIG. 14 is a less compact and possibly more efficient version, which uses extra initial and final key operations plus bit-shifting every other round as follows:  (Equation image '19' not included in text)</p>
    <p num="328">
      This version eliminates two xor operations in the even round which may be unnecessary.
      <br/>
      The left shift operations in those rounds are preserved as a means to reduce byte alignment and to reduce the effectiveness of certain linear attacks, especially in the case of a potentially weak sbox.
    </p>
    <p num="329">And note further that nothing in this discussion restricts the choice of the subkey/session key generation method used in the present invention for possible block ciphers using sboxes; there are many known generally secure published key expansion methods for block ciphers using sboxes which have an avalanche effect and use some non-linear operations, and it seems that virtually all of them appear to be secure key expansion methods consistent with FIG. 14 and variations of FIG. 14.</p>
    <p num="330">There are three general attributes of the method of FIG. 14 which contribute to its security: (a) each input bit difference is guaranteed to cause a change in s-box input within 8 rounds, (b) each bit diffuses linearly in a robust manner to affect most bits after roughly 8 rounds, and (c) the bitwise variability of its nonlinear s-box operation exceeds the number of bits of its s-box input.</p>
    <p num="331">
      First, similar to many block ciphers, bit input changes in the method are guaranteed to cause a substantial affect on nonlinear input in a small number of rounds.
      <br/>
      In 8 rounds, after 128 bits of cipher data affect the s-box inputs, any input difference affects the output of an s-box.
    </p>
    <p num="332">
      Second, the extra shift operations every even round combined with the xor diffusion operations result in smooth effective bitwise linear diffusion.
      <br/>
      When only the linear diffusion patterns of the cipher is evaluated, there doesn't appear to be any periodic linear diffusion patterns resulting from input differences for which the Hamming number of changed bits is on average only a small number of bits per round.
    </p>
    <p num="333">
      Third, the bitwise variability of its nonlinear operator generally exceeds the number of bits input into its box.
      <br/>
      In most block ciphers, the s-box is the sole source of nonlinear strength.
      <br/>
      By contrast, the non-commutative interaction of s-box outputs and linear cipher data diffusion of the present invention gives rise to unpredictable variability which is an additional source of nonlinear strength.
    </p>
    <p num="334">
      The present invention can be embodied in the from of computer-implemented processes and apparatuses for practicing those processes.
      <br/>
      The present invention can also be embodied in the form of computer program code embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other computer-readable storage medium, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention.
      <br/>
      The present invention can also be embodied in the form of computer program code, for example, whether stored in a storage medium (electronic, magnetic or optic), loaded into and/or executed by a computer, or transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via electromagnetic radiation, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention.
      <br/>
      When implemented on a general-purpose microprocessor, the computer program code segments configure the microprocessor to create specific logic circuits.
    </p>
    <p num="335">
      An example of which shows how the present invention may be embodied in hardware is generally shown in a block diagram in FIG. 13. The block diagram is illustrative of a circuit for employing the encryption method using data-dependent rotation in accordance with the algorithmic flow chart of FIG. 6.
      <br/>
      Specifically, the block diagram illustrates the circuitry necessary to encrypt one round.
    </p>
    <p num="336">
      Referring to FIG. 13, a block of plaintext input of n bits is divided up into two equal size primary round segments or half blocks of n/2 bits, R0 (block 380) and R1 (block 382).
      <br/>
      Each computation of the two primary segments in each encryption round is similar in form, even though it has different inputs and outputs, uses different subkeys, and uses different registers.
    </p>
    <p num="337">
      To compute the primary round segments R0 and R1 in the first half round, the following procedure is used.
      <br/>
      First, combine linearly using logic gates (block 384) (such as AND, or and XOR gates) the register R1 with the subkey K2 (block 386) to produce an intermediate segment value.
      <br/>
      Combine linearly using logic gates (block 388) the intermediate segment with R0 producing a replacement value of primary segment R0.
      <br/>
      Then, provide the data or leads of the LSB of R1 at 390 to a shift register (block 392).
      <br/>
      The shift register rotates the replacement value of R0 by the value representative of the LSB of R1.
      <br/>
      This resulting value of R0 after the rotation is the new value of R0 (block 394).
      <br/>
      The output data or leads of the shift register are also switched or rotated a predetermined number of positions (block 396) effectively rotating the segment of data by a predetermined number of bits.
      <br/>
      The resulting value of R0 is the new value of R0 (block 398).
      <br/>
      Then repeat this process to compute the second half round, but where the roles of R0 and R1 are switched, and where the subkey segment used is K3.
    </p>
    <p num="338">
      To compute the primary round segments R0 and R1 in the second half round, the following procedure is used.
      <br/>
      First, combine linearly using logic gates (block 400) the new value of R0 (block 394) with the subkey K3 (block 402) to produce an intermediate segment value.
      <br/>
      The leads representative of R1 (block 382) are switched or rotated a predetermined number of positions (block 404) effectively rotating the segment of data by a predetermined number of bits.
      <br/>
      Then, combine linearly using logic gates (block 406) the intermediate segment of R0 with rotated segment R1 producing a replacement value of primary segment R1.
      <br/>
      Then, provide the leads of the LSB of R0 at 408 to a shift register (block 410).
      <br/>
      The shift register rotates the replacement value of R1 by the value representative of the LSB of R0.
      <br/>
      The resulting value of R1 is the new value of R1 (block 412).
    </p>
    <p num="339">While a predetermined rotation (circular bit rotation) has been described with respect to the various embodiments of the present invention, it is within the scope of the present invention that as a substitute for such predetermined rotation other predetermined bit moving operations (especially bit-permutations and bit-shifts) may be employed as such will be readily appreciated by one of ordinary skill in the art.</p>
    <p num="340">While the use of keys and bit moving operations have been described with respect to various embodiments of the present invention, one skilled in the art will appreciate that additional keys and predetermined or variable bit moving operations (e.g., fixed or variable rotations and fixed or variable shifts) may generally be used.</p>
    <p num="341">
      And, while the embodiments of the present invention have not used certain cryptographic operations, nothing restricts the use in the embodiments of such operators, restricts the type of key-dependent sbox transformations permitted, requires in all cases use of secret keys, or restricts use of the block ciphers as stand-alone encryption functions.
      <br/>
      For example, to the block ciphers of the present invention, one may add use of data-dependent shift operations, integer multiplication, data-dependent multiplication, byte permutations, use of 64-bit addition (or subtraction) instead of 64-bit SIMD addition (or subtraction), or even to find ways of combining sbox operations and data-dependent rotations in the same block cipher.
      <br/>
      As a further example, a standard fixed sbox called in the block cipher embodiments which use an sbox may be modified bytewise prior to use by a simple method such as bytewise rotor encryption, or otherwise modified using generally any method, in order to provide a key-dependent sbox.
      <br/>
      And further, while the block ciphers in the embodiments were shown using a secret key as a means of encryption (or perhaps to calculate a message authentication code), it is possible to use the same block ciphers where any key values are publically known as hash functions.
      <br/>
      And finally, while the block cipher embodiments have been shown as stand-alone functions which encrypt plaintext to ciphertext and vice-versa, they may also of course be used as components of stream ciphers or other cryptographic tools.
    </p>
    <p num="342">
      While preferred embodiments have been shown and described, various modifications and substitutions may be made thereto without departing from the spirit and scope of the invention.
      <br/>
      Accordingly, it is to be understood that the present invention has been described by way of illustrations and not limitation.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method of encrypting an n-bit block of data, comprising:</claim-text>
      <claim-text>representing an n-bit block of data having at least 128 bits to first and second round segments of data;</claim-text>
      <claim-text>and encrypting the n-bit block of data using a secret key and a block cipher comprising:</claim-text>
      <claim-text>- performing a plurality of encrypting rounds on said first and second round segments of data, at least five of said encrypting rounds comprising, - modifying said first round segment of data with values from the first linear combining of first, second, and third variable segments, said first variable segment of at least 64 bits comprising at least 50 variable bits derived solely from said first round segment of data, said second variable segment of at least 64 bits comprising at least 50 variable bits from a first derivation from said second round segment of data, and said third variable segment comprising a value from a second derivation from at least 50 bits selected from a lookup table in response to at least a portion of the n-bit block of data, where said first linear combining is selected from a group consisting of either direct linear combination, indirect linear combination, and - first bit-moving variable bits of a round segment of data derived from one of said first and second round segments of data by predetermined numbers of bits where most of the resulting bits affect the n-bit block of data, and where first bit-moving is an operation selected from a group consisting of circular bit-rotation by non-zero numbers of bits, logical bit-shift by non-zero numbers of bits, non-identity bit-permutation.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of encrypting of claim 1 wherein at least three of said encrypting rounds further comprises: modifying said second round segment of data with values from the second linear combining of fourth, fifth, and sixth variable segments, said fourth variable segment of at least 64 bits comprising at least 50 variable bits derived solely from said second round segment of data, said fifth variable segment of at least 64 bits comprising at least 50 variable bits from a third derivation from said first round segment of data, and said sixth variable segment comprising a value from a fourth derivation from at least 64 bits selected from a lookup table in response to at least a portion of the n-bit block of data, and where said second linear combining is selected from a group consisting of direct linear combination, indirect linear combination, and second bit-moving variable bits of a round segment of data derived from one of said first and second round segments of data by predetermined numbers of bits where most of the resulting bits affect the n-bit block of data, and where second bit-moving is an operation selected from a group consisting of circular bit-rotation by non-zero numbers of bits, logical bit-shift by non-zero numbers of bits, non-identity bit-permutation.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of encrypting of claim 2 wherein the third variable segment is selected from said lookup table in response to a portion of the second round segment of data, and the sixth variable segment is selected from said lookup table in response to a portion of said first round segment of data, and said first and second round segments of data contain in total at least (n-20) bits of data, and the first derivation, second derivation, third derivation, and fourth derivation are each derivations solely from their input round segments.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of encrypting of claim 1 wherein said first linear combining comprises: linearly combining said first variable segment and said second variable segment using a first linear operator;</claim-text>
      <claim-text>and linearly combining said first variable segment and said third variable segment using a second linear operator, wherein the first linear operator and second linear operator are non-commutative with each other.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of encrypting of claim 1 wherein the sbox is optimized so that consecutive sections of 20 bits or fewer are guaranteed to have at least a 1 bit output difference for each input bit difference.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of encrypting of claim 1 wherein the sbox is optimized so that it has a guaranteed minimum number of bits of output difference given any input difference, where that number is greater than what would be expected by chance.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of encrypting of claim 3 wherein the first bit-moving and second bit-moving are selected from a group consisting of logical shifts by predetermined numbers of bits, circular bit-rotation by predetermined numbers of bits.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of encrypting of claim 7 wherein the first linear combining comprises: linearly combining said first variable segment and said second variable segment using a first linear operator;</claim-text>
      <claim-text>and linearly combining said first variable segment and said third variable segment using a second linear operator, wherein the first and second linear operator are non-commutative with each other.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of encrypting of claim 8 wherein the second linear combining comprises: linearly combining said fourth variable segment with said fifth variable segment using a first linear operator;</claim-text>
      <claim-text>and linearly combining said fourth variable segment with said sixth variable segment using a second linear operator, wherein the first and second linear operator are non-commutative with each other.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of encrypting of claim 9 wherein the first linear operator is exclusive-OR and the second linear operator is from a group consisting of SIMD addition, SIMD subtraction.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A binary block cipher data transformation system for changing ordered n-bit cipher input into ordered n-bit cipher output using a secret key, wherein an n-bit block of data is represented by first and second round segments of data, each round segment having n/2 bits, wherein is at least 128 bits, and there are at least 5 rounds, each round comprising, a) a computing unit for executing the operation of each particular round; b) memory for loading and storing round segments; c) a bit-moving function, which is executed on the computing unit in each round where each time it is executed does a preselected operation on bits of a round segment from the group consisting of circular bit-rotation by non-zero numbers of bits, logical bit-shift by non-zero numbers of bits, non-identity bit-permutation, and has an input which is a variable segment and an output which is a variable round segment, and at least 75 percent of its output bits affect the n-bit round output; d) an sbox function, which is executed on the computing unit in each round where each time it is executed uses an input of a number of variable bits dependent on at least a portion of the n-bit block of data to select an sbox output segment of at least 64 bits from a lookup table, and substantially all of the bits of the sbox output segment affect n-bit round output;</claim-text>
      <claim-text>and e) a linear combination function, which is executed on the computing unit in each round where each time it is executed directly combines a first variable round segment with a second variable round segment, where at least 75 percent of the bits of said first variable round segment are variable bits, where at least 75 percent of the bits of said second variable round segment are variable bits, to produce an output which is a variable round segment where at least 75 percent of its output bits affect the n-bit round output, where the linear function is preselected from a group consisting of exclusive-OR, addition, subtraction, SIMD addition, SIMD subtraction, and where the sizes of the input and output segments of the linear combination function are at least 64 bits.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The data transformation system of claim 11 wherein the bit-moving function is selected from a group consisting of a bit-rotation by non-zero numbers of bits, logical bit-shift by non-zero numbers of bits, and each round contains at least 2 uses of the bit-moving function, 2 uses of the sbox function, and at least 2 uses of the linear combination function.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The data transformation system of claim 12 wherein each of the first and second round segments are in each round affected by an sbox output segment and by the output round segment of the linear combination function.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The data transformation system of claim 13 wherein the bit-moving function is placed in the rounds such that in each round the number of specified isolated bits equals the bit-size of the n-bit cipher data block.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A method of key expansion for block ciphers, which use data dependent rotation of round segments in at least three rounds where in each said block cipher round the number of bits of variable rotation of one round segment depends on some portion of another different round segment, comprising: performing a plurality of expansion rounds on key segments to generate subkeys, comprising - linearly combining variable key-dependent segments with predetermined values to generate other segments, where said other segments are in a group of near-to-final results consisting of intermediate values used to generate subkey segments, final subkey segments, and - where use of all mathematical operators used in the expansion rounds are minimized so that the operator ratio, which is the ratio of the total number of bits produced by said mathematical operators to the total number of subkey bits produced, is less than 3.5 to 1.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of key expansion of claim 15 wherein the operator ratio is less than 2 to 1.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method of key expansion of claim 16 wherein said mathematical operators are mostly linear.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method of key expansion of claim 17 wherein the operator ratio is less than 1.25 to 1.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method of key expansion of claim 18 wherein the input key is divided up into y key segments, and the y key segments are directly combined using linear operations with said predetermined values from a lookup table to produce subkey values.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. A binary block cipher data transformation system for changing ordered variable n-bit cipher input into ordered variable n-bit cipher output using a secret key, wherein an n-bit block of data is represented by x round segments of data, where x is between 2 and 8, and there are at least 5 rounds, each round comprising, a) a computing unit for executing the operation of each particular round; b) memory for loading and storing round segments; c) a bit-moving function, which is executed on the computing unit in each round where each time it is executed does a preselected operation on bits of a round segment from the group consisting of circular bit-rotation by non-zero numbers of bits, logical bit-shift by non-zero numbers of bits, non-identity bit-permutation, and has an input which is a variable round segment and an output which is a variable round segment where there are some bits of the output of the bit-moving function which can affect the n-bit round output; d) a variable rotation function, which is executed on the computing unit in each said round where each time it is executed rotates the bits of a first round segment by a value dependent on a preselected number of bits in a preselected location of bits in a second round segment, and has an output which is a round segment and substantially all of the resulting bits affect the n-bit round output;</claim-text>
      <claim-text>and e) a linear combination function, which is executed on the computing unit in each said round where each time it is executed combines one variable round segment with another variable round segment to produce a variable round segment where most of the resulting bits affect the n-bit round output, where one of the variable round segment inputs of the linear combination function is of substantially the same bit-size as the resulting output bits.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The data transformation system of claim 20 wherein each of said rounds receives n-bit round output, and modifies at least x different round segments to provide n-bit cipher round output, and where at least x said round segments are rotated by the variable rotation function.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The data transformation system of claim 21 wherein said bit-moving function is selected from a group consisting of circular bit-rotation by a non-zero number of bits, and any crytographically equivalent use of logical bit-shift by a non-zero number of bits.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The data transformation system of claim 21 wherein the number of specific isolated bits in each round is greater than 50 percent of all bits in the n-bit data block.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The data transformation system of claim 22 wherein the bit-moving function is effective rotation, and x is less than 5.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The data transformation system of claim 22 wherein most of the output bits of the bit-moving function affect n-bit round output.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The data transformation system of claim 22 wherein the number of specific isolated bits in each round of the block cipher is greater than 50 percent of all bits in the n-bit data block, and x is less than 5, and n is a predetermined value of at least 64 bits.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The data transformation system of claim 26 wherein said first round segment rotated by the variable rotation function is a one-to-one round segment and the bits which control said variable rotation of the first round segment are not derived from the first round segment.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The data transformation system of claim 27 wherein both inputs of the linear combination function are different one-to-one round segments from the same one-to-one segment set, and the bit-moving function is selected from a group consisting of rotation by f, and the mathematical equivalent of such rotation by f using logical shift, where f equals the log base 2 of the bit-size of a round segment rotated in round in a data-dependent manner.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The data transformation system of claim 28 wherein each of the x round segments are in each round affected by the output of the variable rotation function, and the output of the linear combination function.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. A method of encrypting an n-bit block of data, comprising: representing an n-bit block of data by a number x of round segments between two and four, where the potential round segments are called a first round segment, second round segment, third round segment, and fourth round segment;</claim-text>
      <claim-text>and encrypting using a secret key and block cipher, said block cipher comprising, - performing a plurality of encrypting rounds on said first and second round segments of data, at least five of said encrypting rounds comprising, - modifying said first round segment of data with output of a first linear combining of first and second variable segments, the first variable segment having a derivation solely from substantially all the variable bits of said first round segment of data, the second variable segment having a first derivation from a most of the bits of a first particular round segment of data, where said linear combining is selected from a group consisting of direct linear combination, indirect linear combination, - variably rotating said first round segment of data by a number of variable bits dependent on at least a portion of the n-bit block of data, and - bit-moving a second particular round segment of data having a second derivation from selected from one of the first, second, third, and fourth round segments of data by a predetermined bit-moving operation selected from the group consisting of circular bit-rotation by non-zero numbers of bits, logical bit-shifts by non-zero numbers of bits, nonidentity bit-permutation, where there are some output bits of the bit-moving operation which can affect the n-bit round output.</claim-text>
    </claim>
    <claim num="31">
      <claim-text>31. The method of claim 30 wherein each of said rounds receives n-bit round output, and modifies at least x different round segments to provide n-bit round output, and where at least x said round segments are rotated by the variable rotation function.</claim-text>
    </claim>
    <claim num="32">
      <claim-text>32. The method of claim 31 wherein the number of specified isolated bits in each round is greater than 50 percent of all the bits in said n-bit block of data, and n is a predetermined number of at least 64 bits.</claim-text>
    </claim>
    <claim num="33">
      <claim-text>33. The method of claim 31 wherein the first derivation and second derivation are derived solely from their respective input round segments, and the first particular round segment is selected from a group consisting of the second round segment, the third round segment, the fourth round segment.</claim-text>
    </claim>
    <claim num="34">
      <claim-text>34. The method of claim 31 wherein the bit-moving operation is selected from a group consisting of circular bit-rotation by non-zero numbers of bits, and mathematically equivalent use of logical bit-shifts by non-zero numbers of bits.</claim-text>
    </claim>
    <claim num="35">
      <claim-text>35. The method of claim 34 wherein the variably rotating of the first round segment is by a number of bits dependent on a portion of data from a round segment other than the first rounds segment.</claim-text>
    </claim>
    <claim num="36">
      <claim-text>36. The method of claim 35 wherein the bit-moving operation is effective fixed rotation.</claim-text>
    </claim>
    <claim num="37">
      <claim-text>37. The method of claim 35 wherein the number of specified isolated bits in each round of the block cipher is greater than 50 percent of all the bits in the n-bit data block.</claim-text>
    </claim>
    <claim num="38">
      <claim-text>38. The method of claim 36 wherein the fixed rotation is by f, where f equals log base 2 of the bit-size of a round segment.</claim-text>
    </claim>
    <claim num="39">
      <claim-text>39. The method of claim 36 wherein n=128, and in each round each primary round segment is modified with output of a linear combining of two variable segments, and each primary round segment is rotated by a data-dependent number of bits.</claim-text>
    </claim>
    <claim num="40">
      <claim-text>40. The method of claim 39 wherein x equals 2, and the first and second round segments each contain 64-bits, and the bit-moving operation is predetermined bit-rotation by 6 bits.</claim-text>
    </claim>
  </claims>
</questel-patent-document>