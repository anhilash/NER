<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182211B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182211</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182211</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="16024606" extended-family-id="13734501">
      <document-id>
        <country>US</country>
        <doc-number>09106083</doc-number>
        <kind>A</kind>
        <date>19980629</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09106083</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>14030843</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>JP</country>
        <doc-number>17707097</doc-number>
        <kind>A</kind>
        <date>19970702</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997JP-0177070</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/38        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>38</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/32        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>32</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>712239000</text>
        <class>712</class>
        <subclass>239000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>712215000</text>
        <class>712</class>
        <subclass>215000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>712238000</text>
        <class>712</class>
        <subclass>238000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>712E09050</text>
        <class>712</class>
        <subclass>E09050</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>712E09077</text>
        <class>712</class>
        <subclass>E09077</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>714718000</text>
        <class>714</class>
        <subclass>718000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/30A3C</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30A3C</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-009/38E2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38E2</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30058</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30058</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3842</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3842</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>3</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>16</number-of-drawing-sheets>
      <number-of-figures>18</number-of-figures>
      <image-key data-format="questel">US6182211</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Conditional branch control method</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>TAKAYAMA SHUICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5928358</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5928358</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>NAKANISHI CHIKAKO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5940857</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5940857</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>STEELE JR GUY L</text>
          <document-id>
            <country>US</country>
            <doc-number>6009515</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6009515</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>OKAZAKI TADASHI</text>
          <document-id>
            <country>US</country>
            <doc-number>6019501</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6019501</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>ITOMITSU FUJIO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5440704</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5440704</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <document-id>
            <country>JP</country>
            <doc-number>57812599</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP57812599</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <document-id>
            <country>JP</country>
            <doc-number>1812599</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP01812599</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>HITACHI LTD</text>
          <document-id>
            <country>JP</country>
            <doc-number>H02130634</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP02130634</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>NEC CORP</text>
          <document-id>
            <country>JP</country>
            <doc-number>H04127237</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP04127237</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>MITSUBISHI ELECTRIC CORP</text>
          <document-id>
            <country>JP</country>
            <doc-number>H0520067</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP05020067</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>KOFU NIPPON DENKI KK</text>
          <document-id>
            <country>JP</country>
            <doc-number>H05173785</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP05173785</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>Patterson, et al., "Computer Architecture: A Quantitative Approach", pp. 262-267 and English translation of pp. 265 121-p. 266 118 thereof.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>Office Action from the Japanese Patent Office dated Mar. 2, 1999 and English translation.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>European Search Report dated Feb. 15, 1999.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>Antonio Gonzalez, "A Survey of Branch Techniques in Pipelined Processors", Microprocessors and Microprogramming, vol. 36, No. 5, Oct. 1, 1993, pp. 243-257, XP00039707.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>Ando, et al., "Speculative Execution and Reducing Branch Penalty on a Superscalar Processor", IEICE Transactions on Electronics, vol. e76c, No. 7, Jul. 1993, pp. 1080-1092, XP000394448.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="6">
          <text>Intrater, et al., "Decoded Instruction Cache for Variable Instruction-Length Computers", Proceedings of the Conference of Electrical and Electronics Engineers in Israel, Tel Aviv, Mar. 7-9, 1989, No. Conf. 16, Mar. 7, 1989, pp. 1-4, XP000077585, Institute of Electrical and Electronics Engineers.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="7">
          <text>Sohie, et al., "A Digital Signal Processor with IEEE Floating-Point Arithmetic", vol. 8, No. 6 + index, Dec. 1, 1988, pp. 49-67, XP000105805.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="8">
          <text>Office Action from the Japanese Patent Office dated Nov. 17, 1998 and English translation.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="9">
          <text>Final Rejection from the Japanese Patent Office dated Jun. 8, 1999 and English translation for Patent Application No. 186570.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Matsushita Electric Industrial Co., Ltd.</orgname>
            <address>
              <address-1>Osaka, JP</address-1>
              <city>Osaka</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>PANASONIC</orgname>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Yamasaki, Masayuki</name>
            <address>
              <address-1>Osaka, JP</address-1>
              <city>Osaka</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Stevens, Daivs, Miller &amp; Mosher, L.L.P.</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Pan, Daniel H.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      In order to effectively reduce branch hazards without a restriction to a structure of a pipeline, the contents of instructions and the like during control of conditional branching in an information processing apparatus which processes an instruction by pipeline processing, before a condition of a conditional branch instruction becomes defined, that is, before a branch judgement is made, pipeline information of a subsequent instruction which is subsequent to the conditional branch instruction is saved so that an instruction beyond a branch is fed to a pipeline in advance.
      <br/>
      When the condition is met, the instruction beyond the branch is executed as it directly is.
      <br/>
      When the condition is not met, the saved pipeline information of the subsequent instruction is returned to the pipeline and the subsequent instruction which is subsequent to the conditional branch instruction is executed.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="2">The present invention relates to a program control method of controlling a conditional branch in an information processing apparatus which processes an instruction by pipeline processing.</p>
    <p num="3">2. Description of the Background Art</p>
    <p num="4">
      In an information processing apparatus which processes an instruction by pipeline processing, while instructions are fed to a pipeline and executed one after another, as the instructions are executed overlapping each other, execution of the instructions is realized at a high speed.
      <br/>
      However, when a conditional branch instruction requires a branch, since an instruction beyond the branch is fetched at a point when the condition is decided, that is, since a branch address is set to a program counter after a branch judgement is made, a wasteful space, namely, a branch hazard is created in the pipeline.
    </p>
    <p num="5">
      Such a branch hazard is more likely to occur when a condition is met than when the condition is not met.
      <br/>
      Branch hazards increase one cycle where there is one instruction fetch stage.
      <br/>
      Branch hazards increase two cycles where there are two instruction fetch stages.
      <br/>
      Further, branch hazards increase N cycles where there are N instruction fetch stages (N is an optional positive integer.).
    </p>
    <p num="6">
      One conventional means for solving the problems is a branch method which uses a so-called delay branch, which requires execution of an instruction located at an address which follows a branch instruction in a delay slot to thereby reduce branch hazards in a pipeline.
      <br/>
      One example of such a conventional branch method is described in Japanese Patent Application Laid-Open Gazette No. 4-127237, for instance.
    </p>
    <p num="7">
      According to the conventional method as described above, since an instruction in a delay slot is executed during a cycle of a branch hazard, execution cycles of a branch instruction reduce on appearance.
      <br/>
      However, in a branch method which utilizes a delay branch described above, since there is a restriction on instructions which can be located in a delay slot, or since it is difficult to appropriately assign instructions to a delay slot if branch hazard have a large number of cycles, or for other reasons, it is not possible to effectively reduce branch hazards in all cases.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="8">The present invention aims at providing a program control method which effectively reduces branch hazards during control of conditional branching in an information processing apparatus which processes an instruction by pipelines processing, without restricting a structure of a pipeline, the contents of an instruction, etc.</p>
    <p num="9">
      A program control method according to the present invention is characterized in that on a premise that a conditional branch instruction includes an address to which a branch is to be made, pipeline information of a subsequent instruction which is subsequent to the conditional branch instruction is saved before a condition of the conditional branch instruction becomes defined, that is, before a branch judgement is made so that an instruction beyond the branch is fed to a pipeline in advance, and the beyond-the-branch instruction is executed as it directly is when the condition is met, but the saved pipeline information of the subsequent instruction is returned to the pipeline and the subsequent instruction which is subsequent to the conditional branch instruction is executed when the condition is not met.
      <br/>
      As the pipeline information of the subsequent instruction described above, the address of the subsequent instruction and the instruction code of the subsequent instruction may be used.
    </p>
    <p num="10">
      In this structure, since the beyond-the-branch instruction is fed to the pipeline in advance before the condition of the conditional branch instruction becomes defined, by the time the condition is met, at lest the first stage of the pipeline processing of the beyond-the-branch instruction is already complete.
      <br/>
      After the condition is met, the pipeline processing of the beyond-the-branch instruction is continued starting at the second stage or one of the following stages.
      <br/>
      Hence, it is possible to reduce branch hazards which are associated with execution of the beyond-the-branch instruction more than where the beyond-the-branch instruction is fed to the pipeline after the condition of the conditional branch instruction becomes defined.
    </p>
    <p num="11">Meanwhile, since pipeline information of a subsequent instruction which is subsequent to the conditional branch instruction is saved before the condition of the conditional branch instruction becomes defined, when the condition is not met, as the saved pipeline information of the subsequent instruction which is subsequent to the conditional branch instruction is returned to the pipeline, the subsequent instruction which is subsequent to the conditional branch instruction is executed without increasing branch hazards.</p>
    <p num="12">Hence, as a whole, it is possible to reduce branch hazards which are created when the condition is met without increasing branch hazards which are created when the condition is not met, execute a program efficiently, and shorten a processing time.</p>
    <p num="13">Further, since the foregoing requires simply to save the pipeline information of the subsequent instruction which is subsequent to the conditional branch instruction and feed the beyond-the-branch instruction to the pipeline in advance before the condition of the conditional branch instruction becomes defined, it is possible to effectively reduce branch hazards without restricting the structure of the pipeline, the contents of instructions, etc.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="14">
      FIG. 1 is a block diagram showing a basic structure of a program control apparatus according to a first, a second, a third and a fourth preferred embodiments of the present invention;
      <br/>
      FIG. 2 is a block diagram showing a specific structure of a program counter portion according to the first and the third preferred embodiments of the present invention;
      <br/>
      FIG. 3 is a block diagram showing a specific structure of a program counter portion according to the second and the fourth preferred embodiments of the present invention;
      <br/>
      FIG. 4 is a block diagram showing a specific structure of an instruction register portion according to the first and the second preferred embodiments of the present invention;
      <br/>
      FIG. 5 is a block diagram showing a specific structure of an instruction register portion according to the third preferred embodiment of the present invention;
      <br/>
      FIG. 6 is a block diagram showing a specific structure of an instruction register portion according to the fourth preferred embodiment of the present invention;
      <br/>
      FIG. 7 is a flowchart which shows a flow of control of conditional branching in a three-stage pipeline according to the first preferred embodiment of the present invention;
      <br/>
      FIG. 8 is a timing chart which shows timing of conditional branching in a three-stage pipeline according to the first preferred embodiment of the present invention;
      <br/>
      FIG. 9 is a flowchart which shows a flow of control of conditional branching in a four-stage pipeline according to the second preferred embodiment of the present invention;
      <br/>
      FIG. 10 is a timing chart which shows timing of conditional branching in a four-stage pipeline according to the second preferred embodiment of the present invention;
      <br/>
      FIG. 11 is a flowchart which shows a flow of control of conditional branching in a four-stage pipeline which includes two stages for fetching instructions according to the third preferred embodiment of the present invention;
      <br/>
      FIG. 12 is a timing chart which sows timing of conditional branching in a four-stage pipeline which includes two stages for fetching instructions according to the third preferred embodiment of the present invention;
      <br/>
      FIG. 13 is a flow chart which shows a flow of control of conditional branching in a five-stage pipeline which includes two stages for fetching instructions according to the third preferred embodiment of the present invention;
      <br/>
      FIG. 14 is a timing chart which shows timing of conditional branching in a five-stage pipeline which includes two stages for fetching instructions according to the third preferred embodiment of the present invention;
      <br/>
      FIG. 15 is a flowchart which shows a flow of control of conditional branching in a six-stage pipeline which includes two stages for fetching instructions according to the fourth preferred embodiment of the present invention;
      <br/>
      FIG. 16 is a timing chart which shows timing of conditional branching in a six-stage pipeline which includes two stages for fetching instructions according to the fourth preferred embodiment of the present invention;
      <br/>
      FIG. 17 is a timing chart which shows timing of conditional branching in a conventional three-stage pipeline; and
      <br/>
      FIG. 18 is a timing chart which shows timing of conditional branching in a conventional four-stage pipeline which includes two stages for fetching instructions.
    </p>
    <heading>DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
    <p num="15">First Preferred Embodiment</p>
    <p num="16">In the following, a program control method and a program control apparatus for conditional branch processing according to a first preferred embodiment of the present invention will be described with reference to the drawings.</p>
    <p num="17">
      FIG. 1 is a block diagram showing a basic structure of a program control apparatus according to the first preferred embodiment of the present invention.
      <br/>
      In FIG. 1, a program counter portion 1 serves as address generation means for reading an instruction code.
      <br/>
      A branch signal 14 which is indicative of a conditional branch instruction and a branch address 15 which corresponds to an address of an instruction beyond a branch are supplied to the program counter portion 1 from a branch judging element 4, and the program counter portion 1 outputs an address 11.
      <br/>
      A memory 2 serves as instruction storing means for storing an instruction code.
      <br/>
      The address 11 is supplied to the memory 2 from the program counter portion 1 and the memory 2 outputs a first instruction code 12 which corresponds to the address 11.
      <br/>
      An instruction register portion 3 serves as instruction control means.
      <br/>
      Receiving the first instruction code 12 from the memory 2 and the branch signal 14 from the branch judging element 4, the instruction register portion 3 outputs a second instruction code 13.
      <br/>
      The branch judging element 4 serves as branch judging means.
      <br/>
      Receiving the second instruction code 13 from the instruction register portion 3 and a condition flag signal 17 from a computing portion 6, the branch judging element 4 judges whether the second instruction code 13 is a conditional branch instruction.
      <br/>
      When the second instruction code 13 is a conditional branch instruction, the branch judging element 4 outputs the branch signal 14 and the address of the beyond-the-branch instruction which is included in the conditional branch instruction, namely, the branch address 15.
      <br/>
      A decoder portion 5 serves as means for decoding an instruction.
      <br/>
      The second instruction code 13 is supplied to the decoder portion 5 from the instruction register portion 3, and the decoder portion 5 outputs a control signal 16.
      <br/>
      The computing portion 6 serves as computing means.
      <br/>
      The control signal 16 is supplied to the computing portion 6 from the decoder portion 5, and the computing portion 6 computes and outputs the condition flag signal 17.
      <br/>
      The structure shown in FIG. 1 is common to structures according to a second through a fourth preferred embodiments which will be described later.
    </p>
    <p num="18">
      FIG. 2 is a block diagram showing a structure of the program counter portion 1 according to the first preferred embodiment of the present invention.
      <br/>
      In FIG. 2, a first program counter 101, serving as first address holding means, receives an address selector output 113 and outputs the address 11.
      <br/>
      An address adder 102, serving as address adding means which increments the address 11, receives the address 11 and outputs an address adder output 114.
    </p>
    <p num="19">
      A second program counter 104 serves as second address holding means which saves an addresses of a subsequent instruction which is subsequent to the conditional branch instruction, which is one of pipeline information of the subsequent instruction which is subsequent to the conditional branch instruction, before a condition of the conditional branch instruction becomes defined.
      <br/>
      The address adder output 114 and a second program counter branch signal 112 are supplied to the second program counter 104, and the second program counter 104 outputs a second program counter output 115.
      <br/>
      The address adder output 114 corresponds to the saved address of a subsequent instruction.
      <br/>
      The second program counter output 115 corresponds to the address of a subsequent instruction which is returned to a pipeline.
    </p>
    <p num="20">
      An address selector 103, serving as address selection means, receives the branch address 15, the address adder output 114, the second program counter output 115 and an address selector branch signal 111, and outputs the address selector output 113.
      <br/>
      When the address selector branch signal 111 is a conditional branch instruction, the address selector 103 selects the branch address 15 as the next address.
      <br/>
      When the address selector branch signal 111 is not a conditional branch instruction, the address selector 103 selects the address adder output 114 as the next address.
      <br/>
      When the conditional branch instruction is not established, at an execution stage for executing the conditional branch instruction, the address selector 103 selects the second program counter output 115 as the next address.
      <br/>
      The structure shown in FIG. 2 is common to a structure according to a third preferred embodiment which will be described later.
    </p>
    <p num="21">When there is a conditional branch instruction, judging that a condition is not met when the condition flag signal 17 is "0," the branch judging element 4 outputs the address selector branch signal 111 and a first instruction register branch signal 311 at the execution stage.</p>
    <p num="22">
      FIG. 4 is a block diagram showing a structure of the instruction register portion 3 according to the first preferred embodiment of the present invention.
      <br/>
      In FIG. 4, a first instruction register 301 serves as first instruction holding means.
      <br/>
      Receiving the first instruction code 12 and the first instruction register branch signal 311, the first instruction register 301 outputs an instruction register output 314.
      <br/>
      In this case, the first instruction register 301 normally stores the first instruction code 12 while updating the first instruction code 12 every cycle.
      <br/>
      When the first instruction register branch signal 311 is received, the first instruction register 301 holds an instruction code of a preceding cycle.
    </p>
    <p num="23">
      An instruction selector 302 serves as instruction selection means.
      <br/>
      The instruction selector 302 receives the instruction register output 314, an NOR code 315 and an instruction selector branch signal 312, and outputs the second instruction code 13.
      <br/>
      In this case, while the instruction selector 302 normally selects the instruction register output 314, when the instruction selector branch signal 312 is received, the instruction selector 302 selects the NOP code.
    </p>
    <p num="24">
      The branch signal 14 is formed by the address selector branch signal 111, the second program counter branch signal 112, the first instruction register branch signal 311 and the instruction selector branch signal 312.
      <br/>
      The structure shown in FIG. 4 is common to a structure according to the second preferred embodiment which will be described later.
    </p>
    <p num="25">Now, operations of the program control apparatus having such a structure described above will be described with reference to FIGS. 7 and 8.</p>
    <p num="26">
      FIG. 7 shows a control flow of execution of a conditional branch instruction for a three-stage pipeline (of an instruction fetch stage IF, an instruction decode stage DEC and an instruction execution stage EX).
      <br/>
      In this case, an address of a conditional branch instruction is an address N, and an address of an instruction beyond a branch is an address M. FIG. 8 is a corresponding timing chart.
      <br/>
      The section (a) corresponds to a case where a condition is met, while the section (b) corresponds to a case where a condition is not met.
      <br/>
      In the following, an operation at each stage of a pipeline will be described.
      <br/>
      The instruction fetch stage will not be described.
    </p>
    <p num="27">(1) Instruction Decode Stage for Conditional Branch Instruction</p>
    <p num="28">
      The branch judging element 4 decodes the second instruction code 13.
      <br/>
      Judging that the second instruction code 13 is a conditional branch instruction, the branch judging element 4 outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="29">(2) Execution Stage for Conditional Branch Instruction.</p>
    <p num="30">
      In accordance with the second program counter branch signal 112, the program counter portion 1 sets an address (N+2) of an instruction two instructions after the conditional branch instruction to the second program counter 104.
      <br/>
      As a result, the address (N+2) of the instruction two instructions after the conditional branch instruction is saved.
    </p>
    <p num="31">The address selector 103 selector branch signal 111, whereby the branch address 15 (M) is set in the first program counter 101 and the address 11 becomes an address M. As a result, before a time point that a branch judgement is made (which is the end of the execution stage for executing the conditional branch instruction), an instruction beyond a branch is fed to the pipeline in advance.</p>
    <p num="32">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="33">Where Condition Is Met:</p>
    <p num="34">(3) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="35">The branch signal 14 is freed and the apparatus returns to the normal operations, so that the second instruction code 13 becomes an instruction at the address M. As a result, the instruction at the address M and the following instructions are executed in a sequence after the conditional branch instruction which is located at the address N, although with one cycle of a branch hazard interposed.</p>
    <p num="36">Where Condition Is Not Met:</p>
    <p num="37">(3) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="38">
      The address selector 103 selects the second program counter output 115 in accordance with the address selector branch signal 111, whereby the value registered in the second program counter 104 is set to the first program counter 101 and the address 11 becomes the address N+2.
      <br/>
      As a result, the saved address of the subsequent instruction is returned to the pipeline.
      <br/>
      Further, the first instruction register 301 holds an instruction at an address N+1 in accordance with the first instruction register branch signal 311, so that the second instruction code 13 becomes the instruction at the address N+1.
      <br/>
      As a result, the instruction at the address N+1 and the following instruction are executed in sequence after the conditional branch instruction which is located at the address N, although with one cycle of a branch hazard interposed.
    </p>
    <p num="39">
      FIG. 17 is a time chart for a conventional example where a conditional branch instruction is executed in a three-stage pipeline (of an instruction fetch stage IF, an instruction decode stage DEC and an instruction execution stage EX).
      <br/>
      The section (a) corresponds to a case where a condition is met, while the section (b) corresponds to a case where a condition is not met.
      <br/>
      In this case, an address of a conditional branch instruction is an address N, and an address of an instruction beyond a branch is an address M.
    </p>
    <p num="40">Comparing FIG. 8 with FIG 17, it is understand that branch hazards are reduced one cycle in the case where the condition is met.</p>
    <p num="41">
      The program control method described above which is shown in FIGS. 1, 2, 4, 7 and 8 is summarized as follows.
      <br/>
      That is, an instruction code at the address 11, which is outputted from the program counter portion 1, is retrieved from the memory 2 to the instruction register portion 3 and a corresponding instruction is executed.
      <br/>
      Therefore, when conditional branching for pipelining the instruction is to be controlled, before a condition of a conditional branch instruction becomes defined, the program counter portion 1 saves an address of an instruction two instruction after the conditional branch instruction, the branch address 15 is set to the program counter portion 1, and the instruction register portion 3 replaces the instruction code with an NOP instruction code.
      <br/>
      When the condition is met, the instructions executed as it directly is.
      <br/>
      When the condition is not met, the saved address of the instruction two instructions after the conditional branch instruction is set to the program counter portion 1, the instruction register portion 3 holds an instruction code of an instruction one instruction after the conditional branch instruction, and the instruction is executed.
    </p>
    <p num="42">
      Meanwhile, the program control apparatus described above which is shown in FIGS. 1, 2, 4, 7 and 8 has the following structure.
      <br/>
      That is, aiming at controlling conditional branching for pipelining an instruction, the apparatus comprises the program counter portion 1 which receives the branch address 15 and the branch signal 14 to generate the address 11, the memory 2 which stores or outputs the first instruction code 12 in accordance with the address 11, the instruction register portion 3 which receives the first instruction code 12 and the branch signal 14 and outputs the second instruction code 13, and the branch judging element 4 which decodes the second instruction code 13, decides a branch and outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="43">
      In this case, the program counter portion 1 is formed by the first and the second program counters 101 and 104, the address selector 103, and the address adder 102.
      <br/>
      The first program counter 101 receives the address selector output 113 and outputs the address 11.
      <br/>
      The address selector 103 receives the branch address 15, the address adder output 114 and the second program counter output 115, and selects and outputs one of the branch address 15, the address adder output 114 and the second program counter output 115 in response to the branch signal 14.
      <br/>
      The address adder 102 increments the address 11.
      <br/>
      The second program counter 104 receives the address adder output 114, and holds the address adder output 114 in response to the branch signal 14.
    </p>
    <p num="44">
      On the other hand, the instruction register portion 3 is formed by the first instruction register 301 and the instruction selector 302.
      <br/>
      The first instruction register 301 receives the first instruction code 12, and holds the first instruction code 12 in response to the branch signal 14.
      <br/>
      The instruction selector 302 receives the first instruction register output 314 and the NOP code 315, and selects either one of the first instruction register output 314 and the NOP code 315 and outputs the first instruction register output 314 or the NOP code 315 as the second instruction code 13 in response to the branch signal 14.
    </p>
    <p num="45">
      In this instruction, before a condition of a conditional branch instruction becomes defined, an address two instructions after the conditional branch instruction is saved in the second program counter 104, the branch address 15 is set to the program counter 101, and the instruction selector 302 selects the NOP code 315.
      <br/>
      When the condition is met, an instruction is executed as it directly is.
      <br/>
      When the condition is not met, the address saved in the second program counter 104 is set to the program counter 101 and the first instruction register 301 holds an instruction code of an instruction one instruction after the conditional branch instruction under control, so that branch hazards are reduced one cycle which are created when the condition of the conditional branch instruction is met.
    </p>
    <p num="46">
      As described above, in accordance with the preferred embodiment, since the branch address 15 is set to the first program counter 101 and consequently fed to a pipeline in advance before a condition of the conditional branch instruction becomes defined, by the time the condition is met, the first stage, i.e., the instruction fetch stage of pipeline processing of an instruction beyond the branch is already complete.
      <br/>
      After the condition is met, the pipeline processing of the beyond-the-branch instruction is continued starting at the second stage, namely the instruction decode stage, and therefore, branch hazards associated with execution of the beyond-the-branch instruction are reduced compared with where the beyond-the-branch instruction is fed to the pipeline after the condition of the conditional branch instruction becomes defined.
    </p>
    <p num="47">
      Meanwhile, an address of a subsequent instruction which is subsequent to the conditional branch instruction is stored in the second program counter 104 before the condition of the conditional branch instruction becomes defined, so that the address of the subsequent instruction which is subsequent to the conditional branch instruction is saved.
      <br/>
      Hence, when the condition is not met, the saved address of the subsequent instruction which is subsequent to the conditional branch instruction is set to the first program counter 101 and consequently returned to the pipeline, and therefore, the subsequently instruction which is subsequent to the conditional branch instruction is executed without increasing branch hazards.
      <br/>
      It then follows that as a whole, it is possible to reduce branch hazards which are created when the condition is met without increasing branch hazards which are created when the condition is not met, execute a program efficiently, and shorten a processing time.
    </p>
    <p num="48">Further, since the foregoing requires simply to save the address of the subsequent instruction which is subsequent to the conditional branch instruction and feed the branch address 15 to the pipeline in advance before the condition of the conditional branch instruction becomes defined, it is possible to effectively reduce branch hazards without restricting the structure of the pipeline, the contents of instructions, etc.</p>
    <p num="49">Although the preferred embodiment described above is related to a three-stage pipeline, a similar effect is obtained with a multi-stage pipeline which comprises four or more stages including two or more instruction decode stages.</p>
    <p num="50">Second Preferred Embodiment</p>
    <p num="51">In the following, a program control method and a program control apparatus for conditional branch processing according to a second preferred embodiment of the present invention will be described with reference to the drawings.</p>
    <p num="52">
      FIG. 3 is a block diagram showing a structure of the program counter portion 1 according to the second preferred embodiment of the present invention.
      <br/>
      A difference from FIG. 2 is that an input to the second program counter 104 is changed to the address 11 from the address adder output 114.
      <br/>
      In FIG. 3, elements which have the same function as those of the elements which are shown in FIG. 2 will be denoted at the same reference symbols as those used in FIG. 2, and a detailed description on those elements will be simply omitted.
      <br/>
      The structure shown in FIG. 3 is common to a structure according to a fourth preferred embodiment which will be described later.
    </p>
    <p num="53">
      According to the second preferred embodiment, the structure of the program counter portion 1 in the basic structure which is shown in FIG. 1 is as shown in FIG. 3, and the structure of the instruction register portion 3 is as shown in FIG. 4.
      <br/>
      The branch signal 14 is formed by the address selector branch signal 111, the second program counter branch signal 112, the first instruction register branch signal 311 and the instruction selector branch signal 312.
    </p>
    <p num="54">Now, operations of the program control apparatus which has such a structure above will be described with reference to FIGS. 9 and 10.</p>
    <p num="55">
      FIG. 9 shows a control flow of execution of a conditional branch instruction for a four-stage pipeline (of an instruction fetch stage IF, a first instruction decode stage DEC1, a second instruction decode stage DEC2 and an instruction execution stage EX).
      <br/>
      In this case, an address of a conditional branch instruction is an address N, and an address of an instruction beyond a branch is an address M. FIG. 10 is a corresponding timing chart.
      <br/>
      The section(a) corresponds to a case where a condition is met, while the section (b) corresponds to a case where a condition is not met.
      <br/>
      In the following, an operation at each stage of a pipeline will be described.
      <br/>
      The instruction fetch stage and the first instruction decode stage will not be described.
    </p>
    <p num="56">(1) Second Instruction Decode Stage for Conditional Branch Instruction</p>
    <p num="57">
      The branch judging element 4 decodes the second instruction code 13.
      <br/>
      Judging that the second instruction code 13 is a conditional branch instruction, the branch judging element 4 outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="58">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="59">(2) Execution Stage for Conditional Branch Instruction</p>
    <p num="60">
      In accordance with the second program counter branch signal 112, the program counter portion 1 sets an address N+2) of an instruction two instructions after the conditional branch instruction to the second program counter 104.
      <br/>
      This saves the address (N+2) of the instruction two instructions after the conditional branch instruction.
    </p>
    <p num="61">The address selector 103 selects the branch address 15 in accordance with the address selector branch signal 111, whereby the branch address 15 is set in the first program counter 101 and the address 11 becomes the address M. As a result, before a time point that a branch judgement is made (which is the end of the execution stage for executing the conditional branch instruction), an instruction beyond a branch is fed to the pipeline in advance.</p>
    <p num="62">The first instruction register 301 holds an instruction at an address N+1 in accordance with the first instruction register branch signal 311, so that the second instruction code 13 becomes the instruction at the address N+1.</p>
    <p num="63">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="64">Where Condition Is Met:</p>
    <p num="65">(3) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="66">The branch signal 14 is freed and the apparatus returns to the normal operations, so that the second instruction code 13 becomes an instruction at the address M.</p>
    <p num="67">As a result, the instruction at the address M and the following instructions are executed in sequence after the conditional branch instruction which is located at the address N, although with two cycles of branch hazards interposed.</p>
    <p num="68">Where Condition In Not Met:</p>
    <p num="69">(3) Next Stage Following Execution Stage for</p>
    <p num="70">Conditional Branch Instruction</p>
    <p num="71">
      The address selector 103 selects the second program counter output 115 in accordance with the address selector branch signal 111, whereby the value registered in the second program counter 104 is set to the first program counter 101 and the address 11 becomes the address N+2.
      <br/>
      As a result, the saved address of the subsequent instruction is returned to the pipeline.
      <br/>
      Further, the first instruction register 301 holds the instruction at the address N+1 in accordance with the first instruction register branch signal 311, so that the second instruction code 13 becomes the instruction at the address N+1.
    </p>
    <p num="72">As a result, the instruction at the address N+1 and the following instructions are executed in sequence after the conditional branch instruction which is located at the address N, although with two cycles of branch hazards interposed.</p>
    <p num="73">
      The program control method described above which is shown in FIGS. 1, 3, 4, 9 and 10 is summarized as follows.
      <br/>
      That is, an instruction code at the address 11, which is outputted from the program counter portion 1, is retrieved from the memory 2 to the instruction register portion 3 and a corresponding instruction is executed.
      <br/>
      Therefore, when conditional branching for pipelining the instruction is to be controlled, before a condition of a conditional branch instruction becomes defined, the instruction register portion 3 replaces the instruction code with the NOP instruction code, the program counter portion 1 thereafter saves an address of an instruction two instructions after the conditional branch instruction, the branch address 15 is set to the program counter portion 1, and the instruction register portion 3 replaces the instruction code with an NOP instruction code.
      <br/>
      When the condition is met, the instruction is executed as it directly is.
      <br/>
      When the condition is not met, the saved address of the instruction two instructions after the conditional branch instruction is set to the program counter portion 1, the instruction register portion 3 holds an instruction code of an instruction one instruction after the conditional branch instruction, and the instruction is executed.
    </p>
    <p num="74">
      Meanwhile, the program control apparatus described above which is shown in FIGS. 1, 3, 4, 9 and 10 has the following structure.
      <br/>
      That is, aiming at controlling conditional branching for pipelining an instruction, the apparatus comprises the program counter portion 1 which receives the branch address 15 and the branch signal 14 to generate the address 11, the memory 2 which stores or outputs the first instruction code 12 in accordance with the address 11, the instruction register portion 3 which receives the first instruction code 12 and the branch signal 14 and outputs the second instruction code 13, and the branch judging element 4 which decodes the second instruction code 13, decides a branch and outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="75">
      In this case, the program counter portion 1 is formed by the first and the second program counters 101 and 104, the address selector 103, and the address adder 102.
      <br/>
      The first program counter 101 receives the address selector output 113 and outputs the address 11.
      <br/>
      The address selector 103 receives the branch address 15, the address adder output 114 and the second program counter output 115, and selects and outputs one of the branch address 15, the address adder output 114 and the second program counter output 115 in response to the branch signal 14.
      <br/>
      The address adder 102 increments the address 11.
      <br/>
      The second program counter 104 receives the address 11, and holds the address 11 in response to the branch signal 14.
    </p>
    <p num="76">
      On the other hand, the instruction register portion 3 is formed by the first instruction register 301 and the instruction selector 302.
      <br/>
      The first instruction register 301 receives the first instruction code 12, and holds the first instruction code 12 in response to the branch signal 14.
      <br/>
      The instruction selector 302 receives the first instruction register output 314 and the NOP code 315, and selects either one of the first instruction register output 314 and the NOP code 315 and outputs the first instruction register output 314 or the NOP code 315 as the second instruction code 13 in response to the branch signal 14.
    </p>
    <p num="77">
      In this structure, before a condition of a conditional branch instruction becomes defined, the instruction selector 302 selects the NOP code 315, an address two instructions after the conditional branch instruction is saved in the second program counter 104, the branch address 15 is set to the program counter 101, and the instruction selector 302 then selects the NOP code 315.
      <br/>
      When the condition is met, an instruction is executed as it directly is.
      <br/>
      When the condition is not met, the address saved in the second program counter 104 is set to the program counter 101 and the first instruction register 302 holds an instruction code of an instruction one instruction after the conditional branch instruction under control, so that branch hazards are reduced one cycle which are created when the condition of the conditional branch instruction is met.
    </p>
    <p num="78">
      As described above, the second preferred embodiment ensure a similar effect to that according to the first preferred embodiment.
      <br/>
      Further, it is possible to provide one more stage for a branch judgement according to the second preferred embodiment than in the first preferred embodiment.
    </p>
    <p num="79">Although the second preferred embodiment described above is related to a four-stage pipeline, a similar effect is obtained with a multi-stage pipeline which comprises five or more stages including three or more instruction decode stages.</p>
    <p num="80">
      In addition, a four-stage pipeline can be realized with the first preferred embodiment as well, if the structure described immediately above is modified in such a manner that the address (N+2) two instructions after the conditional branch instruction is set to the second program counter 104 at the second instruction decode stage instead of at the execution stage.
      <br/>
      More precisely, a difference from the first preferred embodiment lies in the timing of saving the subsequent instruction subsequent to the conditional branch instruction.
      <br/>
      With respect to saving of the address N+2, between where the address 11 is saved and where an output from the address adder 102 is saved, the timing of saving shifts one cycle.
    </p>
    <p num="81">Third Preferred Embodiment</p>
    <p num="82">In the following, a program control method and a program control apparatus for conditional branch processing according to a third preferred embodiment of the present invention will be described with reference to the drawings.</p>
    <p num="83">
      FIG. 5 is a block diagram showing a structure of the instruction register portion 3 according to the third preferred embodiment of the present invention.
      <br/>
      A difference from FIG. 4 is that the third preferred embodiment requires a second instruction register 303 which serves as second instruction holding means which receives the first instruction code 12 and a second instruction register branch signal 313 and outputs a second instruction register output 316 and that the instruction selector 302 selects the first instruction register output 314 or the second instruction register output 316 in accordance with the instruction selector branch signal 312.
      <br/>
      The second instruction register 303 has a function of saving an instruction code of a subsequent instruction which is subsequent to a conditional branch instruction.
      <br/>
      The instruction selector 302, selecting the second instruction register output 316 when a condition is not met, exhibits a function of returning the saved instruction code of the subsequent instruction to a pipeline.
      <br/>
      In FIG. 5, elements which have the same function as those of the elements which are shown in FIG. 4 will be denoted at the same reference symbols as those used in FIG. 4, and a detailed description on those elements will be simply omitted.
    </p>
    <p num="84">
      According to the third preferred embodiment, the structure of the program counter portion 1 in the basic structure which is shown in FIG. 1 is as shown in FIG. 2, and the structure of the instruction register portion 3 is as shown in FIG. 5.
      <br/>
      The branch signal 14 is formed by the address selector branch signal 111, the second program counter branch signal 112, the first instruction register branch signal 311, the instruction selector branch signal 312 and the second instruction register branch signal 313.
    </p>
    <p num="85">Now, operations of the program control apparatus which has such a structure above will be described with reference to FIGS. 11 and 12.</p>
    <p num="86">
      FIG. 11 shows a control flow of execution of a conditional branch instruction for a four-stage pipeline (of a first instruction fetch stage IF1, a second instruction fetch stage IF2, an instruction decode stage DEC, and an instructional execution stage EX) which includes two stages for fetching instructions.
      <br/>
      In this case, an address of a conditional branch instruction is an address N, and an address of an instruction beyond a branch is an address M. FIG. 12 is a corresponding timing chart.
      <br/>
      The section (a) corresponds to a case where a condition is met, while the section (b) corresponds to a case where a condition is not met.
      <br/>
      In the following, an operation at each stage of a pipeline will be described.
      <br/>
      The first instruction fetch stage and the second instruction fetch stage will not be described.
    </p>
    <p num="87">(1) Instruction Decode Stage for Conditional Branch Instruction</p>
    <p num="88">
      The branch judging element 4 decodes the second instruction code 13.
      <br/>
      Judging that the second instruction code 13 is a conditional branch instruction, the branch judging element 4 outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="89">(2) Execution Stage for Conditional Branch Instruction</p>
    <p num="90">
      In accordance with the second program counter branch signal 112, an address (N+3) of an instruction three instructions after the conditional branch instruction is set to the second program counter 104.
      <br/>
      This saves the address (N+3) of the instruction three instructions after the conditional branch instruction.
    </p>
    <p num="91">The address selector 103 selects the branch address 15 in accordance with the address selector branch signal 111, whereby the branch address 15 is set in the first program counter 101 and the address 11 becomes the address M. As a result, before a time point that a branch judgment is made (which is the end of the execution stage for executing the conditional branch instruction), an instruction beyond a branch is fed to the pipeline in advance.</p>
    <p num="92">
      In accordance with the second instruction register branch signal 313, an instruction code (N+1) of an instruction one instruction after the conditional branch instruction is set to the second instruction register 303.
      <br/>
      This saves the instruction code (N+1) of the instruction one instruction after the conditional branch instruction.
    </p>
    <p num="93">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="94">Where Condition Is Met:</p>
    <p num="95">(3) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="96">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="97">(4) Second Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="98">The branch signal 14 is freed and the apparatus returns to the normal operations, so that the second instruction code 13 becomes an instruction at the address M. As a result, the instruction at the address M and the following instructions are executed in sequence after the conditional branch instruction which is located at the address N, although with two cycles of branch hazards interposed.</p>
    <p num="99">Where Condition Is Not Met:</p>
    <p num="100">(3) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="101">
      The address selector 103 selects the second program counter output 115 in accordance with the address selector branch signal 111, whereby the value registered in the second program counter 104 is set to the first program counter 101 and the address 11 becomes the address N+3.
      <br/>
      As a result, the saved address of the subsequent instruction is returned to the pipeline.
    </p>
    <p num="102">
      Meanwhile, the instruction selector 302 selects the second instruction register output 316 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an instruction at the address N+1.
      <br/>
      As a result, the saved instruction code of the subsequent instruction is returned to the pipeline.
    </p>
    <p num="103">(4) Second Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="104">The first instruction register 301 holds the instruction at the address N+2in accordance with the first instruction register branch signal 311, so that the second instruction code 13 becomes the instruction at the address N+2.</p>
    <p num="105">As a result, the instruction at the address N+1 and the following instructions are executed in sequence after the conditional branch instruction which is located at the address N, although with one cycle of a branch hazard interposed.</p>
    <p num="106">
      FIG. 18 is a time chart for a conventional example where a conditional branch instruction is executed in a four-stage pipeline (of a first instruction fetch stage IF1, a second instruction fetch stage IF2, an instruction decode stage DEC and an instruction execution stage EX).
      <br/>
      The section (a) corresponds to a case where a condition is met, while the section (b) corresponds to a case where a condition is not met.
      <br/>
      In this case, an address of a conditional branch instruction is an address N, and an address of an instruction beyond a branch is an address M.
    </p>
    <p num="107">Comparing FIG. 12 with FIG. 18, it is understood that branch hazards are reduced one cycle in the case where the condition is met.</p>
    <p num="108">Next, operations of a five-stage pipeline will be described with reference to FIGS. 13 and 14.</p>
    <p num="109">
      FIG. 13 shows a control flow of execution of a conditional branch instruction for a five-stage pipeline (of a first instruction fetch stage IF1, a second instruction fetch stage IF2, a first instruction decode stage DEC1, a second instruction decode stage DEC2 and an instruction execution stage EX) which includes two stages for fetching instructions.
      <br/>
      In this case, an address of a conditional branch instruction is an address N, and an address of an instruction beyond a branch is an address M. FIG. 14 is a corresponding timing chart.
      <br/>
      The section (a) corresponds to a case where a condition is met, while the section (b) corresponds to a case where a condition is not met.
      <br/>
      In the following, an operation at each stage of a pipeline will be described.
      <br/>
      The first instruction fetch stage, the second instruction fetch stage and the first instruction decode stage will not be described.
    </p>
    <p num="110">(1) Second Instruction Decode Stage for Conditional Branch Instruction</p>
    <p num="111">
      The branch judging element 4 decodes the second instruction code 13.
      <br/>
      Judging that the second instruction code 13 is a conditional branch instruction, the branch judging element 4 outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="112">
      In accordance with the second program counter branch signal 112, an address (N+3) of an instruction three instructions after the conditional branch instruction is set to the second program counter 104.
      <br/>
      This saves the address (N+3) of the instruction three instructions after the conditional branch instruction.
    </p>
    <p num="113">The address selector 103 selects the branch address 15 in accordance with the address selector branch signal 111, whereby the address 15 is set to the first program counter 101 and the address 11 becomes the address M. As a result, before a time point that a branch judgment is made (which is the end of the execution stage for executing the conditional branch instruction), an instruction beyond a branch is fed to the pipeline in advance.</p>
    <p num="114">
      In accordance with the second instruction register branch signal 313, an instruction code (N+1) of an instruction one instruction after the conditional branch instruction is set to the second instruction register 303.
      <br/>
      This saves the instruction code (N+1) of the instruction one instruction after the conditional branch instruction.
    </p>
    <p num="115">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="116">(2) Execution Stage for Conditional Branch Instruction</p>
    <p num="117">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="118">Where Condition Is Met:</p>
    <p num="119">(3) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="120">The branch signal 14 is freed and the apparatus returns to the normal operations, so that the second instruction code 13 becomes an instruction at the address M.</p>
    <p num="121">As a result, the instruction at the address M and the following instructions are executed in sequence after the conditional branch instruction which is located at the addresses N, although the with two cycles of branch hazards interposed.</p>
    <p num="122">Where Condition Is Not Met:</p>
    <p num="123">(3) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="124">
      The address selector 103 selects the second program counter outputs 115 in accordance with the address selector branch signal 111, whereby the value registered in the second program counter 104 is set to the first program counter 101 and the address 11 becomes the address N+3.
      <br/>
      As a result, the saved address of the subsequent instruction is returned to the pipeline.
    </p>
    <p num="125">The first instruction register 301 holds the instruction at the address N+2 in accordance with the first instruction register branch signal 311, so that the second instruction code 13 becomes the instruction at the address N+2.</p>
    <p num="126">
      The instruction selector 302 selects the second instruction register output 316 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an instruction at the address N+1.
      <br/>
      As a result, the saved instruction code of the subsequent instruction is returned to the pipeline.
    </p>
    <p num="127">(4) Second Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="128">The first instruction register 301 holds the instruction at the address N+2 in accordance with the first instruction register branch signal 311, so that the second instruction code 13 becomes the instruction at the address N+2.</p>
    <p num="129">As a result, the instruction at the address N+1 and the following instructions are executed in sequence after the conditional branch instruction which is located at the address N, although with two cycles of branch hazards interposed.</p>
    <p num="130">
      The program control method described above which is shown in FIGS. 1, 2, 5, 11, 12, 13 and 14 is summarized as follows.
      <br/>
      That is, an instruction code at the address 11, which is outputted from the program counter portion 1, is retrieved from the memory 2 to the instruction register portion 3 and a corresponding instruction is executed.
      <br/>
      Therefore, when conditional branching for pipelining the instruction is to be controlled, before a condition of a conditional branch instruction becomes defined, the program counter portion 1 saves an address of an instruction three instructions after the conditional branch instruction, the branch address 15 is set to the program counter portion 1, the instruction register portion 3 saves an instruction code of an instruction one instruction after the conditional branch instruction, and the instruction register portion 3 replaces the instruction code with an NOP instruction code.
      <br/>
      When the condition is met, the instruction is executed as it directly is.
      <br/>
      When the condition is not met, the saved address of the instruction three instructions after the conditional branch instruction is set to the program counter portion 1, the instruction register portion 3 replaces the instruction code with the saved instruction code of the instruction one instruction after the conditional branch instruction, the first instruction register 301 then holds an instruction code of an instruction two instructions after the conditional branch instruction, and the instruction is executed.
      <br/>
      In the case which is shown in FIGS. 13 and 14, there are two steps for replacing an instruction code with an NOP instruction code.
    </p>
    <p num="131">
      Meanwhile, the program control apparatus described above which is shown in FIGS. 1, 2, 5, 11, 12, 13 and 14 has the following structure.
      <br/>
      That is, aiming at controlling conditional branching for pipelining an instruction, the apparatus comprises the program counter portion 1 which receives the branch address 15 and the branch signal 14 to generate the address 11, the memory 2 which stores or outputs the first instruction code 12 in accordance with the address 11, the instruction register portion 3 which receives the first instruction code 12 and the branch signal 14 and outputs the second instruction code 13, and the branch judging element 4 which decodes the second instruction code 13, decides a branch and outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="132">
      In this case, the program counter portion 1 is formed by the first and the second program counters 101 and 104, the address selector 103, and the address adder 102.
      <br/>
      The first program counter 101 receives the address selector output 113 and outputs the address 11.
      <br/>
      The address selector 103 receives the branch address 15, the address adder output 114 and the second program counter output 115, and selects and outputs one of the branch address 15, the address adder output 114 and the second program counter output 115 in response to the branch signal 14.
      <br/>
      The address adder 102 increments the address 11.
      <br/>
      The second program counter 104 receives the address adder output 114, and holds the address adder output 114 in response to the branch signal 14.
    </p>
    <p num="133">
      On the other hand, the instruction register portion 3 is formed by the first and the second instruction registers 301, 303 and the instruction selector 302.
      <br/>
      The first instruction register 301 receives the first instruction code 12, and holds the first instruction code 12 in response to the branch signal 14.
      <br/>
      The second instruction register 303 receives the first instruction code 12, and holds the first instruction cod 12 in response to the branch signal 14.
      <br/>
      The instruction selector 302 receives the first instruction register output 314, the second instruction register output 316 and the NOP code 315, and selects either one of the first instruction register output 314, the second instruction register output 316 and the NOP code 315 and outputs the first instruction register output 314, the second instruction register output 316 or the NOP code 315 as the second instruction code 13 in response to the branch signal 14.
    </p>
    <p num="134">
      In this structure, before a condition of a conditional branch instruction becomes defined, an address of an instruction three instructions after the conditional branch instruction is saved in the second program counter 104, the branch address 15 is set to the program counter 101, an instruction code of an instruction one instruction after the conditional branch instruction is saved to the second instruction register 303, and the instruction selector 302 selects the NOP code 315.
      <br/>
      When the condition is met, an instruction is executed as it directly is.
      <br/>
      When the condition is not met, the address saved in the second program counter 104 is set to the program counter 101, the instruction selector 302 selects the second instruction register 303, the first instruction register 301 holds an instruction code of an instruction two instructions after the conditional branch instruction and the instruction is executed under control, so that branch hazards are reduced two cycles which are created when the condition of the conditional branch instruction is met in a structure in which there are two stages for fetching instructions.
    </p>
    <p num="135">
      As described above, according to the third preferred embodiment, since the branch address 15 is set to the first program counter 101 and consequently fed to a pipeline in advance before a condition of the conditional branch instruction becomes defined, by the time the condition is met, the first stage, i.e., the instruction fetch stage of pipeline processing of an instruction beyond the branch is already complete.
      <br/>
      After the condition is met, the pipeline processing of the beyond-the-branch instruction is continued starting at the second stage, namely the instruction decode stage, and therefore, branch hazards associated with execution of the beyond-the-branch instruction are reduced compared with where the beyond-the-branch instruction is fed to the pipeline after the condition of the conditional branch instruction becomes defined.
    </p>
    <p num="136">
      Meanwhile, an address of a subsequent instruction which is subsequent to the conditional branch instruction is stored in the second program counter 104 before the condition of the conditional branch instruction becomes defined and the first instruction register output 314 is stored in the second instruction register 303, so that the instruction code of the subsequent instruction which is subsequent to the conditional branch instruction is saved.
      <br/>
      Hence, when the condition is not met, the saved address of the subsequent instruction which is subsequent to the conditional branch instruction is set to the first program counter 101 and consequently returned to the pipeline, while the instruction code is outputted from the second instruction register 303 and consequently returned to the pipeline, and therefore, the subsequent instruction which is subsequent to the conditional branch instruction is executed without increasing branch hazards.
      <br/>
      It then follows that as a whole, it is possible to reduce branch hazards which are created when the condition is met without increasing branch hazards which are created when then condition is not met, execute a program efficiently, and shorten a processing time.
    </p>
    <p num="137">Further, since the foregoing requires simply to save the address and the instruction code of the subsequent instruction which is subsequent to the conditional branch instruction and feed the branch address 15 to the pipeline in advance before the condition of the conditional branch instruction becomes defined, it is possible to effectively reduce branch hazards without restricting the structure of the pipeline, the contents of instructions, etc.</p>
    <p num="138">In the case of a four-stage pipeline, the contents of instructions, etc.</p>
    <p num="139">
      In the case of a four-stage pipeline which includes two stages for fetching instructions, in particular, it is possible to reduce branch hazards one cycle which are created when the condition is met.
      <br/>
      In addition, in the case of a five-stage pipeline which includes two stages for fetching instructions, it is possible to reduce branch hazards two cycles which are created when the condition is met.
    </p>
    <p num="140">
      Although the foregoing has described that there are two stages for fetching instructions, it is clearly understood that a structure with an optional number of fetch stages more than two ensures the same effect if instruction registers are additionally disposed in accordance with the number of the fetch stages.
      <br/>
      While the description above is related to where there is one instruction decode stage and where there are two instruction decode stages, the same effect is nevertheless obtained even where there are three or more instruction decode stages.
      <br/>
      Where there are three or more instruction fetch stages, in particular, if three or more instruction decode stages are disposed, it is possible to reduce branch hazards three or more cycles which are created when the condition is met.
    </p>
    <p num="141">Fourth Preferred Embodiment</p>
    <p num="142">In the following, a program control method and a program control apparatus for conditional branch processing according to a fourth preferred embodiment of the present invention will be described with reference to the drawings.</p>
    <p num="143">
      FIG. 6 is a block diagram showing a structure of the instruction register portion 3 according to the fourth preferred embodiment of the present invention.
      <br/>
      A difference from FIG. 5 is that an input to the second instruction register 303 which serves as the second instruction holding means is changed to the first instruction register output 314 from the first instruction code 12.
      <br/>
      In FIG. 6, elements which have the same function as those of the elements which are shown in FIG. 5 will be denoted at the same reference symbols as those used in FIG. 5, and a detailed description on those elements will be simply omitted.
    </p>
    <p num="144">
      According to the fourth preferred embodiment, the structure of the program counter portion 1 in the basic structure which is shown in FIG. 1 is as shown in FIG. 3, and the structure of the instruction register portion 3 is as shown in FIG. 6.
      <br/>
      The branch signal 14 is formed by the address selector branch signal 111, the second program counter branch signal 112, the first instruction register branch signal 311, the instruction selector branch signal 312 and the second instruction register branch signal 313.
    </p>
    <p num="145">Now, operations of the program control apparatus which has such a structure above will be described with reference to FIGS. 15 and 16.</p>
    <p num="146">
      FIG. 15 shows a control flow of execution of a conditional branch instruction for a six-stage pipeline (of a first instruction fetch stage IF1, a second instruction fetch stage IF2, a first instruction decode stage DEC1, a second instruction decode stage DEC2, a third instruction decode stage DEC3 and an instruction execution stage EX) which includes two stages for fetching instructions.
      <br/>
      In this case, an address of a conditional branch instruction is an address N, and an address of an instruction beyond a branch is an address M. FIG. 16 is a corresponding timing chart.
      <br/>
      In the following, an operation at each stage of a pipeline will be described.
      <br/>
      The first instruction fetch stage, the second instruction fetch stage and the first instruction decode stage will not be described.
    </p>
    <p num="147">(1) Second Instruction Decode Stage for Conditional Branch Instruction</p>
    <p num="148">
      The branch judging element 4 decodes the second instruction code 13.
      <br/>
      Judging that the second instruction code 13 is a conditional branch instruction, the branch judging element 4 outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="149">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="150">(2) Third Instruction Decode Stage for Conditional Branch Instruction</p>
    <p num="151">
      In accordance with the second program counter branch signal 112, an address (N+3) of an instruction three instructions after the conditional branch instruction is set to the second program counter 104.
      <br/>
      This saves the address (N+3) of the instruction three instructions after the conditional branch instruction.
    </p>
    <p num="152">The address selector 103 selects the branch address 15 in accordance with the address selector branch signal 111, whereby the address 15 is set to the first program counter 101 and the address 11 becomes the address M. As a result, before a time point that a branch judgment is made (which is the end of the execution stage for executing the conditional branch instruction), an instruction beyond a branch is fed to the pipeline in advance.</p>
    <p num="153">
      In accordance with the second instruction register branch signal 313, an instruction code (N+1) of an instruction one instruction after the conditional branch instruction is set to the second instruction register 303.
      <br/>
      This saves the instruction code (N+1) of the instruction one instruction after the conditional branch instruction.
    </p>
    <p num="154">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="155">(3) Execution Stage for Condition Branch Instruction</p>
    <p num="156">The instruction selector 302 selects the NOP code (i.e., No Operation code) 315 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an NOP instruction.</p>
    <p num="157">Where Condition Is Met:</p>
    <p num="158">(4) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="159">The branch signal 14 is freed and the apparatus returns to the normal operations, so that the second instruction code 13 becomes an instruction at the address M.</p>
    <p num="160">As a result, the instruction at the address M and the following instructions are executed in sequence after the conditional branch instruction which is located at the address N, although with three cycles of branch hazards interposed.</p>
    <p num="161">Where Condition Is Not Met:</p>
    <p num="162">(4) Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="163">
      The address selector 103 selects the second program counter output 115 in accordance with the address selector branch signal 111, whereby the value registered in the second program counter 104 is set to the first program counter 101 and the address 11 becomes the address N+3.
      <br/>
      As a result, the saved address of the subsequent instruction is returned to the pipeline.
      <br/>
      The first instruction register 301 holds the instruction at the address N+2 in accordance with the first instruction register branch signal 311.
    </p>
    <p num="164">
      The instruction selector 302 selects the second instruction register output 316 in accordance with the instruction selector branch signal 312, whereby the second instruction code 13 becomes an instruction at the address N+1.
      <br/>
      As a result, the saved instruction code of the subsequent instruction is returned to the pipeline.
    </p>
    <p num="165">(5) Second Next Stage Following Execution Stage for Conditional Branch Instruction</p>
    <p num="166">The first instruction register 301 holds the instruction at the address N+2 in accordance with the first instruction register branch signal 311, so that the second instruction code 13 becomes the instruction at the address N+2.</p>
    <p num="167">As a result, the instruction at the address N+1 and the following instructions are executed in sequence after the conditional branch instruction which is located at the address N, although with three cycles of branch hazards interposed.</p>
    <p num="168">
      The program control method described above which is shown in FIGS. 1, 2, 5, 11, 12, 15 and 16 is summarized as follows.
      <br/>
      That is, an instruction code at the address 11, which is outputted from the program counter portion 1, is retrieved from the memory 2 to the instruction register portion 3 and a corresponding instruction is executed.
      <br/>
      Therefore, when conditional branching for pipelining the instruction is to be controlled, before a condition of a conditional branch instruction becomes defined, the instruction register portion 3 replaces the instruction code with an NOP instruction code, the program counter portion 1 then saves an address of an instruction three instructions after the conditional branch instruction, the branch address 15 is set to the program counter portion 1, the instruction register portion 3 saves an instruction code of an instruction one instruction after the conditional branch instruction, the instruction register portion 3 replaces the instruction code with an NOP instruction code, the instruction register portion 3 holds an instruction two instructions after the conditional branch instruction, and the instruction register portion 3 replaces the instruction code with an NOP instruction code.
      <br/>
      When the condition is met, the instruction is executed as it directly is.
      <br/>
      When the condition is not met, the saved address of the instruction three instructions after the conditional branch instruction is set to the program counter portion 1, the instruction register portion 3 replaces the instruction code with the saved instruction code of the instruction one instruction after the conditional branch instruction, the instruction register portion 3 then holds the instruction code of an instruction two instructions after the conditional branch instruction, and the instruction is executed.
    </p>
    <p num="169">
      Meanwhile, the program control apparatus described above which is shown in FIGS. 1, 2, 5, 11, 12, 15 and 16 has the following structure.
      <br/>
      That is, aiming at controlling conditional branching for pipelining an instruction, the apparatus comprises the program counter portion 1 which receives the branch address 15 and the branch signal 14 to generate the address 11, the memory 2 which stores or outputs the first instruction code 12 in accordance with the address 11, the instruction register portion 3 which receives the first instruction code 12 and the branch signal 14 and outputs the second instruction code 13, and the branch judging element 4 which decodes the second instruction cod 13, decides a branch and outputs the branch signal 14 and the branch address 15.
    </p>
    <p num="170">
      In this case, the program counter portion 1 is formed by the first and the second program counters 101 and 104, the address selector 103, and the address adder 102.
      <br/>
      The first program counter 101 receives the address selector output 113 and outputs the address 11.
      <br/>
      The address selector 103 receives the branch address 15, the address adder output 114 and the second program counter output 115, and a selects and outputs one of the branch address 15, the address adder output 114 and the second program counter output 115 in response to the branch signal 14.
      <br/>
      The address adder 102 increments the address 11.
      <br/>
      The second program counter 104 receives the address 11, and holds the address 11 in response to the branch signal 14.
    </p>
    <p num="171">
      On the other hand, the instruction register portion 3 is formed by the first and the second instruction registers 301, 303 and the instruction selector 302.
      <br/>
      The first instruction register 301 receives the first instruction code 12, and holds the first instruction code 12 in response to the branch signal 14.
      <br/>
      The second instruction register 303 receives the first instruction register output 314, and holds the first instruction register output 314 in response to the branch signal 14.
      <br/>
      The instruction selector 302 receives the first instruction register output 314, the second instruction register output 316 and the NOP code 315, and selects either one of the first instruction register output 314, the second instruction register output 316 and the NOP code 315 and outputs the first instruction register output 314, the second instruction register output 316 or the NOP code 315 as the second instruction code 13 in response to the branch signal 14.
    </p>
    <p num="172">
      In this structure, before a condition of a conditional branch instruction becomes defined, the instruction selector 302 selects the NOP instruction code 315, an address of an instruction three instructions after the conditional branch instruction is saved in the second program counter 104, the branch address 15 is set to the program counter 101, an instruction code of an instruction one instruction after the conditional branch instruction is saved to the second instruction register 303, and the instruction selector 302 selects the NOP code 315.
      <br/>
      When the condition is met, an instruction is executed as it directly is.
      <br/>
      When the condition is not met, the address saved in the second program counter 104 is set to the program counter 101, the instruction selector 302 selects the second instruction register 303, the first instruction register 301 holds an instruction code of an instruction two instructions after the conditional branch instruction and the instruction is executed under control, so that branch hazards are reduced two cycles which are created when the condition of the conditional branch instruction is met in a structure in which there are two stages for fetching instructions.
    </p>
    <p num="173">
      As described above, according to the fourth preferred embodiment, as in the third preferred embodiment described earlier, in the case of a six-stage pipeline which includes two stages for fetching instructions, it is possible to reduce branch hazards two cycles which are created when the condition is met.
      <br/>
      Further, it is possible to provide one more stage for a branch judgment than in the third preferred embodiment.
    </p>
    <p num="174">
      Although described immediately above is related to where there are two stages for fetching instructions, it is clearly understood that a structure with an optional number of fetch stages more than two ensures the same effect if instruction registers are additionally disposed in accordance with the number of the fetch stages.
      <br/>
      A similar effect is obtained even where there are four or more instruction decode stages.
    </p>
    <p num="175">
      In addition, a six-stage pipeline can be realized with the third preferred embodiment as well, if the structure described immediately above is modified in such a manner that the address (N+3) three instructions after the conditional branch instruction is set to the second program counter 104 at the second instruction decode stage the instruction code (N+1) of the instruction one instruction after the conditional branch instruction is set to the second instruction register 303 at the second instruction decode stage.
      <br/>
      More precisely, a difference from the third preferred embodiment lies in the timing of saving the subsequent instruction subsequent to the conditional branch instruction.
      <br/>
      This difference is as already described in relation to the second preferred embodiment.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A program control method of controlling conditional branching in an information processing apparatus which processes an instruction by pipeline processing without using a branch predictor, said method comprising:</claim-text>
      <claim-text>storing, outside a pipeline, pipeline information of an original pipeline instruction, prior to a condition of a conditional branch instruction being determined, said pipeline information of said original pipeline instruction being subsequent to said conditional branch instruction in said pipeline, said pipeline information of said original pipeline instruction being stored outside said pipeline independently of a determination of said condition of said conditional branch instruction, so that a first branch instruction of a branch identified by said conditional branch instruction is fed to said pipeline in advance of the determination of said condition of said conditional branch, so as to replace said original pipeline instruction with said first branch instruction in said pipeline, wherein:</claim-text>
      <claim-text>- when the condition of said conditional branch is met, said first branch instruction is executed by said information processing apparatus, and - when the condition of said conditional branch is not met, said original pipeline instruction is returned to said pipeline and executed.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The program control method of claim 1, wherein said pipeline information of said original pipeline instruction is formed by a subsequent address.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. A conditional branch control method, wherein for pipeline processing of an instruction within an information processing apparatus, said instruction is decoded, and if said instruction is a conditional branch instruction, then before a condition for said conditional branch instruction becomes definite, an address of a subsequent instruction, which is subsequent to said conditional branch instruction, and an instruction code of said subsequent instruction are saved as pipeline information regarding said subsequent instruction, and an instruction of a branch destination is fed to a pipeline as precedence, and said instruction of said branch destination is executed when said condition is met, but said address and said instruction code of said subsequent instruction which are saved are returned to said pipeline and said subsequent instruction is executed when said condition is not met.</claim-text>
    </claim>
  </claims>
</questel-patent-document>