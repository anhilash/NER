<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06181975B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06181975</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6181975</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="24676137" extended-family-id="58821791">
      <document-id>
        <country>US</country>
        <doc-number>09028443</doc-number>
        <kind>A</kind>
        <date>19980224</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09028443</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>60085962</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>2844398</doc-number>
        <kind>A</kind>
        <date>19980224</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09028443</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>66693896</doc-number>
        <kind>A</kind>
        <date>19960619</date>
        <priority-linkage-type>1</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1996US-08666938</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G05B  13/02        20060101AFI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>13</main-group>
        <subgroup>02</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G05B   9/02        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>9</main-group>
        <subgroup>02</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G05B  13/04        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>13</main-group>
        <subgroup>04</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="4">
        <text>G05B  23/02        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>23</main-group>
        <subgroup>02</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>700029000</text>
        <class>700</class>
        <subclass>029000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>700028000</text>
        <class>700</class>
        <subclass>028000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>700047000</text>
        <class>700</class>
        <subclass>047000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>700048000</text>
        <class>700</class>
        <subclass>048000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>700049000</text>
        <class>700</class>
        <subclass>049000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>700050000</text>
        <class>700</class>
        <subclass>050000</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>714724000</text>
        <class>714</class>
        <subclass>724000</subclass>
      </further-classification>
      <further-classification sequence="7">
        <text>714725000</text>
        <class>714</class>
        <subclass>725000</subclass>
      </further-classification>
      <further-classification sequence="8">
        <text>714728000</text>
        <class>714</class>
        <subclass>728000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G05B-023/02S4M4</text>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>023</main-group>
        <subgroup>02S4M4</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G05B-023/02S6C</text>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>023</main-group>
        <subgroup>02S6C</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G05B-023/0254</classification-symbol>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>23</main-group>
        <subgroup>0254</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G05B-023/0262</classification-symbol>
        <section>G</section>
        <class>05</class>
        <subclass>B</subclass>
        <main-group>23</main-group>
        <subgroup>0262</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>59</number-of-claims>
    <exemplary-claim>13</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>96</number-of-drawing-sheets>
      <number-of-figures>36</number-of-figures>
      <image-key data-format="questel">US6181975</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Industrial process surveillance system</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>LUNZ KENNETH G, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5164895</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5164895</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>WHITE ANDREW M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5586066</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5586066</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>SHIMIZU TAKANORI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5689416</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5689416</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>KEELER JAMES D, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6002839</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6002839</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>ELLIS S</text>
          <document-id>
            <country>US</country>
            <doc-number>3851157</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US3851157</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <text>HASHEMIAN HASHEM M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4295128</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4295128</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>MOTT JACK E</text>
          <document-id>
            <country>US</country>
            <doc-number>4937763</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4937763</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>RAHHAL RODGER G</text>
          <document-id>
            <country>US</country>
            <doc-number>4975685</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4975685</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>TAKEUCHI KENJI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5009833</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5009833</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>KROGMANN UWE</text>
          <document-id>
            <country>US</country>
            <doc-number>5222065</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5222065</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>GROSS KENNY C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5223207</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5223207</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>THAKORE PRASHANT B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5255208</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5255208</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="13">
          <text>NIIDA KAZUO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5402521</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5402521</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="14">
          <text>GROSS KENNETH C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5410492</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5410492</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="15">
          <text>GROSS KENNETH C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5459675</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5459675</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="16">
          <text>QIN S JOE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5680409</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5680409</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="17">
          <text>HITACHI LTD</text>
          <document-id>
            <country>EP</country>
            <doc-number>0626697</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-626697</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="18">
          <text>LISZKA LUDWIK</text>
          <document-id>
            <country>WO</country>
            <doc-number>9016048</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>WO9016048</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>Satnam Alag and Alice M. Agogino; "Intelligent Sensor Validation For On-Line Process Monitoring Diagnosis and Control"; Final Report 1993-94.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>B.R. Upadhyaya et al.; "An Integrated Approach For Sensor Failure Detection In Dynamic Processes"; Mar. 1987.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <continuation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>66693896</doc-number>
              <kind>A</kind>
              <date>19960619</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>5764509</doc-number>
              <kind>A</kind>
            </document-id>
          </parent-doc>
        </relation>
      </continuation>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>ARCH Development Corporation</orgname>
            <address>
              <address-1>Chicago, IL, US</address-1>
              <city>Chicago</city>
              <state>IL</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>ARCH DEVELOPMENT</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Gross, Kenneth C.</name>
            <address>
              <address-1>Bolingbrook, IL, US</address-1>
              <city>Bolingbrook</city>
              <state>IL</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Wegerich, Stephan W</name>
            <address>
              <address-1>Glendale Heights, IL, US</address-1>
              <city>Glendale Heights</city>
              <state>IL</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Singer, Ralph M.</name>
            <address>
              <address-1>Naperville, IL, US</address-1>
              <city>Naperville</city>
              <state>IL</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Mott, Jack E.</name>
            <address>
              <address-1>Idaho Falls, ID, US</address-1>
              <city>Idaho Falls</city>
              <state>ID</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Rechtin, Michael D.</name>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <orgname>Foley &amp; Lardner</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Gordon, Paul P.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A system and method for monitoring an industrial process and/or industrial data source.
      <br/>
      The system includes generating time varying data from industrial data sources, processing the data to obtain time correlation of the data, determining the range of data, determining learned states of normal operation and using these states to generate expected values, comparing the expected values to current actual values to identify a current state of the process closest to a learned, normal state; generating a set of modeled data, and processing the modeled data to identify a data pattern and generating an alarm upon detecting a deviation from normalcy.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This application is a continuation, of application Ser.
      <br/>
      No. 08/666,938, filed Jun. 19, 1996 now U.S. Pat. No. 5,764,509.
    </p>
    <p num="2">
      This invention was made with U.S. Government support under Contract No. W-31-109-ENG-38 awarded by the Department of Energy.
      <br/>
      The U.S. Government has certain rights in this invention.
    </p>
    <p num="3">
      The present invention is related generally to a method and system for carrying out surveillance of industrial processes using sensor or data source outputs.
      <br/>
      More particularly, the invention is concerned with a method and system for processing sensor data and using virtual data as an improved methodology over basic statistical approaches to industrial process surveillance.
      <br/>
      Further, the invention involves use of a plurality of techniques coupled for enhanced analysis of industrial process data.
    </p>
    <p num="4">
      Conventional parameter-surveillance schemes are sensitive only to gross changes in the mean value of a process or a large steps or spikes that exceed some threshold limit check.
      <br/>
      These conventional methods suffer from either large numbers of false alarms (if thresholds are set too close to normal operating levels) or a large number of missed (or delayed) alarms (if the thresholds are set too expansively).
      <br/>
      Moreover, most conventional methods cannot perceive the onset of a process disturbance, sensor deviation or data anomaly which gives rise to a signal below the threshold level for an alarm condition.
      <br/>
      Most methods also do not account for the relationship between a measurement by one sensor relative to another sensor measurement.
    </p>
    <p num="5">
      In another monitoring method, a conventional sequential probability ratio test ("SPRT") technique has found wide application as a signal validation tool in the nuclear reactor industry.
      <br/>
      The SPRT method is a pattern recognition technique which processes the stochastic components associated with physical process variables and has high sensitivity for the onset of subtle disturbances in those variables.
      <br/>
      Two features of the conventional SPRT technique make it attractive for parameter surveillance and fault detection: (1) early annunciation of the onset of a disturbance in noisy process variables, and (2) the SPRT technique has user-specifiable false alarm and missed-alarm probabilities.
      <br/>
      SPRT techniques are primarily directed to the analysis of data from paired or multiple pairs of sensors in contrast to a large number of different process sensor data points.
      <br/>
      SPRT is also typically dependent on assumptions of the data being independent of other data sources and being Gaussian distributed data.
      <br/>
      The SPRT technique used alone therefore has certain shortcomings in identifying anomalies in processes.
    </p>
    <p num="6">Other types of statistical techniques also have been developed for industrial process monitoring and analysis but have other insensitivities for certain classes of sensor data.</p>
    <p num="7">It is, therefore, an object of the invention to provide an improved method and system for surveillance of industrial processes and apparati.</p>
    <p num="8">It is also an object of the invention to provide an improved method and system for evaluation of process data, on-line or off-line, from sensors or data accumulation sources.</p>
    <p num="9">It is a further object of the invention to provide a novel method and system for performing preliminary analysis of data for alarm conditions prior to data input to a SPRT system.</p>
    <p num="10">It is an additional object of the invention to provide an improved method and system for masking selected sensor data and substituting virtual data to perform tests to determine whether abnormal process conditions or abnormal sensor conditions exist and whether or not to halt or modify the process under scrutiny.</p>
    <p num="11">It is still another object of the invention to provide a novel method and system using training data characteristic of normal system and/or sensor and/or data source operation to compare with ongoing industrial processes and/or data accumulation.</p>
    <p num="12">It is yet a further object of the invention to provide an improved method and system for processing data from a process to determine training data for normal operation, storing such training data on a computer storage media and analyzing real process data relative to the normal training data using a plurality of mathematical methodologies stored on a ROM or PROM storage medium.</p>
    <p num="13">It is also an additional object of the invention to provide a novel method and system utilizing a virtual signal characteristic of normal state operation derived on the basis of correlation with a plurality of other process data values to compare with a real process data signal for deriving the likelihood of an abnormal process or operation of data sources.</p>
    <p num="14">It is yet another object of the invention to provide a novel method and apparatus to accumulate training data to recognize any one of a plurality of specific states of operation and thereby identify a particular type of fault or condition present in a process or other system.</p>
    <p num="15">It is also a further object of the invention to provide a novel method and apparatus for monitoring a process using training data to identify slowly changing operational sensor data characteristic of normal process changes.</p>
    <p num="16">It is still an object of the invention to provide an improved method and system for determining whether a system or data source abnormality can be ignored without undesirable effects.</p>
    <p num="17">Other advantages and features of the invention, together with the organization and manner of operation thereof, will become apparent from the following detailed description when taken in conjunction with the accompanying drawings described below.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="18">
      FIG. 1 illustrates a schematic functional flow diagram of a preferred embodiment of the invention;
      <br/>
      FIG. 2 illustrates a functional flow diagram of a time lead-lag correlation methodology;
      <br/>
      FIG. 3 illustrates a functional flow diagram of a method of determining a full range of data by searching normal state training data;
      <br/>
      FIG. 4 illustrates a functional flow diagram of a method for modeling behavior of commercial system operating states;
      <br/>
      FIG. 5 illustrates a functional flow diagram of a method for performing pattern recognition;
      <br/>
      FIG. 6A illustrates sensor signals having a four second delay before applying a lead-lag method, and FIG. 6B illustrates the sensor signals after applying the lead-lag method;
      <br/>
      FIG. 7A illustrates sensor signal data from pump 1 power with an SMSET estimate superimposed thereon; FIG. 7B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 7C illustrates a histogram of the error;
      <br/>
      FIG. 8A illustrates sensor signal data from pump 2 power with an SMSET estimate superimposed thereon; FIG. 8B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 8C illustrates a histogram of the error;
      <br/>
      FIG. 9A illustrates sensor signal data from pump 1 speed with an SMSET estimate superimposed thereon; FIG. 9B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 9C illustrates a histogram of the error;
      <br/>
      FIG. 10A illustrates sensor signal data from pump 2 speed with an SMSET estimate superimposed thereon; FIG. 10B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 10C illustrates a histogram of the error;
      <br/>
      FIG. 11A illustrates sensor signal data for reactor outlet flow rate; FIG. 11B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 11C illustrates a histogram of the error;
      <br/>
      FIG. 12A illustrates sensor signal data for primary pump 2 flow rate; FIG. 12B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 12C illustrates a histogram of the error;
      <br/>
      FIG. 13A illustrates sensor signal data subassembly outlet temperature 1A1; FIG. 13B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 13C illustrates a histogram of the error;
      <br/>
      FIG. 14A illustrates sensor signal data for subassembly outlet temperature 2B1; FIG. 14B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 14C illustrates a histogram of the error;
      <br/>
      FIG. 15A illustrates sensor signal for subassembly outlet temperature 4E1; FIG. 15B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 15C illustrates a histogram of the error;
      <br/>
      FIG. 16A illustrates sensor signal data for subassembly outlet temperature 4F1; FIG. 16B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 16C illustrates a histogram of the error;
      <br/>
      FIG. 17A illustrates sensor signal data for reactor outlet temperature 1534CF; FIG. 17B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 17C illustrates a histogram of the error;
      <br/>
      FIG. 18A illustrates sensor signal data for primary tank sodium level 530 Float; FIG. 18B illustrates the SMSET estimation error between the SMSET estimates and the sensor signal data; and FIG. 18C illustrates a histogram of the error;
      <br/>
      FIG. 19A illustrates sensor signal data for primary tank sodium level 531 induction; FIG. 19B illustrates the SMSET estimation error between the SMSET estimate and the sensor signal data; and FIG. 19C illustrates a histogram of the error;
      <br/>
      FIG. 20A illustrates standard deviation of SMSET errors for each of the data in FIGS. 7-19; and FIG. 20B illustrates the mean value of SMSET errors for each of the data in FIGS. 7-19;
      <br/>
      FIG. 21 shows subassembly outlet temperature ("SOT") and SMSET estimates and in particular FIG. 21A illustrates time dependent normal SOT for 3F1 in the EBR-II nuclear reactor; FIG. 21B illustrates normal SOT for 3C1; FIG. 21C illustrates normal SOT for 5C2 and FIG. 21D illustrates normal SOT for 7A3;
      <br/>
      FIGS. 22A, 22B, 22C and 22D illustrates SMSET estimation error for each of the data of FIGS. 21-D, respectively;
      <br/>
      FIGS. 23A, 23B, 23C and 23D illustrates SPRT results for each of the data of FIGS. 21A-D, respectively;
      <br/>
      FIG. 24A corresponds exactly to FIG. 21A, FIG. 24B includes a linear drift component compared to FIG. 21B; and FIGS. 24C and 24D correspond exactly to FIG. 21C and 21D, respectively;
      <br/>
      FIG. 25A corresponds exactly to FIG. 22A; FIG. 25B includes the effect on SMSET estimation error of the linear drift of FIG. 24B; and FIGS. 24C and 24D correspond exactly to FIGS. 22C and 22D, respectively;
      <br/>
      FIG. 26A corresponds exactly to FIG. 23A; FIG. 26B illustrates the SPRT results for the linear drift error of FIG. 24B; and FIGS. 26C and D corresponds exactly to FIG. 23C and D, respectively;
      <br/>
      FIGS. 27A and 27B corresponds exactly to FIGS. 21A and 21B, respectively; FIG. 27C includes a temporary amplitude pulse of 0.25% of the signal magnitude; and FIG. 27D corresponds exactly to FIG. 21D;
      <br/>
      FIGS. 28A and 28B corresponds exactly to FIGS. 22A and 22B; FIG. 28C illustrates SMSET estimation error for the amplitude pulse effect of FIG. 27C and FIG. 27D corresponds exactly to FIG. 22D;
      <br/>
      FIGS. 29A and 29B corresponds exactly to FIGS. 23A and 23B; FIG. 29C illustrates SPRT results of the amplitude pulse in FIG. 27C; and FIG. 29D corresponds exactly to FIG. 23D;
      <br/>
      FIG. 30A illustrates EBRII subassembly temperature data 3F1 but includes a uniform gain change compared to FIG. 21A and FIGS. 30B-D correspond exactly to FIGS. 21B-D;
      <br/>
      FIG. 31A illustrates SMSET estimation error for the gain change of FIG. 30A; and FIGS. 31B-D correspond exactly to FIGS. 22D-D, respectively; and
      <br/>
      FIG. 32A illustrates the SPRT results for the gain change of FIG. 30A and SMSET analysis of FIG. 31A; and FIGS. 32B-D correspond exactly to FIGS. 23B-D, respectively.
    </p>
    <heading>DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
    <p num="19">
      The system 10 herein includes a methodology (see FIG. 1) and apparatus for surveillance of sensor or data accumulation configurations in industrial, utility, business, medical, investment and transportation applications.
      <br/>
      The system 10 is useful for sensitive identification of the onset of sensor or data source degradation, process or system anomalies, or the onset of change to a different operational state.
      <br/>
      The most preferred form of the system 10 comprises a synergistic integration of four techniques to provide enhanced surveillance capabilities compared to conventional approaches (including neural networks), and also provide enhanced reliability and improved computational efficiency.
      <br/>
      The four elements that make up the most preferred surveillance form of the system 10 are embodied in four different methodologies generally characterized as a time correlation module 20, a training module 30, a system state estimation module 40 and a pattern recognition module 50.
    </p>
    <p num="20">
      Many attempts to apply conventional neural networks to nuclear, petrochemical or any industrial process surveillance applications have met with poor results in part because they fail to take into account lead-lag relationships (lack of proper time correlation of the data sets) between the various sensors or data sources.
      <br/>
      In one example, a pipe is instrumented with a sequence of N thermocouples ("TCs") which measure for instantaneous temperature of the fluid passing through the pipe; and the signals from these TCs are displaced in time along the fluid stream flow path.
      <br/>
      If the sampling interval for the sensors is smaller than the transit time for fluid passing through the pipe, any attempt to monitor these signals with a neural net will produce very high uncertainties in the estimated signals for the TCs.
      <br/>
      For example, if it takes ten seconds for the fluid to pass through the pipe, and the sampling interval is one second, then at any given instant in time, TC(N), at the outlet end of the pipe, is seeing fluctuations that passed TC(1) ten seconds ago.
      <br/>
      These TCs may still contain a small degree of correlation due to gross changes in fluid temperature from a heat source or sink that is upstream of the pipe; however, the more valuable intersensor correlation that arises from local temperature perturbations carried along the pipe will be lost.
      <br/>
      This same phenomenon degrades the performance of neural networks and other pattern-recognition paradigms applied to any processes wherein the physical sensors or data sources are displaced in time across the process they are monitoring.
      <br/>
      Other examples of time delays in correlated systems include: systems with slow data flow rates and/or large physical distances (oil refineries, power plants, HVAC systems, and financial systems), delays due to analog or digital electronics (noise filters and large capacitors) or transmission delays (satellite communications, or transmitting data over different BUS systems.
    </p>
    <p num="21">
      In a preferred form of the time correlation model 20, a Leadlag component of the invention (see FIG. 6) performs dynamic, real-time intersensor lead-lag adjustments.
      <br/>
      The Leadlag module 20 performs adjustments so that the output signals, which are then input subsequently into the SMSET routine (the system state estimation module 40), are optionally correlated and impart the maximum information content to the pattern recognition module 50.
      <br/>
      The Leadlag module 20 is attached hereto as a computer software Appendix A. The Leadlag module 20 accomplishes the adjustment function by performing, for each pair of signals, an iterative regression procedure that generates a vector of correlation coefficients with respect to lag time.
      <br/>
      This vector of correlation coefficients is a unimodal concave function of lag time.
      <br/>
      Thus, the optimal lag time between the pair of signals is identified simply by searching for the zero-crossing of the first derivative of the vector with respect to the lag time.
    </p>
    <p num="22">
      In other forms of the invention it may be unnecessary to utilize the Leadlag module 20, as noted in FIG. 1 wherein the option exists to skip use of the module 20.
      <br/>
      This could occur for systems in which there is adequate time correlation or if time shifting is not needed to achieve correlation.
      <br/>
      If the Leadlag module 20 is not utilized or the data has already been processed by the Leadlag module 20, the data is preferably input to a training module 30.
    </p>
    <p num="23">
      In a preferred embodiment this training module is a MiniMax module 30 which searches through all the observations for all signals or data during a training time period to construct training vectors that include the highest point and lowest point for each signal or data space under surveillance.
      <br/>
      A computer software Appendix B sets forth the MiniMax module 30.
      <br/>
      The MiniMax module 30 produces an "optimal" training set.
      <br/>
      It is optimal in the sense that it contains only, at most, 2N vectors, where N is the number of signals or data points in the system; and these vectors span the full range that all sensors or data sources have noted during the available training period.
      <br/>
      Wherever two or more sensors or data sensors simultaneously attain maxima or minima, the resulting number of training vectors will be less than 2N.
    </p>
    <p num="24">In another form of the invention both the Leadlag module 20 and the MiniMax module 30 can be skipped, and the data can be input directly to the system state module 40.</p>
    <p num="25">
      Once the MiniMax module 30 has constructed a system model (or been skipped as noted above), the system state estimation module 40 (such as the preferred Subsystem Multivariate State Estimation Technique ("SMSET") module) models the behavior of a system through examples of the operating states of the commercial system being modeled.
      <br/>
      A computer software Appendix C sets forth the SMSET module 40.
      <br/>
      In general, the system state estimation module 40 can be any one of a variety of modeling methodologies, such as auto regressive moving average, a neural network, or a Kalman filtering technique or an empirical methodology.
    </p>
    <p num="26">
      The SMSET module 40 utilizes its memory of the learned states of the commercial system in conjunction with a single new observation to provide an estimate of the current "true" system state.
      <br/>
      States of the system are represented by vectors whose elements are comprised of direct values of system parameters (measured signals) as well as any transformation of these system parameters that produce scalar vales, e.g., calculated parameters based upon measured data.
      <br/>
      The SMSET module 40 does not require the state vector elements to be linearly independent as do most other types of estimation techniques.
      <br/>
      The learning process, which results in a "learned-state" matrix, is performed according to the MiniMax module 30 and the Leadlag module 20 described hereinbefore.
    </p>
    <p num="27">
      The basic methodology of the SMSET module 40 involves the input of a new observation of the behavior of a system that is compared with the "memory" of previous system behavior embodied in the learned-state matrix.
      <br/>
      A series of mathematical operations are performed that generates an estimate of the states in the system's memory that is "closest" to the new observation.
      <br/>
      The definition of "closest" that is used by the SMSET module 40 is that state that is lying closest to the new observation from the point of view of a set of rules that determine the association of two vectors.
      <br/>
      From this closest state, an estimate of the "true" state of the system is performed for each and every element of the state vector.
      <br/>
      Thus, given a set of current observed parameters of a system, the SMSET module 40 provides an estimate of the current true state of the system.
      <br/>
      The value of this method is that an estimate of all of the values of the system parameters in the state vector can be provided even if the current observation vector is incomplete (e.g., some sensors or data sensors may have failed or are no longer available), contains erroneous or family elements (some sensors may have drifted, become uncalibrated, become contaminated with high noise levels, etc.), or even if the new system state does not coincide with previous operating states.
      <br/>
      However, the new system state must, in a general sense, be bounded by the domain of the states used to develop the system memory (learned-state matrix).
    </p>
    <p num="28">
      This estimation of the true current state of the commercial system, including estimated values of all system parameters, is used in conjunction with the actual measured system parameters to ascertain the operability of sensors (or other data sources) and disturbances in the system state.
      <br/>
      This state estimation process can further be described as in inference engine that accepts as input a set of learned states and new observation of the commercial system.
      <br/>
      After a series of operations are performed by the inference engine on this input, the result is an estimate of the learned state "closest" to the new observation.
      <br/>
      The definition of "closest" used here is the state lying closest to the new observation from the point of view of a set of rules that determine the association (overlap) of any two vectors.
      <br/>
      Another result is the estimation of the "true" value of each and every element in the new observation vector in the form of an estimated state vector.
      <br/>
      The series of operations performed in the inference engine consist of various matrix operations.
      <br/>
      First, all pairs of learned states are preferably associated two at a time using a rule set to create the elements of a recognition matrix.
      <br/>
      Next, the new observation is associated with each learned state using the rule set to produce a vector that has been the same number of elements as the number of learned states.
      <br/>
      The largest element value in this vector identifies the "closest" learned state to the new observation.
      <br/>
      Finally, the normal matrix product of this vector with the recognition matrix produces a set of linear combination coefficients for combining the learned states into the estimated state vector.
      <br/>
      This methodology, when applied to any true state of a commercial system that is a combination of the learned states, yields a very close approximation to the true state.
      <br/>
      The actual closeness achieved depends most upon nonlinearities arising from the rule set and physical and/or random fluctuations in the variables and is demonstrated by direct testing.
      <br/>
      General experience with use of this method for real operating commercial systems has indicated predictive capabilities typically no worse than +/-0.5% and normally +/-0.1%.
    </p>
    <p num="29">
      Once the SMSET module 40 has modeled the data as described hereinbefore, the data is input to a pattern recognition module 50, such as the Sequential Probability Ratio Test ("SPRT") module.
      <br/>
      The computer software for the SPRT module 50 is in Appendix D. This SPRT module 50 is a sensitive pattern recognition method that can detect the onset of subtle degradation in noisy signals with high reliability, and with quantitative false-alarm and missed-alarm probabilities.
      <br/>
      Output from the SMSET module 40 is provided as a set of estimated signals (also called "virtual signals") for each sensor surveillance.
      <br/>
      These virtual signals are fed into a network of interacting SPRT modules 50 together with the actual sensor readings.
      <br/>
      Each of the SPRT modules 50 receives one sensor-signal, virtual-signal pair.
      <br/>
      If any sensor degradation or process disturbance starts to affect the output of one or more signals under surveillance, the SPRT module(s) 50 provide an annunciation to the operator and an actuator signal to the control system, which can selectively as needed automatically swap in the virtual signal to replace the degrading sensor signal, or data source.
      <br/>
      Further details of the SPRT module 50 are described in U.S. Pat. No. 5,459,675, which is incorporated by reference herein.
    </p>
    <p num="30">The above-described combination of methodologies enables identification of a faulted process, a particular type of fault, a faulted sensor or data source or faulty data itself and enables actions to be taken to correct or modify the process being monitored.</p>
    <p num="31">
      In some cases when a failed sensor, or improper data stream source, is not important to the continued operation of a commercial system, the user can continue operating the commercial system or process if the sensor or data source were operating normally.
      <br/>
      For example, the system 10 can operate to substitute in a modeled estimate into an actual commercial system or process as input to replace a failed sensor or failed data source.
      <br/>
      This allows the commercial system or process to keep operating.
    </p>
    <p num="32">
      Since the system 10 does not rely on analytical modeling by itself, it is applicable to a wide variety of processes and systems, such as petro-chemical, power generation, automotive, manufacturing medical, aeronautical, financial and any system in which signals are available for processing that are related to the commercial system/process operation or performance.
      <br/>
      The only requirement of the system 10 is that there is some type of cross-correlation, be it linear or nonlinear, between the signals used as input to the system 10.
      <br/>
      The signals can be linear, nonlinear, stationary, nonstationary, clean or noisy (with an arbitrary distribution).
      <br/>
      The system 10 uses a database of historical operation data to model the commercial system or process.
      <br/>
      The database is assumed to contain data from all relevant operating modes of the system; however, if a new mode of operation is encountered and is determined not to be a result of commercial system or sensor failures, a new vector can be added to the existing training matrix to incorporate the unanticipated operating mode in the system model.
    </p>
    <p num="33">
      The following nonlimiting examples illustrate various aspects of the invention described herein.
      <br/>
      The data used is all taken from the EBR-II reactor at Argonne National Laboratory (West).
    </p>
    <heading>EXAMPLE I</heading>
    <p num="34">
      The effect of time delay correlation is described in this example, and FIGS. 6A and 6B show two voltage signals with a four second delay between them.
      <br/>
      Before the signals are processed by the Leadlag module 20 (see FIG. 6A), the correlation coefficient is 0.0182 which implies no correlation versus processing through the Leadlag module 20 to obtain a correlation of 0.09209 (see FIG. 6B).
      <br/>
      When the set of signals, or data, being used is more than two, all the possible pair combinations are used to calculate maximum possible correlation coefficients so all signals can be properly correlated.
    </p>
    <heading>EXAMPLE II</heading>
    <p num="35">
      An experiment to determine the accuracy of the invention (the "SMSET" methodology generally) was carried out using sensor data from the Experimental Breeder Reactor II (EBR-II) at Argonne National Laboratory (US58).
      <br/>
      The sensor data set contained 13 signals from sensors monitoring EBR-II.
      <br/>
      Table I shows the SMSET Estimation accuracy for EBR-II Data.
      <br/>
      Table I includes the channel numbers and descriptions for each of the sensor signals used in the analysis.
      <br/>
      The experiment was conducted in three steps; first the SMSET module was trained using two days worth of EBR-II data, next the trained SMSET module was used to estimate the state of approximately 110 hours worth of EBR-II data, and then the accuracy of the estimates was analyzed.
      <br/>
      For each of the sensor signals listed in Table I, FIGS. 7-19, respectively, show the sensor signal (top plot) and SMSET estimate superimposed, the middle plot shows error between the SMSET and the sensor signal (in percent of the signal magnitude), and a histogram (bottom plot) of the error.
      <br/>
      The histogram plots are compared to a Gaussian distribution with the same mean and variance to given an idea of how Gaussian the error signals.
      <br/>
      FIG. 20 provide a summary of the data of FIGS. 7-19.
    </p>
    <p num="36">
      A methodology entitled MiniMax (Appendix B) was used to train the system using the two days of training data cited above.
      <br/>
      After the MiniMax method was applied, a training matrix was constructed consisting of twenty-five unique vectors constituting an empirical model of the overall system.
      <br/>
      After creating the model, the methodology was then applied to the signals listed in the accuracy table.
      <br/>
      Each signal in the system has its own estimation error signal that is a measure of how close the pattern recognition model is representing the system relative to the senor readings.
      <br/>
      The second column of Table I lists the standard deviation of the estimate error for all of the signals in the experiment in terms of each of the signals' magnitude.
      <br/>
      The magnitude of the signal is defined by its mean during normal operation.
      <br/>
      The third column in Table I lists the mean of the estimate error for all of the signals also in terms of the signal magnitude.
      <br/>
      In general the estimate error standard deviations are in the range of 0.01% to 0.1% and the estimate error means are centered around 0.
      <br/>
      Bar graphs of the tabular information are shown in FIGS. 20A and 20B as graphic representation of the accuracy information.
    </p>
    <heading>-- TABLE I</heading>
    <p num="37">
      -- SMSET Estimation Accuracy Table for EBRII Data:
      <br/>
      --                         SMSET Estimate   SMSET Estimate
      <br/>
      --                         Error Standard   Error Mean
      <br/>
      -- Channel Number and      Diviation (% of  Value (% of
      <br/>
      -- Description             Sensor Magnitude) Sensor Magnitude)
      <br/>
      --  1) Primary Pump -1 Power 0.05245          0.01241
      <br/>
      --  2) Primary Pump -2 Power 0.14352          0.06595
      <br/>
      --  3) Primary Pump -1 Speed 0.01078          0.00001
      <br/>
      --  4) Primary Pump -2 Speed 0.01272          -0.00278
      <br/>
      --  5) Reactor Outlet Flowrate 0.09585          0.04452
      <br/>
      --  6) Primary Pump -2  0.06034          -0.02495
      <br/>
      --      Flowrate
      <br/>
      --  7) Subassembly Outlet   0.04635          0.00339
      <br/>
      --      Temperature 2B1
      <br/>
      --  8) Subassembly Outlet   0.04904          -0.00118
      <br/>
      --      Temperature 2B1
      <br/>
      --  9) Subassembly Outlet   0.05664          -0.00306
      <br/>
      --      Temperature 4E1
      <br/>
      -- 10)  Subassembly Outlet   0.04926          -0.00413
      <br/>
      --      Temperature 4F1
      <br/>
      -- 11)  Reactor Outlet       0.04727          0.00513
      <br/>
      --      Temperature 1534CF
      <br/>
      -- 12)  Primary Tank Sodium  0.02440          -0.00280
      <br/>
      -- 13)  Primary Tank Sodium  0.00615          0.00316
      <br/>
      --      Level 531 Induction
    </p>
    <heading>EXAMPLE III</heading>
    <p num="38">
      In FIGS. 21-32 examples of different sensor failure modes are shown along with how the system reacts to the failure.
      <br/>
      The preferred method of FIG. 1 is applied to the data.
      <br/>
      The sensor signals used in these examples are from a subset of 22 sensor signals used in the system.
      <br/>
      The 22 sensors monitored the EBR-II subassembly system at Argonne National Laboratory (West).
      <br/>
      Each of FIGS. 21-32 contains four subplots in which the upper most plot is related to Subassembly Outlet Temperature ("SOT") 3F1, the upper middle plot is related to SOT 3C1, the lower middle plot is related to SOT 5C2, and the bottom plot is related to SOT 7A3.
      <br/>
      The system applied in each of the examples uses the same training matrix, which consists of 83 vectors selected from a training data base containing almost a weeks worth of data taken once every minute.
    </p>
    <p num="39">
      In FIGS. 21-23 are shown the results of using the system 10 during approximately 5.5 days of normal operation of EBR-II.
      <br/>
      FIG. 21 shows the SOT signals with their corresponding SMSET estimates (signal being the circles and the lines being the estimate).
      <br/>
      FIG. 22 shows the respective raw estimate errors (not in terms of the signal magnitude) derived by taking the difference between the SOR signals and corresponding SMSET estimates.
      <br/>
      Finally in FIG. 23 the results are shown from applying the decision making module of the system 10 (the SPRT module 50--see Appendix D) to the SMSET estimation errors of FIG. 22. The SPRT plots show a total of only three false alarms which is a false alarm rate of 9.4 * 10-5, and this is well within the specified false alarm rate of 1.0 * 10-3.
    </p>
    <p num="40">
      One type of failure mode that is common among sensors is a slow drift.
      <br/>
      This type of failure can be difficult to detect early on especially when the sensor signals contain noise.
      <br/>
      FIGS. 24-26 illustrate a comparative example of processing data from this type of failure and failure identification.
      <br/>
      Signal -2 (FIG. 24B) has a 0.2% linear drift in it's mean over the 2.75 day period starting at 4000 minutes into the signal.
      <br/>
      The other sensors are operating normally.
      <br/>
      FIG. 25 shows the resulting SMSET estimation errors for each sensor signal.
      <br/>
      The error plot for signal -2 (FIG. 25B) shows evidence of drifting after the sensor signal has drifted approximately 0.05%. In FIG. 26 the SPRT method has determined that -2 (FIG. 26B) is drifting after approximately 0.05% of drift and that all other sensors are operating normally.
    </p>
    <p num="41">
      Another type of failure that can occur is a step change in the sensor signal.
      <br/>
      This can be the result of a short in the sensor or DAS, a calibration error or for a variety of other reasons.
      <br/>
      FIGS. 27-29, show an example of this type of failure for the SOT measurements.
      <br/>
      In this example sensor signal -3 (FIG. 27C) contains a pulse with an amplitude of 0.25% of the signal magnitude.
      <br/>
      The pulse starts at 4000 minutes and lasts for 2000 minutes.
      <br/>
      FIG. 27 shows the sensor signals and the SMSET estimates for the four SOT signals.
      <br/>
      FIG. 28 shows the resulting SMSET estimation errors.
      <br/>
      The error signal for -3 (FIG. 28C) shows that there is a problem starting at 4000 minutes and ending at 6000 minutes.
      <br/>
      The error signals are fed through the SPRT module 50, and the results are plotted in FIG. 29. Clearly, there has been a disturbance in sensor -3 (FIG. 29C) beginning at time 4000 minutes and ending at 6000 minutes.
    </p>
    <p num="42">
      In FIGS. 30-32 an example of a failure mode related to the sensor gain is shown.
      <br/>
      In this example the gain of the sensor signal changes over time, i.e., the amplitude is increasing over time.
      <br/>
      The gain begins changing linearly over time from a beginning value of 1 to a final value of 1+0.075% of the sensor magnitude.
      <br/>
      The system 10 for the estimation error is applied to the signals, and the results are shown in FIG. 31. A human operator would most likely not be able to tell that there is a problem even after 8000 minutes by looking at the sensor signal.
      <br/>
      In FIG. 31A, it is apparent that signal -1 is operating abnormally.
      <br/>
      This is confirmed in FIG. 32A by the SPRT results, showing a steadily increasing number of SPRT alarms over the 8000 minute period.
    </p>
    <p num="43">While preferred embodiments of the invention have been shown and described, it will be apparent to those skilled in the art that various changes and modifications can be made without departing from the invention in its broader aspects as set forth in the claims provided hereinafter.</p>
    <p num="44">Appendix A</p>
    <p num="45">Computer software for Leadlag module which performs dynamic, real-time intersensor lead-lag time correlation adjustments.</p>
    <p num="46">
      --
      <br/>
      -- /**********************************************************/
      <br/>
      -- /* LEADLAG OPTIMIZATION MODULE
      <br/>
      -- /***********************************************************/
      <br/>
      -- -include &lt;stdio.h&gt;
      <br/>
      -- -include &lt;math.h&gt;
      <br/>
      -- -include &lt;stdlib.h&gt;
      <br/>
      -- -include &lt;string.h&gt;
      <br/>
      -- -define pi 3.1415926
      <br/>
      -- -define N 1024
      <br/>
      -- -define xcsize 2047
      <br/>
      -- -define fil_xcsize 2079
      <br/>
      -- -define filsize 32
      <br/>
      -- void phase_shift_optimization(int argc,char argv���20�,int method);
      <br/>
      -- void conv(float f��, float g��, float c��, int size);
      <br/>
      -- void der(float y��, float diff ��,int size);
      <br/>
      -- void roots(float diffxc ��, int size, float *root);
      <br/>
      -- void fliplr(float a��, int size);
      <br/>
      -- void prn_info(char *);
      <br/>
      -- void main(int argc, char **argv)
      <br/>
      -- +
      <br/>
      --      int i, method;
      <br/>
      --      char tempargv�10��20 �;
      <br/>
      --      if (argc �=5) +
      <br/>
      --         prn_info(argv�0�);
      <br/>
      --         exit(1);
      <br/>
      --      }
      <br/>
      --      for(i=0;i&lt;argc;i++)
      <br/>
      --         stropy(tempargv�i�, argv�i�);
      <br/>
      --      printf("Enter 1 or 2 below, (.backslash."1.backslash." means the
      <br/>
      --  employment of the");
      <br/>
      --      printf(" derivative technique to find the shift, while
      <br/>
      --  .backslash."2.backslash."");
      <br/>
      --      printf(" means the application of direct max. correlation");
      <br/>
      --      printf(" technique.):.backslash.n");
      <br/>
      --      scanf("%d",&amp;method);
      <br/>
      --      phase_shift_optimization(argc,tempargv,method)
      <br/>
      -- +
      <br/>
      -- void phase_shift_optimization(int argc, char argv���20 �, int method)
      <br/>
      -- +
      <br/>
      --      int i,j,ph;
      <br/>
      --      float root;
      <br/>
      --      float fl�xcsize�, f2�xcsize�, b�fi1_xcsize�;
      <br/>
      --      float xc�fi1_xcsize�, fil_xc�fi1_xcsize�;
      <br/>
      --      float diffi1_xc�fi1_xcsize-1�;
      <br/>
      --      FILE *infile1,*infile2,*infile3,*outfile, *outfile1, *outfile2;
      <br/>
      -- /* Open the input and output data files. */
      <br/>
      --      outfile=fopen(argv�4�, "w");
      <br/>
      --      for (i=0;i&lt;xcsize;i++)
      <br/>
      -- + f1�i�=0;
      <br/>
      --  f2�i�=0;
      <br/>
      -- }
      <br/>
      -- for (i=0;i&lt;fi1_xcsize;i++)
      <br/>
      -- + xc�i�=0;
      <br/>
      --  b�i�=0;
      <br/>
      --  fi1_xc�i�=0;
      <br/>
      -- }
      <br/>
      -- if((infile1=fopen(argv�1�, "r")) == NULL)
      <br/>
      -- + printf("There is no data file %s�.backslash.n", argv�1�);
      <br/>
      --  exit(0);
      <br/>
      -- }
      <br/>
      -- else
      <br/>
      -- + i=0;
      <br/>
      --  while((fscanf(infile1,"%f",&amp;f1�i�)) � =HOF)
      <br/>
      --  i++;
      <br/>
      -- }
      <br/>
      -- if((infile2=fopen(argv�2�, "r")) == NULL)
      <br/>
      -- + printf("There is no data file %s�.backslash.n", argv�2�);
      <br/>
      --  exit(0);
      <br/>
      -- }
      <br/>
      -- else
      <br/>
      -- + i=0;
      <br/>
      --  while((fscanf(infile2,"%f",%f2�i�)) � =HOF)
      <br/>
      --  i++;
      <br/>
      -- }
      <br/>
      -- if ((infile3=fopen(argv�3�, "r")) == NULL)
      <br/>
      -- +printf("There is no data file %s�.backslash.n", argv�3�);
      <br/>
      --  exit(0);
      <br/>
      -- }
      <br/>
      -- else
      <br/>
      -- + i=0;
      <br/>
      --  while((fscanf(infile3,"%f",%b�i�)) � =HOF)
      <br/>
      --  i++;
      <br/>
      -- }
      <br/>
      -- /* Caluclate the cross-correlation of the input and the */
      <br/>
      -- /* reference signals.                 */
      <br/>
      -- flip1r(f1,N);
      <br/>
      -- conv(f1,f2,xc,xcsize);
      <br/>
      -- /* To pass xc through a LPF */
      <br/>
      -- conv(b,xc,fi1_xc,fi1_xcsize);
      <br/>
      -- /* Find the shift, using direct max. correlation technique. */
      <br/>
      -- if(method==2)
      <br/>
      -- + ph=fi1_xc�0�;
      <br/>
      -- j=0;
      <br/>
      -- for(i=0; i&lt;fi1_xcsize;i++)
      <br/>
      --      if(fi1_xc�i�&gt;ph)
      <br/>
      --      + ph=fi1_xc�i�;
      <br/>
      --       j=i;
      <br/>
      --      }
      <br/>
      --      ph=j-(fi1_xcsize+1)/2;
      <br/>
      --      printf("The shift is %d.backslash.n,ph);
      <br/>
      -- }
      <br/>
      -- /* Find the shift, using derivative techinque. */
      <br/>
      -- if (method==1)
      <br/>
      -- + der(fi1_xc,difffi1_xc,fi1_scsize);
      <br/>
      --  roots(difffi1_xc,fi1_xcsize-1,%root);
      <br/>
      --  ph=root-(fi1_xcsize+1)/2;
      <br/>
      --  printf("The shift is %f.backslash.n",ph);
      <br/>
      -- }
      <br/>
      -- /* Phase-equalize the input (f2) relative to reference (f1) */
      <br/>
      -- /* If ph&gt;0, f2 leads f1, if ph&lt;0, f2 lags f1. */
      <br/>
      -- if(ph&gt;0)
      <br/>
      -- + for (i=ph;i&lt;N;i++)
      <br/>
      --  f2�i-ph� = f2�i�;
      <br/>
      -- for (i=N-ph; i&lt;N;i++)
      <br/>
      --  f2�i�=0;
      <br/>
      -- }
      <br/>
      -- if(ph&lt;0)
      <br/>
      -- + ph = -ph;
      <br/>
      -- for (i=N-1,i&gt;=ph:i--)
      <br/>
      --  f2�i� = f2�i-ph�;
      <br/>
      -- for(i=0;i&lt;ph;i++)
      <br/>
      --  f2�i� =0;
      <br/>
      -- }
      <br/>
      -- for(i=0;i&lt;N:i++)
      <br/>
      --  fprintf(outfile,"%f.backslash.n",f2�i�);
      <br/>
      -- fclose(infile1);
      <br/>
      -- fclose(infile2);
      <br/>
      -- fclose(infile3);
      <br/>
      -- fclose(outfile);
      <br/>
      -- }
      <br/>
      -- void conv(float f��, float g��, float c��, int size)
      <br/>
      -- +
      <br/>
      --  int m,k;
      <br/>
      --  for(k=0;k&lt;size;k++)
      <br/>
      --      + c�k� = 0
      <br/>
      --      c�k� = c�k�
      <br/>
      --      + f�m�*g�k-m�;
      <br/>
      --       }
      <br/>
      --      }
      <br/>
      --      void flip1r(float a��, int size)
      <br/>
      --      +
      <br/>
      --      int i,j;
      <br/>
      --      float temp;
      <br/>
      --      j=floor(size/2);
      <br/>
      --      for(i=0;i&lt;j,i++)
      <br/>
      --       + temp=a�i�;
      <br/>
      --      a�i�=a�size-i-1�;
      <br/>
      --      a�size-i-1�=temp;
      <br/>
      --  }
      <br/>
      -- }
      <br/>
      -- void der(float y��, float diffy��, int size)
      <br/>
      -- +
      <br/>
      --  int i;
      <br/>
      --  float diff;
      <br/>
      --  for (i=0;i&lt;size-1,i++)
      <br/>
      --      diffy�i� = y�i+1�-y�i�;
      <br/>
      --      }
      <br/>
      --      void roots(float diffxc��, int size, float *root)
      <br/>
      --      +
      <br/>
      --       int i,j;
      <br/>
      --       float term;
      <br/>
      --       if (diffxc�0�*diffxc�size-1� &gt; 0)
      <br/>
      --      + printf("The cross_correlation is not unimodal..backslash.n");
      <br/>
      --      exit(0);
      <br/>
      --      }
      <br/>
      --  else
      <br/>
      --      + (*root)=0.0;
      <br/>
      --        for (i=0;i&lt;size-1;i++)
      <br/>
      --        + term = i;
      <br/>
      --        for (j=0;j&lt;size-1;j++)
      <br/>
      --        if((i-j)&gt;0)
      <br/>
      --         term=term*((-diffxc�j�))/�diffxc�i�-diffxc�j�));
      <br/>
      --        (*root) = (*root) + term;
      <br/>
      --      }
      <br/>
      --  }
      <br/>
      -- }
      <br/>
      -- void prn_info(char *pgm_name)
      <br/>
      -- +
      <br/>
      -- printf(".backslash.n%s%s%s.backslash.n",
      <br/>
      --      "Usage: ", pgm_name, "infile1 infile2 infile3 outfile");
      <br/>
      -- printf(".backslash.n");
      <br/>
      -- printf("Note that infile1 &amp; infile2 are reference and input signal*);
      <br/>
      -- printf(" respectively. infile3 should contain the coefficients of*);
      <br/>
      -- printf("the LPF, and outfile receives the phase-equalized input
      <br/>
      --  signal..backslash.n");
      <br/>
      -- }
    </p>
    <p num="47">Appendix B</p>
    <p num="48">Computer software for producing an optimal training set derived by searching signal information during a training period to construct training vectors including highest and lowest points for signals under surveillance.</p>
    <p num="49">
      --
      <br/>
      -- /**********************************************************/
      <br/>
      -- /* MINIMAI TRAINING MODULE                 */
      <br/>
      -- /***********************************************************/
      <br/>
      -- void MinMax��+
      <br/>
      --      int L,W,j,i,k,numPairs,didSwitch;
      <br/>
      --      int time_pts �MAISKNS*2�,c;
      <br/>
      --      /*int min_time_pts�MAISHNS�,*/
      <br/>
      --      float minmax�2� �MAISHNS�,tmp,ex;
      <br/>
      --      InitialScreen();
      <br/>
      --      textLook(YELLOW,BLUE)
      <br/>
      --      fseek(Train,0L,0);
      <br/>
      --      gotoxy(17,8);
      <br/>
      --      cprintf(" train using the full file? (y/n):  ");
      <br/>
      --      gotxy(56.8);
      <br/>
      --      c=getche();
      <br/>
      --      /*cscanf("%c",&amp;c);*/
      <br/>
      --      if(c==`n`)+
      <br/>
      --         gotoxy(17,8);
      <br/>
      --         cprintf(" How many lines into the file:  ");
      <br/>
      --         gotoxy(53.8);
      <br/>
      --         cscanf("%d",%L);
      <br/>
      --      }
      <br/>
      --      else+
      <br/>
      --         L=lengthFile(Train);
      <br/>
      --         fseek(Train,0L,0);
      <br/>
      --      }
      <br/>
      --      W=readinputSample (Train);
      <br/>
      --      gotoxy(17,8);/*                */
      <br/>
      --      cprintf(" Finding max and min for all sensors...  *);
      <br/>
      --      for(j=0;j&lt;W;j++)+
      <br/>
      --         minmax�0� �j�=Sample�j�;
      <br/>
      --         minmax�1� �j�=Sample�j�;
      <br/>
      --         time_pts�j�= 0;
      <br/>
      --         time_pts�W+j�=0;
      <br/>
      -- }
      <br/>
      -- /***** Finding time points for each sensor ******/
      <br/>
      -- for (i=1;i&lt;L;i++)+
      <br/>
      --         W=readinputSample(Train);
      <br/>
      --         for(j=0;j&lt;W;j++)+
      <br/>
      --             if(Sample�j�&gt;=minmax�0� �j�)
      <br/>
      --                time_pts�j�=i;
      <br/>
      --             if(Sample�j�&lt;=minmax�1� �j�)
      <br/>
      --                time_pts�W-1+j�=i;
      <br/>
      --         }
      <br/>
      -- }
      <br/>
      -- fseek(Train,0L,0);
      <br/>
      -- gotoxy(17,8);/*                    */
      <br/>
      -- cprintf(" Sorting time points............    *);
      <br/>
      -- /***********************/
      <br/>
      -- /********sorting *******/
      <br/>
      -- numPairs=2*W;
      <br/>
      -- didSwitch=1;
      <br/>
      -- while(didSwitch)+
      <br/>
      --         numPairs--;
      <br/>
      --         didSwitch=0;
      <br/>
      --         for(i=0;i&lt;numPairs;i++)+
      <br/>
      --             if(time_pts�i�&gt;time_pts�i+1�)+
      <br/>
      --                tmp=time_pts�i�;
      <br/>
      --                time_pts�i�=time_pts�i+1�;
      <br/>
      --                time_pts�i+1�=tmp;
      <br/>
      --                didSwitch=1;
      <br/>
      --             }
      <br/>
      --         }
      <br/>
      -- }
      <br/>
      -- /******** getting unique time points ******/
      <br/>
      -- gotoxy(17,8);/*                    */
      <br/>
      -- cprintf(" Removing redundant time points.....    *);
      <br/>
      -- j=0;
      <br/>
      -- for(i=1;i&lt;2*W;i++)+
      <br/>
      --         if(time_pts�i-1�;=time_pts�i�)+
      <br/>
      --             j++;
      <br/>
      --             time_pts�j�=time_pts�i�;
      <br/>
      --         }
      <br/>
      -- }
      <br/>
      -- ColxD=j;
      <br/>
      -- RowsD=W;
      <br/>
      -- j=0;
      <br/>
      -- gotoxy(17,8);/*                    */
      <br/>
      -- cprintf(*  Creating training matrix............    *);
      <br/>
      -- for(i=0;i&lt;L,i++)+
      <br/>
      --         W=readinputSample(Train);
      <br/>
      --         if(i==time_pts�j�)+
      <br/>
      --             for(k=0;k&lt;RowsD;k++)+
      <br/>
      --                D�k� �j� =Sample �k�;
      <br/>
      --                Dt�j� �k� =Sample �k�;
      <br/>
      --             }
      <br/>
      --             j++;
      <br/>
      --         }
      <br/>
      -- }
      <br/>
      -- gotoxy(17,8);/*                    */
      <br/>
      -- cprintf(" Extend training range (y/n):    *);
      <br/>
      -- gotoxy(56.8);
      <br/>
      -- /*csncanf("%c",%c);*/
      <br/>
      -- getche();
      <br/>
      -- c-getche();
      <br/>
      -- if(c==`y`)+
      <br/>
      --      gotoxy(17,14);                 /*
      <br/>
      --      cprintf(" How many standard deviations from the mean: *);
      <br/>
      --      gotoxy(17,15);
      <br/>
      --      cprintf(*  (typical value = 3) Enter value =   *);
      <br/>
      --      gotoxy(53,15);
      <br/>
      --      cscanf("%f",%ex);
      <br/>
      --      gotoxy(17,17);
      <br/>
      --      cprintf(*  Extending training matrix.......   *);
      <br/>
      --      extendD (ex);
      <br/>
      --      }
      <br/>
      -- }
      <br/>
      -- /**********************************************************/
      <br/>
      -- /**********************************************************/
      <br/>
      -- void EquallySpaced()+
      <br/>
      --         int L,W,i,j,k,count,num,c,stop;
      <br/>
      --         float ex;
      <br/>
      --         InitialScreen();
      <br/>
      --         textLook(YELLOW,BLUE);
      <br/>
      --         fseek(Train,0L,0);
      <br/>
      --         gotoxy(17,8);
      <br/>
      --         cprintf(" train using the full file? (y/n):    *);
      <br/>
      --         gotoxy(56,8);
      <br/>
      --         c=getche();
      <br/>
      --         if(c==`n`)+
      <br/>
      --             gotoxy(17,8);
      <br/>
      --             cprintf(" How many lines into the file:    *);
      <br/>
      --             gotoxy(53,8);
      <br/>
      --             cscanf("%d,",&amp;L);
      <br/>
      --         }
      <br/>
      --         else+
      <br/>
      --             L=lengthFile(Train);
      <br/>
      --             fseek(Train,0L,0);
      <br/>
      --         }
      <br/>
      --         stop=0;
      <br/>
      --         while (�stop)+
      <br/>
      --           gotoxy(14,8);/*           */
      <br/>
      --           crpintf(" Enter numer of training vectors (max 132);   *);
      <br/>
      --           gotoxy(61,8);
      <br/>
      --           cscanf("%d",%num);
      <br/>
      --           if(num&gt;132) stop=1;
      <br/>
      --         }
      <br/>
      --         gotoxy(14,8);
      <br/>
      --         cprintf(" Getting vectors from training file....    *);
      <br/>
      --         count=floor(((float)L)/((float) num;
      <br/>
      --         if(count&lt;1)+ count=1; l=num;}
      <br/>
      --         ColsD=num;
      <br/>
      --         j=0;
      <br/>
      --         for (i=0;i&lt;L;i++)+
      <br/>
      --             if((i%count)==0)+
      <br/>
      --                W=readinputSample(Train);
    </p>
    <p num="50">
      --                RowsD=W;
      <br/>
      --                for(k=0;k&lt;RowsD;k++)+
      <br/>
      --                    D�k� �j� =Sample �k�;
      <br/>
      --                    Dt�j� �k�=Sample �k�;
      <br/>
      --                }
      <br/>
      --                j++;
      <br/>
      --             }
      <br/>
      --         }
      <br/>
      --      gotoxy(17,8);/*                */
      <br/>
      --      cprintf("   Extend training range (y/n):   ");
      <br/>
      --      gotoxy(56,8);
      <br/>
      --      /*cscanf("%c",%c);*/
      <br/>
      --      getcha();
      <br/>
      --      c=getche();
      <br/>
      --      if(c==`y`) +
      <br/>
      --        gotoxy(17,14):/*             */
      <br/>
      --         cprintf(" How many standard deviations from the mean:  *);
      <br/>
      --         gotoxy(17,15);
      <br/>
      --         cprintf(" (typical value = 3) Enter value =    *);
      <br/>
      --         gotoxy(53,15);
      <br/>
      --         cscanf("%f",%ex);
      <br/>
      --         gotoxy(17,17);
      <br/>
      --         cprintf("   Extending training matrix.......   *);
      <br/>
      --         extendD(ex);
      <br/>
      --      }
      <br/>
      -- }
      <br/>
      -- void UserSpecified()+
      <br/>
      --      InitialScreen();
      <br/>
      --      gotoxy(14,8);
      <br/>
      --      cprintf(" This feature is not available in the DEMO version  ");
      <br/>
      --      gotoxy(14,9);
      <br/>
      --      cprintf(" using MinMax (hit a key to continue)....    *);
      <br/>
      --      getch();
      <br/>
      --      MinMax();
      <br/>
      -- }
      <br/>
      -- void extendD(float ex)+
      <br/>
      --      int i,j;
      <br/>
      --      float mn�MAISENS/*RowsD*/1, std�MAISHNS/*RowsD*/1,tmp;
      <br/>
      --      /**** Initializing**************/
      <br/>
      --      for(i=0;i&lt;RowsD;i++)+
      <br/>
      --         mn�i�=0.0;
      <br/>
      --         std�i�=0.0;
      <br/>
      --         }
      <br/>
      --         /*****Calculating the mean ******/
      <br/>
      --         for (i=0;i&lt;ColsD;i++)+
      <br/>
      --             for(j=0;j&lt;RowsD;j++)
      <br/>
      --                mn�j�+=D�j� �i�;
      <br/>
      --         for(j=0;j&lt;RowsD;j++)
      <br/>
      --             mn �j�/=ColsD;
      <br/>
      --         /**** Calculating the standard deviation*****/
      <br/>
      --         for(i=0;i&lt;ColsD;i++)
      <br/>
      --         for (j=0;j&lt;RowsD;j++)
      <br/>
      --                std�j�+=(D�j� �i�-mn�j�) = (D�j� �i�-mn�j�);
      <br/>
      --         for(j=0;j&lt;RowsD;j++)
      <br/>
      --             std�j�/=(ColsD-1);
      <br/>
      --         /**** Extending the range of the training matrix***/
      <br/>
      --         for (i=0;i&lt;ColsD;i++)+
      <br/>
      --             for(j=0;j&lt;RowsD;j++)+
      <br/>
      --                D�j� �i� -=std�j�*ex;
      <br/>
      --                Dt�i� �j� -=std�j�*ex;
      <br/>
      --             }
      <br/>
      --             else+
      <br/>
      --                D�j� �i� -=std�j�*ex;
      <br/>
      --                Dt�i� �j� -=std�j�*ex;
      <br/>
      --             }
      <br/>
      --         }
      <br/>
      --      }
      <br/>
      -- }
      <br/>
      -- int lengthFile(FILE *f1)+
      <br/>
      --      char c;
      <br/>
      --      int i;
      <br/>
      --      i=0;
      <br/>
      --      while((c=getc(f1)) �=EOF)
      <br/>
      --         if(c==`/n`) i++;
      <br/>
      --      fseek(f1,0L,0);
      <br/>
      --      return �i�;
      <br/>
      -- }
      <br/>
      -- /*
      <br/>
      -- int widthFile(FILE *f1)+
      <br/>
      --      char c;
      <br/>
      --      int i;
      <br/>
      --      i=0;
      <br/>
      --      while((c=getc(f1))1=`.backslash.n``)+
      <br/>
      -- }
      <br/>
      -- */
      <br/>
      -- int ChooseTraining ()
      <br/>
      -- +
      <br/>
      --         int ch, yy, xx, stop;
      <br/>
      --         char *buff;
      <br/>
      --         textLook (YELLOW, BLUE);
      <br/>
      --         gotoxy(8,7);
      <br/>
      --      cprintf("There are four different ways of extracting training data
      <br/>
      --  from ");
      <br/>
      --         gotoxy(8,8);
      <br/>
      --      cprintf(" the training file, ");
      <br/>
      --      gotoxy(28,8);
      <br/>
      --      textLook(13,BLUE);
      <br/>
      --      cprintf("%-12s", training);
      <br/>
      --      gotoxy(40,8);
      <br/>
      --      textLook(YELLOW,BLUE);
      <br/>
      --      cprintf(", choose one below:    ");
      <br/>
      --         gotoxy(30,11);
      <br/>
      --         textLook(BLACK,LIGHTGRAY);
      <br/>
      --         cprint(" 1) Use File as is ");
      <br/>
      --         gotoxy(30,13);
      <br/>
      --         cprintf(" 2) MinMax method ");
      <br/>
      --         gotoxy(30,15);
      <br/>
      --         cprintf(" 3) Equally Spaced *);
      <br/>
      --         gotoxy(30,17);
      <br/>
      --         cprintf(" 4) Specify States *);
      <br/>
      --         /* make selection */
      <br/>
      --         gotoxy(48,11);
      <br/>
      --         yy=11;
      <br/>
      --         xx=48;
      <br/>
      --         stope=0;
      <br/>
      --         while (stop�=1)+
      <br/>
      --             ch=getch();
      <br/>
      --         if (ch==80) +
      <br/>
      --             yy=yy+2;
      <br/>
      --             if (yy&gt;17)
      <br/>
      --                yy=11;
      <br/>
      --         }
      <br/>
      --         if (ch==72)+
      <br/>
      --             yy=yy-2;
      <br/>
      --             if (yy&lt;11)
      <br/>
      --                yy=17;
      <br/>
      --         }
      <br/>
      --         if (ch==13) stop=1;
      <br/>
      --         /*   TESTING CONTENTS */
      <br/>
      --         /*
      <br/>
      --         gotoxy(1,22);
      <br/>
      --         cprintf("    ");
      <br/>
      --         gotoxy(1,22);
      <br/>
      --         cprintf("choice = %d",((yy-9)/2));
      <br/>
      --         */
      <br/>
      --         gotoxy(xx,yy);
      <br/>
      --      }
      <br/>
      --      return ((yy-5)/2);
      <br/>
      -- }
      <br/>
      -- void GetSettings()
      <br/>
      -- +
      <br/>
      --      int ch, yy, xx, stop;
      <br/>
      --      char *buff;
      <br/>
      --      /* default F1 and F2 : columns for flow 1 and flow 2*/
      <br/>
      --      F1=1;
      <br/>
      --      F2=2;
      <br/>
      --      textLook(YELLOW,BLUE);
      <br/>
      --      gotoxy(8,7);
      <br/>
      -- cprintf(" The default input and output file names are listed below.   *);
      <br/>
      --      gotoxy(8,8);
      <br/>
      -- cprintf(" Use %c and %c to move to selection, &lt;backspace&gt; to change name.
      <br/>
      --  ",
      <br/>
      --             24,25);
      <br/>
      --         gotoxy(22,11);
      <br/>
      --         textLook(BLACK,LIGHTGRAY);
      <br/>
      --         cprintf(" 1) training data:");
      <br/>
      --         gotoxy(40,11);
      <br/>
      --         textLook(LIGHTGRAY,BLACK);
      <br/>
      --         cprintf(" %s,  ", training); /* use gotoxy(51,11) */
      <br/>
      --         gotoxy(22,13);
      <br/>
      --         textLook(BLACK,LIGHTGRAY);
      <br/>
      --         cprintf(" 2) input data   ;*);
      <br/>
      --         gotoxy(40,13)
      <br/>
      --         textLook(LIGHTGRAY,BLACK);
      <br/>
      --         cprintf("%s   ",input); /* use gotoxy(51,13) */
      <br/>
      --         gotoxy(22,15);
      <br/>
      --         textLook(BLACK,LIGHTGRAY);
      <br/>
      --         cprintf(" 3) SFM   ;*);
      <br/>
      --         gotoxy(40,15);
      <br/>
      --         textLook(LIGHTGRAY,BLACK);
      <br/>
      --         cprint(" 2    "); /* use gotoxy(51,15) */
      <br/>
      --         gotoxy(22,17);
      <br/>
      --         textLook(BLACK,LIGHTGRAY);
      <br/>
      --         cprintf(" 4) Clumn flow 1:");
      <br/>
      --         gotoxy(40,17);
      <br/>
      --         textLook(LIGHTGRAY,BLACK);
      <br/>
      --         cprintf(" 1    *);
      <br/>
      --         textLook(BLACK,LIGHTGRAY);
      <br/>
      --         gotoxy(22,19);
      <br/>
      --         cprintf(" 5) Column flow 2:");
      <br/>
      --         gotoxy(40,19);
      <br/>
      --         textLook(LIGHTGRAY,BLACK);
      <br/>
      --         cprintf(" 2    ");
      <br/>
      --         gotoxy(37,21);
      <br/>
      --         textLook(RED,LIGHTGRAY);
      <br/>
      --         cprintf(" done "); /*use goto(42,21) */
      <br/>
      --         /* make selection */
      <br/>
      --         gotoxy (53,11);
      <br/>
      --         yy=11;
      <br/>
      --         xx=53;
      <br/>
      --         stope=0;
      <br/>
      --         while (stop �=1)+
      <br/>
      --             ch=getch();
      <br/>
      --             if (ch==80)+
      <br/>
      --                yy=yy+2;
      <br/>
      --                if (yy&gt;21)
      <br/>
      --                    yy=11;
      <br/>
      --             }
      <br/>
      --             if (ch==72) +
      <br/>
      --                yy=yy-2;
      <br/>
      --                if (yy&lt;11)
      <br/>
      --                    yy=21;
      <br/>
      --             }
      <br/>
      --             if ((ch==8)&amp;&amp;(yy�=21))+
      <br/>
      --                if (yy==11)
      <br/>
      --                    NewName(xx,yy,1);  /* 1=training */
      <br/>
      --                if (yy==13)
      <br/>
      --                    NewName(xx,yy,2);  /* 2=input */
      <br/>
      --                if (yy==15)
      <br/>
      --                    NewName(xx,yy,3);  /* 3=output */
      <br/>
      --                if (yy==17)
      <br/>
      --                    NewName(xx,yy,4);
      <br/>
      --                if (yy==19)
      <br/>
      --                    NewName(xx,yy,5);
      <br/>
      --                yy=yy+2;
      <br/>
      --             }
      <br/>
      --             if (yy==21)
      <br/>
      --                xx=42,
      <br/>
      --             else
      <br/>
      --                xx=53;
      <br/>
      --             if ((yy==21)&amp;&amp;(ch==13)) stop=1;
      <br/>
      --             /*  TESTING CONTENTS   */
      <br/>
      --             /*
      <br/>
      --             gotoxy(1,22);
      <br/>
      --             cprintf(" *);
      <br/>
      --             gotoxy(1,22);
      <br/>
      --             cprintf("training = %s",training);
      <br/>
      --             gotoxy(1,23);
      <br/>
      --             cprintf(" *);
      <br/>
      --             gotoxy(1,23);
      <br/>
      --             cprintf("input = %s.backslash.n",input);
      <br/>
      --             gotoxy(1,24);
      <br/>
      --             cprintf(" *);
      <br/>
      --             gotoxy(1,24);
      <br/>
      --             cprintf("output = %s.backslash.n",output);
      <br/>
      --             */
      <br/>
      --             gotoxy (xx,yy);
      <br/>
      --         }
      <br/>
      -- }
      <br/>
      -- void InitialScreen()
      <br/>
      -- +
      <br/>
      --         textbackground (CYAN);
      <br/>
      --         clrscr();
      <br/>
      --         textLook(RED,BLACK);
      <br/>
      --         highvideo();
      <br/>
      --         gotoxy(24,2);
      <br/>
      --         cprintf(" *);
      <br/>
      --         gotoxy(24,3);
      <br/>
      --         cprintf(" MSET SIGNAL VALIDATION SYSTEM ");
      <br/>
      --         gotoxy (24,4);
      <br/>
      --         cprintf(" *);
      <br/>
      --         normvideo():
      <br/>
      --         textLook(YELLOW,BLUE);
      <br/>
      -- }
      <br/>
      -- void textLook (int txt, int bg)+
      <br/>
      --         textbackground(bg);
      <br/>
      --         textcolor (txt);
      <br/>
      -- }
      <br/>
      -- void NewName (int xpos, int ypos, int whc)
      <br/>
      -- +
      <br/>
      --         int i, c, maxi;
      <br/>
      --         char temp�4�;
      <br/>
      --         textLook(LIGHTGRAY,BLACK);
      <br/>
      --         gotoxy(xpos-12,ypos);
      <br/>
      --         printf(" *);
      <br/>
      --         gotoxy(xpos-12,ypos);
      <br/>
      --         i=0;
      <br/>
      --         maxi=-1;
      <br/>
      --         while ((c=getche())�=13) +
      <br/>
      --             if (c==8) +i=i-1;
      <br/>
      --                if (i&lt;0) i=0;
      <br/>
      --             }
      <br/>
      --             else+
      <br/>
      --                maxi-max(i,maxi);
      <br/>
      --             switch (whc)+
      <br/>
      --                case 1: training �i�=c; break;
      <br/>
      --                case 2: input �i�=c;   break;
      <br/>
      --                case 3: temp �i�=c; break;
      <br/>
      --                case 4: temp�i�=c;break;
      <br/>
      --                case 5: temp �i�=c;break;
      <br/>
      --                default: break;
      <br/>
      --             }
      <br/>
      --             i++;
      <br/>
      --             }
      <br/>
      -- }
      <br/>
      -- switch (whc) +
      <br/>
      --                case 1: training �maxi+1�=`.backslash.0`;break;
      <br/>
      --                case 2: input �maxi+1�=`.backslash.0`; break;
      <br/>
      --                case 3: temp�maxi+1�=`.backslash.0`;
      <br/>
      --                    FACTOR =(float) atof(temp); break;
      <br/>
      --                case 4: temp �max+1�`.backslash.0`;
      <br/>
      --                    f1=stoi(temp); break;
      <br/>
      --                case 5:
      <br/>
      --                    temp �maxi+1�=`.backslash.0`;
      <br/>
      --                    F2=stoi(temp); break;
      <br/>
      --                default: break;
      <br/>
      --             }
      <br/>
      --             /*      F1=F1-1;
      <br/>
      --                     F2=F2-1;   */
    </p>
    <p num="51">Appendix C</p>
    <p num="52">Computer software for modeling behavior for examples of the operating states of the commercial system.</p>
    <p num="53">
      --
      <br/>
      -- % function �Erms, X_hat, Err,WW2,WW� = mset (Input, rangeL, rangeU, D, DDi,
      <br/>
      --  ...
      <br/>
      -- %       out_cols, prt_cols, alpha, beta, p_flag, thrsh);
      <br/>
      -- %
      <br/>
      -- %    This function estimates the state of a system using the (MSET).
      <br/>
      It
      <br/>
      -- %    allows scaling of the input data to the range
      <br/>
      -- %    0-1 and the use of the algorithm in a predictive mode.
      <br/>
      -- %
      <br/>
      -- % Function outputs:
      <br/>
      -- %    Erms = Root mean squared errors variables specified by
      <br/>
      -- %                prt_cols.
      <br/>
      -- %    I_hat= Estimated states for variables specified by prt_cols.
      <br/>
      -- %    Err= Estimation error for variables specified by prt_cols.
      <br/>
      -- %
      <br/>
      -- % Function inputs:
      <br/>
      -- %    Input= input state matrix: an N by M+1 array with the first column
      <br/>
      -- %                containing a timestamp.
      <br/>
      The array contains n observation
      <br/>
      -- %                vectors, with a dependant variables in each vector.
      <br/>
      -- %    rangeL= Length M vector, where each element sets the upper limit of
      <br/>
      -- %                data for a corresponding variable.
      <br/>
      -- %    rangeU= Length M vector, where each element sets the upper limit of
      <br/>
      -- %                data for a corresponding variable.
      <br/>
      -- %    D=   Training set, an M by N array.
      <br/>
      -- %    DDi= Inverse of the similarity matrix (from auto_trainnsa).
      <br/>
      -- %    out_cols= Optional vector specifying which columns represent output
      <br/>
      -- %                variables predicted by the algorithm.
      <br/>
      These variables are
      <br/>
      -- %                not included in the evaluation of W.
      <br/>
      -- %    prt_cols= Optional vector specifying which columns to keep in the
      <br/>
      -- %                output.
      <br/>
      -- %    alpha= Multiplicative factor in the vprprod nonlinear operator.
      <br/>
      -- %    beta= Power factor in the vprprod nonlinear operator.
      <br/>
      -- %    p_flag= Print/don't print run progress data for 0/1.
      <br/>
      -- %    thrsh= Cutoff threshold for weighting vector W (default 0)
      <br/>
      -- % The rangeL and rangeU vectors are used to specify the anticipated range
      <br/>
      --  of
      <br/>
      -- % the variables.
      <br/>
      Data is linearly scaled from the ranges specified by these
      <br/>
      -- % vectors to the range 0:1.
      <br/>
      If the rangeL vector specifies the lower limit
      <br/>
      --  of
      <br/>
      -- % the data while rangeU is 0, then the code will shift the data by
      <br/>
      --  subtracting
      <br/>
      -- % the rangeL values from each element in a corresponding column of the
      <br/>
      --  data.
      <br/>
      -- % If both of the rangeL and rangeU vectors are set to a scalar value of 0,
      <br/>
      -- % the data will not be scaled.
      <br/>
      -- function �Erms, X_hat, Err,WW2,WW� = mset (Input, rangeL, rangeU, D, DDi,
      <br/>
      --  ...
      <br/>
      --         out_cols, prt_cols, alpha, beta, p_flag, thrsh);
      <br/>
      -- if (nargin &lt; 11), thrsh=0.0; and
      <br/>
      -- tic
      <br/>
      -- % Case in which not enough inputs are specified.
      <br/>
      -- if nargin &lt; 5
      <br/>
      --         error (`Required arguments are: Input, rangeL, rangeU, D and
      <br/>
      --  DDi.backslash.n.backslash.n`);
      <br/>
      -- end
      <br/>
      -- % Remove time stamp from input matrix and transpose input matrix.
      <br/>
      -- Time = Input (:,1);
      <br/>
      -- Y = Input (:,2:size(Input,2))`;
      <br/>
      -- �M, N�= size (Y);
      <br/>
      -- % If out_cols, prt_cols, alpha, beta, and p_flag are not specified, pick
      <br/>
      -- % default values for them.
      <br/>
      -- if nargin == 5, out_cols=0; prt_cols=1:M; alpha=1; beta=1; p_flage=0: end
      <br/>
      -- if nargin == 6, prt_cols=1:M; alpha=1; beta=1; p_flag=0; end
      <br/>
      -- if nargin == 7, alpha=1; beta=1; p_flag=0; end
      <br/>
      -- if nargin == 8, beta=1; p_flag=0; end
      <br/>
      -- if nargin == 9, p_flag=0; end
      <br/>
      -- if prt_cols == 0, prt_cols=1:M; end
      <br/>
      -- if alpha ==0; alpha=1; end
      <br/>
      -- if beta == 0, beta=1; end
      <br/>
      -- % Set print flag for debug printout.
      <br/>
      -- print_flag = p_flag;
      <br/>
      -- % Print message if print_flag is set.
      <br/>
      -- if (print_flag &gt;= 1)
      <br/>
      --         fprintf(`.backslash.n Starting MSET
      <br/>
      --  .........backslash.n.backslash.n`);
      <br/>
      -- end
      <br/>
      -- % Scale the input matrix to the range 0:1, if the rangeL and rangeU
      <br/>
      -- % vectors are specified.
      <br/>
      -- if (length(rangeL) == M) &amp; (length(rangeU) == M)
      <br/>
      --      % Scale each observation vector in the training matrix.
      <br/>
      --         Y=(Y-rangeL'*ones(1,N))./...
      <br/>
      --             (rangeU'*ones(1,N)-rangeL'*ones(1,N));
      <br/>
      --      %for i - 1:M
      <br/>
      --      %   Y(i,:) = (Y(i,:) - rangeL(i)) / (rangeU(i) - rangeL(i));
      <br/>
      --      %end
      <br/>
      --      % Print message if print_flag is set.
      <br/>
      --      if (print_flag &gt;= 1)
      <br/>
      --         fprintf(` Data is scaled to 0:1 range
      <br/>
      --  .....backslash.n.backslash.n`);
      <br/>
      --      end
      <br/>
      -- end
      <br/>
      -- % Shift the training matrix by the values specified in rangeL, if the
      <br/>
      --  rangeL
      <br/>
      -- % vector is specified and rangeU is 0.
      <br/>
      -- if (length(rangeL) == M) &amp; (rangeU == 0)
      <br/>
      --      % Shift each observation vector in the training matrix.
      <br/>
      --      Y = Y - rangeL'*ones(1,N);
      <br/>
      --      %for i = 1:M
      <br/>
      --      %   Y(i,:) = Y(i,:) - rangeL(i);
      <br/>
      --      %end
      <br/>
      --      % Print message if print_flag is set.
      <br/>
      --      if (print_flag &gt;= 1)
      <br/>
      --         fprintf(` Data is shifted by the values in
      <br/>
      --  rangeL.....backslash.n.backslash.n`);
      <br/>
      --      end
      <br/>
      -- end
      <br/>
      -- % If the are output colums specified, then remove these variables from the
      <br/>
      -- % D and Y matrices.
      <br/>
      -- D-proj = D;
      <br/>
      -- Y_proj = Y;
      <br/>
      -- if (out_cols -= 0)
      <br/>
      --      D_proj (out_cols,:) = ��;
      <br/>
      --      Y_proj (out-cols,:) = ��;
      <br/>
      -- end
      <br/>
      -- % Print message if print_flag is set.
      <br/>
      -- if (print_flag &gt;= 1)
      <br/>
      --      fprintf(` percent complete:  0`);
      <br/>
      -- end
      <br/>
      -- I_hat = zeros(lenth(prt_cols),N);
      <br/>
      -- tmp = zeros(M,1);
      <br/>
      -- Erms = zeros(length(prt_cols),1);
      <br/>
      -- Err = zeros(length(prt_cols),N);
      <br/>
      -- DtY = zeros(M-length(out_cols)1);
      <br/>
      -- W = zeros(N,1);
      <br/>
      -- % Main loop.
      <br/>
      Calculate estimate vectors (X_hat) for each input state
      <br/>
      -- % vecotr Y.
      <br/>
      -- for i=1:N
      <br/>
      --      DtY = vprprod(D_proj', Y_proj (:,i), alpha, beta);
      <br/>
      --      W = DDi * DtY;
      <br/>
      --         WW2(:,i)=W;
      <br/>
      --      %W = W ./ sum(W);
      <br/>
      --      ii=find(W&lt;thrsh):
      <br/>
      --      if(length(ii)&gt;0)
      <br/>
      --         W(ii)=zeros(length(ii),1);
      <br/>
      --      %  W = W./sum(W):
      <br/>
      --      end
      <br/>
      --         WW(:,i)=W;
      <br/>
      --      tmp = D * W;
      <br/>
      --      X_hat(:,i) = tmp(prt_cols);
      <br/>
      --      % Print message if print_flag is set.
      <br/>
      --      if (print_flag &gt;= 1)
      <br/>
      --         if ((rem(i,floor(N/100)) == 0) .vertline. (i ==1))
      <br/>
      --             fprintf(`.backslash.b.backslash.b.backslash.b`);
      <br/>
      --             fprint(`%3.0f`, i/N*100);
      <br/>
      --         end
      <br/>
      --      end
      <br/>
      -- end
      <br/>
      -- % Scale the X_hat matrix from the range 0:1 back to the range specified by
      <br/>
      -- % the rangeL and rangeU vectors, if necessary.
      <br/>
      -- if (length(rangeL) == M) &amp; (length(rangeU) ==M)
      <br/>
      --      % Scale each observation vector in the training matrix.
      <br/>
      --      %NNN=length(rangeU(prt_cols));
      <br/>
      --      %rU=rangeU(prt_cols); rL=rangeL(prt_cols);
      <br/>
      --      %X_hat=(rU(:)*ones(1,N)-...
      <br/>
      --      %           rL(:)*ones(1,N))...
      <br/>
      --      %           * I_hat + rL(:)*ones(1,N);
      <br/>
      --      for i = 1:length(prt_cols)
      <br/>
      --         X_hat(i,:) = (rangeU(prt_cols(i)) - rangeL(prt_cols(i))) * ...
      <br/>
      --                X_hat(i,:) + rangeL(prt_cols(i));
      <br/>
      --      end
      <br/>
      -- end
      <br/>
      -- % Shift the I_hat matrix back to the range of the data by adding rangeL to
      <br/>
      -- % the data, if necessary.
      <br/>
      -- if (length(rangeL) == M) &amp; (rangeU == 0)
      <br/>
      --      % Shift each observation vector in the training matrix.
      <br/>
      --      NNN=length(prt_cols);
      <br/>
      --      X_hat=X_hat + rangeL(prt_cols)*ones(1,NNN);
      <br/>
      --      %for i = 1:length(prt_cols)
      <br/>
      --      %       X_hat(i,:) = X_hat(i,:) + rangeL(prt_cols(i));
      <br/>
      --      %end
      <br/>
      -- end
      <br/>
      -- % Reset Y matrix to input matrix.
      <br/>
      -- Y = Input(:,2:size(Input,2))';
      <br/>
      -- % Calculate error.
      <br/>
      -- Err = Y(prt_cols,:) - X_hat;
      <br/>
      -- % Calculate rms error for variables specified by prt_cols.
      <br/>
      -- Erms = diag(Err * Err');
      <br/>
      -- Erms = sqrt(Erms' ./ (N - M - 1));
      <br/>
      -- % Add timestamp to X_hat and Err arrays and transpose X_hat and Err arrays.
      <br/>
      -- X_hat = (Time`, X_hat)`;
      <br/>
      -- Err = �Time`; Err�`;
      <br/>
      -- if (print_flag &gt;= 1)
      <br/>
      --      btm=fix(clock);
      <br/>
      --      fprintf(`.backslash.n.backslash.n Total time to complete MSET using %d
      <br/>
      --  training vectors.backslash.n`, ...
      <br/>
      --                sixe (D, 2));
      <br/>
      --      fprintf(`to analyze %d observations with %d variables each: ', N, M);
      <br/>
      --      fprintf(`%6.2f mins.backslash.n.backslash.n`, toc/60);
      <br/>
      -- end
      <br/>
      -- % function �z, norm_dist� vprprod (x, y, alpha, beta);
      <br/>
      -- %
      <br/>
      -- % This function performs the nonlinear operation on matrices x and y at the
      <br/>
      -- % heart of the MSET.
      <br/>
      It uses the following noclinear
      <br/>
      -- % operator to compare vectors in the matrices;
      <br/>
      -- %    f(dist) = 1 / (1 + alpha dist beta),
      <br/>
      -- where dist is the normalized distance between a vector in y and each
      <br/>
      -- % observation vector in x.
      <br/>
      -- %
      <br/>
      -- % If the constant alpha and beta are not specified, default values of 1 are
      <br/>
      -- % used for both of them.
      <br/>
      -- %
      <br/>
      -- % This version of vprprod returns the norm of the distance between the
      <br/>
      -- % each vector in y and the exemplar vectors in x. The vector distances are
      <br/>
      -- % normalized with respect to the sum of the distance vectors.
      <br/>
      -- %
      <br/>
      -- %
      <br/>
      -- %
      <br/>
      -- function �z, norm_dist� = vprprod (x, y, alpha, beta);
      <br/>
      -- if (nargin == 2)
      <br/>
      --      alpha = 1;
      <br/>
      --      beta = 1;
      <br/>
      -- end
      <br/>
      -- �Nx,Mx� = size(x);
      <br/>
      -- �Ny,My� = size(y);
      <br/>
      -- if (Mx -= Ny)
      <br/>
      --      fprintf(`.backslash.n.backslash.n in vprprod (x,y), the number of
      <br/>
      --  columns in x must.backslash.n`);
      <br/>
      --      fprintf(` equal the number of rows in y.backslash.n.backslash.n`);
      <br/>
      --      str=�`columns in x: `, num2str(Mx), ...
      <br/>
      --      `, and the number of rows in y: `, num2str(Ny)�;
      <br/>
      --      error(str);
      <br/>
      -- end
      <br/>
      -- % Initialize arrays.
      <br/>
      -- z = zeros (Nx,My);
      <br/>
      -- norm = zeros (Nx,My);
      <br/>
      -- yi = zeros (Nx,Mx);
      <br/>
      -- dist = zeros (Nx,1);
      <br/>
      -- tmp = zeros (Mx,Nx);
      <br/>
      -- for i = 1:My
      <br/>
      --      % Expand each column of y into a Nx by Ny (= Nx by Mx) matrix.
      <br/>
      -- end
    </p>
    <p num="54">Appendix D</p>
    <p num="55">Computer software for performing pattern recognition by detecting onset of degradation in noisy signals.</p>
    <p num="56">
      --
      <br/>
      -- /* SPRT MODULE                             */
      <br/>
      -- /**********************************************************/
      <br/>
      -- /* Start the SPRT analysis..... */
      <br/>
      -- /* Calculate The variance of the estimate errors*/
      <br/>
      -- if (length&lt;calcLength) calcLength=Length;
      <br/>
      -- mean1=0.0; mean2=0.0;
      <br/>
      -- for (i=0, i&lt;calcLength:i++)+
      <br/>
      --         fgets(buf,13,error1);
      <br/>
      --         temp=atof(buf);
      <br/>
      --         mean1+=temp/calcLength;
      <br/>
      --         fgets (fub,13,error2);
      <br/>
      --         temp=atof(buf);
      <br/>
      --         mean2+=temp/calcLength;
      <br/>
      -- }
      <br/>
      -- fseek(error1,0L,0);
      <br/>
      -- fseek(error2,0L,0);
      <br/>
      -- variance1=0.0; variance2=0.0;
      <br/>
      -- for (i=0;i&lt;calcLength,i++)+
      <br/>
      --         fgets(buf,13,error1);
      <br/>
      --         temp=atof(buf);
      <br/>
      --         variance1+=(temp-mean1)*(temp-mean1)/(calcLength-1);
      <br/>
      --         fgets(buf,13,error2);
      <br/>
      --         temp=atof(buf);
      <br/>
      --         variance2+=(temp-mean2)*(temp-mean2)/(calcLength-1);
      <br/>
      -- }
      <br/>
      -- fseek(error1,0L,0);
      <br/>
      -- fseek(error2,0L,0);
      <br/>
      -- /* Actual SPRT calculation and signal swapping logic */
      <br/>
      -- sub1=0; sub2=0;
      <br/>
      -- M1=FACTOR*sqrt(variance1);
      <br/>
      -- g1=M1/variance1;
      <br/>
      -- M2=FACTOR*sqrt(variance2);
      <br/>
      -- g2=M2/variance2;
      <br/>
      -- AA=log(BETA/(1-ALPHA));
      <br/>
      -- BB=log((1-BETA)/ALPHA);
      <br/>
      -- for(i=0; i&lt;4; i++)+
      <br/>
      --         if (i==0)fprintf(params, "%f.backslash.n",AA);
      <br/>
      --         if (i==1)fprintf(params, "%f.backslash.n",BB);
      <br/>
      --         if (i==2)fprintf(params, "%f.backslash.n",AA);
      <br/>
      --         if (i==3)fprintf(params, "%f.backslash.n",BB);
      <br/>
      -- }
      <br/>
      -- fclose(params):
      <br/>
      -- Spos1=0; Spos2=0; Sneg1=0; Sneg2=0;
      <br/>
      -- for (i=0, i&lt;Length;i++)+
      <br/>
      -- /*      fgets(buf,13,error2);
      <br/>
      --         temp=atof(buf);
      <br/>
      -- */
      <br/>
      --         fscanf(error1,"%f.backslash.n",%temp1);
      <br/>
      --         fscanf(error2,"%f.backslash.n",%temp2);
      <br/>
      --         if ((Spos1 == AA) .vertline..vertline. (Spos1 ==BB)) Spos1=0;
      <br/>
      --         if ((Spos2 == AA) .vertline..vertline. (Spos2 ==BB)) Spos2=0;
      <br/>
      --         if ((Sneg1 == AA) .vertline..vertline. (Sneg1 ==BB)) Sneg1=0;
      <br/>
      --         if ((Sneg2 == AA) .vertline..vertline. (Sneg2 ==BB)) Sneg2=0;
      <br/>
      --         steppos1= -g1*(M1/2 - temp1); stepneg1= -g1*(M1/2 + temp1);
      <br/>
      --         steppos2= -g2*(M2/2 - temp2); stepneg2= -g2*(M2/2 + temp2);
      <br/>
      --         Spos1 += steppos1; Sneg1 += stepneg1;
      <br/>
      --         Spos2 += steppos2; Sneg2 += stepneg2;
      <br/>
      --         if(Spos1 &lt;=AA) Spos1=AA: if Sneg1 &lt;= AA) Sneg1=AA;
      <br/>
      --         if(Spos2 &lt;=AA) Spos2=AA: if Sneg2 &lt;= AA) Sneg2=AA;
      <br/>
      --         if(Spos1 &gt;=BB) Spos1=BB: if Sneg1 &gt;= BB) Sneg1=BB;
      <br/>
      --         if(Spos2 &gt;=BB) Spos2=BB: if Sneg2 &gt;= BB) Sneg2=BB;
      <br/>
      --         if((Spos1&gt;=BB) .vertline..vertline. (Sneg1&gt;=BB)) sub1=1;
      <br/>
      --         if((Spos1&lt;=AA) %% (Sneg1&gt;=AA)) sub2=0;
      <br/>
      --         if((Spos2&gt;=BB) .vertline..vertline. (Sneg2&gt;=BB)) sub2=0;
      <br/>
      --         if((Spos2&lt;=AA) &amp;&amp; (Sneg2&lt;=AA)) sub2=0;
      <br/>
      --         fprintf(sprtpos1,"%f.backslash.n",Spos1);
      <br/>
      --         fprintf(sprtpos2,"%f.backslash.n",Spos2);
      <br/>
      --         fprintf(sprtneg1,"%f.backslash.n",Sneg1);
      <br/>
      --         fprintf(sprtneg2,"%f.backslash.n",Sneg2);
      <br/>
      --         fscanf(flow1,"%f.backslash.n",%temp1);
      <br/>
      --         fscanf(fast1,"%f.backslash.n",%temp2);
      <br/>
      --         if (sub1)
      <br/>
      --             fprintf(comb1,"%f.backslash.n",temp2);
      <br/>
      --         else
      <br/>
      --             fprintf(comb1,"%f.backslash.n",temp1);
      <br/>
      --         fscanf(flow2,"%f.backslash.n",&amp;temp1);
      <br/>
      --         fscanf(fest2,"%f.backslash.n",&amp;temp2);
      <br/>
      --         if (sub2)
      <br/>
      --             fprintf(comb2,"%f.backslash.n",temp2);
      <br/>
      --         else
      <br/>
      --             fprintf(comb2,"%f.backslash.n",temp1);
      <br/>
      --         if(fmod((double) (cnt+i+1), (double)per)==0) +
      <br/>
      --           gotoxy(47,11);
      <br/>
      --           cprintf("%-3.3f *,((float) (cnt+i+1))/((float)Length)*100/2;
      <br/>
      --         }
      <br/>
      -- }
      <br/>
      -- gotoxy(47,11),
      <br/>
      -- cprintf("%-3.3f *,100.0);
      <br/>
      -- gotoxy(34,15);
      <br/>
      -- textLook(WHITE,RED);
      <br/>
      -- cprintf("HIT ANY KEY ");
      <br/>
      -- gotoxy(45,15);
      <br/>
      -- getch��;
      <br/>
      -- fclose(sprtpos1); fclose(sprtneg1); fclose(fest1); fclose(error1);
      <br/>
      --             fclose(comb1); fclose(flow1);
      <br/>
      -- fclose(sprtpos2); fclose(sprtneg2), fclose(fast2); fclose(error2);
      <br/>
      --             fclose(comb2); fclose(flow2);
      <br/>
      -- fclose (In);
      <br/>
      -- }
      <br/>
      -- /**********************************************************/
      <br/>
      -- /**********************************************************/
      <br/>
      -- +
      <br/>
      --      int num, flag, i, j;
      <br/>
      --      char ch, buf�16�;
      <br/>
      --      num=0; flag=0; i=0; j=0;
      <br/>
      --      ch=fgetc (in);
      <br/>
      --      while ((ch�=`.backslash.n`)&amp;&amp;(chi=EOF))+
      <br/>
      --         num=(��isspace(ch)));/*&amp;&amp;(chi=`,`)&amp;&amp;(chi=`*`));*/
      <br/>
      --        /*  if (ch==`.backslash.n`) +k++; RowsD=j; j=0;} */
      <br/>
      --         if (num==1)+
      <br/>
      --             buf�i�=ch;
      <br/>
      --             i++;
      <br/>
      --             flag=1;
      <br/>
      --         }
      <br/>
      --         if ((num==0)%%(flag==1))+
      <br/>
      --             buf�i+1�=`.backslash.0`;
      <br/>
      --             Sample�j�=(float) strtod(buf,NULL);
      <br/>
      --             i=0;
      <br/>
      --             flag=0;
      <br/>
      --             j++;
      <br/>
      --         }
      <br/>
      --         ch=fgetc(in);
      <br/>
      --      }
      <br/>
      --      if (ch==EOF)+
      <br/>
      --         /*   fclose(In); */
      <br/>
      --         return (0);
      <br/>
      --      }
      <br/>
      --      else
      <br/>
      --         return (j);
      <br/>
      -- }
      <br/>
      -- float Ratio (float num1, float num2)+
      <br/>
      --      if ((num1 == 0) .vertline..vertline. ( num2 == 0 ))
      <br/>
      --         return 0.0;
      <br/>
      --      else if (num1 &gt;= num2)
      <br/>
      --         return num1/num2;
      <br/>
      -- }
      <br/>
      -- void AsIsD ��
      <br/>
      -- +
      <br/>
      --         int num, flag, i, j, k;
      <br/>
      --         char ch, buf�16�;
      <br/>
      --         num=0; flag=0; i=0; j=0; k=0;
      <br/>
      --         while ((ch=fgetc(Train)) �=EOF) +
      <br/>
      --             if (ch==`.backslash.n`) +k++; RowsD=j; j=0;}
      <br/>
      --             if (num==1)+
      <br/>
      --                buf�i�=ch;
      <br/>
      --                i++;
      <br/>
      --                flag=1;
      <br/>
      --             }
      <br/>
      --             if ((num==0)&amp;&amp;(flag==1))+
      <br/>
      --             but �i+1�=`.backslash.0`;
      <br/>
      --             Dt�k��j�= (float) strtod(buf,NULL);
      <br/>
      --             D�j��k� =(float) strtod (buf,NULL);
      <br/>
      --             i=0;
      <br/>
      --             flag=0;
      <br/>
      --             i++;
      <br/>
      --         }
      <br/>
      --      }
      <br/>
      --      ColsD=k;
      <br/>
      --      fclose(Train);
      <br/>
      -- }
      <br/>
      -- /**********************************************************/
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13.</claim-text>
      <claim-text>A computerized system for monitoring at least one of an industrial process and industrial sensors, comprising: means for generating time varying data from a plurality of industrial sensors; computer means for executing a software module for processing the time varying data to determine optimum time correlation of the data accumulated from the plurality of industrial sensors; computer means for executing a software module for searching the time correlated data to identify maximum and minimum values for the data, thereby determining a full range of values for the data characteristic of the at least one of the industrial process and the industrial sensors; computer means for executing a software module for determining learned states of a normal operational condition of the at least one of the industrial process and the industrial sensors and using the learned states to generate expected values characteristic of at least one of the industrial process and the industrial sensors; computer means for executing a software module for comparing the expected values to current actual values characteristic of the at least one of the industrial process and the industrial sensors to identify a current state of the at least one of the industrial process and the industrial sensors closest to one of the learned states and generating a set of modeled data;</claim-text>
      <claim-text>and computer means for executing a software module for processing the modeled data to identify a pattern for the data and upon detecting a deviation from a pattern characteristic of normal operation of the at least one of the industrial process and the industrial sensors, an alarm is generated.</claim-text>
      <claim-text>1. A method for monitoring a plurality of data sources in order to determine a pattern characteristic of a system, comprising the steps of:</claim-text>
      <claim-text>accumulating data over time from the data sources; processing the data to obtain optimum time correlation of the data accumulated from the plurality of data sources; determining learned states of at least one desired pattern of the system; using the learned states to generate expected data values of the data accumulated over time from the data sources of the system; comparing the expected data values to current actual data values of the data from the data sources to identify a current state of the system closest to one of the learned states and generating a set of modeled data;</claim-text>
      <claim-text>and determining from the modeled data a pattern for the current actual values and if the pattern deviates from a pattern characteristic of the desired pattern, an alarm notice is provided.</claim-text>
      <claim-text>2. The method as defined in claim 1 further including the step of searching the time correlated data to identify maximum and minimum values for the data to determine a full range of values for the data from the data sources.</claim-text>
      <claim-text>3. The method as defined in claim 1 wherein the data sources comprise at least one of industrial sensors and a financial information source.</claim-text>
      <claim-text>4. The method as defined in claim 1 further including the step of modifying the system responsive to determining a deviation from a pattern characteristic of the desired pattern.</claim-text>
      <claim-text>5. The method as defined in claim 1 wherein the step of determining optimum time correlation comprises comparing pairs of data from different data source, each set of data being characteristic of a separate data source and calculating a cross-correlation vector over time, applying a low pass filter to remove noise from the cross-correlation vector and determining a phase shift between the data.</claim-text>
      <claim-text>6. The method as defined in claim 5 wherein the step of determining the phase shift comprises differentiating the cross-correlation vector with respect to lag time between each pair of data and performing an interpolation to compute the root of the differential of the cross-correlation vector.</claim-text>
      <claim-text>7. The method as defined in claim 1 wherein the step of identifying a current state of the data closest to the learned states includes forming a combination of the learned states to identify a true state of the system.</claim-text>
      <claim-text>8. The method as defined in claim 7 further including the step of substituting an expected value for faulty observations from a system data source.</claim-text>
      <claim-text>9. The method as defined in claim 1 wherein the step of detecting a deviation from the desired pattern comprises applying a sequential probability ratio test to the modeled data.</claim-text>
      <claim-text>10. The method as defined in claim 1 wherein the step of detecting a deviation from a desired pattern comprises performing a pattern recognition analysis using computer means.</claim-text>
      <claim-text>11. The method as defined in claim 1 wherein the system is selected from the group consisting of an industrial manufacturing system, a utility operation, a business operation, an investment operator, a weather forecasting system, a database of medical information and a transportation system.</claim-text>
      <claim-text>12. The method as defined in claim 1 wherein the plurality of data sources includes a plurality of data source pairs.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The computerized system as defined in claim 13 wherein the industrial sensors include data sources which are selected from the group consisting of physical sensors, chemical sensors, biological sensors and financial data over time.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The computerized system as defined in claim 13 wherein said computer means for determining optimum time correlation comprises means for comparing pairs of data from different data sources, each characteristic of a separate data source and calculating a cross-correlation vector over time, applying a low pass filter to remove noise from the cross-correlation vector and determining a phase shift between the data.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The computerized system as defined in claim 15 wherein said computer means for determining the phase shift comprises means for differentiating the cross-correlation vector with respect to lag time between each pair of data and performing an interpolation to compute the root of the differential of the cross-correlation vector.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The computerized system as defined in claim 13 wherein said computer means for identifying a current state of the system closest to the learned state includes means for forming a combination of the learned states to identify a true state of the system.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The computerized system as defined in claim 17 further including computer means for executing a software module for substituting an expected value for faulty observations from at least one of the industrial sensors.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The computerized system as defined in claim 13 further including means for modifying the at least one of an industrial process and industrial sensors being monitored responsive to detecting a deviation from normal operation.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The computerized system as defined in claim 13 wherein said computer means for detecting a deviation pattern comprises means for performing a pattern recognition analysis.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. A system for monitoring a data source characteristic of a process, comprising: means for generating time varying data from a data source; computer means for executing a software module for processing the time varying data to determine optimum time correlation of the data accumulated from the data source; computer means for executing a software module for searching the time correlated data to identify maximum and minimum values for the data, thereby determining a full range of values for the data from the data source; computer means for executing a software module for determining learned states of a desired operational condition of the data source and using the learned states to generate expected values of the data source; computer means for executing a software module for comparing the expected values to current actual values of the data source to identify a current state of the data source closest to one of the learned states and generating a set of modeled data;</claim-text>
      <claim-text>and computer means for executing a software module for processing the modeled data to identify a pattern for the data and upon detecting a deviation from a pattern characteristic of normal operation of the process, an alarm is generated.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The system as defined in claim 21 further including means for modifying the process being monitored responsive to the alarm.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The system as defined in claim 21 wherein the data source is selected form the group consisting of an industrial data source, a utility operational data source, a business data source, a financial data source, a weather data source, a medical data source, a transportation data source and a chemical data source.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The system as defined in claim 21 wherein said computer means for determining optimum time correlation comprises means for comparing pairs of data from different data sources, each characteristic of a separate data source and calculating a cross-correlation vector over time, applying a low pass filter to remove noise from the cross-correlation vector and determining a phase shift between the data.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The system as defined in claim 21 wherein said computer means for identifying a current state of the process closest to the learned state includes means for forming a combination of the learned states to identify a true state of the process.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The system as defined in claim 21 further including means for identifying a current state of the process closed to the learned state comprises means for forming a combination of the learned states to identify a true state of the process.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The system as defined in claim 21 further including computer means for executing a software module for substituting an expected value for faulty observations from the data source.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The system as defined in claim 21 wherein said means for processing the modeled data to identify a pattern for the data comprises means for applying a sequential probability ratio test.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The system as defined in claim 21 wherein said means for processing the modeled data to identify a pattern for the data comprises means for performing a pattern recognition analysis.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. A system for monitoring a plurality of data sources in order to determine a pattern characteristic of a process, comprising: means for accumulating data over time from the data sources; means for processing the data to obtain optimum time correlation of the data accumulated from the plurality of the data sources; means for determining learned states of at least one desired pattern of the process; means for using the learned states to generate expected data values of the data accumulated over time from the data sources of the process; means for comparing the expected data values to current actual data values of the data from the data sources to identify a current state of the process closest to one of the learned states and generating a set of modeled data;</claim-text>
      <claim-text>and means for determining from the modeled data pattern for the current actual values and if the pattern deviates from a pattern characteristic of the desired pattern, an alarm notice is provided.</claim-text>
    </claim>
    <claim num="31">
      <claim-text>31. The system as defined in claim 30 further including means for searching the time correlated data to identify maximum and minimum values for the data to determine a full range of values for the data from the data sources.</claim-text>
    </claim>
    <claim num="32">
      <claim-text>32. The system as defined in claim 30 wherein said data sources are selected from the group consisting of an industrial data source, a utility operational data source, a business data source, a financial data source, a weather data source, a medical data source, a transportation data source and a chemical data source.</claim-text>
    </claim>
    <claim num="33">
      <claim-text>33. The system as defined in claim 30 further including means for substituting an expected value for faulty observation from one of said data sources.</claim-text>
    </claim>
    <claim num="34">
      <claim-text>34. The system as defined in claim 30 wherein said means for determining from the modeled data a pattern for the current actual values comprises a sequential probability ratio test.</claim-text>
    </claim>
    <claim num="35">
      <claim-text>35. The system as defined in claim 30 further including means for modifying the process being monitored responsive to the alarm notice.</claim-text>
    </claim>
    <claim num="36">
      <claim-text>36. A system for monitoring a process, comprising: input means for acquiring sensor data descriptive of an operational state of said process; memory means for storing a plurality of data values characteristic of at least one normal state of operation of said process; means for computing a measure of similarity of the operational state of the process with each of the plurality of data values characteristic of the at least one normal state of operation of the process;</claim-text>
      <claim-text>and alarm means for generating a signal indicative of a difference between the operational state and the at least one normal state of operation of the process, based on a sequence of such measures of similarity over successively acquired ones of said sensor data.</claim-text>
    </claim>
    <claim num="37">
      <claim-text>37. A system according to claim 36, wherein said means for computing further generates a set of estimated sensor data computed from the measure of similarity.</claim-text>
    </claim>
    <claim num="38">
      <claim-text>38. A system according to claim 37, wherein said alarm means is responsive to a difference between the sensor data and the estimated sensor data.</claim-text>
    </claim>
    <claim num="39">
      <claim-text>39. A system according to claim 38, wherein said alarm means applies a sequential probability ratio test to the difference between the sensor data and the estimated sensor data.</claim-text>
    </claim>
    <claim num="40">
      <claim-text>40. A system according to claim 39, wherein said means for computing determines the measure of similarity at least by comparing the sensor data to at least one value in the set of reference sensor data to compute a measure of association for each such comparison.</claim-text>
    </claim>
    <claim num="41">
      <claim-text>41. A system according to claim 40, wherein said means for computing determines the measure of similarity as a combination of a plurality of the association measures.</claim-text>
    </claim>
    <claim num="42">
      <claim-text>42. A system according to claim 41, wherein said means for computing determines the set of virtual sensor data as a linear combination of contributions from the set of reference sensor data wherein the contributions are determined based on the measure of similarity.</claim-text>
    </claim>
    <claim num="43">
      <claim-text>43. A system according to claim 37, further comprising presentation means disposed to receive the estimated sensor data and the sensor data, and responsive to the signal from said alarm means, presents a set of composite sensor data comprising at least a portion of the sensor data and at least a portion of the estimated sensor data.</claim-text>
    </claim>
    <claim num="44">
      <claim-text>44. A system according to claim 36, further comprising correlation means for receiving successive sensor data from said input means and presenting the sensor data to said processing means in a modified succession reflective of time delays of correlated effects between sensors in the sensor data.</claim-text>
    </claim>
    <claim num="45">
      <claim-text>45. A system according to claim 44, wherein said correlation means compares pairs of successive sensor data from different ones of the input means to compute a cross-correlation vector over time, removes noise from the cross-correlation vector by applying a low pass filter and determines a phase shift to apply to the sensor data for presentation to the processing means.</claim-text>
    </claim>
    <claim num="46">
      <claim-text>46. A system according to claim 36, further comprising memory update means for adding further reference sensor data to said memory means descriptive of additional normal states of operation of the process.</claim-text>
    </claim>
    <claim num="47">
      <claim-text>47. A method of determining an operational state of a process, comprising the steps of: collecting reference sensor data descriptive of normal states of operation of the process; acquiring recent sensor data from at least one sensor descriptive of the operational state of the process; computing a measure of association of the recent sensor data to reference sensor data of each of the normal states of operation of the process;</claim-text>
      <claim-text>and providing a composite of association measures as a determination of the operational state of the process.</claim-text>
    </claim>
    <claim num="48">
      <claim-text>48. A method according to claim 47, wherein said computing step further comprises for each of the at least one normal state, the steps of: comparing each element of the recent sensor data corresponding to a particular sensor to each element of reference sensor data corresponding to the particular sensor for one of the data values of the at least one normal state to provide a similarity value for each such step of comparing;</claim-text>
      <claim-text>and statistically combining all the similarity values for the one of the data values of the at least one normal state to compute a measure of association of the recent sensor data to the reference sensor data for the at least one normal state.</claim-text>
    </claim>
    <claim num="49">
      <claim-text>49. A method according to claim 48, wherein said step of statistically combining comprises averaging all such similarity values to provide the measure of association.</claim-text>
    </claim>
    <claim num="50">
      <claim-text>50. A method according to claim 48, comprising the further steps of: creating estimated sensor data from combinations of the reference sensor data based on the measure of association of the recent sensor data with the reference sensor data for each of the data values of the at least one normal state;</claim-text>
      <claim-text>and evaluating the estimated sensor data as a further determination of the operational state of the process.</claim-text>
    </claim>
    <claim num="51">
      <claim-text>51. A method according to claim 50, comprising the further steps of: obtaining a residual measure from the difference between the recent sensor data and the estimated sensor data; applying a statistical significance test to the residual measure;</claim-text>
      <claim-text>and generating a signal representative of a statistically significant difference between the operational state of the process and the at least one normal state of operation of the process.</claim-text>
    </claim>
    <claim num="52">
      <claim-text>52. A method according to claim 51 wherein said step of applying a statistical significance test comprises applying a sequential probability ratio test.</claim-text>
    </claim>
    <claim num="53">
      <claim-text>53. A method according to claim 47, wherein said step of collecting reference sensor data comprises the steps of: gathering sensor data from the process when the process is in one of the normal states; identifying in the gathered sensor data at least one set of data from the at least one sensor at moments when the sensor attains a highest value and a lowest value; combining in a collection each set of data identified in the previous step;</claim-text>
      <claim-text>and removing from the collection a redundant set of data.</claim-text>
    </claim>
    <claim num="54">
      <claim-text>54. A method according to claim 47, comprising the further steps of: determining if the operational state of the process is an additional normal state of operation, and if it is, then adding the recent sensor data to the collected reference sensor data.</claim-text>
    </claim>
    <claim num="55">
      <claim-text>55. A system for monitoring a process, comprising: input means for acquiring sensor data descriptive of an operational state of said process; memory means for storing a plurality of reference sensor data sets descriptive of normal states of operation of said process; means for computing a measure of similarity of the sensor data descriptive of the operational state of the process with each of the reference sensor data sets descriptive of the normal states of operation of the process;</claim-text>
      <claim-text>and alarm means for generating a signal indicative of a difference between the operational state and the normal states of operation of the process, based on the measure of similarity over successively acquired ones of said sensor data.</claim-text>
    </claim>
    <claim num="56">
      <claim-text>56. A system according to claim 55, wherein said means for computing further generates a set of estimated sensor data computed from the measure of similarity.</claim-text>
    </claim>
    <claim num="57">
      <claim-text>57. A system according to claim 55, wherein said alarm means is responsive to a difference between the sensor data and the estimated sensor data.</claim-text>
    </claim>
    <claim num="58">
      <claim-text>58. A system according to claim 55, wherein said alarm means applies a sequential probability ratio test to the difference between the sensor data and the estimated sensor data.</claim-text>
    </claim>
    <claim num="59">
      <claim-text>59. A system according to claim 55, further comprising presentation means disposed to receive the estimated sensor data and the sensor data, and responsive to the signal from said alarm means, presents a set of composite sensor data comprising at least a portion of the sensor data and at least a portion of the estimated sensor data.</claim-text>
    </claim>
  </claims>
</questel-patent-document>