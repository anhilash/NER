<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06192472B1.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as first publication">
      <document-id>
        <country>US</country>
        <doc-number>06192472</doc-number>
        <kind>B1</kind>
        <date>20010220</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6192472</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B1</original-publication-kind>
    <application-reference family-id="25457123" extended-family-id="42061088">
      <document-id>
        <country>US</country>
        <doc-number>09338797</doc-number>
        <kind>A</kind>
        <date>19990623</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09338797</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43099754</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>33879799</doc-number>
        <kind>A</kind>
        <date>19990623</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09338797</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>92898297</doc-number>
        <kind>A</kind>
        <date>19970912</date>
        <priority-linkage-type>3</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-08928982</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010220</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H04L   9/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>713165000</text>
        <class>713</class>
        <subclass>165000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>713153000</text>
        <class>713</class>
        <subclass>153000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-009/302</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>302</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130919</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-009/085</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>085</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140702</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-009/3257</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>3257</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140702</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99953</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99953</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>31</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>9</number-of-drawing-sheets>
      <number-of-figures>9</number-of-figures>
      <image-key data-format="questel">US6192472</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and apparatus for the secure distributed storage and retrieval of information</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>ROGAWAY PHILLIP W</text>
          <document-id>
            <country>US</country>
            <doc-number>5491749</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5491749</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>BELLARE MIHIR M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5491750</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5491750</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>CHENG PAU-CHEN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5544322</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5544322</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>BLAKLEY III GEORGE R, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5604490</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5604490</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>HERZBERG AMIR, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5625692</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5625692</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>FOSDICK ERIC L</text>
          <document-id>
            <country>US</country>
            <doc-number>5752041</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5752041</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>BRANDT MARCIA LYNN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5758068</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5758068</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>RABIN MICHAEL O</text>
          <document-id>
            <country>US</country>
            <doc-number>5485474</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5485474</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>David Chaum, "Blind Signatures for Untraceable Payments", Proceedings of Crypto 82, Aug. 1982, p. 199-203.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>Ran Canetti et al., "Proactive Security: Long-Term Protection Against Break-Ins", RSA Laboratories' CryptoBytes, vol. 3, No. 1, Spring 1997, p. 1-16.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>D. Chaum, "Achieving Electronic Privacy", Scientific American, Aug. 1992, p. 96-101. Copyright (C) 1992.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>Hugo Krawczyk, "Secret Sharing Made Short", Advances in Cryptology-Crypto 1993, Lecture Notes in Computer Science, pp. 136-146, Springer-Verlag, 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>Krawczyk, H., "Distributed Fingerprints and Secure Information Dispersal", Proc. 20th Anual ACM Symp. On Principles of Disb/tributed Computing , pp. 207-218, Ithaca, NY, 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="6">
          <text>Y.G. Desmedt. Threshold cryptography. European Transactions on Telecommunications, 5(4):449-457, Jul. 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="7">
          <text>Rabin, M., "Efficient Dispersal of Information for Security, Load Balancing, and Fault Tolerance", Journal of the ACM, vol. 36(2), pp. 335-348-1989.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="8">
          <text>Bellare M. et al., "Keying Hash Functions for Message Authentication," Proc. Advances in Cryptology-CRYPTO 1996, LNCS vol. 1109, Springer-Verlag, pp. 1-15, 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="9">
          <text>L. Lamport et al., The Byzantine General Problem, ACM Trans. Prog. Lang. and Systems, 4:3 (1982), pp. 382-401.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="10">
          <text>Shamir, A., "How to Share a Secret", Communications of the ACM, vol. 22, pp. 612-613, 1979.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <division>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>92898297</doc-number>
              <kind>A</kind>
              <date>19970912</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>5991414</doc-number>
              <kind>A</kind>
            </document-id>
          </parent-doc>
        </relation>
      </division>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Garay, Juan Alberto</name>
            <address>
              <address-1>Yonkers, NY, US</address-1>
              <city>Yonkers</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Gennaro, Rosario</name>
            <address>
              <address-1>New York, NY, US</address-1>
              <city>New York</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Jutla, Charanjit Singh</name>
            <address>
              <address-1>Elmsford, NY, US</address-1>
              <city>Elmsford</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Rabin, Tal D.</name>
            <address>
              <address-1>Riverdale, NY, US</address-1>
              <city>Riverdale</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>McGuireWoods</orgname>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>Herzberg, Louis B.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Beausoliel, Jr., Robert W.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A solution to the general problem of Secure Storage and Retrieval of Information (SSRI) guarantees that also the process of storing the information is correct even when some processors fail.
      <br/>
      A user interacts with the storage system by depositing a file and receiving a proof that the deposit was correctly executed.
      <br/>
      The user interacts with a single distinguished processor called the gateway.
      <br/>
      The mechanism enables storage in the presence of both inactive and maliciously active faults, while maintaining (asymptotical) space optimailty.
      <br/>
      This mechanism is enhanced with the added requirement of confidentiality of information; i.e., that a collusion of processors should not be able to learn anything about the information.
      <br/>
      Also, in this case space optimality is preserved.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This application is a division of U.S. patent application Ser.
      <br/>
      No. 08/928,982 filed Sep. 12, 1997, now U.S. Pat. No. 5,991,414.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="3">The present invention generally relates to the secure storage and retrieval of information and, more particularly, to a method and apparatus which guarantees the integrity and confidentiality of the stored information.</p>
    <p num="4">2. Description of the Prior Art</p>
    <p num="5">
      The problem this invention is concerned with is the secure storage and retrieval of information.
      <br/>
      Consider a user who stores his or her files on his or her workstation.
      <br/>
      Random failures (such as a hard disk crash) could cause the loss or the temporary unavailability of the data.
      <br/>
      Also possibly malicious intrusions may occur which would destroy both the confidentiality and integrity of the data.
      <br/>
      Ideally, the user would like a fully secure system which provides protection against these and maybe other kinds of faults without overburdening the system with memory and computational requirements.
    </p>
    <p num="6">
      Typically, protection against random failures is obtained via replication.
      <br/>
      That is, the data is stored in multiple locations so that failures in some of them can be tolerated.
      <br/>
      One such example is the Redundant And Inexpensive Drive (RAID) standard commonly used on servers in a Local Area Network (LAN).
      <br/>
      In order to obtain a significant degree of protection, there is a high cost in terms of memory requirements.
    </p>
    <p num="7">
      The notion of information dispersal was introduced by M. Rabin in his well-known Information Dispersal Algorithm (IDA) described in "Efficient Dispersal of Information for Security, Load Balancing, and Fault Tolerance", Journal of the ACM, Vol. 36(2), pp. 335-348, 1989.
      <br/>
      The basic approach taken in IDA is to distribute the information F being stored among n active processors in such a way that the retrieval of F is possible even in the presence of up to t failed (inactive) processors.
      <br/>
      The salient point was to achieve this goal while incurring a small overhead in needed memory.
      <br/>
      And in fact Rabin's result is space optimal.
      <br/>
      Retrieval of F is possible out of n-t pieces, where each piece is of length  (Equation image '1' not included in text)
    </p>
    <p num="8">
      The Information Dispersal Algorithm uses a linear transformation to convert m=nt-t bytes of input into m bytes of output.
      <br/>
      This transformation is given by an m * n matrix T over GF(28).
      <br/>
      Moreover, the matrix T has the property that every (n-t) columns of T are linearly independent.
      <br/>
      Thus, each input and output byte is viewed as an element of GF(28).
      <br/>
      The block size is m bytes and the operation is repeated for every m bytes.
    </p>
    <p num="9">
      Let the (i,j)th entry of T be represented by Tij.
      <br/>
      Let P0, P1, . . . , Pm-1 be a block of input.
      <br/>
      Then the output bytes Q0, Q1, . . . , Qn-1 are given by
      <br/>
      Qi =T0,i * P0 +T1,i * P1 +. . . Tm-1,i * Pm-1,
    </p>
    <p num="10">where the arithmetic is performed in the field GF (28)</p>
    <p num="11">
      Given any m output bytes, the input can be recovered because every m columns of T are linearly independent.
      <br/>
      In other words, the matrix S formed by taking the columns of T which correspond to these m output bytes is invertible.
      <br/>
      Again, the inverse of this matrix is computed over GF(28).
    </p>
    <p num="12">
      As an example, let m=3 and n=5.
      <br/>
      The following matrix T has the property that every three columns of T are linearly independent.
      <br/>
      Note that we are using polynomials in x for representing elements of GF(28).
      <br/>
      The polynomial arithmetic can be done modulo x8 +x6 +x5 +x4 +1, which is an irreducible polynomial over GF(2).  (Equation image '2' not included in text)
    </p>
    <p num="13">If, for example, only the first, second and fifth byte of a coded text are known, the plaintext (or original text) can be retrieved by applying the following transformation to the three bytes of coded text:  (Equation image '3' not included in text)</p>
    <p num="14">In addition to its optimal space complexity, the IDA technique has the following very attractive properties:</p>
    <p num="15">
      it permits any party in the system to retrieve the distributed information (by communicating with the piece holders);
      <br/>
      it does not require a central authority;
      <br/>
      it is symmetric with respect to all participants; and
      <br/>
      no secret cryptographic keys are involved.
    </p>
    <p num="16">However, this combination of very desirable properties is achieved at the expense of limiting the kind of faults against which the algorithm is robust, namely, by assuming that available pieces are always unmodified.</p>
    <p num="17">
      An enhanced mechanism to reconstruct the information when more general faults occur was presented by H. Krawczyk, in "Distributed Fingerprints and Secure Information Dispersal", Proc. 20th Annual ACM Symp. on Principles of Distributed Computing, pp. 207-218, Ithaca, N.Y., 1993, who called this problem, and its solution, the Secure Information Dispersal problem/algorithm (SIDA).
      <br/>
      This mechanism is able to tolerate malicious parties that can intentionally modify their shares of the information, and is also space optimal (asymptotically).
      <br/>
      In a nutshell, SIDA makes use of a cryptographic tool called distributed fingerprints, which basically consists of each processor's share being hashed, i.e., the fingeprints, and then distributing this value among an processors using the coding function of an error correcting code that is able to reconstruct from altered pieces (e.g., the Reed-Solomon code).
      <br/>
      In this way, the correct processors are able to reconstruct the fingerprints using the code's decoding function, check whether pieces of the tile were correctly returned, and finally reconstruct F from the correct pieces using the IDA algorithm.
    </p>
    <p num="18">A shortcoming of these methods is to assume that the faults only occur at reconstruction time, after the dispersal of the shares has been properly done.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="19">It is therefore an object of the present invention to provide a solution to the general problem of Secure Storage and Retrieval of Information (SSRI) and guarantee that also the process of storing the information is correct even when some of the processors fail.</p>
    <p num="20">
      We consider the scenario in which a user interacts with the storage system by depositing a file and receiving a proof (in the form of a receipt) that the deposit was correctly executed.
      <br/>
      For efficiency reasons, we require the distributed nature of the system to be transparent to the user, who will interact with a single distinguished processor which we call the gateway.
      <br/>
      This distinguished processor does not need to be the same for all users.
      <br/>
      This adds the extra technical difficulty of designing the protocol in a way that the gateway is not a single point of failure.
      <br/>
      The invention provides the following:
      <br/>
      SSRI with integrity: We introduce a mechanism that extends the above methods to enable storage in the presence of both inactive and maliciously active faults, while maintaining the (asymptotical) space optimality of the above methods.
      <br/>
      Namely, each share is of size  (Equation image '4' not included in text)
      <br/>
      plus a small quantity q which does not depend on the size of the file (but on n and a security parameter s defined as the logarithm base two of an acceptable probability of failure of the system).
    </p>
    <p num="21">SSRI with integrity and confidentiality: We also introduce a mechanism for SSRI with the added requirement of confidentiality of information;</p>
    <p num="22">
      i.e., that any collusion of up to t processors (except ones including the rightful owner of the information) should not be able to learn anything about the information.
      <br/>
      Also, in this case space optimality is preserved.
    </p>
    <p num="23">
      First we concern ourselves only with the integrity of the information.
      <br/>
      We introduce simple protocols that extend the above methods to enable storage in the presence of malicious faults, while maintaining the (asymptotical) space optimality of the above methods.
      <br/>
      Namely, each share is of size  (Equation image '5' not included in text)
    </p>
    <p num="24">
      plus a small quantity q which does not depend on the size of the file (but on n and a security parameter s).
      <br/>
      Our storage protocol is designed so that some form of consistency is maintained among the processors without incurring the cost of (potentially expensive) agreement protocols.
      <br/>
      Another important technical element of the storage protocol is the generation of receipts for the deposit of files through the application of distributed digital signatures.
      <br/>
      It will guarantee that a receipt is issued only when the correct information has been stored.
    </p>
    <p num="25">
      We also consider SSRI with the added requirement of confidentiality of information; i.e., that any collusion of up to t processors (except ones including the rightful owner of the information) should not be able to learn anything about the information.
      <br/>
      Confidentiality of information is easily achieved by encryption.
      <br/>
      Yet, this in return poses two problems.
      <br/>
      One is key management; that is, the safe deposit of the cryptographic key(s) used to encrypt the file that is deposited.
      <br/>
      And the second problem is how under this scheme would the user retrieve his file? Remember that he or she is communicating with the system through a single gateway, which means that if we use only known techniques of secret sharing reconstruction as described, for example, by A. Shamir in "How to Share a Secret", Communications of the ACM, Vol. 22, pp. 612, 613, 1979, the gateway will know all the information available to the user.
    </p>
    <p num="26">
      One novel component of our confidentiality protocol is the distributed key management aspect, via the application of threshold cryptography.
      <br/>
      This is a mechanism that allows the user to keep his or her decryption key shared among several (say n) servers in such a way that when the user wants to decrypt a given ciphertext, he or she will have to interact with a single server (the gateway) to obtain the matching plaintext, while none of the servers (including the gateway) gets any information about the plaintext.
      <br/>
      This solves the first problem.
    </p>
    <p num="27">
      The way we get around the second problem is via a novel application of "blinding" in the context of decryptions rather than signatures.
      <br/>
      See D. Chaum, "Blind signatures for untraceable payments", Proc.
      <br/>
      CRYPTO 82, pp. 199-203, 1983.
    </p>
    <p num="28">
      The novel characteristics of our invention are:
      <br/>
      distributed implementation of the storing device,
      <br/>
      tolerance of faults (inactive or maliciously active) during the process of storing and retrieval of the information,
      <br/>
      tolerance of faults as above, where all servers can be faulty during the lifetime of the system but only up to t servers can be faulty during each time interval (herein referred to as proactive SSRI),
      <br/>
      transparency of the distributed implementation from the user's point of view, and
      <br/>
      space optimality.
    </p>
    <p num="29">
      Potential uses and applications of our invention are:
      <br/>
      Electronic Vault.
      <br/>
      A robust distributed repository (a.k.a. E-Vault, strong box, safety box, secure back-up, secure archive) of users' information.
    </p>
    <p num="30">A mechanism for the delivery and distribution of files in a communication network robust against malicious failures and break-ins.</p>
    <p num="31">Regular and anonymous electronic P.O. Boxes with the same robustness and resiliency properties.</p>
    <p num="32">
      Secure distributed file system.
      <br/>
      We view the SSRI as implemented at the application Layer.
      <br/>
      However, the concepts described above can be broadened to apply to a distributed file system, with a richer functionality and security properties over Sun's Network File System (NFS) and the DCE-based Distributed File System (DFS).
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="33">
      The foregoing and other objects, aspects and advantages will be better understood from the following detailed description of a preferred embodiment of the invention with reference to the drawings, in which:
      <br/>
      FIG. 1 is a generalized block diagram showing a computer network system on which the method according to the invention may be implemented;
      <br/>
      FIG. 2 is a protocol flow diagram illustrating the deposit protocol according to the invention;
      <br/>
      FIG. 3 is a flow diagram of the deposit protocol performed by the servers in FIG. 1;
      <br/>
      FIG. 4 is a protocol flow diagram illustrating the retrieval protocol according to the invention;
      <br/>
      FIGS. 5A and 5B, taken together, are a flow diagram of the retrieval protocol according to the invention;
      <br/>
      FIG. 6 is a protocol flow diagram illustrating the retrieval protocol with confidentiality according to the invention; and
      <br/>
      FIGS. 7A and 7B, taken together, are a flow diagram of the retrieval protocol with confidentiality according to the invention.
    </p>
    <heading>DE</heading>
    <heading>TAILED DESCRIPTION OF A PREFERRED EMBODIMENT OF THE INVENTION</heading>
    <p num="34">Model, Definitions, and System Considerations</p>
    <p num="35">
      Referring now to the drawings, and more particularly to FIG. 1, we start by describing an abstraction of the distributed system in which our invention is practiced.
      <br/>
      The distributed system includes a communication network with two classes of entities: the users, denoted U1, U2, . . . , Um, and the servers, denoted V1, V2, . . . , Vn. In FIG. 1, only one user is indicated, but it will be understood that in a practical system, there will be a plurality of users.
      <br/>
      We will sometimes refer to the servers collectively as V. It is among the servers that the distributed storage of the information takes place.
    </p>
    <p num="36">
      We model the communication among the servers by a completely connected graph of authenticated links.
      <br/>
      For the purpose of this description, we also assume a point-to-point communication link between each of the users and every server.
      <br/>
      The servers V are connected in a network, which may be an intranet (e.g., LAN, WAN, etc.) or the Internet.
      <br/>
      In its preferred form, it is contemplated that the invention will be implemented on the World Wide Web (WWW).
      <br/>
      In such an environment, authenticated communication can be realized through, for example, SSL.
      <br/>
      Similarly, point-to-point communication can be realized in various ways, and not necessarily through a direct connection.
    </p>
    <p num="37">
      In a specific implementation of the invention, the servers may be IBM RS/6000 servers running the AIX operating system (IBM's version of the UNIX operating system), but these servers may also be mini-computers, such as IBM's AS/4000 computers, or mainframe computers, such as IBM's ES/9000 enterprise series computers.
      <br/>
      Other comparable computers of various other manufactures may be used as well.
      <br/>
      Secure point-to-point connections between servers may be provided by the Internet secure protocol IPSec.
    </p>
    <p num="38">
      For efficiency's sake, in our protocols the users will interact with a single, not necessarily the same, distinguished server, called the gateway (GW) server.
      <br/>
      However, our design is uniform in the sense that all servers are able to perform the same distribution and recovery functions.
      <br/>
      Thus, as shown in FIG. 1, the user's computer, which may be a personal computer (PC) with WWW interface, is connected to server V1 via a secure Internet connection (SSL); however, the user's computer may be connected to any one of the servers which, for purposes of either file storage or retrieval, may be designated as the GW server.
    </p>
    <p num="39">
      We assume the availability of a global clock, which allows the network computation to evolve as a series of rounds.
      <br/>
      Again, this is for simplicity of exposition, as our only need is a reliable time out mechanism and means to guarantee the freshness of authentication.
      <br/>
      Possible realizations of the latter are via secure time stamps.
    </p>
    <p num="40">
      It is assumed that at any time during the life of the system, at most t of the n servers can malfunction.
      <br/>
      Our design tolerates a wide range of failures, specifically:
    </p>
    <p num="41">Inactive failures (aka crash failures, fail-stop failures, omission failures): These failures occur when servers stop prematurely or when servers fail to send and receive messages as prescribed by the protocols.</p>
    <p num="42">
      Malicious failures (aka arbitrary failures, Byzantine failures): These failures occur when servers can act arbitrarily, without any restriction to their possible behavior.
      <br/>
      Further, we assume that the faulty servers can collude and act in concert in order to disrupt the computation.
      <br/>
      For example, the bad servers may try to prevent the storage or reconstruction of a file, learn some information, say a key, which a user wants to keep private.
    </p>
    <p num="43">
      The last type of fault reflects the security concern of break ins.
      <br/>
      We also assume that n&gt;2t.
    </p>
    <p num="44">
      Reconstruction is possible in information dispersal methods because some redundancy is added to the n pieces into which the original information is partitioned.
      <br/>
      The amount of redundancy in an information dispersal method is typically measured by the following parameter.
    </p>
    <p num="45">
      Definition 1.
      <br/>
      The blow-up factor of an information dispersal scheme is the ratio between the total size of the information being dispersed and the size of the original information. (By total size, we mean the sum of sizes of all distributed pieces.)
    </p>
    <p num="46">The blow-up of the methods of Rabin and Krawczyk, supra, is  (Equation image '6' not included in text)</p>
    <p num="47">
      which is clearly optimal if only n-t pieces are to be used for reconstruction.
      <br/>
      Our methods also maintain this bound.
      <br/>
      We note that reconstruction of information is also possible through error correcting codes.
      <br/>
      However, the inherent blow-up factor deteriorates to  (Equation image '7' not included in text)
    </p>
    <p num="48">in this case.</p>
    <p num="49">We now turn to describe the various cryptographic mechanisms that our protocols use.</p>
    <p num="50">Cryptographic Terminology and Tools</p>
    <p num="51">The cryptographic primitives used in the protocols are summarized in Tables 1 and 2.</p>
    <p num="52">
      -- TABLE 1
      <br/>
      -- Keys
      <br/>
      --      PKU, SKU  Public and secret keys for a 1024-bit
      <br/>
      --                         RSA-OAE of user/party U
      <br/>
      --      CERTU         Public key certificate of user U issued
      <br/>
      --                         by the servers V. We assume it includes
      <br/>
      --                         U, PKU and V's signature on PKU.
      <br/>
      --      PKU, s, SKU, s  Public and secret "signing" keys of
      <br/>
      --                         user/party U for a 1024-bit RSA-SHA-1
      <br/>
      --                         scheme
      <br/>
      --      skvi          Server Vi 's share of secret key SKv
    </p>
    <p num="53">
      -- TABLE 2
      <br/>
      -- Cryptographic Primitives
      <br/>
      --      +character pullout}( * ) SHA-1: a strong collision-resistant
      <br/>
      --                         one-way hash function.
      <br/>
      Think of +character
      <br/>
      --  pullout}( * )
      <br/>
      --                         as returning "random" values
      <br/>
      --      EU            1024-bit RSA-OAE public key
      <br/>
      --                         encryption using PKU
      <br/>
      --      SU ( * ) RSA-SHA-1 digital signature with
      <br/>
      --                         respect to SKU.
      <br/>
      Note the signature of
      <br/>
      --                         message m does NOT include m.
      <br/>
      --      Sv1, . . . , vn ( * ) Distributed RSA-SHA-1 digital
      <br/>
      --                         signature with respect to keys
      <br/>
      --                         skv1, . . . , skvs
      <br/>
      --       SIGMA vi ( * ) Partial digital signature with
      <br/>
      --                         respect to skvi
      <br/>
      --      eK            DES-CBC: symmetric key-based
      <br/>
      --                         encryption algorithm, taking key K
      <br/>
      --                         and a plaintext, and producing the
      <br/>
      --                         ciphertext
      <br/>
      --      macK          HMAC: message authentication code
      <br/>
      --                         (MAC), taking key K and a plaintext,
      <br/>
      --                         and returning a short tag
      <br/>
      --      fK            HMAC: a conjectured pseudorandom
      <br/>
      --                         function with index K
      <br/>
      --      RS( * )       Reed-Solomon code
    </p>
    <p num="54">
      All the users have public/secret key pairs.
      <br/>
      These keys are used for the basic encryption/decryption functions, respectively. (For simplicity, we will assume that the servers also act as the certification authority (CA), so that no third party needs to be involved in the transactions in order to verify the validity of the public keys.) The encryption function is randomized: E, invoked upon message m will use some randomizer, so that each encryption is different from previous ones.
      <br/>
      The notation .sym. denotes bitwise exclusive OR (XOR).
    </p>
    <p num="55">
      The privacy requirement of SSRI with confidentiality raises the question of key management; i.e., the safe deposit of the keys used to encrypt the files.
      <br/>
      The simplest solution requires each user to have a public key for encryption, say PKU, and the corresponding private key SKU.
      <br/>
      This requires the user U to maintain SKU in a safe manner.
      <br/>
      For conceptual and security reasons, we assume users have two sets of public/secret key pairs, one for encryption and the other for authentication (SKU,s) (i.e., "signing") purposes. (This is a natural assumption, as all browsers provided it in some form or another.) Ideally, the user would keep the latter in her smart cards; alternatively, the user's application (e.g., a browser) would (only) provide an authentication key.
    </p>
    <p num="56">The following describes two major tools that we use in our protocols.</p>
    <p num="57">Threshold Cryptography</p>
    <p num="58">
      The security of cryptographic protocols relies mainly on the security of the secret keys used in these protocols.
      <br/>
      Security means that these keys should be kept secret from unauthorized parties, but at the same time should always be available to the legitimate users.
    </p>
    <p num="59">
      Threshold cryptography embodies techniques that help in achieving the above goals.
      <br/>
      Suppose you have a key K which is used to perform some cryptographic function F on a message m, denote the result with FK (m).
      <br/>
      The idea is to start with a sharing of K among a set of players P1, . . . , Pn using a (t,n) secret sharing scheme.
      <br/>
      See Shamir, supra.
      <br/>
      And then compute PH without ever reconstruct the key K, using it instead implicitly when the function FK needs to be computed.
      <br/>
      This is done by having the players compute values based on their shares of the key.
    </p>
    <p num="60">
      There are various methods for generating the sharing of the secret key.
      <br/>
      Here we will only note that they require various levels of trust in the system.
    </p>
    <p num="61">
      In the following we will use this terminology.
      <br/>
      Let the n servers V1, . . . , Vn hold shares sk1, . . . , skn, respectively, of a secret key SK which is the inverse of a public key PK.
    </p>
    <p num="62">A distributed threshold decryption protocol using V1, . . . , Vn, is a protocol that takes as input a ciphertext C which has been encrypted with PK (i.e., c=EPK (m) for some message m), and outputs m.</p>
    <p num="63">A distributed threshold signature protocol for V1, . . . , Vn is a protocol that takes as input a message m and outputs a signature a for m under SK.</p>
    <p num="64">
      The above protocols must be secure; i.e., they must reveal no information about the secret key SK.
      <br/>
      A threshold cryptography protocol is called t-robust if it also tolerates t malicious faults.
    </p>
    <p num="65">
      Using threshold cryptography increases the secrecy of the key since now an attacker has to break into t+1 servers in order to find out the value of K. Also, the basic approach increases the availability of the key in the presence of fail-stop faults (crashes).
      <br/>
      Indeed, it suffices to have t+1 functioning servers to be able to compute the function FK, meaning that one can tolerate up to n-t-1 crashes.
    </p>
    <p num="66">A survey of threshold cryptography technique can be found in Y. G. Desmedt, "Threshold Cryptography", European Transactions on Telecommunications, 5(4):449-457, Jul. 1994. We present below an example of threshold cryptography applied to the RSA cryptosystem.</p>
    <p num="67">Example: Threshold RSA</p>
    <p num="68">
      We give a specific example of threshold cryptography assuming that the public key cryptosystem used is RSA.
      <br/>
      In this case,
      <br/>
      PK=(3,N),
    </p>
    <p num="69">
      where N is the RSA module, and
      <br/>
      SK=(d,N),
    </p>
    <p num="70">
      where d is the inverse of 3 modulo  PHI  (N).
      <br/>
      Assume that the user's secret key SK has been shared as an n-out-of-n sharing, meaning all the shares will be required in order to reconstruct the key (this is without loss generality, as it is easy to generalize to a threshold scheme).
      <br/>
      We can assume that SKj=dj,
    </p>
    <p num="71">
      where
      <br/>
      d1 + . . . +dn =dmod PHI (N).
    </p>
    <p num="72">
      Assume we want to compute a signature  SIGMA =md mod n for a message m. Then each server can compute the following
      <br/>
      SIGMA j =mdj  modN
    </p>
    <p num="73">and then we see that</p>
    <p num="74">SIGMA 1 *  SIGMA 2 . . .  SIGMA n =md1 . . . mdn  =md1 + . . . +dn  = SIGMA</p>
    <p num="75">A dual approach clearly works for RSA signatures.</p>
    <p num="76">Initialization</p>
    <p num="77">
      The n servers are initialized in a trusted environment.
      <br/>
      Each of them is given a "name" (i.e., V1 to V2), an Initialization Procedure (IP) address and a share of the signing and decryption key for the whole system.
      <br/>
      The key generation is done by a trusted party who then "self-destroys" after generating such keys and sharing them among the servers.
      <br/>
      In case one uses discrete-log based cryptosystems, it is possible to have the n servers run a key generation protocol which eliminates the need for such trusted party.
      <br/>
      However, the other parts of the initialization needs to be conducted in a trusted environment.
    </p>
    <p num="78">Blinding</p>
    <p num="79">
      The cryptographic technique called "blinding" as described by Chaum, surpa, can be explained as follows.
      <br/>
      Suppose that a server holds a secret key SK that allows the server to compute a cryptographic function FSK (once again, think of F as a signature or a decryption algorithm).
      <br/>
      Assume also that the matching public key PK is known, which allows the computation of the inverse function FPK =FSK-1.
    </p>
    <p num="80">
      Consider the following problem.
      <br/>
      A user wants to obtain the result of FSK (m) but without telling the server the value in on which he wants the function to be computed.
      <br/>
      If the functions FPK and FSK are homomorphic, i.e., F(ab)=F(a)F(b), then the problem has a solution.
    </p>
    <p num="81">The user generates a random string r, computes the value s=FPK (r) using the public key PK and presents the server with the value ms which is random and thus gives no information about m. The server returns the value FSK (ms) which, by the homomorphic properties of FSK, is equal to FSK (m)FSK (s)=FSK (m)FSK (FPK (r) )=FSK (m) * r. Thus, if the user divides the obtained result by r, he or she obtains the desired output.</p>
    <p num="82">Example: Blinding with the RSA Cryptosystem</p>
    <p num="83">
      We present an example of the blinding technique as described Chaum based on RSA.
      <br/>
      The server owns the secret key SK=(d,N) and the user knows the public key PK=(e,N).
      <br/>
      The user wants to decrypt a ciphertext c=me mod N without telling the server c. The user chooses r at random and computes s=re mod N. The user then gives cs=(mr) mod N to the server who returns w=(CS) d =mr mod N. Finally, the user computes  (Equation image '8' not included in text)
    </p>
    <p num="84">
      A novelty of this invention is the way we use blinding.
      <br/>
      Traditionally, this technique was introduced to obtain signatures from a server on secret messages.
      <br/>
      This is in turn was used to produce untraceable electronic cash.
      <br/>
      We use blinding in the context of decryptions rather than signatures in order to enhance the security of our distributed key management.
      <br/>
      The use of blinding will protect the privacy of the user's information against all servers (in particular the "gateway" or GW server), hence eliminating the possibility of privacy loss due to a single point of failure.
    </p>
    <p num="85">
      We now present a high-level description of our "integrity only" protocol.
      <br/>
      The protocols extend the methods of Rabin and Krawczyk, supra, for integrity to achieve SSRI while maintaining (asymptotically) the space optimality.
      <br/>
      Namely, each share of the file F deposited at each server is of size  (Equation image '9' not included in text)
    </p>
    <p num="86">
      plus a small quantity which does not depend on the size of the file.
      <br/>
      We distinguish the following three transactions in SSRI for integrity:
    </p>
    <p num="87">Deposit: User U contacts the gateway GW, deposits file F, and gets a receipt for it.</p>
    <p num="88">Dispersal: The actual information dispersal takes place among the servers Vj.</p>
    <p num="89">Retrieval: The user contacts GW to get F back.</p>
    <p num="90">
      The Deposit protocol is initiated by a user U who would like to store a file safely.
      <br/>
      The user contacts one of the servers (GW) and transmits a request for deposit.
      <br/>
      This request includes a digital signature on the file being stored.
      <br/>
      The user will conclude that the deposit has been carried out successfully once he or she receives a receipt from GW.
      <br/>
      We require that the protocol for Deposit satisfy the following two conditions:
      <br/>
      Deposit Availability: A user wishing to deposit a file will always manage to do so and will receive a receipt (i.e., proof of deposit).
    </p>
    <p num="91">Deposit Correctness: If a receipt is generated by the servers for a file F, then all the correct servers have a copy of the file.</p>
    <p num="92">Table 3 is a skeleton of the (fault-free) flow of the protocol for Deposit, and FIG. 2 is the corresponding protocol flow diagram.</p>
    <p num="93">
      -- TABLE 3
      <br/>
      -- Fields
      <br/>
      --         F           User' file to be deposited at the servers.
    </p>
    <p num="94">
      For the purpose of this description, we set aside all kinds of optimization issues, such as reducing the number of "echo" messages, reducing their size (e.g., only re-transmit the file when necessary, otherwise send its hash), arranging fields so that cryptographic operations do not have to be computed twice, etc.
      <br/>
      For the issuance of the receipt, the servers implement a (t+1)-threshold signature, meaning that at least t+1 servers have to participate in the signing, and that the faulty servers by themselves cannot generate a correct signature.
    </p>
    <p num="95">
      We now describe the protocol in more detail, with reference to FIG. 3.
      <br/>
      In deposit request 300, the user contacts GW and submits the file he or she wants to deposit, together with his or her signature on the file under his or her private authentication key.
      <br/>
      The user keeps a hash of the file +character pullout}(F) for future control.
      <br/>
      This is not mandatory, but it will enable the user to verify the file upon retrieval without verifying a digital signature.
      <br/>
      In execution block 310, the GW forwards the request from the previous flow to the remaining servers.
      <br/>
      Every server receiving a (valid) message from GW "echoes" this message request to every other server at 320.
      <br/>
      Servers receiving at least one valid message store F as a valid request from user U. Servers receiving the DExecutionl (block 310) message from GW use their share of the secret key to generate a partial signature on F and U, and send this message to GW at block 330.
      <br/>
      Servers not receiving a DExecutionl message from GW do not participate.
      <br/>
      In receipt 340, the GW computes the distributed digital signature on F and U, and sends it to the user.
      <br/>
      Should the user not receive a receipt from GW, he or she tries again a different server (as the design of the servers is uniform, it is guaranteed that the user will eventually contact a correct server).
    </p>
    <p num="96">
      We note that a solution is possible which does not require the user to generate a signature during Deposit.
      <br/>
      This, however, happens at the expense of the servers running a Byzantine agreement protocol in order to maintain consistency.
      <br/>
      Roughly, in Byzantine agreement, as described, for example, by L. Lamport, R. E. Shostak and M. Pease, "The Byzantine General's Problem", ACM Trans.
      <br/>
      Prog. Lang. and Systems, 4:3(1982, pp. 382-401, a distinguished processor called "the source" sends its initial value to all other processors.
      <br/>
      It is required that upon termination of the protocol all the correct processors output the same "value and, moreover, if the source is correct, then the value the correct processors output is the value sent by the source.
      <br/>
      However, running a Byzantine agreement protocol is potentially expensive, in terms of number of communication rounds (greater than or equal to t+1), and communication complexity.
    </p>
    <p num="97">We now provide some justification for the correctness of the Deposit protocol.</p>
    <p num="98">Lemma I Protocol Deposit satisfies the Deposit Availability and Correctness conditions.</p>
    <p num="99">
      Proof: Deposit Availability.
      <br/>
      If GW does not respond to the user with a receipt, then the user will turn to another server in order to deposit the file.
      <br/>
      As, by assumption, only a fraction of the servers can malfunction and the design of the servers is uniform, it is guaranteed that the user will eventually contact a correct GW.
      <br/>
      Once this happens, all the correct servers get the user's message, reply with a partial signature under their share of the private key, and a correct receipt is generated by GW and sent to the user.
    </p>
    <p num="100">
      Deposit Validity.
      <br/>
      If a receipt is generated for a file F, then there were at least t+1 partial signatures generated for this file under the server's shares of the secret key SKv.
      <br/>
      As we assume that at most t of the servers can be faulty, this implies that at least one of these partial signatures was generated by a correct server.
      <br/>
      A correct server generates a partial signature only if it has received a valid deposit request from GW, and in this case it also echoes the file to all the other servers.
      <br/>
      Hence, every correct server has a copy of the file.
    </p>
    <p num="101">Dispersal</p>
    <p num="102">The sketch for the second transaction, Dispersal, is shown in Table 4.</p>
    <p num="103">
      -- TABLE 4
      <br/>
      -- Fields
      <br/>
      --         F           User file to be dispersed among servers
      <br/>
      --                     Vi, 1  &lt;=  i  &lt;=  n
      <br/>
      --         Fi     Portion of the file dispersed at server Vi
      <br/>
      --         +character pullout}(Fi) Hash of Fi
    </p>
    <p num="104">The protocol steps are as follows:</p>
    <p num="105">
      Each server Vi, 1 &lt;= i &lt;= n, does:
      <br/>
      .A-inverted.j, 1 &lt;= j &lt;= n, compute Fj =F * Tj (IDA);
      <br/>
      .A-inverted.j, 1 &lt;= j &lt;= n, compute +character pullout}(Fj);
      <br/>
      save Fi and +character pullout}(Fj), 1 &lt;= j &lt;= n.
    </p>
    <p num="106">
      We assume that the starting point for Dispersal is consistent as a result of Deposit.
      <br/>
      Namely, every correct server has a copy of the user's file F. The dispersal is a local computation requiring no communication.
      <br/>
      Every correct server computes everybody's share of F using IDA and the corresponding hashes of the pieces, and saves its own share of the file and all the hashes.
    </p>
    <p num="107">
      The storage required by this method is as follows.
      <br/>
      Each server is saving its portion of the file .vertline.Fi.vertline., plus all the hashes +character pullout}(Fj), 1 &lt;= j &lt;= n. Thus, the memory required at each server is .vertline.Fj.vertline.+n.vertline.+character pullout}(Fj).vertline.. We note that .vertline.+character pullout}(Fj).vertline. is independent of the size of F and small (e.g., 160 bits).
      <br/>
      This overhead becomes relatively Less significant as the size of the file increases.
      <br/>
      In contrast, Krawczyk, supra, suggests sharing the hashes of the pieces themselves using Reed-Solomon codes.
      <br/>
      The space required by that method is  (Equation image '10' not included in text)
    </p>
    <p num="108">Thus, our approach is slightly less efficient storage wise but with the advantage of avoiding the complexity of the coding and the communication. (Also note that for values of realistic implementations, e.g., n=5 and t=2, the storage requirements would be identical.)</p>
    <p num="109">Retrieval</p>
    <p num="110">
      Retrieval is the transaction initiated byh a user in order to retrieve a file he or she has previously deposited and for which he or she has received a receipt.
      <br/>
      The protocol for Retrieval satisfies the following requirements:
      <br/>
      Retrieval Availability: A user who has previously deposited a file (and received a receipt for it) will always be able to retrieve
      <br/>
      Retrieval Correctness: It is impossible for a part other than the rightful owner of the file to retrieve it.
    </p>
    <p num="111">The protocol flows for the Retrieval transaction is shown in Table 5, and its protocol flow diagram is shown in FIG. 4.</p>
    <p num="112">
      -- TABLE 5
      <br/>
      -- Fields
      <br/>
      --         Fj       Portion of the file stored in server Vj
      <br/>
      --         +character pullout}(Fj) Hash of Fj
      <br/>
      --         +character pullout} Hashes of all fis stored at each server,
      <br/>
      --                       i.e., +character pullout}(Fi), 1  &lt;=  i
      <br/>
      --   &lt;=  n
    </p>
    <p num="113">
      With reference now to FIGS. 5A and 5B, in Retrieval Request 600, the user contacts the GW to get the file back.
      <br/>
      He or she sends information identifying the deposit and signs the request under his or her authentication key, which convinces the servers of the authenticity of the request.
      <br/>
      In fact, more is needed than shown, e.g., a transaction ID, in order to prevent so-called "re-play" attacks, but we ignore this problem for the purpose of this discussion.
      <br/>
      In execution block 610, GW forwards the user's request to all servers.
      <br/>
      Every server Vj receiving the request sends to GW its share Fj of the file, together with file hashes of an the shares +character pullout}(Fi), 1 &lt;= i &lt;= n in block 620.
      <br/>
      GW establishes what hashes are valid by computing majority, and discards those shares of the file whose hash does not evaluate to the computed one.
      <br/>
      Finally, the GW reconstructs the file using the remaining shares using IDA in block 630.
      <br/>
      Specifically, GW computes the following:
      <br/>
      .A-inverted.j, +character pullout}(Fj)=majority of received +character pullout}(Fj);
      <br/>
      G: set of good indices; G=0;
      <br/>
      .A-inverted.j, if Fj evaluates to +character pullout}(Fj) then G=Gu 0 (slashed zero) +j};
      <br/>
      F= SIGMA ieG Fi * Ti-1 (reconstruct IDA).
    </p>
    <p num="114">
      In delivery block 640 (FIG. 5B), GW sends the file to the user.
      <br/>
      Upon receiving the file F, the user computes +character pullout}(F) and verifies that it matches the hash that he or she stored during.
      <br/>
      If so, he or she sends a conformity message to the GW in block 650, and GW forwards the `OK` message to all servers in block 660.
      <br/>
      Servers receiving the message from GW echo it to all servers in block 670.
    </p>
    <p num="115">Lemma 2 The Retrieval protocol satisfies the Retrieval Availability and Retrieval Correctness conditions.</p>
    <p num="116">
      Proof: Retrieval Availability.
      <br/>
      If GW does not respond to the user with the requested file, then the user will turn to another server in order to retrieve the file.
      <br/>
      As, by assumption, only a fraction of the servers can malfunction, and the design of the servers is uniform, it is guaranteed that the user will eventually contact a correct GW.
      <br/>
      Once this happens, all the correct servers get the user's request.
      <br/>
      As we assume that the user has in fact previously deposited the file and received a receipt, we are guaranteed that each correct server has saved the file (Lemma 1).
      <br/>
      This in turn enables each correct server to send GW its piece of the file and the hashes of all shares.
      <br/>
      Thus, GW will be able to compute the correct majority on the hashes and properly reconstruct the file.
    </p>
    <p num="117">
      Retrieval Correctness.
      <br/>
      If an improper request for Retrieval is received by the correct servers, they will not send their shares to GW.
      <br/>
      GW needs at least t+1 shares of the file in order to reconstruct it.
      <br/>
      As there are at most t faulty servers, GW will be short by at least one piece.
    </p>
    <p num="118">
      Lemmas 1 and 2, together with the arguments of the Dispersal subsection allow us to corroborate our claims of an integrity SSRI system with an asymptotically optimal blow-up.
      <br/>
      We now turn to the added requirement of confidentiality of the information.
    </p>
    <p num="119">Integrity and Confidentiality</p>
    <p num="120">
      We extend our protocols to enable the user to store the files while maintaining their contents private.
      <br/>
      The requirements for the confidentiality function consist of the Validity and Consistency conditions of the integrity, while adding to it a privacy condition.
      <br/>
      Any coalition of up to t servers (even those including GW) cannot learn anything about the contents of the file.
    </p>
    <p num="121">
      The privacy requirement poses the question of key management, that is, the safe deposit of the keys used to encrypt the file.
      <br/>
      The simplest solution requires each user U to have a public key for encryption, say PKU, and the corresponding private key SKU.
      <br/>
      This requires the user U to maintain SKU in a safe manner, just as he or she is maintaining the authentication private key SKU,3.
      <br/>
      To deposit a file F with confidentiality, the user would generate a key (say a DES key) FK, encrypt the file F with FK, encrypt the key FK with the public key PKU, and deposit both the encrypted file and the encrypted key EU (FK).
      <br/>
      The retrieval procedure is just the reverse.
    </p>
    <p num="122">
      However, it may be impractical or insecure to require that the user maintain the key SKU.
      <br/>
      In the case of a smartcard implementation, the smartcard which maintains such keys securely may be limited in memory.
      <br/>
      In a software only solution, it would be ill-advised to keep SKU at the user's workstation, as if this key is compromised, then the secrecy of all the data will be lost.
      <br/>
      On the other hand, just maintaining the authentication key presents less of a problem, as authenticity can be regained through a combination of on-line and out-of-band steps.
      <br/>
      Also, the user application (e.g., a browser) may only provide an authentication key.
    </p>
    <p num="123">
      In the following, we show how SKU can be kept shared among the servers.
      <br/>
      This improves the security of SKU and it also provides a key recovery function for emergency situations.
      <br/>
      The file DES key FK will be retrieved by the user (or transferred to another user) without even the gateway server GW getting any knowledge about FK.
      <br/>
      To this end we use "blinding" in a novel way.
      <br/>
      We add confidentiality on top of the integrity-only solution described above.
      <br/>
      For this we require in our design that the user's private key SKU be kept shared among the servers, as described in more detail below.
    </p>
    <p num="124">
      Now we assume that in the Deposit protocol the file F is really the encrypted file eFK (F), under the key FK, and we append the encryption of the key EU (FK), under the user's encryption key.
      <br/>
      In the Dispersal protocol, however, it might be more time efficient to keep the encrypted key as it is at each server Vi.
      <br/>
      Thus, one consequence of the above is that at deposit time GW does not gain any information about F or FK.
    </p>
    <p num="125">
      At retrieval time, the GW requests each server to send it not only the portions of the encrypted file (and hashes), but also the partial decryptions of EU (FK) using a threshold decryption protocol.
      <br/>
      However, this would allow the gateway to reconstruct the complete decryption of EU (FK), i.e., the file key FK.
      <br/>
      In our protocol we use a "blinding" technique in order to prevent this.
      <br/>
      Namely, only the authorized user will be able to reconstruct FK.
    </p>
    <p num="126">The fields for Retrieval with Confidentiality protocol are listed in Table 6 and the protocol flow diagram is shown in FIG. 6.</p>
    <p num="127">
      -- TABLE 6
      <br/>
      -- Fields
      <br/>
      --        r       Blinding factor: random number chosen by user U
      <br/>
      --        b       EU (r)
      <br/>
      --        Fi  Portion of the file dispersed at server Vi
      <br/>
      --        +character pullout} Hashes of all Fi s stored at each server,
      <br/>
      --  i.e.,
      <br/>
      --                +character pullout}(Fi), 1  &lt;=  i  &lt;=  n
      <br/>
      --        di  Server Vi 's share of the decryption exponent,
      <br/>
      --                i.e., SKU
      <br/>
      --        Pi  Partial decryption from Vi of EU (FK  *
      <br/>
      --  r)
      <br/>
      --        P       P = (FK  *  r)
    </p>
    <p num="128">
      The flow diagram of the Retrieval protocol with confidentiality is shown in FIGS. 7A and 7B, to which reference is now made.
      <br/>
      The process begins in block 700 with the user U generating a retrieval request to a GW server for a previously stored file.
      <br/>
      The user also generates a random integer r. The user then saves r securely, though temporarily.
      <br/>
      The number r is intended to act as a blinding factor.
      <br/>
      The user then computes b=EU (r) (if RSA is used, then b=r3 mod N.) The user then signs b and the name of the file he or she is requesting under his or her signing key and sends it to the GW.
      <br/>
      In CExecutionl block 710, the GW forwards this request to each of the servers Vi.
      <br/>
      The servers check in CExecution2 block 720 that the user signing this request has permission to access this file.
      <br/>
      If so, server Vi generates Pi, a partial decryption of EU (FK) * b=EU (FK * r) (assuming some homomorphic property of E, as in the case of RSA).
      <br/>
      If we are using a threshold RSA cryptosystem, then simply Pi =EU (FK) * b)di  mod N, where di is the share of SKU held by server Vi.
      <br/>
      Each server Vi then sends Fi, the hashes +character pullout}(Fj), 1 &lt;= j &lt;= n, and Pi to the GW.
      <br/>
      In block 730, the GW determines good shares from a majority of hashes, reconstructs the encrypted file using IDA, and also reconstructs the product of the file key and blinding factor from partial decryptions.
      <br/>
      As in protocol Retrieval before, the GW computes eFK (F) using the hashes and the Fi s received (not shown).
      <br/>
      It also computes the value P=FK * r from the partial decryptions Pi.
    </p>
    <p num="129">
      In block 740 in FIG. 7B, the GW now sends the encrypted file and the blinded key P=(FK * r) to user U. The user obtains the file key FK by factoring out r, and acknowledges receipt of the file in CAckl block 750.
      <br/>
      GW then forwards an acknowledgment message to all servers in CAck2 block 760.
      <br/>
      Finally, the servers "echo" the acknowledgment message to all servers in block 770.
    </p>
    <p num="130">Lemma 3 Protocol Retrieval is correct, i.e., it satisfies the Retrieval Validity, Consistency and Privacy conditions.</p>
    <p num="131">
      Proof: Validity and Consistency are an immediate consequence of the integrity. only protocol.
      <br/>
      The Privacy condition can be argued as follows.
      <br/>
      Note that at no time the full key SKU is reconstructed.
      <br/>
      Also, we assume that the threshold decryption protocol used by the servers is secure, so it reveals no information to coalitions of size smaller than t, other than the plaintext being decrypted, in this case P=FK * r. GW is the only party who gets to see P=FK * r, but this is a randomly distributed value which gives no information about FK.
      <br/>
      The same measures that are used in the integrity-only solution against possible denial of service caused by a faulty GW are applied in this case too.
    </p>
    <p num="132">Proactive SSRI</p>
    <p num="133">The protocols described in the previous sections withstand the presence of an adversary that can read the memory and correct the behavior of at most t servers during the whole lifetime of the system.</p>
    <p num="134">
      If such lifetime is long, then the assumption that only t servers can be broken into may become unreasonable or too optimistic.
      <br/>
      Proactive Security, described by R. Canetti and A. Herzberg in "Maintaining security in the presence of transient faults", Advances in Cryptology-CRYPTO '94, Lecture Notes in Computer Science (839), pp. 425-438, Springer-Verlag, 1994, is an area of research that deals with secure distributed systems in the presence of an adversary that may corrupt all the serves during the whole lifetime of the system, although only t at a time (i.e., the assumption is that during a pre-specified interval of time, say a day, the adversary may break into at most t servers.
    </p>
    <p num="135">
      A basic technique of Proactive Security is to introduce refreshment phases in the system.
      <br/>
      During a refreshment phase, a server that has been broken into, but is not anymore under the control of the adversary, can be restored to its initial state.
      <br/>
      In particular, all the data destroyed or modified by the adversary is restored with the help of the other servers.
      <br/>
      Also, all secret information (e.g., cryptographic keys) contained in all the servers is somehow randomized so that the information leaked to the adversary in the previous time intervals will be useless in the future.
      <br/>
      Refreshment phases are invoked periodically regardless of the fact that break-ins have been detected or not.
    </p>
    <p num="136">
      The "poactivization" of our distributed storage system poses several interesting questions.
      <br/>
      At refreshing time, we need to restore the memory of potentially compromised servers.
      <br/>
      This can indeed be done by the assumption that only a minority of the servers might have been broken into during the previous interval.
      <br/>
      However, such a restoring operation can be potentially very expensive.
      <br/>
      Indeed, in order to restore the shares of a server, we need to recompute all the files and disperse them again.
      <br/>
      This means that at refreshing time, the whole memory of the system has to circulate around in order to restore eventual break-ins.
      <br/>
      This can potentially be an enormous task and should be performed only if strictly necessary.
      <br/>
      For example, if in the previous interval the adversary did not produce any damage (or corrupted only a small fraction of the memory of the system), the above task would be too expensive.
    </p>
    <p num="137">
      What we need is a form of "adaptive" proactiveness in which the system performs the expensive restoring only when it is really necessary, while routine refreshment phases are cheaper to perform.
      <br/>
      We describe our solutions, first for the integrity-only case and then for the integrity plus confidentiality case.
    </p>
    <p num="138">
      Integrity Only.
      <br/>
      Recall that each file F being deposited is first dispersed using our variation of SIDA.
      <br/>
      This means that each server Vi, 1 &lt;= i &lt;= n, will have an IDA-share of F, Fi, plus all the "fingerprints" of all the shares +character pullout}(F1) , . . . , +character pullout}(Fn).
      <br/>
      By assumption, during any given time interval, only a minority of the servers can be corrupted.
      <br/>
      At the beginning of the refreshing phase, each server broadcasts to the other servers the fingerprints.
      <br/>
      Server Vi takes a majority vote among the received fingerprints to identify the correct ones.
      <br/>
      It then checks if its own fingerprints are correct.
      <br/>
      If they are corrupted, it replaces them with the correct ones.
      <br/>
      It then checks its own IDA-share Fi against the correct fingerprint +character pullout}(F1).
      <br/>
      If the share has been modified, it broadcasts a message asking the other servers to reconstruct Fi for it.
      <br/>
      It then takes a majority from among the received messages to identify the correct Fi.
    </p>
    <p num="139">
      Notice that if the adversary was not present (or did no damage) in the previous time interval, fingerprints of the stored files must circulate during the refreshment phase.
      <br/>
      This is clearly a negligible communication cost compared to the whole storage of the system.
      <br/>
      If the adversary did some damage, then the communication complexity of the refreshing phase is still only proportional to the amount of information the adversary corrupted and not to the whole memory of the system.
    </p>
    <p num="140">
      Integrity and Confidentiality.
      <br/>
      In this case, the refreshment phase will consist first of all of the integrity-only refreshment phase, carried out on the encrypted files.
      <br/>
      However, in this scenario we need to worry about an adversary who, besides corrupting the files, might also read the shares of the users' secret keys kept at a server.
      <br/>
      Once the adversary reads more than t+1 of such shares, the adversary will be able to decrypt the users' files.
      <br/>
      But the shares of the secret keys can be proactivized using techniques used in threshold cryptography.
      <br/>
      The refreshment phases for proactive threshold cryptography schemes have a communication complexity proportional to the size of the keys.
      <br/>
      So once again in the optimistic case (i.e., when the adversary does not corrupt the memory of the system) the work done in a refreshment phase is very small compared to the potential amount of memory of the system.
    </p>
    <p num="141">Specific Implementation</p>
    <p num="142">
      In this section we describe a specific implementation of the invention.
      <br/>
      We designed a fully secure system which provides protection against these and other kinds of faults without overburdening the system with memory and computational requirements.
      <br/>
      The main feature of our storage system is its distributed nature.
      <br/>
      The implemented storage system is generally as illustrated in FIG. 1.
    </p>
    <p num="143">
      The storage system is composed by five servers, which we denote as V1, . . . , V5. These are high-end RS/6000 computer systems running the AIX operating system.
      <br/>
      These computer systems have large storage capabilities and high-performance features.
      <br/>
      We assume that at most two of these servers can be corrupted (i.e., malfunctioning in any way) at any time.
    </p>
    <p num="144">
      The servers are connected by a secure point-to-point network; that is, messages exchanged by two servers cannot be read or modified by anybody.
      <br/>
      Such secure channels can be implemented either physically or via cryptographic techniques.
    </p>
    <p num="145">
      The storage system (which we denote in its entirety with V) is accessible to the users.
      <br/>
      A user U runs some software on a low-end machine (like a personal computer (PC)) using a World Wide Web (WWW) interface.
      <br/>
      Communication between U and V is via the Internet.
      <br/>
      We require such communication also to be secure.
      <br/>
      This can be achieved via protocols for secure transmission of information over the Internet, such as SSL.
    </p>
    <p num="146">
      For efficiency's sake, in our protocols the users will interact with a single, not necessarily the same, distinguished server, called the gateway (GW).
      <br/>
      However, this implementation is uniform, in the sense of all servers are able to perform the same distribution and recovery functions.
      <br/>
      This means that the software run by the user will approach a randomly chosen server as the GW.
      <br/>
      If the protocol fails, then the software will approach another randomly chosen server Vj among the remaining ones.
      <br/>
      Since a failure of the protocol from the user's end means that GW is corrupted, then we know that U tries at most three servers as the GW.
    </p>
    <p num="147">
      The choice of server as the gateway is randomized (instead of deterministic) to avoid overloading a single server.
      <br/>
      Other strategies can be used for this goal, like a different sequence of servers to try out depending on the geographic location of the user.
    </p>
    <p num="148">
      This implementation uses the following cryptographic functions.
      <br/>
      We stress that while we are specifying algorithms for this implementation, the scheme works in general under any secure instatiation.
      <br/>
      In particular one could use discrete log based algorithms instead of RSA.
      <br/>
      Also, key lengths appear appropriate today, but should be updated according to algorithmic advances or computing power increases.
    </p>
    <p num="149">
      We need a hash function +character pullout}which is collision-resistant; i.e., it is infeasible to find two strings x not equal to y such that +character pullout}(x)=+character pullout}(y).
      <br/>
      In this implementation, we istantiate this to the function SHA-1 proposed by the National Institute of Standards and Technology as the standard for collision-resistant hash functions.
      <br/>
      SHA-1 takes an argument of arbitrary length and returns a 160-bit value as the result.
    </p>
    <p num="150">
      Symmetric encryption is an algorithm e which takes as input a message M and a key K and returns a ciphertext eK (M).
      <br/>
      It is infeasible to compute M from eK (M) without knowledge of K. This specific implementation uses DES-CBC.
      <br/>
      In this case K is 56 bits long.
    </p>
    <p num="151">
      An algorithm message authentication code (MAC) takes as input a message M and a key K and returns a tag macK (M).
      <br/>
      It is infeasible to compute a valid pair (M, macK (M)) without knowledge of K. This specific implementation uses HMAC as described, for example, by M. Bellare, R.f Canetti and H. Krawczyk in "Keying Hash Functions for Message Authentication", Proc.
      <br/>
      Advances in Cryptoloty-CRYPTO '96, LNCS vol. 1109, Springer-Verlag, pp. 1-15, 1996.
      <br/>
      We use HMAC also as construction for pseudorandom function families.
    </p>
    <p num="152">
      Public-key encryption is an algorithm E which takes as input message M and a public key PK and returns EPK (M).
      <br/>
      It is infeasible to compute back M without knowledge of the secret key SK matching PK.
      <br/>
      We use it only to encrypt symmetric keys; i.e., keys K for the algorithm e. We instatiate this primitive to 1024-bit RSA-OAE, which is a variant of RSA which also provides "plaintext-aware" encryption, which detects tampering on the ciphertext.
    </p>
    <p num="153">
      The signature algorithm used in the protocols is the 1024-bit RSA-SHA-1.
      <br/>
      That is, the signer has an RSA public key N of 1024 bits.
      <br/>
      The secret key is d=3-1 mod  PHI (N).
      <br/>
      To sign a message M, the signer first computes m'=SHA-1 (M) and then pads it with random bits to a string of 1024 bits, m=r * m'. He or she then computes  SIGMA =md mod N as the signature on M. The 49 pair M, SIGMA  is verified by the receiver by checking that lsb160 ( SIGMA 3)=SHA-1(M) mod N.
    </p>
    <p num="154">The keys and cryptographic primitives used in the protocols are summarized in Tables 7 and 8, respectively.</p>
    <p num="155">
      -- TABLE 7
      <br/>
      -- Fields
      <br/>
      -- PKU, SKU  Public and Secret keys for a 1024-bit RSA-OAF of
      <br/>
      --                user U
      <br/>
      -- CERTU     Public key certificate of user U, issued by the
      <br/>
      --                servers V
      <br/>
      -- PKU, s, SKU, s  Public and secret "signing" keys of user U for
      <br/>
      --                1024-bit RSA-SHA-1 scheme
      <br/>
      -- skVi   Server Vi 's share of secret key SKV
    </p>
    <p num="156">
      -- TABLE 8
      <br/>
      -- Fields
      <br/>
      -- +character pullout}( * ) SHA-1: a strong collision-resistant one-way
      <br/>
      --  has
      <br/>
      --               function
      <br/>
      -- EU       1024-bit RSA-OAE public key encryption using PKU
      <br/>
      -- SU ( * ) RSA-SHA-1 digital signature with respect to SKU
      <br/>
      -- SV1 , . . . , v5  ( * ) Distributed
      <br/>
      --  RSA-SHA-1 digital signature with
      <br/>
      --               respect to keys skVi , . . . ,
      <br/>
      --  skV5
      <br/>
      --  SIGMA Vi  ( * ) Partial digital signature with
      <br/>
      --  respect to skVi
      <br/>
      -- eK       DES-CBC: symmetric key-based encryption
      <br/>
      --               algorithm, taking key K and a plaintext, and
      <br/>
      --               producing a ciphertext
      <br/>
      -- macK     HMAC: message authentication code, taking key K
      <br/>
      --               and a plaintext, and returning a short tag
      <br/>
      -- fK       HMAC: a conjectured pseudorandom function with
      <br/>
      --               index K
      <br/>
      -- RS( * )  Reed-Solomon code
    </p>
    <p num="157">
      In order to achieve tolerance of faults among the servers, we need to share their decryption and signature power among them.
      <br/>
      In order to do that we need to construct the system's signature scheme in a way that only when three out of five of them collaborate, a valid signature is produced.
      <br/>
      Also, the system should be able to tolerate two faulty players who want to prevent the whole system from issuing a signature, and similarly for a public key decryption.
    </p>
    <p num="158">
      In this specific implementation, we use RSA-based a algorithms for both signatures and public key encryption.
      <br/>
      In order to distribute this power among the servers, we use the protocols for robust threshold RSA.
      <br/>
      Using that protocol, the secret key SK of the system is shared among the servers.
      <br/>
      Each server receives a partial key skVi .
    </p>
    <p num="159">
      For the case of signing on input M, each server creates a partial signature  SIGMA Vi  (M) which also includes a proof of its correctness.
      <br/>
      The GW will discard the invalid partial signatures (at most two of them) using such proof.
      <br/>
      Then from the remaining three valid partial signature will reconstruct the real signature on M.
    </p>
    <p num="160">
      The process is similar for the case of public key decryption.
      <br/>
      On input of a ciphertext C, each server will create a partial plaintext Pi which also includes a proof of its correctness.
      <br/>
      The Gw discards the invalid partial plaintexts (at most two of them) using such proof.
      <br/>
      Then, from the remaining three valid partial plaintexts, the GW reconstructs the full plaintext P.
    </p>
    <p num="161">We use blinding to prevent the GW from learning the content of a file deposited by the user in encrypted form when confidentiality is required.</p>
    <p num="162">
      When the user deposits the file F (see deposit protocol of FIG. 2) when confidentiality is required, he or she performs the following steps.
      <br/>
      First, a 56-bit file key FK for the encryption algorithm e is generated.
      <br/>
      Then he or she deposits eFK (F), EV (FK).
      <br/>
      The user saves only the receipt and not the file key FK since this is sensitive information.
    </p>
    <p num="163">When the file is retrieved, the GW should provide the user with eFK (F) and FK. But if done in the clear, this will allow the GW to learn the content of F. So the retrieval protocol works as follows.</p>
    <p num="164">
      U sends EV (r).
      <br/>
      Recall that this is the Bellare-Rogaway RSA-based OAE scheme.
      <br/>
      That means that first there is a randomized preprocessing that maps r to r' and then r' is encrypted with traditional RSA; i.e., the value c=(r')3 mod N is produced.
      <br/>
      The preprocessing is reversible; i.e., from r' it is possible to compute r. FK is also encrypted in the same fashion.
    </p>
    <p num="165">
      The servers do only the RSA part of the decryption for the value EV (FK) * EV (r))d ; i.e., the modular exponentiation to the secret exponent.
      <br/>
      They do this in the distributed fashion described above.
      <br/>
      So the value (EV (FK) * EV (r))d mod N is computed.
      <br/>
      But given the homomorphic property of traditional RSA this is just FK' * r'.
    </p>
    <p num="166">U has kept r' securely so he or she can recover FK' and from that FK, The GW knows nothing about FK.</p>
    <p num="167">
      The five servers are initialized in a trusted environment.
      <br/>
      Each of them is given a name (i.e., V1 to V5), an IP address and a share of the signing and decryption key for the whole system.
      <br/>
      The key generation is done by a trusted party who then self-destroys after generating such keys and sharing them among the servers.
      <br/>
      In case one uses a discrete-log based cryptosystem, it is possible to have the five servers run a key generation protocol which eliminates the need for such trusted party.
      <br/>
      However, the other parts of the initialization needs to be conducted in a trusted environment.
    </p>
    <p num="168">While the invention has been described in terms of a single preferred embodiment and by of a specific implementation example, those skilled in the art will recognize that the invention can be practiced with modification within the spirit and scope of the appended claims.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>Having thus described our invention, what we claim as new and desire to secure by Letters Patent is as follows:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A computer implemented method for the secure distributed storage of information from a user into a storage system including a plurality of servers comprising:</claim-text>
      <claim-text>designating one server of said plurality of servers as a gateway server for the user; depositing a file from said user to said storage system via the gateway server; distributing by the gateway server said file among said plurality of servers within said storage system; receiving by the gateway server an acknowledgment from each of the servers in the storage system receiving parts of the dispersed file;</claim-text>
      <claim-text>and generating by the gateway server an authenticated proof that said storage system received and correctly stored the file, said proof being provided even when at least one of said servers malfunctions due to a failure.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The computer implemented method as recited in claim 1, wherein there exists a first number n of said servers, and wherein there exists a second number t of said servers that have malfunctioned, where t is less than n, and wherein each said servers receives a share of the file F, each said share having an element size of at least  (Equation image '11' not included in text)</claim-text>
      <claim-text>plus a quantity of q, in which q depends upon n and a security parameter s.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The computer implemented method recited in claim 2, wherein said security parameter s is equal to the logarithm base two of an acceptable probability of failure of the system.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The computer implemented method as recited in claim 3, wherein a proactive security protocol is implemented in which all servers may be corrupted during a lifetime of the storage system but only t servers are corrupted during any given time period.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The computer implemented method as recited in claim 4, wherein the proactive security protocol includes the steps of: broadcasting by each server hashes of file shares; taking a majority vote by each server among the received hashes of file shares to identify correct hashes; checking by each server to determine if hashes of file shares stored by the server are correct; if hashes of files shares stored by a server are corrupted, replacing by the server corrupted hashes with correct hashes; then checking by each server its share of the stored file against a correct hash of the file; if a server's share of the stored file has been modified, broadcasting by the server a message asking other servers to reconstruct the file share;</claim-text>
      <claim-text>and then taking a majority vote among received response from other servers to identify a correct file share.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The computer implemented method as recited in claim 1, wherein said step of distributing is transparent to the user.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The computer implemented method as recited in claim 1, wherein each user of the storage system may interact with a different server designated as the gateway for the user for a given transaction whereby a single gateway does not become a single point of failure for the storage system.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The computer implemented method as recited in claim 1, wherein said storage of information takes place in a successful manner despite the presence of at least a malfunctioning server due to a malicious fault.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The computer implemented method as recited in claim 1, wherein said authenticated proof is obtained by generating a receipt for a deposit of said file through an application of distributed digital signatures such that said receipt is only issued when said file has been successfully stored.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The computer implemented method as recited in claim 9, wherein said step of generating a receipt is performed even when one or more of the servers malfunctions due to a failure.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A computer implemented method for the secure distributed storage and retrieval of information of a user in a storage system including a plurality of servers comprising: for a given transaction, designating one server of said plurality of servers as a gateway server for the user; depositing a file from the user to the storage system via the gateway server; distributing by the gateway server by dispersing the file among a plurality of servers within said storage system; receiving by the gateway server an acknowledgment from each of the servers in the storage system receiving parts of the dispersed file; generating by the gateway server an authenticated proof that said storage system received and correctly stored the file, said proof being provided even when at least one of said servers malfunctions due to a failure; responding by the gateway server to a user request for a previously stored file by forwarding the request to all servers in the storage system; checking by each server to determine if the user making the request has permission to access the requested file; if the user making the request has permission to access the requested file, sending by each server in the storage system their respective shares of the stored file and hashes of all shares to the gateway server; determining by the gateway server good shares from a majority of hashes received from other servers and reconstituting the file using an information dispersal algorithm;</claim-text>
      <claim-text>and sending the reconstituted file to the user.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The computer implemented method as recited in claim 11, wherein there exists a first number n of said servers, and wherein there exists a second number t of said servers that may have malfunctioned, where t is less than n, and wherein each said servers receives a share of the file F, each said share having an element size of at least  (Equation image '12' not included in text)</claim-text>
      <claim-text>plus a quantity of q, in which q depends upon n and a security parameter s.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The computer implemented method recited in claim 12, wherein said security parameter s is equal to the logarithm base two of an acceptable probability of failure of the system.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The computer implemented method as recited in claim 13, wherein an proactive security protocol is implemented in which all servers may be corrupted during a lifetime of the storage system but only t servers are corrupted during any given time period.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The computer implemented method as recited in claim 14, wherein the proactive security protocol includes the steps of: broadcasting by each server hashes of file shares; taking a majority vote by each server among the receive hashes of file shares to identify correct hashes; checking by each server to determine if hashes of file shares stored by the server are correct; if hashes of files shares stored by a server are corrupted, replacing by the server corrupted hashes with correct hashes; then checking by each server its share of the stored file against a correct hash of the file; if a server's share of the stored file has been modified, broadcasting by the server a message asking other servers to reconstruct the file share;</claim-text>
      <claim-text>and then taking a majority vote among received response from other servers to identify a correct file share.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The computer implemented method as recited in claim 13, wherein said step of distributing is transparent to the user.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The computer implemented method as recited in claim 13, wherein each user of the storage system may interact with a different server designated as the gateway for the user for a given transaction whereby a single gateway does not become a single point failure for the storage system.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The computer implemented method as recited in claim 17, wherein said storage of information takes place in a successful manner despite the presence of a malfunctioning server due to a malicious fault.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The computer implemented method as recited in claim 17, wherein said authenticated proof is obtained by generating a receipt for a deposit of said file through an application of distributed digital signatures such that said receipt is only issued when said file has been successfully stored.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The computer implemented method as recited in claim 19, wherein said step of generating a receipt is performed even when one or more of the servers malfunctions due to a failure.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The computer implemented method for the secure distributed storage and retrieval of information recited in claim 13 wherein the step of designating one server of said plurality of servers as a gateway server for the user includes designating any one of said plurality of servers as the gateway for purposes of file storage and any one of said plurality of servers as the gateway for purposes of file retrieval, the designated gateway servers for file storage and retrieval not necessarily being the same server from transaction to transaction.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. A storage system for the secure distributed storage and retrieval of information from a user comprising a plurality of servers connected in a network, one of said servers being designated as a gateway server for the user for a given transaction, the gateway server receiving a file from the user to be stored in the storage system, the gateway server distributing the file by dispersing among a plurality of servers within said storage system, the gateway server receiving an acknowledgment from each of the servers in the storage system receiving parts of the dispersed file, and the gateway server generating an authenticated proof that the storage system received and correctly stored the file, said proof being provided even when at least one of said servers malfunctions due to a failure.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The storage system recited in claim 22 wherein the gateway server responds to a user request for a previously stored file by forwarding the request to all servers in the storage system, each server in the storage system checking to determine if the user making the request has permission to access the requested file and if the user making the request has permission to access the requested file, each server sending their respective shares of the stored file and hashes of all shares to the gateway server, the gateway server determining good shares from a majority of hashes received from other servers and reconstituting the file using an information dispersal algorithm and sending the reconstituted file to the user.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The storage system recited in claim 23 wherein the network is the Internet.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The storage system recited in claim 23 wherein any one of said plurality of servers may be designated as the gateway for purposes of file storage and any one of said plurality of servers may be designated as the gateway for purposes of file retrieval, the designated gateway servers for file storage and retrieval not necessarily being the same server from transaction to transaction.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. A storage system comprising: a plurality of servers connected in a communication network having a protocol which enables information files to be stored distributively throughout the network of servers and information files to be retrieved by any single server in the network using a retrieval protocol, one of said servers being designated as a gateway server for a user of the storage system;</claim-text>
      <claim-text>and a computer capable of accessing the gateway server by a communication link established with said network, said computer depositing a file from the user to said storage system via the gateway server, the gateway server distributing said file among said plurality of servers within said storage system, the gateway server receiving an acknowledgment from each of the servers in the storage system receiving parts of the dispersed file, and the gateway server generating an authenticated proof that said storage system received and correctly stored the file, said proof being provided even when at least one of said servers malfunctions due to a failure and retrieve said distributively stored information or input information to be distributively stored on said network of servers.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The storage system recited in claim 26 wherein the network is the Internet.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The storage system recited in claim 26 wherein any one of said plurality of servers may be designated as the gateway for purposes of file storage.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. A storage and retrieval system comprising: a plurality of servers connected in a communication network having a protocol which enables information files to be stored distributively throughout the network of servers and information files to be retrieved by any single server in the network using a retrieval protocol, one of said servers being designated as a gateway server for a user of the storage and retrieval system for a given transaction;</claim-text>
      <claim-text>and a computer capable of accessing the gateway server by a communication link established with said network, said computer depositing a file from the user to the storage and retrieval system via the designated gateway server, the designated gateway server distributing the file among a plurality of servers within said storage and retrieval system, the gateway server receiving an acknowledgment from each of the servers in the storage system receiving parts of the dispersed file, the gateway server generating an authenticated proof that said storage system received and correctly stored the file, said proof being provided even when at least one of said servers malfunctions due to a failure, the gateway server responding to a user request for a previously stored file by forwarding the request to all servers in the storage system, each server checking to determine if the user making the request has permission to access the requested file, each server sending their respective shares of the stored file and hashes of all shares to the gateway server if the user making the request has permission to access the requested file, the gateway server determining good shares from a majority of hashes received from other servers and reconstituting the file using an information dispersal algorithm and sending the reconstituted file to said computer.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. The storage and retrieval system recited in claim 29 wherein the network is the Internet.</claim-text>
    </claim>
    <claim num="31">
      <claim-text>31. The storage and retrieval system recited in claim 29 wherein any one of said plurality of servers may be designated as the gateway for purposes of file storage and any one of said plurality of servers may be designated as the gateway for purposes of file retrieval, the designated gateway servers for file storage and retrieval not necessarily being the same server from transaction to transaction.</claim-text>
    </claim>
  </claims>
</questel-patent-document>