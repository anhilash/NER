<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06195616B1.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as first publication">
      <document-id>
        <country>US</country>
        <doc-number>06195616</doc-number>
        <kind>B1</kind>
        <date>20010227</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6195616</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B1</original-publication-kind>
    <application-reference family-id="25150749" extended-family-id="42059690">
      <document-id>
        <country>US</country>
        <doc-number>09390826</doc-number>
        <kind>A</kind>
        <date>19990907</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09390826</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43097914</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>39082699</doc-number>
        <kind>A</kind>
        <date>19990907</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09390826</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>79046097</doc-number>
        <kind>A</kind>
        <date>19970129</date>
        <priority-linkage-type>3</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-08790460</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010227</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G01R  31/3183      20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>01</class>
        <subclass>R</subclass>
        <main-group>31</main-group>
        <subgroup>3183</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>702119000</text>
        <class>702</class>
        <subclass>119000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>702117000</text>
        <class>702</class>
        <subclass>117000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G01R-031/3183B</text>
        <section>G</section>
        <class>01</class>
        <subclass>R</subclass>
        <main-group>031</main-group>
        <subgroup>3183B</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G01R-031/3183A</text>
        <section>G</section>
        <class>01</class>
        <subclass>R</subclass>
        <main-group>031</main-group>
        <subgroup>3183A</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G01R-031/318314</classification-symbol>
        <section>G</section>
        <class>01</class>
        <subclass>R</subclass>
        <main-group>31</main-group>
        <subgroup>318314</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20170407</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G01R-031/318307</classification-symbol>
        <section>G</section>
        <class>01</class>
        <subclass>R</subclass>
        <main-group>31</main-group>
        <subgroup>318307</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20170407</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G01R-031/3193</classification-symbol>
        <section>G</section>
        <class>01</class>
        <subclass>R</subclass>
        <main-group>31</main-group>
        <subgroup>3193</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20170330</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>18</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>9</number-of-drawing-sheets>
      <number-of-figures>15</number-of-figures>
      <image-key data-format="questel">US6195616</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and apparatus for the functional verification of digital electronic systems</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>WHETSEL LEE D</text>
          <document-id>
            <country>US</country>
            <doc-number>5677915</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5677915</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>BARCH PHILLIP THOMAS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6101457</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6101457</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="3">
          <text>ROBINSON GORDON D</text>
          <document-id>
            <country>US</country>
            <doc-number>4601032</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4601032</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="4">
          <text>HUNG ANGELO C J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4716564</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4716564</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>SHEPPARD JOHN W, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5130936</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5130936</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <text>OKE TIMOTHY P, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5469075</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5469075</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>NEEDHAM WAYNE</text>
          <document-id>
            <country>US</country>
            <doc-number>5583786</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5583786</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>ANGELOTTI FRANK W, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5617430</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5617430</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>ELLIS JAMES P, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5684946</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5684946</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <related-documents>
      <division>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>79046097</doc-number>
              <kind>A</kind>
              <date>19970129</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>5995915</doc-number>
              <kind>A</kind>
            </document-id>
          </parent-doc>
        </relation>
      </division>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Advanced Micro Devices, Inc.</orgname>
            <address>
              <address-1>Sunnyvale, CA, US</address-1>
              <city>Sunnyvale</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>ADVANCED MICRO DEVICES</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Reed, David F.</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Hamid, Adnan A.</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Daffer, Kevin L.</name>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <orgname>Conley, Rose &amp; Tayon</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Hoff, Marc S.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method and apparatus capable of generating and executing large numbers of functional tests for complex digital electronic systems at low cost are presented.
      <br/>
      The apparatus includes a test generator which uses a decision tree representation of a verification space, derived from a functional specification of the digital electronic system, to generate functional tests.
      <br/>
      A decision tree representation of a verification space includes an initial goal node, a leaf goal node, and at least one intermediate goal node interconnected by a plurality of directed decision arcs formed between the initial goal node and the leaf goal node.
      <br/>
      Goal plans assigned to goal nodes include operations which generate functional tests.
      <br/>
      Functional tests are generated by recursively "walking" the decision tree, the choices of which goal node to visit next being made at random and according to decision weights assigned to each goal node.
      <br/>
      The decision weights assigned to each goal node in the decision tree may be adjusted to ensure all portions of the verification space are adequately tested.
      <br/>
      A testing system issues functional tests to both a golden device and a device under test.
      <br/>
      The testing system compares expected responses from the golden unit to responses from device under test and produces functional test results.
      <br/>
      Specialized structures called monitors ensure sets of functional tests (i.e., functional test suites) exercise all parts of a system implementation.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This is a division of application Ser.
      <br/>
      No. 08/790,460, filed Jan. 29, 1997, now U.S. Pat. No. 5,995,915.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="3">This invention relates to electronic circuits and more specifically the functional verification of digital electronic systems.</p>
    <p num="4">2. Description of the Relevant Art</p>
    <p num="5">
      An electronic circuit may fail to function correctly due to design errors, fabrication errors, fabrication defects, and/or physical failures.
      <br/>
      A failure to properly implement a functional specification represents a design error.
      <br/>
      Fabrication errors are attributable to human error, and include the use of incorrect components, the incorrect installation of components, and incorrect wiring.
      <br/>
      Examples of fabrication defects, which result from imperfect manufacturing processes, include conductor opens and shorts, mask alignment errors, and improper doping profiles.
      <br/>
      Physical failures occur due to wear-out and/or environmental factors.
      <br/>
      The thinning and/or breakage of fine aluminum lead wires inside integrated circuit packages due to electromigration or corrosion are examples of physical failures.
    </p>
    <p num="6">
      Functional verification (i.e., functional testing) is often performed to validate the correct operation of a system with respect to a set of functional specifications.
      <br/>
      Functional verification includes applying known stimuli to inputs of a system under test, recording the responses, and comparing the responses to expected responses derived from the set of functional specifications.
      <br/>
      Any deviation of recorded responses from expected responses represents a failure of a functional test.
    </p>
    <p num="7">
      The functional testing of a complex digital electronic system is a difficult process requiring large amounts of time and effort.
      <br/>
      Complex digital electronic systems typically contain memory elements, and have outputs which depend on past inputs as well as current inputs.
      <br/>
      Such digital electronic systems are called sequential systems, and their status at any given time is referred to as a system state.
      <br/>
      A digital electronic system with 2M possible system states and 2N possible input combinations would require the application of all 2M+N possible functional tests to completely verify the correct operation of the system.
      <br/>
      Such a system has a verification space defined by all 2M+N possible functional tests.
      <br/>
      As the number of possible system states and input combinations increases, it quickly becomes impractical to apply all of the 2M+N possible tests required to completely verify the correct operation of a complex digital electronic system.
    </p>
    <p num="8">While there is no quantitative measure of how much of the total functional specification is verified by a set of functional tests which does not include all possible tests, confidence that a system functions correctly generally increases with the number of unique functional tests performed and passed which span all areas of the system verification space and exercise all parts of the system implementation.</p>
    <p num="9">
      Functional tests are typically derived manually by persons familiar with the system, however, and the manual generation of large numbers of functional tests for complex systems is a difficult, tedious, time consuming, and error prone process.
      <br/>
      It would thus be advantageous to provide an method and apparatus for the functional verification of digital electronic systems capable of generating and executing large numbers of functional tests for complex systems at low cost.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="10">
      The problems outlined above are in large part solved by a method and apparatus for the functional verification of digital electronic systems in accordance with the present invention.
      <br/>
      Algorithmic generation of functional tests is employed in order to make the generation of large numbers of functional tests for complex systems practical.
      <br/>
      A decision tree is created from a functional specification and represents a verification space.
      <br/>
      Such a decision tree includes an initial goal node, a leaf goal node, and at least one intermediate goal node interconnected by a plurality of directed decision arcs formed between the initial goal node and the leaf goal node.
      <br/>
      Goal plans assigned to goal nodes include operations which generate functional tests.
      <br/>
      Functional tests are generated by recursively "walking" the decision tree, the choices of which goal node to visit next being made at random and according to decision weights assigned to each goal node.
      <br/>
      The decision weights assigned to each goal node in the decision tree may be adjusted to ensure all portions of the verification space are adequately tested.
    </p>
    <p num="11">
      The apparatus for the functional verification of digital electronic systems includes a test generator, a testing system, a golden unit, and a device under test.
      <br/>
      The test generator uses a decision tree representation of a verification space to generate functional tests as described above.
      <br/>
      The test generator provides these functional tests to the testing system as output.
      <br/>
      The testing system issues functional tests to both the golden device and the device under test.
      <br/>
      The golden device produces expected responses as output to the testing system.
      <br/>
      The device under test also produces responses as output to the testing system.
      <br/>
      The testing system compares expected responses from the golden unit to responses from device under test and produces functional test results.
      <br/>
      These functional test results flag differences in the responses from the device under test and expected responses from the golden unit as potential functional errors.
      <br/>
      The functional test results may then be screened by testing personnel to determine if differences in the responses from the device under test and expected responses from golden unit represent functional errors.
    </p>
    <p num="12">
      The present invention also contemplates the use of specialized structures called monitors to ensure sets of functional tests (i.e., functional test suites) exercise all parts of a system implementation.
      <br/>
      A device may be implemented in hardware or in any combination of hardware, firmware, and software.
      <br/>
      A monitor structure used to observe a hardware implementation of a device under test is called a hardware monitor.
      <br/>
      A monitor structure used to observe an implementation of a device under test which resides in software running in a hardware environment (i.e., a software implementation) is referred to as a software monitor.
    </p>
    <p num="13">
      Monitors also have a beneficial side effect in that they may also help to discover areas of a verification space unintentionally omitted from a decision tree representation of that verification space.
      <br/>
      An investigation based on a report from a monitor indicating that one or more functional areas of a system implementation were not fully exercised may reveal that one or more areas of a verification space were omitted from the decision tree representation.
    </p>
    <p num="14">Employing automated functional test generation and test execution, the method and apparatus of the present invention is capable of generating and executing large numbers of functional tests for complex systems at low cost.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="15">
      Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:
      <br/>
      FIG. 1a is a two-dimensional representation of the six possible operations of a simple digital microprocessor;
      <br/>
      FIG. 1b is a Venn diagram of the six possible operations of the simple digital microprocessor;
      <br/>
      FIG. 1c is a decision tree representation of the verification space of the simple digital microprocessor;
      <br/>
      FIG. 1d is a representation of a code block array structure;
      <br/>
      FIG. 1e shows the contents of the code block array structure after a register initialization step;
      <br/>
      FIG. 1f shows the contents of the code block array structure after the generation of a functional test for the simple digital microprocessor;
      <br/>
      FIG. 2a is a three-dimensional representation of the 12 possible operations of the simple digital microprocessor after adding a second operating mode;
      <br/>
      FIG. 2b is a Venn diagram of the 12 possible operations of the simple digital microprocessor after adding a second operating mode;
      <br/>
      FIG. 2c is a decision tree representation of the verification space of the simple digital microprocessor after adding a second operating mode;
      <br/>
      FIG. 3 is a spatial representation of functional errors within a multi-dimensional verification space;
      <br/>
      FIG. 4 is a graph of the rate of functional error detection versus the number of functional tests performed;
      <br/>
      FIG. 5 is a block diagram of a functional verification apparatus in accordance with the present invention;
      <br/>
      FIG. 6 is a block diagram of a test generator of the functional verification apparatus;
      <br/>
      FIG. 7 is a block diagram of a testing system of the functional verification apparatus; and
      <br/>
      FIG. 8 is a block diagram illustrating the relationships between major objects of an example functional test generation engine.
    </p>
    <p num="16">
      While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail.
      <br/>
      It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.
    </p>
    <heading>DETAILED DESCRIPTION OF THE INVENTION</heading>
    <p num="17">
      A decision tree is a convenient graphical method of expressing, in chronological order, the alternative actions available to a decision maker.
      <br/>
      In the present invention, a decision tree consists of goal nodes connected by directed decision arcs.
      <br/>
      Directed decision arcs emanating from a given goal node represent choices which may be made by a decision maker when the goal node is encountered.
    </p>
    <p num="18">
      For example, consider a very simple digital microprocessor which can only increment (add the number one to) or decrement (subtract the number one from) the contents of one of three registers: `EAX`, `EBX`, and `ECX`. FIG. 1a is a two-dimensional representation of the six possible operations.
      <br/>
      FIG. 1b is also a two-dimensional at representation of the six possible operations.
      <br/>
      FIG. 1b is called a Venn diagram, where each possible operation occupies a defined region of two-dimensional space.
    </p>
    <p num="19">
      Assume that the functional specification for the simple digital microprocessor specifies only the six operations above.
      <br/>
      Thus the verification space for the simple digital microprocessor also includes these same six possible operations.
      <br/>
      FIG. 1c is a decision tree representation of the verification space of the simple digital microprocessor which may be used to generate one or more functional tests for the simple digital microprocessor.
      <br/>
      Decision tree 100 consists of an initial goal node 102 coupled to a select instruction goal-plan subtree 104 by a directed decision arc 106. (A decision tree of the present invention has only one initial goal node, which has at least one directed decision arc emanating from it, and no directed decision arcs directed at it).
      <br/>
      Select instruction goal-plan subtree 104 is coupled to select register goal-plan subtree 108 by two directed decision arcs 110 and 112.
    </p>
    <p num="20">Select instruction goal-plan subtree 104 consists of three intermediate goal nodes 114, 116, and 118. (In a decision tree of the present invention, an intermediate goal node has at least one directed decision arc directed at it and at least one directed decision arc emanating from it).</p>
    <p num="21">Select register goal-plan subtree 108 consists of one intermediate goal node 120 and three leaf goal nodes 122, 124, and 126. (In a decision tree of the present invention, a leaf goal node has at least one directed decision arc directed at it and no directed decision arcs emanating from it).</p>
    <p num="22">
      Once a decision tree is generated, each goal node is assigned a goal plan.
      <br/>
      A goal plan includes one or more operations which must be performed in the order prescribed in order to accomplish a particular goal.
      <br/>
      In addition, intermediate and leaf goal nodes are assigned decision weights used during decision-making operations.
    </p>
    <p num="23">
      A functional test is generated from a decision tree by executing the goal plan assigned to the initial goal node.
      <br/>
      At least one operation of the goal plan assigned to the initial goal involves the execution of the goal plan assigned to a goal node directed to by a decision arc emanating from the initial goal node.
      <br/>
      Goal plans assigned to goal nodes in the decision tree contain operations which generate functional tests.
      <br/>
      Functional tests may be generated manually, or with the aid of a computer.
    </p>
    <p num="24">
      The following section describes an algorithmic approach to functional test generation which may be programmed to run on a computer.
      <br/>
      In such a routine, a global array of characters called `code_block` contains functional tests generated.
      <br/>
      Each row of array code_block represents an instruction line containing an instruction which may be executed by the simple digital microprocessor under test.
      <br/>
      FIG. 1d illustrates code block structure 128.
      <br/>
      A variable called `code_ptr` 130 contains the address of the next empty instruction line (i.e., row) in global array code_block.
      <br/>
      When code_ptr is initialized, the address of the first (empty) line in code_block is stored in code_ptr.
      <br/>
      Thus code_ptr points to (i.e., contains the address of) the first line of code_block as shown in FIG. 1d.
    </p>
    <p num="25">
      In the embodiment described above with a single code_block structure 128 as shown in FIG. 1d, each row of array code_block contains an instruction which may be executed by the simple digital microprocessor under test.
      <br/>
      Alternately, the code_block structure may contain both instructions and pointers to one or more sub_code_block structures.
      <br/>
      Sub_code_block structures may contain instructions which represent portions of functional tests generated.
      <br/>
      The embodiment with a single code_block structure 128 as shown in FIG. 1d is described below in greater detail.
    </p>
    <p num="26">
      The first step in the generation of a functional test is to execute the goal plan assigned to the initial goal node.
      <br/>
      As will be described in detail below, goal plans assigned to goal nodes in the decision tree are responsible for adding instruction lines to global structure code_block, thus creating one or more functional tests.
    </p>
    <p num="27">Let the goal plan assigned to initial goal node 102 include the following operations:</p>
    <p num="28">1) Repeat the following steps 2 and 3 for the number of functional test to be generated:</p>
    <p num="29">
      - 2) Choose a goal node directed to by a directed decision arc emanating from the current goal node at random and according to the decision weights assigned to all goal nodes directed to by directed decision arcs emanating from the current goal node,
      <br/>
      - 3) Pass the address of code_ptr to the chosen node (so that the value of code_ptr may be changed) and invoke the execution of the goal plan assigned to the chosen goal node, and
      <br/>
      4) Output the contents of global structure code_block.
    </p>
    <p num="30">
      Assume that only one functional test is to be generated.
      <br/>
      Thus steps 2 and 3 will be executed only once.
      <br/>
      At step 2, initial goal node 102 has but one directed decision arc emanating from it, and this directed decision arc is directed to intermediate goal node 114.
      <br/>
      Thus intermediate goal node 114 will be chosen during step 2 of the goal plan assigned to initial goal node 102 (regardless of the decision weight assigned to intermediate goal node 114).
      <br/>
      Step 3 of the goal plan of initial goal node 102 calls for invoking the execution of the goal plan assigned to chosen goal node 114.
    </p>
    <p num="31">
      At this point, execution of the goal plan assigned to initial goal node 102 is temporarily suspended until the goal plan assigned to goal node 114 is accomplished.
      <br/>
      After the goal plan assigned to goal node 114 is completed, execution of the goal plan assigned to goal node 102 will resume with step 4 (since only one functional test is to be generated).
    </p>
    <p num="32">
      Intermediate goal node 114 is the top goal node in select instruction goal-plan subtree 104, and is associated with the selection of one of the two possible instructions: increment (`INC`) and decrement (`DEC`).
      <br/>
      Let the goal plan assigned to intermediate goal node 114 include the following steps:
      <br/>
      1) Choose a goal node directed to by a directed decision arc emanating from the current goal node at random and according to the decision weights assigned to all goal nodes directed to by directed decision arcs emanating from the current goal node, and
      <br/>
      2) Pass the address of code_ptr to the chosen node and invoke the execution of the goal plan assigned to the chosen goal node.
    </p>
    <p num="33">
      Goal node 114 has two directed decision arcs emanating from it.
      <br/>
      Thus a choosing procedure is needed to accomplish step 1 of the goal plan assigned to goal node 114.
    </p>
    <p num="34">
      In a preferred embodiment, decision weights assigned to goal nodes have integer values greater than or equal to 1.
      <br/>
      Also, a computer software routine capable of generating a random integer between 1 and a specified integer value greater than one is available.
      <br/>
      Given the above conditions, one method of implementing a goal node choosing procedure which is random in nature and depends on decision weights assigned to each goal node is to:
      <br/>
      1) Sum the decision weights assigned to eligible goal nodes (i.e., goal nodes directed to by decision arcs emanating from the current node):
      <br/>
      - SW =sum of decision weights of all eligible goal nodes  (Equation image '1' not included in text)
      <br/>
      -  where:
      <br/>
      - Wi =decision weight assigned to eligible goal node `i` and
      <br/>
      - n=total number of eligible goal nodes, n &gt;= 1
      <br/>
      2) Allocate sections of the range of the random number generator (from 1 to Sw) to each eligible goal node depending on decision weights:
      <br/>
      - Sm =section of the range assigned to eligible node `m`
      <br/>
      - 1 &lt;= S1 &lt;= W1 ;  (Equation image '2' not included in text)
      <br/>
      3) Use the computer software routine to select a random integer within the range of 1 to SW.
      <br/>
      4) If the random integer selected is within section Sm, eligible goal node `m` is considered chosen.
    </p>
    <p num="35">
      Let the decision weights assigned to intermediate goal node 116 (representing the `INC` instruction) be 1, and the decision weight assigned to intermediate goal node 118 (representing the `DEC` instruction) be 1.
      <br/>
      At step 1 of the above choosing procedure, the sum of decision weights assigned to eligible goal nodes is 2.
      <br/>
      At step 2,
      <br/>
      1 &lt;= S1 &lt;= 1, where choice 1 is intermediate goal node 116, and
      <br/>
      2 &lt;= S2 &lt;= 2, where choice 2 is intermediate goal node 118.
    </p>
    <p num="36">
      Assume the value 2 is generated by the computer software routine at step 3 of the choosing procedure.
      <br/>
      Since the value 2 lies in the S2 segment, choice 2 (intermediate goal node 118 representing the `DEC` instruction) is considered chosen at step 4 of the choosing procedure.
      <br/>
      This action completes step 1 of the goal plan of goal node 114.
    </p>
    <p num="37">
      Step 2 of the goal plan of goal node 114 calls for invoking the execution of the goal plan assigned to chosen goal node 118 (representing the `DEC` instruction).
      <br/>
      At this point, execution of the goal plan assigned to goal node 114 is temporarily suspended until the goal plan assigned to goal node 118 is accomplished.
      <br/>
      After the goal plan assigned to goal node 118 is completed, execution of the goal plan assigned to goal node 114 will also be completed.
    </p>
    <p num="38">
      Let the goal plan assigned to intermediate goal node 118 include the following steps:
      <br/>
      1) Choose a goal node directed to by a directed decision arc emanating from the current goal node at random and according to the decision weights assigned to all goal nodes directed to by directed decision arcs emanating from the current goal node,
      <br/>
      2) Pass the address of code_ptr to the chosen node and invoke the execution of the goal plan assigned to the chosen goal node, and
      <br/>
      3) Receive a character string (i.e., register name) from the chosen goal node,
      <br/>
      4) Append the name of the instruction associated with the current goal node (i.e., character string `dec`) to the front of the character string from the chosen goal node, and
      <br/>
      5) Store the resulting text string (i.e., instruction line) in global structure code_block at the address contained in (i.e., pointed to by) code_ptr.
      <br/>
      6) Update the value of code_ptr so that code_ptr contains the address of (i.e., points to) the next empty line in code_block.
    </p>
    <p num="39">
      Intermediate goal node 118 has but one directed decision arc emanating from it, directed decision arc 112, and this directed decision arc is directed to intermediate goal node 120.
      <br/>
      Thus intermediate goal node 120 will be chosen during step 1 of the goal plan assigned to goal node 118 (regardless of the decision weight assigned to intermediate goal node 120).
    </p>
    <p num="40">
      At this point, execution of the goal plan assigned to goal node 118 is temporarily suspended until the goal plan assigned to goal node 120 is accomplished.
      <br/>
      After the goal plan assigned to goal node 120 is completed, execution of the goal plan assigned to goal node 118 will resume with step 2.
    </p>
    <p num="41">
      Intermediate goal node 120 is the top goal node in select register goal-plan subtree 108, and is associated with the selection of one of the three possible registers: `EAX`, `EBX`, and `ECX`. Let the goal plan assigned to intermediate goal node 120 include the following steps:
      <br/>
      1) Choose a goal node directed to by a directed decision arc emanating from the current goal node at random and according to the decision weights assigned to all goal nodes directed to by directed decision arcs emanating from the current goal node,
      <br/>
      2) Pass the address of code_ptr to the chosen node and invoke the execution of the goal plan assigned to the chosen goal node, and
      <br/>
      3) Receive a character string (register name) from the chosen goal node, and
      <br/>
      4) Return the character string (register name) from the chosen goal node to the invoking goal plan.
    </p>
    <p num="42">
      Directed decision arcs emanating from intermediate goal node 120 are directed at leaf goal nodes 122, 124, and 126.
      <br/>
      Let the decision weight assigned to leaf goal node 122 (representing the `EAX` register) be 2, the decision weight assigned to leaf goal node 124 (representing the `EBX` register) be 3, and the decision weight assigned to leaf goal node 126 (representing the `ECX` register) be 5.
      <br/>
      At step 1 of the above choosing procedure, the sum of the decision weights of all eligible goal nodes is 10.
      <br/>
      At step 2 of the above choosing procedure,
      <br/>
      1 &lt;= S1 &lt;= 2, where choice 1 is leaf goal node 122,
      <br/>
      3 &lt;= S2 &lt;= 5, where choice 2 is leaf goal node 124, and
      <br/>
      6 &lt;= S3 &lt;= 10, where choice 3 is leaf goal node 126
    </p>
    <p num="43">
      Assume the value 5 is selected at step 3 of the choosing procedure.
      <br/>
      Since the value 5 lies in the S2 segment, choice 2 (leaf goal node 124 representing the `EBX` register) is considered chosen at step 4 of the above choosing procedure.
      <br/>
      This action completes step 1 of the goal plan assigned to goal node 120.
      <br/>
      Step 2 of the goal plan of goal node 120 calls for the execution of the goal plan assigned to chosen goal node 124 representing the `EBX` register.
    </p>
    <p num="44">
      At this point, execution of the goal plan assigned to goal node 120 is temporarily suspended until the goal plan assigned to goal node 124 is accomplished.
      <br/>
      After the goal plan assigned to goal node 124 is completed, execution of the goal plan assigned to goal node 120 will resume with step 3.
    </p>
    <p num="45">
      Let the goal plan of goal node 124 include the following steps:
      <br/>
      1) Initialize register `EBX` by storing the instruction `mov ebx,1` in global structure code_block at the line with address contained in (i.e., pointed to by) code_ptr.
      <br/>
      2) Update the value of code_ptr so that code_ptr now contains the address of (i.e., points to) the next empty line in code_block.
      <br/>
      3) Return the character string `ebx` to the invoking goal plan.
    </p>
    <p num="46">
      At step 1, the goal plan of leaf goal node 124 stores the instruction required to initialize the `EBX` register of the simple digital microprocessor to 1.
      <br/>
      As shown in FIG. 1e, the instruction `mov ebx,1` is stored in line 1 of global structure code_block.
      <br/>
      The value of code_ptr, the address of line 1 of code_block, is used to access code_block.
      <br/>
      At step 2, the value of code_ptr is changed to reflect the address of the next empty line in code_block (line 2).
    </p>
    <p num="47">At step 3 of the goal plan assigned to leaf goal node 124, the character string `ebx` is returned to the invoking goal plan of intermediate goal node 120.</p>
    <p num="48">
      The goal plan assigned to leaf goal node 124 has now been completed, and the execution of the goal plan assigned to intermediate goal node 120 resumes at step 3.
      <br/>
      At step 4 of the goal plan assigned to goal node 120, the character string `ebx` received from leaf goal node 124 is returned to the invoking goal plan of goal node 118.
    </p>
    <p num="49">
      The goal plan assigned to intermediate goal node 120 has now been completed, and the execution of the goal plan assigned to intermediate goal node 118 resumes at step 3.
      <br/>
      At step 4 of the goal plan assigned to goal node 118, the character string `dec` is appended to the front of the character string `ebx` received from intermediate goal node 120.
    </p>
    <p num="50">
      At step 5 of the goal plan assigned to intermediate goal node 118, the instruction `dec ebx` is stored at line 2 of global structure code_block as shown in FIG. 1f. The value of code_ptr, updated by the goal plan of leaf goal node 124 to reflect the address of line 2 of code_block, is used to access code_block.
      <br/>
      At step 6, the value of code_ptr is changed to reflect the address of the next empty line in code_block (line 3).
    </p>
    <p num="51">
      The goal plan assigned to intermediate goal node 118 has now been completed, and the execution of the goal plan assigned to intermediate goal node 114 resumes.
      <br/>
      The goal plan assigned to intermediate node 114 is also complete, and execution of the goal plan assigned to initial goal node 102 resumes at step 4 (since only one functional test is to be generated).
    </p>
    <p num="52">At step 4 of the goal plan assigned to initial goal node 102, the contents of global structure code_block are output:</p>
    <p num="53">mov ebx,1</p>
    <p num="54">dec ebx</p>
    <p num="55">
      Thus the functional test for the simple digital microprocessor described above consists of two lines of instructions.
      <br/>
      After the above two instructions are executed, the contents of `EBX` may be checked to verify the correct value of 0 is stored in `EBX`.
    </p>
    <p num="56">
      Alternately, the goal plan of intermediate goal node 118 may be modified to generate an additional line of code to store the value of register `EBX` at a known location in a system memory of the simple digital microprocessor for later retrieval and analysis.
      <br/>
      This is convenient when more than one functional test is to be generated, and the value stored in a given register location as a result of one functional test may be overwritten by a subsequent functional test.
    </p>
    <p num="57">
      In a preferred embodiment described in greater detail below, a separate testing system issues functional tests to both a golden device and a device under test.
      <br/>
      The golden device produces expected responses as output to the testing system.
      <br/>
      The device under test also produces responses as output to testing system.
      <br/>
      The testing system compares expected responses from the golden unit to responses from the device under test and produces functional test results.
      <br/>
      These functional test results flag differences in the responses from the device under test and expected responses from golden, unit as potential functional errors.
    </p>
    <p num="58">
      In the preferred embodiment, the goal plan of intermediate goal node 118 may be modified to generate a line of code to store the value of register EBX at a known location in a system memory of the simple digital microprocessor for later retrieval and analysis.
      <br/>
      Results of subsequent tests may be stored in other locations.
      <br/>
      Such stored results may be retrieved by the testing system at a later time and compared to expected results produced by the golden device.
      <br/>
      In another approach, the goal plan of intermediate goal node 118 may be modified to generate an additional line of code to store the value of register EBX at an address associated with an input/output port coupled to the testing system.
      <br/>
      Thus the testing system may compare expected responses from the golden unit to responses from the device under test immediately after the execution of one test and prior to the execution of a subsequent test.
    </p>
    <p num="59">It is also be noted that the comparison function of the preferred embodiment allows registers to be initialized to randomly selected integer values rather than predetermined values as described above.</p>
    <p num="60">
      A second method of implementing a goal node choosing procedure which is random in nature and depends on decimal values of decision weights will now be described.
      <br/>
      Given a table of random decimal numbers ranging from 0.0 to 1.0, or access to a computer capable of generating such random decimal numbers, one method of making a random choice according to decimal decision weights assigned to all possible events is to:
      <br/>
      1) Determine individual probabilities that a given eligible goal node will be chosen:
      <br/>
      - Pm =probability that eligible goal node `m` will be chosen  (Equation image '3' not included in text)
      <br/>
      -  where:
      <br/>
      - Wm =decision weight assigned to eligible goal node `m` and
      <br/>
      - n=total number of eligible goal nodes, n &gt;= 1
      <br/>
      2) Allocate sections of the range of the random number generator (from 0.0 to 1.0) to each eligible goal node depending on the probability that a given goal node will be chosen:
      <br/>
      - Sm =section of the range of 0.0 to 1.0 assigned to eligible node `m`
      <br/>
      - 0.0 &lt;= S1 &lt;P1 ;  (Equation image '4' not included in text)
      <br/>
      3) Select a random decimal number between 0.0 and 1.0 from a table of random numbers, or have a computer capable of generating such random numbers generate a random decimal number between 0.0 and 1 0 (slashed zero)
      <br/>
      4) If the decimal random number selected is within section Sm, eligible goal node `m` is considered chosen.
    </p>
    <p num="61">
      Close examination of the goal plans assigned to goal nodes in the decision tree described above reveals some obvious similarities.
      <br/>
      Note that the goal plans of initial goal node 102 and all three intermediate goal nodes 114, 118, and 120 share the following identical steps:
      <br/>
      1) Choose a goal node directed to by a directed decision arc emanating from the current goal node at random and according to the decision weights assigned to all goal nodes directed to by directed decision arcs emanating from the current goal node, and
      <br/>
      2) Pass the address of code_ptr to the chosen node and invoke the execution of the goal plan assigned to the chosen goal node.
    </p>
    <p num="62">
      Had goal plans for all leaf goal nodes 122, 124, and 126 been disclosed, they also would have shared almost identical steps:
      <br/>
      1) Initialize register `xxx` by storing the instruction `mov xxx,1` in global structure code_block at the line with address contained in code_ptr.
      <br/>
      2) Update the value of code_ptr so that code_ptr contains the address of the next empty line in code_block.
      <br/>
      3) Return the character string `xxx` to the invoking goal plan.
    </p>
    <p num="63">
      These similarities were realized and exploited in the creation of an automated implementation of the above method of generating functional tests.
      <br/>
      Modern object-oriented programming environments allow programmers to take advantage of such similarities, relieving them of the burden of having to duplicate similar blacks of computer code.
      <br/>
      This benefit becomes especially important as the size of the programming task grows.
    </p>
    <p num="64">
      More traditional computer programs include algorithmic computer code and passive data.
      <br/>
      A computer program in an object-oriented environment is a system of interactive objects.
      <br/>
      Objects are self-contained modules that include both data (i.e., values associated with class and instance variables) and procedures which act on data (i.e., methods).
      <br/>
      Objects take action in response to messages from other objects.
      <br/>
      Objects that have a common use are grouped together in a class, and new classes may be created that inherit the procedures and data from existing classes.
      <br/>
      Classes are organized as hierarchies, and the mechanism of inheritance automatically provides each subclass with the methods and data of parent classes.
      <br/>
      Class hierarchies and inheritance allow programmers to reuse existing computer code and data embodied in classes, and to program new subclasses with only the differences.
    </p>
    <p num="65">
      Let the simple digital microprocessor described above be extended to have two possible operating modes: a 16-bit operating mode and a 32-bit operating mode.
      <br/>
      FIG. 1a is a two-dimensional representation of the six possible operations.
      <br/>
      Adding a second operating mode has doubled the number of possible operations as shown in FIG. 2a. FIG. 2b is a Venn diagram assigning each of the 12 possible operations a defined region of two-dimensional space.
    </p>
    <p num="66">
      Assume that the functional specification for the extended simple digital microprocessor specifies only the 12 operations as shown in FIGS. 2a and 2b. Thus the verification space for the simple digital microprocessor also includes these same 12 possible operations.
      <br/>
      FIG. 2c is a decision tree representation of the verification space of the extended simple digital microprocessor which may be used to generate one or more functional tests for the extended simple digital microprocessor.
      <br/>
      Decision tree 200 consists of an initial goal node 102 coupled to a select mode goal-plan subtree 202 by a directed decision arc 204.
      <br/>
      Select mode goal-plan subtree 202 is coupled to select instruction goal-plan subtree 104 by directed decision arcs 206 and 208.
      <br/>
      As before, select instruction goal-plan subtree 104 is coupled to select register goal-plan subtree 108 by two directed decision arcs 110 and 112.
    </p>
    <p num="67">
      Select mode goal-plan subtree 202 consists of three intermediate goal nodes 210, 212, and 214.
      <br/>
      Select instruction goal-plan subtree 104 consists of three intermediate goal nodes 114, 116, and 118.
      <br/>
      Select register goal-plan subtree 108 consists of one intermediate goal node 120 and three leaf goal nodes 122, 124, and 126.
    </p>
    <p num="68">
      As before, each goal node is now assigned a goal plan.
      <br/>
      In addition, intermediate and leaf goal nodes are assigned decision weights used during decision-making operations.
      <br/>
      A functional test may now be generated from the decision tree by executing the goal plan assigned to the initial goal node.
    </p>
    <p num="69">
      Modern microprocessors are much more complex than either versions of the simple digital microprocessor described above.
      <br/>
      Verification space is multi-dimensional, each dimension representing instructions, addressing modes, operating modes, system configurations, etc.
      <br/>
      A functional error in a digital electronic system may be modeled as occupying some region of the multi-dimensional verification space.
      <br/>
      Certain functional errors may occupy fairly large regions, and may have correspondingly higher probabilities of being detected by a randomly-generated functional test.
      <br/>
      Other functional errors may occupy very small regions of the multi-dimensional verification space, and may have correspondingly smaller probabilities of being detected with a randomly-generated functional test.
      <br/>
      Still other functional errors may occupy regions of multi-dimensional verification space within regions occupied by other functional errors.
    </p>
    <p num="70">
      FIG. 3 is a spatial representation of functional errors 302, 304, and 306 within an multi-dimensional verification space 308.
      <br/>
      Functional error 302 occupies a fairly large region, and may have a correspondingly higher probability of being detected by a randomly-generated functional test.
      <br/>
      Functional error 306 occupies a smaller region of multi-dimensional verification space 308, and may have a correspondingly smaller probability of being detected with a randomly-generated functional test.
      <br/>
      Functional error 304 occupies a region of multi-dimensional verification space 308 within a region occupied by functional error 302.
      <br/>
      In this case, functional error 302 may actually mask functional error 304.
      <br/>
      It may not be possible to detect functional error 304 until functional error 302 is detected, diagnosed, and eliminated.
    </p>
    <p num="71">
      Based on experience, the authors submit that the rate of functional error detection versus the number of functional tests performed in the debugging of a complex digital electronic system follows an equation similar to that of a Wiebull probability distribution function.
      <br/>
      The term debugging as used herein refers an operation involving the detection, diagnosis, and elimination of functional errors.
    </p>
    <p num="72">In general, the equation for the rate of functional error detection versus the number of functional tests performed is:</p>
    <p num="73">rate=i anb * e-(cnd )</p>
    <p num="74">
      where n=number of functional tests performed.
      <br/>
      The values of a, b, c, and d may be determined by curve fitting to actual debugging data.
    </p>
    <p num="75">
      FIG. 4 is a graph of the rate of functional error detection versus the number of functional tests performed which conforms to the above equation.
      <br/>
      The shape of this curve may result from a rate of functional error detection that starts at zero with no functional tests performed and increases as functional errors occupying fairly large regions of the verification space are detected and eliminated, unmasking functional errors occupying smaller regions of the verification space.
      <br/>
      Functional error detection may peak when most of the functional errors occupying fairly large regions of the verification space have been detected and eliminated.
      <br/>
      The rate of functional error detection may then decrease exponentially as more functional tests must be performed to detect the remaining functional errors occupying smaller regions of verification space.
    </p>
    <p num="76">
      It is noted that although the performance of additional functional tests is always likely to result in the detection of functional errors, it is also likely that at some point a low functional error detection rate may not justify the costs associated with performing additional functional tests.
      <br/>
      The utility of the functional error detection rate curve is that once defining parameters are determined by curve fitting to actual debugging data, the number of functional errors likely to be detected by a given number of additional functional tests may then be calculated.
      <br/>
      This allows a decision to be made concerning when the costs associated with additional functional testing may not be justified.
    </p>
    <p num="77">
      Modern microprocessors are much more complex than either versions of the simple digital microprocessor described above.
      <br/>
      Due to the vast amount of software available for x86 microprocessors, they are the most popular family of digital microprocessors available today.
      <br/>
      In order to maintain compatibility with their predecessors, newer x86 microprocessors simply added instructions, addressing modes, architectural features, and operating modes to a basic x86 architecture.
      <br/>
      For example, a protected operating mode became available with the introduction of the 80286 digital microprocessor to provide memory protection in a multitasking environment.
      <br/>
      The 80286 had two operating modes; the real operating mode of the original 8086 digital microprocessor and the new protected mode.
    </p>
    <p num="78">
      A third virtual-8086 (i.e., virtual) operating mode became available with the introduction of the 80386 digital microprocessor.
      <br/>
      The virtual operating mode exists within the protected operating mode.
      <br/>
      A new hardware paging unit was added to support a new a memory management technique called paging.
      <br/>
      Paging may be enabled or disabled by system software.
      <br/>
      More modern x86 microprocessors also include a system management mode (SMM) which allows control over the amount of power dissipated by the microprocessor.
      <br/>
      Newer x86 microprocessors also have cache memory systems located on the same integrated circuit (i.e., chip) or within the same semiconductor device package.
      <br/>
      Such on-chip and on-package caches operate under software control, and may be operated in a write-back mode, a write-through mode, or may be disabled.
    </p>
    <p num="79">
      The fourteen 16-bit registers of the original 8086 digital microprocessor have been extended and expanded to the ten 32-bit registers and six 16-bit registers of modern x86 microprocessors.
      <br/>
      As a result, a modern x86 microprocessor must be capable of executing each of a large number of variable-length x86 instructions, many of which have several different possible addressing modes, while operating in any one of several possible operating modes including the real, protected, and virtual operating modes.
    </p>
    <p num="80">
      FIG. 5 is a block diagram of a functional verification apparatus 500 in accordance with the present invention.
      <br/>
      A functional specification 502 is used to generate a decision tree design 504.
      <br/>
      Decision tree design 504 is embodied in test generator 506 as will be described below.
      <br/>
      Test generator 506 produces one or more functional tests as output to a testing system 508.
      <br/>
      Testing system 508 is coupled to a golden device 510 and a device under test 512.
      <br/>
      Device under test 512 is coupled to a monitor 514.
    </p>
    <p num="81">As defined herein, a device may be implemented in hardware or any combination of hardware, firmware, and software.</p>
    <p num="82">
      Testing system 508 issues functional tests to both golden device 510 and device under test 512.
      <br/>
      Golden device 510 produces expected responses as output to testing system 508.
      <br/>
      Device under test 512 produces responses as output to testing system 508.
      <br/>
      Testing system 508 compares expected responses from golden unit 510 to responses from device under test 512 and produces functional test results.
      <br/>
      These functional test results flag differences in the responses from device under test 512 and expected responses from golden unit 510 as potential functional errors.
      <br/>
      The functional test results may then be screened by testing personnel to determine if differences in the responses from device under test 512 and expected responses from golden unit 510 represent functional errors.
    </p>
    <p num="83">
      Monitor 514 is coupled to device under test 512 and produces functional test coverage information.
      <br/>
      Functional test coverage information may include areas of functionality of device under test 512 exercised (or not exercised) during one or more functional tests.
      <br/>
      For example, functional test coverage information may include areas of a system memory of device under test 512 addressed (or not addressed), registers used (or not used), lines of microcode addressed (or not addressed), states of state machines entered (or not entered), and operating modes entered (or not entered) during one or more functional tests.
      <br/>
      Monitors are included in the functional test apparatus to ensure functional tests (i.e., functional test suites) exercise all parts of system implementations.
    </p>
    <p num="84">
      One embodiment of device under test 512 is a hardware implementation.
      <br/>
      A monitor structure used to observe a hardware implementation of device under test 512 also comprises hardware, and is called a hardware monitor.
      <br/>
      A hardware monitor may have an external bus structure to allow connection to one or more accessible pins, terminals, or external signal lines of a hardware implementation of device under test 512.
    </p>
    <p num="85">
      An alternate embodiment of device under test 512 is a software implementation which operates in a computer hardware environment.
      <br/>
      A monitor structure used to observe a software implementation of device under test 512 may also comprise software.
      <br/>
      Such a monitor is referred to as a software monitor.
    </p>
    <p num="86">
      Monitors also have a beneficial side effect in that they may also help to discover areas of a verification space unintentionally omitted from a decision tree representation of that verification space.
      <br/>
      For example, a failure to exercise a given functional area of device under test 512 may result from a failure to include the functional area in decision tree design 504 or the decision tree embodied in test generator 506.
    </p>
    <p num="87">
      In the embodiment of FIG. 6, test generator 506 includes a control unit 602 and a decision tree unit 604.
      <br/>
      Control unit 602 performs functional test pre- and post-processing actions, controls the actions of decision tree unit 604, and drives the signal lines of an output port with functional tests.
      <br/>
      Functional test pre-processing actions may include initialization of golden device 510 and device under test 512.
      <br/>
      Functional test pre-processing actions may also include the initialization of a special section of a system memory of golden device 510 and device under test 512 used to store intermediate and final results of functional tests.
      <br/>
      Functional test post-processing may include the outputing of intermediate and final results of functional tests stored in a special section of a system memory of golden device 510 and device under test 512.
    </p>
    <p num="88">
      Decision tree unit 604 is an embodiment of a decision tree design 504.
      <br/>
      Upon instruction from control unit 602, decision tree unit 604 is capable of generating one or more functional tests.
    </p>
    <p num="89">
      As devices, test generator 506, control unit 602, and decision tree unit 604 may be implemented in hardware or any combination of hardware, software, and firmware.
      <br/>
      In one embodiment, test generator 506 is a computer system, and control unit 602 and decision tree unit 604 are computer software programs.
    </p>
    <p num="90">
      FIG. 7 shows one embodiment of testing system 508.
      <br/>
      A queue unit 702 is coupled to a device under test (DUT) dispatch unit 704 and a golden unit dispatch unit 706.
      <br/>
      DUT dispatch unit 704 is coupled to a code assembler unit 708a and a compare unit 710.
      <br/>
      Code assembler unit 708a is coupled to a DUT run unit 712.
      <br/>
      DUT run unit 712 is coupled to DUT dispatch unit 704 and DUT 512.
      <br/>
      Golden unit dispatch unit 706 is coupled to a code assembler unit 708b and compare unit 710.
      <br/>
      Code assembler unit 708b is coupled to a golden device run unit 714.
      <br/>
      Golden device run unit 714 is coupled to golden device dispatch unit 706 and golden device 510.
    </p>
    <p num="91">
      Queue unit 702 is adapted to receive functional tests generated by test generator 506.
      <br/>
      Queue unit 702 issues functional tests received from test generator 506 to DUT dispatch unit 704 and golden unit dispatch unit 706.
    </p>
    <p num="92">
      DUT dispatch unit 704 issues functional tests received from queue unit 702 to code assembler unit 708a.
      <br/>
      Code assembler unit 708a encodes the functional test received from DUT dispatch unit 704 into machine instructions capable of being executed by DUT 512.
      <br/>
      DUT run unit 712 issues machine instructions received from code assembler unit 708a to DUT 512, and receives response signals back from DUT 512.
      <br/>
      DUT run unit 712 sends response signals received from DUT 512 to DUT dispatch unit 704.
    </p>
    <p num="93">
      Golden device dispatch unit 706 issues functional tests received from queue unit 702 to code assembler unit 708b.
      <br/>
      Code assembler unit 708b encodes the functional test received from DUT dispatch unit 706 into machine instructions capable of being executed by golden device 510.
      <br/>
      Golden device run unit 714 issues machine instructions received from code assembler unit 708b to golden device 510, and receives response signals back from golden device 510.
      <br/>
      The response signals received from golden device 510 are called expected response signals.
      <br/>
      Golden device run unit 712 sends expected response signals received from golden device 510 to golden device dispatch unit 706.
    </p>
    <p num="94">
      In a preferred embodiment, code assembler units 708a and 708b are combined into a single code assembler unit 708 coupled to DUT dispatch unit 704, DUT run unit 712, golden device dispatch unit 706, and golden device run unit 714.
      <br/>
      Two separate code assembler units 708a and 708b are shown to improve the clarity of FIG. 7.
      <br/>
      When code assembler unit 708 receives a functional test from DUT dispatch unit 704, code assembler unit 708 decodes the functional test and issues machine instructions to DUT run unit 712.
      <br/>
      When code assembler unit 708 receives a functional test from golden device dispatch unit 706, code assembler unit 708 decodes the functional test and issues machine instructions to golden device run unit 714.
    </p>
    <p num="95">
      DUT dispatch unit 704 issues response signals from DUT 512 to compare unit 710.
      <br/>
      Golden device dispatch unit 706 issues expected response signals from golden device unit 510 to compare unit 710.
      <br/>
      Compare unit 710 compares the response signals from DUT 512 to expected response signals from golden device unit 510, and issues functional test results.
      <br/>
      As mentioned above, these functional test results flag differences in the responses from DUT 512 and expected responses from golden unit 510 as potential functional errors.
      <br/>
      The functional test results may then be screened by testing personnel to determine if differences in the responses from device under test 512 and expected responses from golden unit 510 represent functional errors.
    </p>
    <p num="96">
      The method and apparatus described above is capable of generating and executing large numbers of functional tests for complex digital electronic systems at low cost.
      <br/>
      The apparatus includes a test generator which uses a decision tree representation of a verification space, derived from a functional specification of the digital electronic system, to generate functional tests.
      <br/>
      A decision tree representation of a verification space includes an initial goal node, a leaf goal node, and at least one intermediate goal node interconnected by a plurality of directed decision arcs formed between the initial goal node and the leaf goal node.
      <br/>
      Goal plans assigned to goal nodes include operations which generate functional tests.
      <br/>
      Functional tests are generated by recursively "walking" the decision tree, the choices of which goal node to visit next being made at random and according to decision weights assigned to each goal node.
      <br/>
      The decision weights assigned to each goal node in the decision tree may be adjusted to ensure all portions of the verification space are adequately tested.
    </p>
    <p num="97">
      A testing system issues functional tests to both a golden device and a device under test.
      <br/>
      The testing system compares expected responses from the golden unit to responses from device under test and produces functional test results.
      <br/>
      Specialized structures called monitors ensure sets of functional tests (i.e., functional test suites) exercise all parts of a system implementation.
    </p>
    <p num="98">
      The following is a working example of a functional test generation engine.
      <br/>
      The functional test generation engine is a computer program specifically adapted to generate testing sequences (i.e., functional tests) for a microprocessor under test.
      <br/>
      The microprocessor under test may be, for example, an x86 microprocessor.
      <br/>
      The functional tests are used to verify the proper operation of the microprocessor.
      <br/>
      The executions of these functional tests may be monitored as described above in order to implement a functional verification system.
    </p>
    <p num="99">
      Complete functional testing of a modern microprocessor is made difficult by the large number of possible combinations of instructions, operating modes, and system configurations.
      <br/>
      The functional test generation engine automates the task of generating functional tests, allowing large numbers of functional tests to be generated in a relatively short period of time.
      <br/>
      The functional tests produced by the functional test generation engine include instructions which will later be executed by a microprocessor under test.
    </p>
    <p num="100">
      The functional test generation engine employs the novel method of generating functional tests described above.
      <br/>
      The functional tests include random valid microprocessor instructions.
      <br/>
      The functional tests are in essence computer programs which first put a microprocessor under test into a desired operating mode, then cause the microprocessor under test to perform a desired activity which produces a result.
      <br/>
      The result produced by the microprocessor under test is then compared to an expected result.
      <br/>
      If the result produced by the microprocessor under test does not match the expected response, the microprocessor under test fails the functional test.
    </p>
    <p num="101">
      The functional test generation engine is described using constructs of the Common LISP programming language with Common LISP Object Structure (CLOS) extensions.
      <br/>
      A description of the Common Lisp computer language with CLOS object-oriented extensions may be found in Steele, Guy L., Common Lisp, Digital Press, 1990.
    </p>
    <p num="102">
      The functional test generation engine is implemented in LISP as a goal-plan problem solver.
      <br/>
      Extensive use of slot and method inheritance allow goal hierarchies to be encoded efficiently without becoming huge coding projects.
      <br/>
      Code generation is driven by a decision tree representation of verification space, where each decision node in the tree is represented by a goal object.
      <br/>
      Each goal object may have two or more child objects which represent more specific goals which would satisfy the parent goal.
      <br/>
      If a goal object has no children, it has associated with it a plan.
      <br/>
      This plan is implemented as a method which encodes the steps necessary to achieve that goal.
      <br/>
      In order to decide on one of the possibilities at a decision node, the software recursively advances through the goal hierarchy, at each stage making a weighted random choice on which child object to go to, until a leaf object is reached.
      <br/>
      The plan method associated with that leaf object is then executed.
      <br/>
      This processes also identifies any new goals which need to be achieved in order to implement the plan.
      <br/>
      These new goals are then achieved by other plans.
    </p>
    <p num="103">While the functional test generation engine is specifically adapted to generate functional tests for microprocessors, the method of advancing through a "decision tree" which represents the universe of all possible functional tests may be applied to testing other types of microprocessors, and even electronic circuits in general.</p>
    <p num="104">
      The functional test generation engine is preferably implemented in Common LISP with Common LISP Object Structure (CLOS) extensions and within the Franz Common LISP Environment (Allegro Common LISP, Version 4.e or higher, Franz Inc., 1995 University Ave., Berkeley, Calif. 97404).
      <br/>
      The assembly language programs produced by the functional test generation engine are intended to be assembled and linked into executable functional test programs.
      <br/>
      If the microprocessor under test is an x86 microprocessor, the x86 assembly language programs preferably contain assembly directives and linker options of the Phar Lap 386 ASM Assembler (Phar Lap Software Inc., Cambridge, Mass.).
      <br/>
      The Phar Lap LinkLoc Linker is preferably used to generate executable functional test code.
      <br/>
      In addition, the Allegro Composer program is preferably employed to allow CLOS structures of the functional test generation engine to be viewed. (Allegro Composer, Franz Inc., 1995 University Ave., Berkeley, Calif. 97404).
      <br/>
      Further, a screen editor is preferably used to edit functional test generation engine source files.
      <br/>
      Suitable screen editors include the `vi` or `emacs` editors which run under the UNIX.RTM. operating system. (Unix.RTM. is a registered trademark of Bell Laboratories, Murray Hill, N.J.).
      <br/>
      The screen editor may be initiated before the Allegro Common LISP and Composer programs are loaded in order to allow editing of source code files and viewing of CLOS structures.
      <br/>
      After loading all required files, the functional test generation engine may be invoked within the Allegro Common LISP environment.
    </p>
    <p num="105">
      Functional testing is accomplished using a testing system which includes the microprocessor under test and is capable of:
      <br/>
      1) loading an executable functional test program into a memory unit coupled to the microprocessor under test,
      <br/>
      2) initiating execution of the functional test program, and
      <br/>
      3) saving the computed results to a peripheral device which stores the computed results in a non-volatile form.
    </p>
    <p num="106">
      In the case of an x86 microprocessor under test, an x86 WBINVD (write back invalidate) instruction is preferably executed after computed results are produced in order to save any cached data to memory.
      <br/>
      The contents of memory may then be printed or otherwise saved in a non-volatile form.
    </p>
    <p num="107">
      The functional test generation engine uses a decision tree to capture the knowledge required to generate all possible functional tests (i.e., to cover a "verification space").
      <br/>
      Each node in the functional test generation engine decision tree is a resource capable of providing a solution to a particular problem (i.e., a problem solver resource).
      <br/>
      The top level problem to be solved is "to generate an functional test".
      <br/>
      This problem can be solved by breaking it down into several more specific problems; for example, "generate an instruction test" or "generate a page re-map".
      <br/>
      This is analogous to the choices that can be made at a top DO-TEST node in the decision tree.
      <br/>
      Solving the "generate an instruction test" problem might involve breaking the problem into still more specific problems such as: "select an instruction", "select a valid format for that instruction", and if the format involves a memory location "generate a memory location to use in this test".
      <br/>
      Solving each of these problems is analogous to moving one decision node further down in the decision tree.
    </p>
    <p num="108">
      Viewing the functional test generation engine as a problem solver accurately reflects the internal software architecture implemented.
      <br/>
      Essentially, the functional test generation engine includes a software implementation of a decision tree, and is capable of generating all possible functional tests.
      <br/>
      Advancing through this decision tree involves making a number of independent decisions.
      <br/>
      Each independent decision made have a large number of associated possible choices, and may be considered a problem to be solved.
    </p>
    <p num="109">
      A given problem may have several possible solutions, and each solution may have something in common with all other solutions.
      <br/>
      This commonality among possible solutions makes an object hierarchy a very efficient way of encoding the possible solutions.
      <br/>
      In object-oriented programming terms, "parent" objects may be used to represent classes of solutions.
      <br/>
      These parent objects may have commonality encoded within them as methods. "Child" objects, which represent a more specific solutions, inherit the methods of their parent objects.
      <br/>
      Child objects need only redefine inherited methods as required to reflect their more specific solution.
    </p>
    <p num="110">
      Each object in an object hierarchy can be thought of as a resource which is able to provide a solution to a particular class of problems.
      <br/>
      Typically, when asked to provide a solution, an object will make a weighted random selection among its children, each one of which provides a more specific class of solutions.
      <br/>
      The weighting which biases the relative frequency of selection is preset by the programmer or test engineer prior to generating the functional test.
      <br/>
      This continues until we reach a "leaf" object which has no children.
      <br/>
      The leaf object is capable of providing a specific solution.
      <br/>
      Once a leaf object has been chosen, its methods are executed.
      <br/>
      The result is the code and/or data definitions required to generate the functional test.
      <br/>
      Other resource objects may also contribute to the actual generation of software instructions and data written to the functional test source code file.
    </p>
    <p num="111">
      FIG. 8 is a block diagram of the major CLOS objects of the functional test generation engine.
      <br/>
      These objects interact in order to generate functional tests.
      <br/>
      Each box represents a CLOS object in the object hierarchy.
      <br/>
      An arrow from one box to another represents a call from one object to another object.
      <br/>
      Each object will be described below along with the modules which include them.
    </p>
    <p num="112">
      The functional test generation engine includes three main modules: the KERNEL module, the DATA-LOC module, the RANDOM INSTRUCTION GENERATOR module.
      <br/>
      The KERNEL module is independent of microprocessor functionality and provides the framework under which functional tests are generated.
      <br/>
      In addition to providing key resources such as memory management and keeping track of the generated code, the KERNEL module contains a registry which tracks the presence of other modules.
      <br/>
      This registry allows the KERNEL module to: (i) initialize other modules as required, and (ii) maintain a list of available objects which may be called upon to generate functional tests.
    </p>
    <p num="113">
      The KERNEL module includes most of the objects shown in FIG. 8: a TOFU (Top OF Universe) object 802, a CODE-GEN object 804, a KERNEL object 806, a REGISTRY object 808, an INITIALIZE object 810, a DO-TEST object 812, a CLEANUP object 814, a POST-PROCESS object 816, a MEM-MANAGER object 818, and a CODE-STRUC object 820.
      <br/>
      The TOFU object 802 provides a common root from which the rest of the objects in the functional test generation engine descend.
      <br/>
      The CODE-GEN object 804 is a child of the TOFU object 802.
      <br/>
      The CODE-GEN object 804 defines two slots, a `choices` slot and a `priority` slot, along with a `choose` method.
      <br/>
      The choices slot contains a list of choices available to a given object in the problem solver object hierarchy, and usually contains a list of the children of that object.
      <br/>
      The priority slot defines the relative priority (i.e., selection probability) of a given object with respect to its siblings.
      <br/>
      The choose method uses the priority values in the priority slot to perform a random selection between the choices listed in the choices slot.
      <br/>
      The choices slot, the priority slot, and the choose method are inherited by the rest of the objects in the functional test generation engine.
    </p>
    <p num="114">
      The KERNEL object 806 provides a common root from which the remaining objects in the functional test generation engine descend, including the REGISTRY object 808 and the MEM-MANAGER object 818.
      <br/>
      The REGISTRY object 808 maintains lists of objects that need to be involved at various stages of test code generation.
      <br/>
      The REGISTRY object 808 has four child objects to maintain each of the lists: the INITIALIZE object 810, the DO-TEST object 812, the CLEANUP object 814, and the POST-PROCESS object 816.
    </p>
    <p num="115">
      The INITIALIZE object 810 maintains a list of objects which need to be initialized before generating each test code file.
      <br/>
      Each object in the list is initialized by calling an `initialize` method with the name of the object to be initialized as an argument.
      <br/>
      The DO-TEST object 812 is the root of the decision tree used to generate tests.
      <br/>
      Objects which can generate different classes of tests register themselves with the DO-TEST object 812.
      <br/>
      At each iteration of functional test code generation a random selection is made among the registered objects, and a call to a `do-test` method is made with the selected object as an argument.
      <br/>
      The CLEANUP object 814 maintains a list of objects that need to be called to generate proper termination code at each possible exit point in the generated test pattern.
      <br/>
      When an exit point is reached during test code generation, a `cleanup` method is called upon each object in the list.
    </p>
    <p num="116">
      The POST-PROCESS object 816 implements a post-processing code generation phase.
      <br/>
      Activities which could not be performed during the original code generation phase are performed during the post-processing phase.
      <br/>
      For example, memory allocation cannot occur until the size of each required block of memory has been determined, and paging iterations cannot be generated until the location of each of the pages in memory has been determined.
      <br/>
      All objects that need to be called during the post-processing phase register themselves with the POST-PROCESS object 816.
      <br/>
      At the time of registration, each object supplies the relative order in which the object needs to be called.
      <br/>
      Once test generation is complete, a `post process post-process` method is called.
      <br/>
      The `post process post-process` method calls each of the registered objects in the appropriate order, thus completing functional test code generation.
    </p>
    <p num="117">
      The MEM-MANAGER object 818 allocates memory during the post-processing phase.
      <br/>
      The CODE-STRUC object 820 keeps track of the generated blocks of code.
    </p>
    <p num="118">
      The RANDOM INSTRUCTION GENERATOR module is responsible for generating simple integer unit instruction tests.
      <br/>
      The RANDOM INSTRUCTION GENERATOR module is registered with the DO-TEST object 812 of the KERNEL module as a source of top level tests.
      <br/>
      The RANDOM INSTRUCTION GENERATOR module relies upon the DATA-LOC module to provide the resources it needs as operands for the instruction test.
    </p>
    <p num="119">
      The RANDOM INSTRUCTION GENERATOR module includes three of the objects shown in FIG. 8: an INSTRS object 822, an OS-INSTRS object 824, and an APP-INSTRS object 826.
      <br/>
      The INSTRS object 822 provides a framework for the generation of instruction tests.
      <br/>
      The children of the INSTRS object 822, the OS-INSTR object 824 and the APP-INSTRS object 826, break the set of available instructions into specific groups.
      <br/>
      The OS-INSTRS object 824 generates instruction tests for instructions executed by an operating system (e.g., privileged x86 instructions executed by an operating system at privilege level 0).
      <br/>
      The APP-INSTRS object 826 generates instructions executed by an application program (i.e., application instructions).
      <br/>
      For example, most x86 instructions are classified as application instructions, excluding those which are floating-point related, branch related, segmentation related, or intended for operating system use.
    </p>
    <p num="120">
      The DATA-LOC module generates various types of instruction operands, including immediate operands, register operands, memory operands, and I/O operands, for functional tests which require them.
      <br/>
      When a memory operand is selected, the DATA-LOC module is capable of generating complex addressing modes.
      <br/>
      The DATA-LOC module does not generate any tests itself, but it is responsible instead for satisfying requests for resources from other modules.
      <br/>
      The major types of resources the DATA-LOC module supplies includes integer registers, floating point registers, immediates, input/output (I/O) ports, and memory locations.
      <br/>
      Any module requiring one of these resources for a test simply requests that resource from the DATA-LOC module.
      <br/>
      Thus the DATA-LOC module allows other modules to increase their functional test coverage.
    </p>
    <p num="121">
      The DATA-LOC module includes three of the objects shown in FIG. 8: an IU-REG object 828, an IMMEDIATE object 830, and a MEM-LOC object 832.
      <br/>
      The IU-REGS object 828 generates integer register operands.
      <br/>
      The IMMEDIATE object 830 generates immediate operands.
      <br/>
      The MEM-LOC object 832 generates memory address operands.
    </p>
    <p num="122">
      The KERNEL, DATA-LOC, and RANDOM INSTRUCTION GENERATOR modules will now be described in detail, beginning with the KERNEL module.
      <br/>
      The KERNEL module also defines the CODE-GEN object 804 as a child of the TOFU object 802.
      <br/>
      The CODE-GEN object 804 defines certain properties which are inherited by the rest of the objects in the functional test generation engine.
      <br/>
      As described above, the CODE-GEN object 804 defines two slots, a `choices` slot and a `priority` slot, along with a `choose` method.
      <br/>
      The two slots and the choose method are inherited by all other objects.
      <br/>
      The choices slot contains a list of the available choices at a given object in the problem solver object hierarchy, and usually contains a list of the children of that object.
      <br/>
      The priority slot defines the relative priority (i.e., selection probability) of a given object with respect to its siblings.
    </p>
    <p num="123">
      When the choose method is invoked in an object, a random selection is made from the list of candidates in that object's choices slot.
      <br/>
      Each candidate in the choices slot has a corresponding priority value in the priority slot.
      <br/>
      If there are `n` candidates in the choices slot, and candidate `j` has a corresponding priority value of pj in the priority slot, the probability that candidate `j` will be selected at random, Ps, is:  (Equation image '5' not included in text)
    </p>
    <p num="124">
      Thus the priority value associated with a given candidate is used to control how often the candidate is chosen.
      <br/>
      Setting the priority value to a larger number increases the relative probability that the given candidate will be selected.
      <br/>
      On the other hand, setting the priority value to 0 ensures that the given candidate will never be selected.
    </p>
    <p num="125">
      The choose method is utilized frequently to select among a set of candidates in the choices slot.
      <br/>
      Candidates may be, for example, instructions or alternate methods for generating a floating point number.
      <br/>
      An interface mechanism allows a user to set multipliers which increase or decrease priority values as needed.
      <br/>
      The priority values are preferably set to generate functional tests which exercise a wide range of the functionality of a microprocessor under test.
    </p>
    <p num="126">
      The KERNEL module includes functions required by all modules, including a memory management function.
      <br/>
      The memory manager (i.e., memory allocator) allows a functional test to use all of, or only selected portions of, the available memory space.
      <br/>
      Where the microprocessor under test include separate code and data caches, the memory allocator attempts to set up memory usage to cause many cache line replacements in both caches.
      <br/>
      The KERNEL module also generates random numerical values for both integer and floating point operations.
      <br/>
      When an argument is needed for an integer operation, the KERNEL module simply generates a random number of the appropriate size.
    </p>
    <p num="127">
      The memory manager of the KERNEL module ensures that the low bits of the addresses used are unique to the available memory space.
      <br/>
      For example, if the functional test generation engine is configured to use 256 kb of memory, all generated patterns would use 256 kb or less of total memory.
      <br/>
      The contiguous blocks (i.e., allocations) of memory used would be logically spread across the entire address space (e.g., 4 Gb), but would actually be placed such that the low 18 bits of every used address is unique in the available 256 kb of actual memory.
      <br/>
      A typical hardware platform which supports 256 kb of memory would be designed to decode only the low 18 bits of the address bus to allow tests which exercise all of the 4 Gb test space to run in 256 kb without problems.
    </p>
    <p num="128">
      The memory manager decides which parts of the 4 Gb address space to use when it is initialized before each file is generated.
      <br/>
      Given a total amount of available memory M, it essentially starts by breaking the total available memory into contiguous blocks (i.e., memory blocks) the size of which are determined by internal parameters.
      <br/>
      Each contiguous block is then assigned for use at one of the possible 4 Gb/M aliases for that contiguous block.
      <br/>
      This generates the map of available memory.
    </p>
    <p num="129">
      As code for a file is generated, various "blocks" of code and data (i.e., code blocks) are dynamically created and are added to.
      <br/>
      As code and data definitions are generated, the memory manager keeps track of the approximate number of memory bytes used by each code block.
      <br/>
      When the total amount of memory used crosses a pre-set threshold, subsequent new code block generation is suppressed to keep from exceeding the available memory.
      <br/>
      Once all code generation has been completed, the code blocks of varying sizes are allocated into the available memory during the post-processing phase.
      <br/>
      This involves a multiple pass effort.
    </p>
    <p num="130">
      Memory allocation begins by selecting a cache index which the pattern will try to "hit" on and around.
      <br/>
      For each block of code, a random choice is made among the available memory blocks big enough to accommodate the code block.
      <br/>
      If possible, the code block is placed in the memory block such that it crosses an address which will hit on the chosen cache index.
      <br/>
      Failing this condition, the code block will be allocated at the beginning or end of the memory block.
    </p>
    <p num="131">
      If the code blocks being allocated are large relative to the available memory blocks, the above scheme sometimes causes too much fragmentation in available memory.
      <br/>
      Such fragmentation can cause memory allocations to fail to complete.
      <br/>
      In this event, the entire allocation process is restarted without attempting to hit the chosen cache index.
      <br/>
      If this fails as well, presumably due to the initial allocation being too fragmented, the entire pattern is regenerated from the beginning.
      <br/>
      If the entire allocation scheme fails twice in a row, the functional test generation engine terminates with the assumption that the chosen configuration is not suitable for proper test code generation.
    </p>
    <p num="132">
      When allocating 16-bit code blocks into high memory, the memory manager generates the appropriate linker information in the header of the file.
      <br/>
      This information is later used by the assembly script to achieve the desired result of linking the 16-bit code segments into the required address in high memory.
    </p>
    <p num="133">
      As code is generated by the functional test generation engine, it is stored in a dynamic structure in memory and is not printed out until the very end of the file generation sequence (i.e., after completion of the post-processing phase).
      <br/>
      The CODE-STRUC object 820 keeps track of the generated blocks of code.
      <br/>
      The code block structure has the form ((insertion-point.info.entries)).
      <br/>
      For a given code block (blk) the entries field ((cddr blk)) is a list of elements which can be one of several types.
      <br/>
      These include elements which represent a single line in the file defining code, data, or a comment, or multiple lines such as a descriptor definition, or verbatim code which gets put into the file "as is".
      <br/>
      An entry can also be another code block creating a hierarchical structure which allows the file to be logically broken into various sections where code can be added.
      <br/>
      A depth-first advance through the hierarchy defines the order in which blocks are produced.
    </p>
    <p num="134">
      The CODE-STRUC object 820 uses two slots to keep track of code blocks as they are generated.
      <br/>
      The top-blk slot ((slot-value code-struc top-blk)) contains the top level code block for the current file.
      <br/>
      All other code blocks are inserted as an entry somewhere in this block to create the hierarchy structure for the file being generated.
      <br/>
      Once code generation is complete, the function `code-dump` is called on this top level code block to print out the assembly file text for the file being generated.
    </p>
    <p num="135">
      The current-blk slot of CODE-STRUC ((slot-value code-struc `current-blk)) points to the code block that code is currently being generated into.
      <br/>
      Once the initialization phase is complete, this slot is set up to point to a code block whose insertion-point points to the end of the block.
      <br/>
      Subsequent `do-test` iterations usually simply add test code to the bottom of this code block.
    </p>
    <p num="136">
      The KERNEL module also keeps track of assigned thread numbers and the thread count.
      <br/>
      At each iteration of code generation, the thread count is incremented, and all generated lines of code are tagged with that thread number in the form of a comment (e.g.: ";T54").
      <br/>
      Lines of code and data with the same thread number can be identified as coming from the same `do-test` iteration.
    </p>
    <p num="137">
      The REGISTRY object 808 of the KERNEL module maintains central lists of modules.
      <br/>
      When a module is loaded, the module registers itself in the REGISTRY object 808.
      <br/>
      This allows new modules to be added into the system without having to modify the KERNEL module.
      <br/>
      The functional test generation engine has several different registries, including the INITIALIZE object 810, the DO-TEST object 812, the CLEANUP object 814, and the POST-PROCESS object 816.
    </p>
    <p num="138">
      The registries described above make up the heart of the functional test generation engine.
      <br/>
      The internal top-level call to generate a file is (gen-file registry len) which is essentially defined as follows:
    </p>
    <p num="139">
      (defmethod gen-file ((self registry) len)
      <br/>
      (setf (slot-value code-struc `test-len) len)
      <br/>
      (initialize initialize)
      <br/>
      (do-test do-test)
      <br/>
      (cleanup cleanup)
      <br/>
      (post-process post-process)
      <br/>
      (code-dump (slot-value code-struc `top-blk))
      <br/>
      )
    </p>
    <p num="140">
      The DATA-LOC module will now be described in detail.
      <br/>
      As described above, the DATA-LOC module generates various types of instruction operands for functional tests which require them.
      <br/>
      Requests for immediate operands, either integer or floating point, are passed on to the KERNEL module.
      <br/>
      Requests for I/O addresses will be satisfied by locations which cover the entire I/O space.
      <br/>
      Requests for integer registers will be satisfied by any of the available general purpose registers which will also be initialized with a random integer if necessary.
      <br/>
      The major exception is the extended stack pointer register `ESP` which is reserved for use as the stack pointer.
      <br/>
      The DATA-LOC module maintains the stack and is capable of generating tests to switch the current stack to different logical addresses in memory.
    </p>
    <p num="141">
      The DATA-LOC module keeps track of the STATE of the floating point registers.
      <br/>
      It can return any one of the floating point registers when requested.
      <br/>
      The DATA-LOC module can also initialize a returned floating point register with a floating point random number obtained from the KERNEL module.
    </p>
    <p num="142">
      An important feature of the functional test generation engine is that it provides "fault visibility".
      <br/>
      The DATA-LOC module keeps track of both floating point registers and integer registers which contain the results of previous computations, and can use this information to decide when to save register contents to memory.
    </p>
    <p num="143">
      A major portion of verification space covered by the DATA-LOC module occurs during the accessing of memory locations.
      <br/>
      When asked for a memory location, the DATA-LOC module can generate the data definition either "in-line" or in one of several data blocks.
      <br/>
      In-line memory locations are generated within the code stream and cause contention for the memory location between the instruction and data caches.
      <br/>
      Given a w-way data cache, the DATA-LOC module will set up w+1 data blocks.
      <br/>
      The DATA-LOC module can generate the requested memory location in any one of these data blocks.
      <br/>
      Both of these schemes are designed to interact with the memory allocation methods to cause many cache line replacements along with data-accesses to an entire address space (e.g., 4 Gb).
    </p>
    <p num="144">
      Once a memory location has been defined, the DATA-LOC module can generate an access using any of the available addressing modes (both 16-bit and 32-bit modes).
      <br/>
      When an "interesting" memory address is required such as for a snoop or a debug breakpoint, DATA-LOC generates an address that points somewhere into any of the data blocks, the stack, or the current code stream.
    </p>
    <p num="145">
      The current STATE contains some information about the integer registers, including which of these registers are marked `LOCKED` and `ACTIVE`. Registers are LOCKED when they are selected for a particular use in a test sequence which requires them to be loaded with a specific value.
      <br/>
      Locking a register will not allow it to be selected for subsequent operations which might need to write to that register.
      <br/>
      All registers are `UNLOCKED` at the end of each `do-test` call.
    </p>
    <p num="146">
      Registers are marked as ACTIVE when the result of a tested operation is written into them.
      <br/>
      An ACTIVE register can be read or modified, but is saved to memory before any write operation which could destroy its contents is performed.
      <br/>
      ACTIVE registers are also periodically saved out to memory and are marked as `INACTIVE` even if they are not needed by an immediate operation.
    </p>
    <p num="147">
      Once an addressing mode has been selected for a particular memory access, any required registers are loaded with appropriate values right before executing the instruction carrying out the memory access.
      <br/>
      Certain cases (e.g., DS: �ECX��ECX�) can require the target memory location to be aligned on specific boundaries.
      <br/>
      This requirement is handled when generating the data definition.
    </p>
    <p num="148">
      The RANDOM INSTRUCTION GENERATOR module will now be described in detail.
      <br/>
      The RANDOM INSTRUCTION GENERATOR module covers most of the instructions of the microprocessor under test.
      <br/>
      Instructions not covered involve branches, floating point operations, segmentation, mode switching, and debug breakpoints.
      <br/>
      This essentially leaves all integer instructions which do straight-forward operations on a destination location (register or memory), optionally using one or possibly two source operands.
      <br/>
      Undocumented instructions which fall into this set are also covered by the RANDOM INSTRUCTION GENERATOR module.
    </p>
    <p num="149">
      In addition to exercising all of the above instructions, the RANDOM INSTRUCTION GENERATOR module is also responsible for exercising all legal forms of each one of the instructions (i.e., all combinations and variations of registers, memory locations, and immediates that the instruction supports).
      <br/>
      This coverage is multiplied by the verification space coverage provided by the DATA-LOC module when the DATA-LOC module is supplying the resources used as arguments to the instruction tests.
    </p>
    <p num="150">
      The RANDOM INSTRUCTION GENERATOR module also tests a small amount of self-modifying code (SMC) functionality.
      <br/>
      Because the Phar Lap assembler does not support generating specific forms of certain instructions having alternate forms, instructions with similar encoding are generated and are self-modified by the code stream to generate the target instruction.
      <br/>
      Sometimes this self-modification is done well before the target instruction executes, and in other cases, the modification happens just before the target instruction executes.
      <br/>
      In the case of an x86 microprocessor under test, if 486-style compatibility is required, a branch instruction can be forced between the modifying code and the target instruction.
    </p>
    <p num="151">
      If x86 instructions with LOCK prefixes are generated, a label is inserted between the LOCK prefix and the rest of the instruction.
      <br/>
      This label can be used as a target of a branch instruction to cause the target code to be re-interpreted without the consideration of the LOCK prefix.
    </p>
    <p num="152">
      The RANDOM INSTRUCTION GENERATOR module creates a large object hierarchy which exists under an INSTR-CLASSES object.
      <br/>
      The INSTR-CLASSES object has four sub-hierarchies defined under it which makes up the RANDOM INSTRUCTION GENERATOR module mechanism: the INSTRS object 822, an INSTR-TYPES object, an INSTR-FMTS object, and an INSTR-FIXUP object.
    </p>
    <p num="153">
      The INSTRS object 822 is the object from the RANDOM INSTRUCTION GENERATOR module which is registered with the DO-TEST object 812 in the KERNEL module.
      <br/>
      Under the INSTRS object 822 is a hierarchy representing all of the available x86 instructions that can be tested directly.
      <br/>
      Instructions supported by the RANDOM INSTRUCTION GENERATOR module which are executed by an operating system are organized under the OS-INSTR object 824.
      <br/>
      Other instructions (i.e., application instructions) fall under the APP-INSTRS object 826.
    </p>
    <p num="154">
      When the DO-TEST object 812 calls the INSTRS object 822 to generate a top level test, `(choose instrs)` is called to make a weighted random advance through the object hierarchy under the INSTRS object 822 and to select an object from which no arc extends to another object (i.e., a "leaf object").
      <br/>
      Such leaf objects represent specific x86 instructions.
      <br/>
      The relative priorities down the object hierarchy can be controlled by the user interface to allow user control of the frequency with which different instructions are generated.
    </p>
    <p num="155">
      Once an instruction has been selected, a particular format for that instruction must be chosen.
      <br/>
      Because many x86 instructions share the same set of formats (e.g.: `add`, `sub`, `and`, and `or` instructions all support the same set of instruction formats), these sets are defined as shared resources under the INSTR-TYPES object.
      <br/>
      The objects under the INSTR-TYPES object define types or classes of instructions which all support the same set of instruction formats.
      <br/>
      Each of these objects has access to a list of the instruction formats that type of instruction supports.
      <br/>
      The list is defined under the INSTR-FMTS object (described below).
      <br/>
      Each leaf object under the INSTRS object has associated with it the object under INSTR-TYPES that represents its instruction type.
      <br/>
      The choose method is then called on this object to select which format should be used for the instruction.
    </p>
    <p num="156">
      The hierarchy under the INSTR-FMTS object defines all the instruction formats supported by the x86 definition.
      <br/>
      Once an instruction and its format have been chosen, control is passed to the appropriate object under INSTR-FMTS.
      <br/>
      This object maintains a record of the types of destination and source resources required by the instruction format.
      <br/>
      The INSTR-FMTS object will call the DATA-LOC module to set up those resources and then generate the code to execute the selected instruction test.
      <br/>
      If the destination of the instruction test is a register, the test ends with a call to Data-Loc which might optionally cause the register to be written out to a unique location in memory.
    </p>
    <p num="157">
      Certain x86 instruction formats are not supported by the Phar Lap assembler.
      <br/>
      These instructions have multiple forms, of which only one is generated by the assembler.
      <br/>
      In order to generate the missing formats, the RANDOM INSTRUCTION GENERATOR module generates the closest possible encoding of the instruction that the assembler does support, then self-modifies that instruction to generate the required encoding.
    </p>
    <p num="158">
      The above mechanism is handled by the INSTR-FIXUP object which can cause code modification to take place in one of two possible locations.
      <br/>
      The modifying instruction is generated either near the beginning of the code stream so that the modification happens well before the target instruction executes.
      <br/>
      Alternately, the modifying instruction is generated just before the target instruction in the code stream so that modification and execution happens in sequence.
      <br/>
      If, as occurs in the 486 microprocessor, a branch is required between the modifying instruction and its target, the branch instruction is generated by the INSTR-FIXUP object as well.
    </p>
    <p num="159">
      Although most instruction tests are generated under the mechanism described above, certain instructions have special formats that are handled separately.
      <br/>
      For example, x86 LOCK prefix instructions generate a label between the LOCK prefix and the rest of the instruction.
      <br/>
      This label can be used as a target for a BRANCH instruction to cause a certain amount of code re-interpretation.
      <br/>
      Another example is the REP string operations which set up blocks of memory upon which to perform string operations.
    </p>
    <p num="160">
      It will be appreciated by those skilled in the art having the benefit of this disclosure that this invention is believed to be capable of generating and executing large numbers of functional tests for complex digital electronic systems at low cost.
      <br/>
      Furthermore, it is also to be understood that the form of the invention shown and described is to be taken as exemplary, presently preferred embodiments.
      <br/>
      Various modifications and changes may be made without departing from the spirit and scope of the invention as set forth in the claims.
      <br/>
      It is intended that the following claims be interpreted to embrace all such modifications and changes.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A testing system for verifying proper functional operation of a device under test, wherein the testing system comprises circuitry configured to:</claim-text>
      <claim-text>apply a functional test to the device under test, wherein the functional test is generated using a decision tree representation of a verification space of the device under test; receive a first response from the device under test;</claim-text>
      <claim-text>and produce a functional test result dependent upon the first response.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The testing system as recited in claim 1, wherein the device under test is a digital electronic device.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The testing system as recited in claim 1, wherein the decision tree representation of the verification space is derived from a functional specification of the device under test.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The testing system as recited in claim 1, wherein the decision tree representation of the verification space includes an initial goal node, a leaf goal node, and at least one intermediate goal node interconnected by a plurality of directed decision arcs formed between the initial goal node and the leaf goal node.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The testing system as recited in claim 1, wherein the testing system is further configured to apply the functional test to a golden device and to receive a second response from the golden device.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The testing system as recited in claim 5, wherein the testing system is further configured to compare the first and second responses in order to produce the functional test result.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The testing system as recited in claim 6, wherein the second response from the golden device is an expected response, and wherein the functional test result flags a difference between the first response from the device under test and the expected response from the golden device as a potential functional error in the device under test.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A functional verification apparatus, comprising: a test generator configured to produce a functional test using a decision tree representation of a verification space of a device under test;</claim-text>
      <claim-text>and a testing system coupled to receive the functional test and configured to:</claim-text>
      <claim-text>- apply the functional test to the device under test and to a golden device; - receive a first response from the device under test and a second response from the golden device; - compare the first and second responses;</claim-text>
      <claim-text>and - produce a functional test result dependent upon said comparison.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The functional verification apparatus as recited in claim 8, wherein the device under test is a digital electronic device.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The functional verification apparatus as recited in claim 8, wherein the decision tree representation of the verification space is derived from a functional specification of the device under test.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The functional verification apparatus as recited in claim 8, wherein the decision tree representation of the verification space includes an initial goal node, a leaf goal node, and at least one intermediate goal node interconnected by a plurality of directed decision arcs formed between the initial goal node and the leaf goal node.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The functional verification apparatus as recited in claim 8, wherein the second response from the golden device is an expected response, and wherein the functional test result flags a difference between the first response from the device under test and the expected response from the golden device as a potential functional error in the device under test.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The functional verification apparatus as recited in claim 8, wherein the test generator comprises: a decision tree unit including the decision tree representation of the verification space of the device under test, wherein the decision tree unit is configured to produce the functional test in response to control information;</claim-text>
      <claim-text>and a control unit coupled to the decision tree unit and configured to provide said control information to the decision tree unit, to receive the functional test from the decision tree unit, and to provide the functional test to the testing system.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The functional verification apparatus as recited in claim 8, wherein the decision tree representation of the verification space includes an initial goal node, a leaf goal node, and at least one intermediate goal node interconnected by a plurality of directed decision arcs formed between the initial goal node and the leaf goal node, and wherein the decision tree unit produces the functional test by: assigning a goal plan to the initial goal node, the leaf goal node, and the at least one intermediate goal node, wherein each goal plan comprises at least one operation;</claim-text>
      <claim-text>and executing the goal plan assigned to the initial goal node.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The functional verification apparatus as recited in claim 8, wherein the testing system comprises: a queue unit coupled to receive the functional test from the test generator and configured to provide the functional test; a device under test (DUT) dispatch unit coupled to receive the functional test from the queue unit and configured to provide the functional test to the device under test, to receive the first response from the device under test, and to provide the first response; a golden device dispatch unit coupled to receive the functional test from the queue unit and configured to provide the functional test to the golden device, to receive the second response from the golden device, and to provide the second response; a first code assembler unit coupled to receive the functional test from the DUT dispatch unit and configured to produce a DUT machine language functional test and to provide the DUT machine language functional test; a second code assembler unit coupled to receive the functional test from the golden device dispatch unit and configured to produce a golden device machine language functional test and to provide the golden device machine language functional test; a DUT run unit coupled to receive the DUT machine language functional test from the first code assembler unit and configured to provide the DUT machine language functional test to the device under test, to receive the first response from the device under test, and provide the first response to the DUT dispatch unit; a golden device run unit coupled to receive the golden device machine language functional test from the second code assembler unit and configured to provide the golden device machine language functional test to the golden device, to receive the second response from the golden device, and to provide the second response to the golden device dispatch unit;</claim-text>
      <claim-text>and a compare unit coupled to receive the first response from the DUT dispatch unit and the second response form the golden device dispatch unit, wherein the compare unit is configured to produce the functional test result.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The functional verification apparatus as recited in claim 8, further comprising at least one monitor coupled to the device under test and configured to produce functional test coverage information.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The functional verification apparatus as recited in claim 16, wherein the monitor comprises electrical hardware.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The functional verification apparatus as recited in claim 16, wherein the monitor comprises software.</claim-text>
    </claim>
  </claims>
</questel-patent-document>