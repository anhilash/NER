<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182024B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182024</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182024</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="25492186" extended-family-id="42108771">
      <document-id>
        <country>US</country>
        <doc-number>08951811</doc-number>
        <kind>A</kind>
        <date>19971014</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08951811</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165316</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>95181197</doc-number>
        <kind>A</kind>
        <date>19971014</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08951811</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/44        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>44</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>703022000</text>
        <class>703</class>
        <subclass>022000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>345440000</text>
        <class>345</class>
        <subclass>440000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>717105000</text>
        <class>717</class>
        <subclass>105000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-008/10</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>10</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-008/24</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>24</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-008/10</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>10</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-008/24</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>24</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>30</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>9</number-of-drawing-sheets>
      <number-of-figures>11</number-of-figures>
      <image-key data-format="questel">US6182024</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Modeling behaviors of objects associated with finite state machines and expressing a sequence without introducing an intermediate state with the arc language</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>BECK KENT L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4885717</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4885717</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>CLARK ANDREW L</text>
          <document-id>
            <country>US</country>
            <doc-number>5297150</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5297150</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>KITA RONALD A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5408597</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5408597</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>DANGELO CARLOS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5555201</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5555201</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>JUETTNER PETER, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5615333</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5615333</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>RAIMI RICHARD, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5680332</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5680332</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>ONO KIYOSHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5794040</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5794040</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>KITA RONALD ALLEN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5870590</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5870590</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>BRODSKY STEPHEN ANDREW, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5893913</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5893913</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>BRODSKY STEPHEN ANDREW, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5895472</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5895472</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="11">
          <text>BRODSKY STEPHEN ANDREW, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5907706</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5907706</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="12">
          <text>JAY CHRISTIAN Y, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5910958</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5910958</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="13">
          <text>KORENSHTEIN RONI</text>
          <document-id>
            <country>US</country>
            <doc-number>5917498</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5917498</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="14">
          <text>BRODSKY STEPHEN ANDREW, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5960199</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5960199</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="15">
          <text>BRODSKY STEPHEN ANDREW, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5983016</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5983016</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="16">
          <text>BRODSKY STEPHEN ANDREW, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5991536</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5991536</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="17">
          <text>GANGOPADHYAY DIPAYAN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6011559</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6011559</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>"ObjChart-builder: An Environment for Executing Visual Models", Gangopadhyay et al., 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>"ObjChart: Tangible Specification of Reactive Object Behavior", Gangopadhyay et al., 1993, Object-Oriented Programming, 7th European Conference.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>"Contracts: Specifying Behavioral Compositions in Object Oriented Systems", Helm et al., ECOOP/OOPSLA 1990 Proceedings.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>"Monitoring Semantics: A Formal Framework for Specifying Implementing, and Reasoning about Execution Monitors", Kishon et al., ACM 1991.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>"The UAN: A User Oriented Representation for Direct Manipulation Interface Designs", Hartson et al. ACM Transactions on Information Systems, vol. 8, No. 3, Jul. 1990, pp. 181-203.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="6">
          <text>Rational Rose, "Using Rational Rose 4.0", Rational Software Company, 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="7">
          <text>"Object Oriented Specification and its Generation for Compiler", Wu et al, ACM 1992.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="8">
          <text>"A New Formalism for Discrete Event Simulation", Radiya et al., 1987.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="9">
          <text>"Report on the Workshop Framework-Centered Software Development", Gangopadhyay et al., 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="10">
          <text>"Attribute GrammarParadigms-A High Level Methodology in Language Implementation", Paakki, 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="11">
          <text>Gangopadhyay, Dipayan, et al., Research Report, "ObjChart-Builder: An Environment for Executing Visual Object Models", IBM Research Division, pp. 1-16, Apr. 29, 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="12">
          <text>Gangopayhyay, Dipayan, et al., "ObjChart: Tangible Specification of Reactive Object Behavior", Proceedings of the Seventh European Conference on Object Oriented Programming, Jul. 26-30, 1993, pp. 432-457.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="13">
          <text>Misra, Jayadev, "Equational Reasoning About Nondeterministic Processes", Formal Aspects of Computing, vol. 2, No. 2, pp. 167-195, Apr.-Jun. 1990.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Gangopadhyay, Dipayan</name>
            <address>
              <address-1>Cupertino, CA, US</address-1>
              <city>Cupertino</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Mitra, Subrata</name>
            <address>
              <address-1>San Jose, CA, US</address-1>
              <city>San Jose</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Gates &amp; Cooper</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Stamber, Eric W.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method, apparatus, and article of manufacture for object modeling.
      <br/>
      An object model is created in a computer using an executable visual specification language to model behaviors of one or more objects within the object model.
      <br/>
      A sequence of actions can then be expressed within the executable visual specification language for the behaviors of the objects within the object model.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
    <p num="1">This application is related to the following co-pending and commonly-assigned patent applications:</p>
    <p num="2">
      application Ser.
      <br/>
      No. 08/747,415, entitled "METHOD FOR SYNCHRONIZING CLASSES, OBJECTS, ATTRIBUTES AND OBJECT PROPERTIES ACROSS AN OBJECT-ORIENTED SYSTEM," filed on Nov. 12, 1996, by Stephen A. Brodsky et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/747,414, entitled "LAYOUT METHOD FOR ARC-DOMINATED LABELLED GRAPHS," filed on Nov. 12, 1996, by Dipayan Gangopadhyay, et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/747,416, entitled "MULTI-OBJECT VIEWS IN AN OBJECT MODELING TOOL," filed on Nov. 12, 1996, by Roni Korenshtein.;
      <br/>
      application Ser.
      <br/>
      No. 08/747,057, entitled "INTERACTIVE MODELING AGENT FOR AN OBJECT-ORIENTED SYSTEM," filed on Nov. 12, 1996, by Stephen A. Brodsky et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/747,058, entitled "EXECUTION ENGINE IN AN OBJECT MODELING TOOL," filed on Nov. 12, 1996, by Stephen A. Brodsky et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/747,417, entitled "NOTIFICATION MANAGER FOR OBJECT-ORIENTED SYSTEMS," filed on Nov. 12, 1996, by Stephen A. Brodsky et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/850,829, entitled "METHOD FOR SYNCHRONIZATION BETWEEN LINKS AND GROUP DEFINITIONS WITHIN AN OBJECT-ORIENTED SYSTEM," filed on May 2, 1997, by Stephen A. Brodsky, et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/850,858, entitled "OBJECT OUTLINE VIEW FOR GROUPS WITHIN AN OBJECT-ORIENTED SYSTEM," filed on May 2, 1997, by Stephen A. Brodsky, et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/850,214, entitled "METHOD FOR SENDING A MESSAGE TO A GROUP AND THE GROUP BROADCASTS THE MESSAGE TO ITS MEMBERS OR REFERENCES WITHIN AN OBJECT-ORIENTED SYSTEM," filed on May 2, 1997, by Stephen A. Brodsky, et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/850,832, entitled "CHANGE AND ACCOUNTING LOG FOR OBJECT-ORIENTED SYSTEMS," filed on May 2, 1997, by Stephen A. Brodsky, et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/850,838, entitled "MODEL TRACE VIEW FOR OBJECT-ORIENTED SYSTEMS," filed on May 2, 1997, by Stephen A. Brodsky et al.;
      <br/>
      application Ser.
      <br/>
      No. 08/850,337, entitled "FRACTAL NESTED LAYOUT FOR HIERARCHICAL SYSTEMS," filed on May 2, 1997, by Stephen A. Brodsky.;
      <br/>
      application Ser.
      <br/>
      No. 08/850,847, entitled "REFERENCE ATTRIBUTES WITHIN AN OBJECT-ORIENTED SYSTEM," filed on May 2, 1997, by Stephen A. Brodsky.;
    </p>
    <p num="3">all of which applications are incorporated by reference herein.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="4">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="5">This invention relates in general to object-oriented programming systems, and in particular, to a method for adding sequentiality to an arc language in an object modeling tool used in an object-oriented programming system.</p>
    <p num="6">2. Description of Related Art</p>
    <p num="7">
      Object modeling tools are available that provide an executable visual specification language for modeling the dynamic behavior of objects.
      <br/>
      An example is object modeling tools that are used to specify finite state machines (FSMs) of the Mealy machine variety, which are used extensively in telecommunication protocol design and object-oriented computer-assisted software engineering (CASE).
    </p>
    <p num="8">
      The reactive behavior of each object is specified by associating an extended finite-state machine with the object or by using object integration diagrams.
      <br/>
      The finite-state machines use an arc-language for behavioral specifications, while object interaction diagrams use constructs similar to the arc-language.
      <br/>
      Generally, each arc consists of an event-condition-actions triple: an "event" is a trigger in time, which may result in a state transition, concurrently initiating the actions, provided the corresponding condition holds.
    </p>
    <p num="9">
      However, existing arc-languages are weak on two counts: they cannot directly express sequencing of actions, and there is no way to refine conditions within the visual framework.
      <br/>
      The present invention solves these problems by introducing an additional connective for sequencing of actions and extending conditions to invoke events.
      <br/>
      Since it is preferable to remove some of the duality between methods and events, the present invention also incorporates return values from events.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="10">
      To overcome the limitations in the prior art described above, and to overcome other limitations that will become apparent upon reading and understanding the present specification, the present invention discloses a method, apparatus, and article of manufacture for object modeling.
      <br/>
      An object model is created in a computer using an executable visual specification language to model behaviors of one or more objects within the object model.
      <br/>
      A sequence of actions can then be expressed within the executable visual specification language for the behaviors of the objects within the object model.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="11">
      Referring now to the drawings in which like reference numbers represent corresponding parts throughout:
      <br/>
      FIG. 1 illustrates an exemplary computer hardware environment compatible with the present invention;
      <br/>
      FIG. 2 illustrates the main visual constructs provided by the computer programs according to the present invention;
      <br/>
      FIG. 3 illustrates a first finite state machine for sequencing by introducing artificial states;
      <br/>
      FIG. 4 illustrates a second finite state machine for sequencing by introducing artificial states;
      <br/>
      FIG. 5 illustrates an arc-label with an extended signature;
      <br/>
      FIG. 6 illustrates a possible deadlock in a naive interpretation of the ";" connective;
      <br/>
      FIG. 7 illustrates the data structures used in interpreting the object modeling tool;
      <br/>
      FIG. 8 is a flowchart that illustrates some of the steps performed by the computer programs of the present invention;
      <br/>
      FIG. 9 illustrates a finite state machine for the factorial example of FIG. 7;
      <br/>
      FIG. 10 illustrates a user interface of the object modeling tool depicting objects in a collection scheme; and
      <br/>
      FIG. 11 illustrates a user interface of the object modeling tool depicting a finite state machine for the objects in the collection scheme of FIG. 10.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="12">
      In the following description of the preferred embodiment, reference is made to the accompanying drawings which form a part hereof, and in which is shown by way of illustration a specific embodiment in which the invention may be practiced.
      <br/>
      It is to be understood that other embodiments may be utilized and structural and functional changes may be made without departing from the scope of the present invention.
    </p>
    <p num="13">Hardware Environment</p>
    <p num="14">
      FIG. 1 illustrates an exemplary environment that could be used with the present invention.
      <br/>
      The present invention his typically implemented using a computer 100, wherein the computer 100 comprises a processor, random access memory (RAM), read-only memory (ROM) and/or other components.
      <br/>
      The computer 100 may be coupled to I/O devices, such as a monitor 102, keyboard 104, mouse device 106, fixed and/or removable data storage devices 108 and 110, and printer 112.
      <br/>
      The computer 100 could also include data communications devices (not shown) for coupling to other I/O devices, including a local area network (LAN) or wide area network (WAN) via interface cable 114.
      <br/>
      Of course, those skilled in the art will recognize that any combination of the above components, or any number of different components, peripherals, and other devices, may be used with the computer 100.
    </p>
    <p num="15">
      Generally, the computer 100 operates under control of an operating system 116, which is represented by the display on the monitor 102.
      <br/>
      The present invention is preferably implemented within an Object Modeling Tool comprised of one or more computer programs 118, which are represented by the window displayed on the monitor 102 operating under the control of the operating system 116.
      <br/>
      In alternative embodiments, the present invention may be implemented in the operating system 116 itself.
    </p>
    <p num="16">
      The operating system 116 is booted into the memory of the computer 100 for execution when the computer 100 is powered-on or reset.
      <br/>
      In turn, the operating system 116 then controls the execution of the computer programs 118 by the computer 100.
      <br/>
      The operating system 116 and computer programs 118 are comprised of instructions which, when read and executed by the computer 100, causes the computer 100 to perform the steps necessary to implement and/or use the present invention.
    </p>
    <p num="17">
      Generally, the operating system 116 and/or computer programs 118 are tangibly embodied in and/or readable from a device, carrier, or media, such as a memory, data storage devices 108 and/or 110, and/or remote devices accessible via data communications devices.
      <br/>
      Under control of the operating system 116, the computer programs 118 may be loaded from the memory, data storage devices 108 and/or 110, and/or remote devices into the memory of the computer 100 for use during actual operations.
    </p>
    <p num="18">
      Thus, the present invention may be implemented as a method, apparatus, or article of manufacture using standard programming and/or engineering techniques to produce software, firmware, hardware, or any combination thereof.
      <br/>
      The term "article of manufacture" (or alternatively, "computer program carrier") as used herein is intended to encompass any device, carrier, or media that provides access to a computer program performing the same or similar functionality.
      <br/>
      Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope of the present invention.
    </p>
    <p num="19">
      Those skilled in the art will recognize that the exemplary environment illustrated in FIG. 1 is not intended to limit the present invention.
      <br/>
      Indeed, those skilled in the art will recognize that other alternative hardware environments may be used without departing from the scope of the present invention.
    </p>
    <p num="20">Operation of the Object Modeling Tool</p>
    <p num="21">
      1.
      <br/>
      Introduction
    </p>
    <p num="22">
      FIGS. 2-11 illustrate the operation of the Object Modeling Tool according to the present invention.
      <br/>
      As described above, the Object Modeling Tool comprises a collection of computer programs 118, which were known previously as objChart (tm)  and now as Dynamic Designer (tm) .
    </p>
    <p num="23">The computer programs 118 of the present invention provides an executable visual specification language for modeling dynamic behavior of objects, as described in D. Gangopadhyay and S. Mitra, ObjChart: Tangible Specification of Reactive Object Behavior, Proceedings of the European Conference on Object Oriented Programming (ECOOP '93), Vol. 707, pages 432-457 of Lecture Notes in Computer Science, 1993, which publication is incorporated by reference herein.</p>
    <p num="24">
      The main visual constructs provided by the computer programs 118 are shown in FIG. 2.
      <br/>
      The reactive behavior of each object is specified by associating an extended finite state machine (FSM) with it (another way to specify behavior is by using Object Interaction Diagrams).
    </p>
    <p num="25">
      An FSM of an object captures the reactions of this object to received messages.
      <br/>
      Receipt of a message is treated as an event, which may cause a state transition, and concomitantly initiating the reactions, wherein reactions are asynchronous messages with limited scope.
    </p>
    <p num="26">
      An object can send messages to itself, its immediate sub-objects, its parent object, or its ports.
      <br/>
      Ports of sibling objects can be connected by behavioral relations, each of which has an FSM controlling the message exchanges over these connected ports.
      <br/>
      Thus, a typical model is a part-of hierarchy of objects with relations (both behavioral and functional) among siblings and the behavior of these objects is controlled by FSMs.
    </p>
    <p num="27">The computer programs 118 include a Builder that allows creation and execution of models, as described in D. Gangopadhyay, S. Mitra and S. S. Dhaliwal, ObjChart-Builder: An Environment for Executing Visual Object Models, Proceedings of the Eleventh International Conference and Exhibition of TOOLS U.S.A. 1993 (Technology of Object-Oriented Languages and Systems), Prentice-Hall, 1993, which publication is incorporated by reference herein.</p>
    <p num="28">
      The Builder embodies a constraint solver and FSM interpreter for executing diagrams in the present invention.
      <br/>
      For further details on the language and model specification used in the present invention, see D. Gangopadhyay and S. Mitra, ObjChart: Tangible Specification of Reactive Object Behavior, Proceedings of the European Conference on Object Oriented Programming (ECOOP '93), Vol. 707, pages 432-457 of Lecture Notes in Computer Science, 1993, which publication is incorporated by reference herein, while further details on model execution are available in D. Gangopadhyay, S. Mitra and S. S. Dhaliwal, ObjChart-Builder: An Environment for Executing Visual Object Models, Proceedings of the Eleventh International Conference and Exhibition of TOOLS U.S.A. 1993 (Technology of Object-Oriented Languages and Systems), Prentice-Hall, 1993, which publication is incorporated by reference herein.
    </p>
    <p num="29">
      The semantics of reactive objects of the present invention are provided in D. Gangopadhyay and S. Mitra, ObjChart: Tangible Specification of Reactive Object Behavior, Proceedings of the European Conference on Object Oriented Programming (ECOOP '93), Vol. 707, pages 432-457 of Lecture Notes in Computer Science, 1993, which publication is incorporated by reference herein, using an equational formalism described in J. Misra, Equational reasoning about nondeterministic processes, Formal Aspects of Computing, Vol. 2, pages 167-195, 1990, which publication is incorporated by reference herein.
      <br/>
      The operational semantics of the present invention have been implemented along the same lines.
    </p>
    <p num="30">Behavioral descriptions are presented (primarily) using the state machine arc-language of the present invention (for details, see D. Gangopadhyay and S. Mitra, ObjChart: Tangible Specification of Reactive Object Behavior, Proceedings of the European Conference on Object Oriented Programming (ECOOP '93), Vol. 707, pages 432-457 of Lecture Notes in Computer Science, 1993, which publication is incorporated by reference herein).</p>
    <p num="31">
      Some simple behavior descriptions can also be provided using the Object Interaction Diagrams as shown in FIG. 2, which use constructs similar to the arc-language.
      <br/>
      The FSM of each object has arcs, that are labeled using the arc-language, that is, each arc has a label of the form:  (Equation image '1' not included in text)
    </p>
    <p num="32">
      where e is the input event (which would either be atomic or could contain a list of parameters which gets matched with actual values during execution), c is a (side-effect free) conditional, and a is one or more actions, which are of the form:
      <br/>
      o1 &lt;e1, . . . , on &lt;en
    </p>
    <p num="33">where n &gt;= 0.</p>
    <p num="34">
      It is assumed that whenever an object receives a matching event (in the proper state) and the associated condition "holds," the events in the action part are transmitted, in parallel, to the corresponding recipient objects.
      <br/>
      Therefore, it is not possible to directly express sequencing among events that appear as a part of a given action-list.
      <br/>
      Sequencing, however, can be simulated, if the exact execution semantics are known.
    </p>
    <p num="35">Another important drawback of the current system is that conditions, which could consist of method calls, expressions involving relational connectives (like&gt;,  &gt;= , etc.), and built-in functions (such as GetAttribValue, GetName, etc.), cannot be subjected to step-wise refinement, i.e., once one of these constructs is used to define the condition, it is not possible to refine them further using any of the visual notations of the present invention.</p>
    <p num="36">
      The primary goal of the present invention is to suggest changes such that conditions can be independently refined, and ordering can be imposed on the individual components of the action-list of an arc.
      <br/>
      This is accomplished by providing the following extensions to the arc-language.
    </p>
    <p num="37">
      The condition part of the arc-language is extended by allowing calls to other events (obeying encapsulation rules).
      <br/>
      Thus, the following arc-label can thus be implemented:
    </p>
    <p num="38">(Equation image '2' not included in text)</p>
    <p num="39">where E is an event associated with an object o, such that o is in the scope of the current object (i.e., o could be one of the sub-objects, or ports, or could be the reserved words "parent" or "self").</p>
    <p num="40">This addition allows step-wise refinement, since E could be the event of an arc, which can be refined using its actions (the actions could invoke events on objects which are in the scope of o, and so forth).</p>
    <p num="41">
      In order to introduce sequentiality into the arc-language, the operator ";" is provided as a connective between individual actions that constitute the action part of an arc.
      <br/>
      Therefore, the following applies:  (Equation image '3' not included in text)
    </p>
    <p num="42">where seq is a Sequence object.</p>
    <p num="43">In the previous arc-language, it would be necessary to introduce an additional state (to wait for the new element to get created) before sending it the SetAttribValue message. (Note that a method sub1 has to be used to get D from C; this is because elements of a sequence are indexed starting at 0 and not 1.)</p>
    <p num="44">As an outcome of the suggested extensions, the following observations can be made:</p>
    <p num="45">
      Methods truly become a short-hand of events.
      <br/>
      With the possibility of invoking events on objects in the condition part, methods are not needed other than as a short-hand.
    </p>
    <p num="46">Explicit control on execution of parts of an action-list is provided, which becomes necessary whenever sequencing has to be expressed (this specification later discusses how explicit sequencing is better than the prior version of enforcing sequentiality between events).</p>
    <p num="47">
      Although event calls can be used uniformly in the condition and action parts of an arc label, there is still a subtle difference between the two: a condition has to be fully evaluated before a commitment is made to the execution of the arc; however, the actions may take place at any future time (of course, respecting the dependency enforced by the newly introduced ";" operator).
      <br/>
      In other words, condition evaluation still takes place synchronously, while actions are emitted out asynchronously, to be handled at a later time.
    </p>
    <p num="48">
      Within the actions themselves, due to the new connective, a new meaning has to be introduced.
      <br/>
      For example, if a( ); b( ) is an action-list, this means that b( ) will be activated after a( ) has been completed.
      <br/>
      Note that the completion of the first action may mean doing other actions.
      <br/>
      For example, if:  (Equation image '4' not included in text)
    </p>
    <p num="49">
      is an arc specification for a( ), then a1( ) and a2( ) (and recursively, their reactions, if any) have to be completed before b( ) is activated in the a( ); b( ) action-list.
      <br/>
      Therefore, a new notion, that of completion (or quiescence) of an action, is introduced into the semantics.
    </p>
    <p num="50">Since the dichotomy between methods and events are being removed, the latter must return values (as in the first example, where E returns a value in X, which later gets used in SetAttribValue).</p>
    <p num="51">
      Due to the introduction of the ";", there can be data exchange between parts of a given action-list.
      <br/>
      For example, the following transition:  (Equation image '5' not included in text)
    </p>
    <p num="52">is considered legal (where X is a variable which gets bound in the invocation of e; this bound value being later used in the invocation of E).</p>
    <p num="53">
      It is possible to have delayed bindings of targets for messages in the action part of an arc.
      <br/>
      For example, the following can be used:  (Equation image '6' not included in text)
    </p>
    <p num="54">
      Note that, when the actions are emitted out (after the event matches, and the condition is evaluated), C and D are still unknowns, and therefore so is the target of the message:
      <br/>
      seq�D�&lt;msg(X)
    </p>
    <p num="55">Similar situations could occur even when the target of a message is a regular (non-Sequence) object, as with the following:  (Equation image '7' not included in text)</p>
    <p num="56">In fact, the following combination of the two could be performed (in which the target is a sequence, however, its name is not available until after actions have been emitted; similarly for the index):  (Equation image '8' not included in text)</p>
    <p num="57">The present invention, and its implementation in the computer programs 118, handles all of these issues.</p>
    <p num="58">
      The rest of this specification is organized as follows.
      <br/>
      Section 2 is a description of how sequentiality can be achieved in the arc-language (with knowledge of the exact execution semantics, though), which also illustrates with examples some of the drawbacks of this method.
      <br/>
      Section 3 describes an extended arc-language that solves the problem of sequential events in a much more elegant way.
      <br/>
      Section 4 discusses operational semantics for the extended arc-language, after showing that a naive model may lead to deadlocks.
      <br/>
      Section 5 describes implementation issues, which also solves another problem of carrying variable bindings from one event to another in a single action-list, and using events in a call-return fashion.
      <br/>
      Finally, Section 6 concludes with examples of the extended capabilities of the arc-language.
    </p>
    <p num="59">2. Previous Approach for Sequencing</p>
    <p num="60">Execution semantics for the prior version of the Object Modeling Tool are described in D. Gangopadhyay and S. Mitra, ObjChart: Tangible Specification of Reactive Object Behavior, Proceedings of the European Conference on Object Oriented Programming (ECOOP '93), Vol. 707, pages 432-457 of Lecture Notes in Computer Science, 1993, which publication is incorporated by reference herein, using Misra's work on non-deterministic data-flow networks, as described in J. Misra, Equational reasoning about nondeterministic processes, Formal Aspects of Computing, Vol. 2, pages 167-195, 1990, which publication is incorporated by reference herein.</p>
    <p num="61">
      Therefore, the following assumptions hold about the execution model:
      <br/>
      messages are asynchronous;
      <br/>
      each node in the data-flow network (i.e., each object) maintains a queue of messages sent to it;
      <br/>
      the message queues are unbounded, but have a first-in first-out (FIFO) discipline; and
      <br/>
      message transmission is instantaneous (i.e., takes zero time).
    </p>
    <p num="62">In other words, whenever an object receives a matching event (and the corresponding condition holds), the events in the action part are dispatched to the corresponding recipients in zero time.</p>
    <p num="63">Therefore, following the above rules, the only possible way to ensure that an object received two (or more) messages in a given sequence is to make sure that the second one was generated after the first one was received (i.e., the concerned object had to send out the first message and go to an intermediate state before sending out the second message).</p>
    <p num="64">
      This dependence leads to a painful explosion of intermediate states in the FSMs, for no reason other than to sequence events to a given object.
      <br/>
      As discussed above, in the prior version of the Object Modeling Tool, it is possible to force actions in a particular order, although at some expense.
    </p>
    <p num="65">
      The only way to enforce sequentiality is by introducing additional states.
      <br/>
      For example, in order to have e' be handled after e (by an object o), the FSM depicted in FIG. 3 must be used (if self is distinct from o).
      <br/>
      Note that the middle state is a "spurious" state that is needed for sequencing.
    </p>
    <p num="66">
      Furthermore, since computation is event driven, the additional event E is introduced to trigger the object in this new state.
      <br/>
      The goal of the present invention is to be able to directly substitute o&lt;&lt;e' in place of self&lt;&lt;E in the very first state.
    </p>
    <p num="67">
      In FIG. 3, if o and self are allowed to be identical, then the situation is even more complicated, and the FSM depicted in FIG. 4 would be required.
      <br/>
      In this case, e and E are both incident on the same object, and due to the inherent parallelism between actions separated by "," further states, i.e., the two middle states, have to be introduced to keep track of which of these events actually arrived.
      <br/>
      More importantly, the only way to introduce sequentiality would intimately depend on the semantic model (or operational model) chosen, and this is quite unsatisfactory.
    </p>
    <p num="68">The situation is particularly painful for Sequence objects (a special construct), for which it is customary to create a new element before invoking some operation (entering a value for an attribute, say) on the entry just created.</p>
    <p num="69">
      For instance, consider the CheckView example outlined in Section 2 of D. Gangopadhyay and S. Mitra, ObjChart: Tangible Specification of Reactive Object Behavior, Proceedings of the European Conference on Object Oriented Programming (ECOOP '93), Vol. 707, pages 432-457 of Lecture Notes in Computer Science, 1993, which publication is incorporated by reference herein.
      <br/>
      With the prior version of the Object Modeling Tool, an additional state would have to be introduced, each time such an operation has to be performed.
    </p>
    <p num="70">
      Furthermore, it is common to have safety properties associated with objects, which are usually depicted by arcs with the same event for all states of the object (albeit doing slightly different things depending on the state in which the event was received).
      <br/>
      For instance, consider the example of specifying an Elevator control system, as depicted in Section 4.1 of D. Gangopadhyay and S. Mitra, ObjChart: Tangible Specification of Reactive Object Behavior, Proceedings of the European Conference on Object Oriented Programming (ECOOP '93), Vol. 707, pages 432-457 of Lecture Notes in Computer Science, 1993, which publication is incorporated by reference herein.
    </p>
    <p num="71">Therefore, if sequentiality has to be expressed by adding states for any such object, all the safety-related arcs have to be replicated for each of these spurious states, thus compounding the problem many fold.</p>
    <p num="72">3. Extended Arc-Language</p>
    <p num="73">
      The present invention introduces an additional connective into the arc-language.
      <br/>
      This connective, which is denoted as ";", could be used in the action part of the arc-language.
      <br/>
      With this extended arc-language, sequencing for both examples considered above in Section 2 can be performed, respectively, as:  (Equation image '9' not included in text)
    </p>
    <p num="74">In fact, with this extended arc-language, the arc-labels depicted below can be used:  (Equation image '10' not included in text)</p>
    <p num="75">
      In contrast, if the brute-force mechanisms of introducing sequentiality were used, as described in Section 2 above, these would require numerous additional states to be introduced.
      <br/>
      Given this extended signature of the actions, it is now possible to specify completely asynchronous or completely sequential computations (together with a mixture of the two, as shown by the examples above).
    </p>
    <p num="76">The new arc-language syntax can be specified using a Backus-Naur Form (BNF), wherein the unspecified non-terminals continue to have the same definitions as before:</p>
    <p num="77">
      --
      <br/>
      -- ArcLabel       : := Event "�" Condition "�" Actions
      <br/>
      -- Actions        : := NullActions .linevert split.NonNullActions
      <br/>
      -- NullActions    : :=
      <br/>
      -- NonNullActions : := Action .linevert split.
      <br/>
      --                NonNullActions "," NonNullActions .linevert split.
      <br/>
      --                NonNullActions ";" NonNullActions .linevert split.
      <br/>
      --                "(" NonNullActions ")"
    </p>
    <p num="78">
      4.
      <br/>
      Operational Semantics
    </p>
    <p num="79">
      In this section, the operational semantics of the arc-language are extended, so as to include the additional connective introduced in Section 3 above.
      <br/>
      However, in doing so, an anomaly would be introduced, because of the interplay of the existing dependencies due to directed communication, two messages sent from the same source to a given destination as parts of two different action-lists should be handled in the correct order, with the newly introduced one, i.e., that due to the ";" operator.
      <br/>
      In fact, because of these two different dependencies, a deadlock situation is possible, which can be shown using the arcs of FIG. 5.
    </p>
    <p num="80">
      In the first part of FIG. 6, the consequences of the first message, i.e., self&lt;&lt;E, are shown.
      <br/>
      The side arrows in FIG. 6 depict the dependence due to messages going to the same object, in this case, self.
      <br/>
      Notice that, in this case, the arrow could have been the other way around, i.e., from self&lt;&lt;E" to self&lt;&lt;E' if a different order for the "," operation is considered.
      <br/>
      In the second part of FIG. 6, the effect of self&lt;&lt;E" is shown; in the third part of FIG. 6, the effect of self&lt;&lt;E' is shown.
      <br/>
      At this stage, there exists a scenario in which none of the four messages can be handled: o'&lt;&lt;E1 depends on o'&lt;&lt;e2 (due to order dependence in the queue for the object o'); o'&lt;&lt;E1 depends on o&lt;&lt;e2 due to ";" in Arc3 ; o&lt;&lt;e1 depends on o&lt;&lt;e1 since the latter was received by o before the former, and finally, o&lt;&lt;e1 depends on o&lt;&lt;E2 due to the ";" in Arc1, and the expansion of self&lt;&lt;E' due to Arc2.
      <br/>
      Therefore, there is a deadlock. (Note that it may be possible to have the deadlock even with 3 events, instead of the 4 events used here.)
    </p>
    <p num="81">
      It is possible to avoid deadlock once it is noticed that deadlock is caused due to the interplay of the two kinds of dependencies: one from message ordering on a given queue, and the other due to the ordering introduced by ";".
      <br/>
      Breaking either dependency would result in a deadlock free solution.
      <br/>
      Since, in some sense, both dependencies are required, the following way to break the deadlock has been developed:
      <br/>
      Objects maintain their queues as before.
    </p>
    <p num="82">
      Whenever an action-list of the form e;e' is encountered, only e is dispatched and e' is stored.
      <br/>
      When the dispatch of e is completed, then the next outstanding event on the sequence of interest is dispatched (note that the next event could be one other than e', since e may have an action-list of the form E;E', which would result in the next dispatch being E).
    </p>
    <p num="83">5. Implementation</p>
    <p num="84">
      In view of this extended arc-language, certain data structures need to be maintained, which are explained in this section.
      <br/>
      The section also describes the pseudo-code for the implementation of the present invention, and provides more details about some of the features that are discussed in Section 1 above.
    </p>
    <p num="85">5.1. Object Queues</p>
    <p num="86">Each object maintains a first-in first-out (FIFO) queue of messages sent to it, i.e., messages to a given object are processed in the order they are received.</p>
    <p num="87">5.2. Sequential/Parallel Structure (SPS)</p>
    <p num="88">
      In order to ensure that ";" and "," are treated in the correct order, actions of arcs are parsed into a binary tree structures, based on the BNF grammar provide in Section 3 above (previously, with "," being the only allowed connective between individual actions, it was sufficient to collect all individual actions into a list).
      <br/>
      For a parser component of the computer programs 118 to work correctly, a precedence has to be specified between the connectives ("," has higher precedence than ";") and their associativity (both associate to the left).
      <br/>
      However, explicit parentheses is the best way to clearly nest the connectives.
    </p>
    <p num="89">
      Also, an interpreter component of the computer programs 118 keeps a binary tree of all the outstanding events (which have been generated, but not yet consumed) in the system.
      <br/>
      This tree is called the Sequential Parallel Structure (SPS).
      <br/>
      The interpreter operates on this tree structure, for example, to dispatch b after a has completed, with the dependency being a( ); b( ).
      <br/>
      Section 5.4 below provides more details on the interpreter component of the computer programs 118.
    </p>
    <p num="90">5.3. Symbol Table</p>
    <p num="91">
      A symbol table is essentially an association list for variable names and corresponding values.
      <br/>
      Each parameter passed to the event is in the symbol table, and so are all the variables used in the condition and action parts.
      <br/>
      With the prior version of the arc-language (without ";"), it was sufficient to associate symbol tables directly with the arc data structures.
      <br/>
      This is because, with a matching event, all the variables are bound by the time the condition is evaluated.
      <br/>
      Therefore, it suffices to simply replace the variables with their bindings in the action-list, before those events are sent out to their corresponding recipients.
    </p>
    <p num="92">With ";" and the ability for events to return values, the situation gets more complicated, as can be seen from the following example:  (Equation image '11' not included in text)</p>
    <p num="93">which effectively computes the factorial of any positive integer X and returns the value in Y.</p>
    <p num="94">
      Assume that another arc has an action-list of the form:
      <br/>
      self&lt;fact (3, X); self&lt;SetAttribValue(`fact3`,X)
    </p>
    <p num="95">In effect, fact(3, X) would bind X to the factorial of 3 (i.e., 6), which would be saved in the attribute `fact3`. During evaluation of the first event, at some point, the tree of messages as shown in FIG. 7 would result.</p>
    <p num="96">Thus, several copies of the symbol table are needed for the arc; in fact, the symbol tables need to be akin to activation records of usual programming languages.</p>
    <p num="97">
      In the implementation of the present invention, the symbol table is therefore taken out of the arc structure.
      <br/>
      Every time the event of an arc matched, a new symbol table instance is created, with all the variables found in that arc.
    </p>
    <p num="98">
      During condition evaluation, which takes place synchronously, the entirety of this table get updated whenever a binding is made for a variable.
      <br/>
      If condition evaluation fails, then this symbol table instance is useless, and is destroyed.
      <br/>
      On the contrary, if there is success, each individual action in the action-list gets associated with this symbol table.
    </p>
    <p num="99">
      Due to delayed binding introduced by ";" some of the entries in the symbol table may still be unbound as in the factorial example above, where Y1, Y2, etc., gets bound at the end of the evaluation step, and Z1, Z2, etc., gets bound after the recursive call to fact(W, Z) is terminated.
      <br/>
      Such variables may get bound later, which updates the symbol table.
    </p>
    <p num="100">
      Furthermore, since the symbol table is shared with the other actions from the same action-list, the updated value can be used by another action.
      <br/>
      For the above example, once Z2 gets assigned in the recursive call to fact(1, Z2 ), its value will be available in the call to mult(Z2, 2, Y2 ).
    </p>
    <p num="101">
      Finally, symbol tables are associated with reference counts.
      <br/>
      For example, in the current status of the snapshot depicted in FIG. 7, the reference count for the second and third symbol tables (each of which has 3 entries) is 2, since each is shared between two action nodes.
      <br/>
      The count is initially set to the number of elementary actions in the action-list, after condition evaluation.
    </p>
    <p num="102">
      Whenever an event is completed (roughly, either when there are no matching arcs, or after the match has been determined and the arc's new symbol table has been created) this count is decremented.
      <br/>
      Whenever the count goes to zero, the symbol table itself may be discarded.
    </p>
    <p num="103">
      FIG. 7 is a "snapshot" of the Factorial example as represented in the memory of the computer 100.
      <br/>
      The snapshot reflects the point where the event fact( 1,Z2 ) has matched, before the corresponding symbol table gets discarded.
      <br/>
      Note that several invocations of the arc are active at the same time, and that they need different symbol tables, since the values X=Y1, Z1=Y2, etc., are still unbound, and these variables have to get bound to distinct values for a correct expansion of Factorial.
    </p>
    <p num="104">5.4. Implementation</p>
    <p num="105">FIG. 8 is a flowchart that illustrates some of the steps performed by the computer programs 118 according to the present invention.</p>
    <p num="106">
      Block 800 is a decision block that represents the computer 100 looping through all objects.
      <br/>
      The present invention uses time slicing, wherein an object with a non-empty queue of messages gets a turn in every time-slice.
    </p>
    <p num="107">
      Block 802 is a decision block that represents the computer 100 looping through all messages for the object.
      <br/>
      During its time slice, an object extracts messages from its queue.
      <br/>
      Events in the queues of objects also are a part of the SPS.
    </p>
    <p num="108">
      Block 804 represents the computer 100 comparing the message to the finite-state machines for the object.
      <br/>
      The FSMs are consulted to determine whether the arcs of the FSM match the event message.
    </p>
    <p num="109">
      If a matching arc is found (Block 806 ), and the corresponding condition holds (Block 808 ), then Block 810 represents the computer 100 processing the corresponding action.
      <br/>
      This step also introduces all the variables in the arc triple (event, condition and action) into the symbol table (with possible bindings, whenever they exist).
    </p>
    <p num="110">
      As part of its processing, Block 810 also performs the following steps:
      <br/>
      (a) If the arc under consideration has no actions (for example, setAttribValue), then the event is removed from the queue of the object and the SPS.
      <br/>
      As a result, it may become necessary to delete some of the nodes in the SPS, using the following rules:
    </p>
    <p num="111">
      - 1. �Rule for ","� If either branch of e',e" has been completed, then replace "e',e" with the existing branch.
      <br/>
      - 2. �Rule for ";"� When the left branch of e'; e" is completed (notice that the left branch must complete before the right one is started), then this subtree is replaced by e".
      <br/>
      At the same time, the right branch (i.e., e") must be introduced into the object queues, using the procedure described in Step (b) below).
      <br/>
      (b) If the arc has one or more actions, then the current event is removed from the object's queue.
      <br/>
      In the SPS, the event is replaced by the tree of actions.
      <br/>
      Finally, some of these new actions have to be introduced within the object queues, using the following rules:
      <br/>
      - 1. �Base� If there is a leaf node, then append the corresponding action into the event queue of the concerned object(s).
      <br/>
      - 2. �Recursive Case for ","� If there is a node, then recursively apply the procedure to both sub-trees.
      <br/>
      3. �Recursive Case for ";"� In this case, recursively call the same procedure on the left branch (with the understanding that when processing of the left branch is done, the right will be handled, as mentioned in Step (a)(2) above).
    </p>
    <p num="112">
      Block 812 represents the computer 100 processing the symbol tables.
      <br/>
      Every node in the SPS tree stores a pointer to the (corresponding) symbol table.
      <br/>
      These pointers are initialized when the actions are introduced into the SPS in Step (b) above.
      <br/>
      Actions are allowed to make additional bindings to variables in the symbol table passed to it.
      <br/>
      Thus, since the same symbol table gets passed to different actions in an action-list, a variable bound in an action can be used by a later action in a ";" operation.
      <br/>
      There will also be a need to delete symbol tables, which is accomplished using reference counts (which is set when the actions of a given arc are introduced into the SPS; thereafter, whenever any part of it gets done, the count is decremented, until all references are gone, when the symbol table itself is removed).
    </p>
    <p num="113">5.5. Support for Event Calls from Conditions</p>
    <p num="114">
      In order to have ";" and data communication between individual actions separated by this connective, the symbol table is extracted from the arc-structure and made like activation records.
      <br/>
      With that, events can return values, and can therefore be used in situations where methods were needed before.
      <br/>
      Thereafter, making conditions invoke them is straightforward, once the following are resolved.
    </p>
    <p num="115">
      In general, conditions have to be evaluated synchronously, while actions are handled asynchronously.
      <br/>
      Thus, when an arc event is invoked from a condition, its consequent actions cannot be inserted into the global SPS, since, if they are, then the completion of this arc-evaluation (and thus the invoking condition) would depend on when the corresponding objects get their turn to execute, as so forth.
      <br/>
      Therefore, a local copy of the event tree (similar in structure to the global SPS) is kept whenever a condition invoked an event.
      <br/>
      Also, any resulting reactions for any of the events in this local tree are merged into the local tree.
      <br/>
      Finally, all events of this tree are handled without any further time slicing.
    </p>
    <p num="116">
      A second issue relates to the details of the implementation and involves a function known as "TraverseListForEventMatch".
      <br/>
      In this function, the arc-list for a state have to be traversed.
      <br/>
      With events being called from conditions, this list is duplicated before the traversal, since, without duplication, condition evaluation would traverse the same global list, and would cause erroneous results when matching of events to arcs also march on the same list.
      <br/>
      Thus, this involves an issue of having a local list pointer, rather than of duplication itself.
      <br/>
      Another way to circumvent the problem is to implement lists where cursors could be given to individual clients, without having to duplicate the list, as such.
    </p>
    <p num="117">5.6. Lazy binding for Targets of Messages</p>
    <p num="118">
      With ";", it is possible that the target of a message is unknown (an unbound variable) when condition evaluation takes place (see examples in Section 1 above).
      <br/>
      However, when the time comes to dispatch the message, the target must become known (bound).
      <br/>
      A change is needed in a "BuildAction" function to handle this, together with checking explicitly for unbound targets at the time of dispatching an event to the corresponding object queues, which could be much after BuildAction, since ";" may cause some events which have been handled by BuildAction to be frozen in the SPS, until everything that such an event depends on has been evaluated.
    </p>
    <p num="119">6. Examples</p>
    <p num="120">In this section, the new arc-language is illustrated using a few examples.</p>
    <p num="121">6.1. Factorial</p>
    <p num="122">
      The first example is a Factorial function, along the lines of the example given in Section 5.3 above.
      <br/>
      Only one object is needed for this example, the state machine for which is depicted in FIG. 9.
      <br/>
      Notice that the sub (subtract), mult (multiply) and assign (assignment) functions, as shown in FIG. 9, are all implemented as methods in the present invention.
    </p>
    <p num="123">
      This example would be impossible to encode in the prior version of the arc-language, since without the currently introduced extensions, it would not be possible for events to return values back to the caller.
      <br/>
      Therefore, the new constructs have added to the expressive power of the arc-language of the present invention, since, with these additions, any general recursive function can be encoded.
    </p>
    <p num="124">
      In the example, methods have been used on three occasions; in fact, all of these could be avoided in favor of using only built-in events and additional attributes.
      <br/>
      For example, instead of sub (subtract), the built-in function SetAttribvalueSubtractedBy could be used.
      <br/>
      Similarly, instead of using assign(X, Y), the built-in function SetAttribValue(`assign`,X) followed by GetAttribValue(`assign`,Y) could be used.
      <br/>
      However, the current functions are quite cumbersome.
      <br/>
      Therefore, there is a need to enhance the arc-language further by allowing simple functions in them.
    </p>
    <p num="125">6.2. Collection Scheme</p>
    <p num="126">
      The next example that is considered is of a collection scheme, using the objects shown in FIG. 10. The teacher object has a sequence of student objects attached to its items port, and a grader object attached to its tally port.
      <br/>
      The teacher object calculates and stores a tally of the value attributes of the student objects in its result attribute.
      <br/>
      In order to get the tally, the teacher object has a count (as a sub-object) which knows the number of student objects to iterate on via its items port.
      <br/>
      The teacher object requests the value for each of its student objects.
      <br/>
      When a student object reports its value, the teacher object gives the value to the grader object via its tally port, and concurrently decrements the count sub-object.
      <br/>
      Finally, when the count sub-object reaches zero, the teacher object retrieves the total value from the grader object, and records that in the result.
      <br/>
      The FSM for the teacher object is shown in FIG. 11.
    </p>
    <p num="127">
      If the model is executed repeatedly, the results would be incorrect, at least for some executions.
      <br/>
      The main problem is due to the asynchronous nature of messages.
      <br/>
      For example, for the doIt message, which starts the execution, its actions are all in parallel.
      <br/>
      Thus, depending on which of the actions get consumed first, the count sub-object and grader object (either one or both) may be with the wrong state when the reportValue messages arrives.
    </p>
    <p num="128">
      Similarly, considering the reportvalue message itself, it can be seen that its actions decrement the count sub-object and reports to the grader object in parallel.
      <br/>
      Thus, if the message to the count sub-object gets handled before the nextValue message, then the grader object is not in sync with the count sub-object, leading to the declaration of reachedZero (which is when the grader object reaches zero) message to be received before the grader object adds all the values, which may cause an incorrect result.
    </p>
    <p num="129">One way to correct these problems would be to use the following arcs to replace the corresponding ones in FIG. 11:  (Equation image '12' not included in text)</p>
    <p num="130">
      Thus, using the newly introduced ";" connective, it is possible to synchronize activities of different objects.
      <br/>
      Although, as noted earlier, it would have been possible to have a similar effect by adding wait states and dummy messages, this solution is much more elegant and declarative, and is independent of the operational semantics of the language.
    </p>
    <heading>CONCLUSION</heading>
    <p num="131">
      The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description.
      <br/>
      It is not intended to be exhaustive or to limit the invention to the precise form disclosed.
      <br/>
      Many modifications and variations are possible in light of the above teaching.
      <br/>
      It is intended that the scope of the invention be limited not with this detailed description, but rather by the claims appended hereto.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A computer-implemented method of object modeling, comprising:</claim-text>
      <claim-text>(a) creating an object model in a computer-implemented object-oriented modeling system using an arc language to model behaviors of one or more objects and associate one or more finite state machines with the one or more objects within the object model; (b) expressing a sequence of actions without introducing an intermediate state using the arc language for the behaviors of the objects within the object model;</claim-text>
      <claim-text>and (c) executing the expressed sequence of actions in the computer-implemented object-oriented modeling system.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The computer-implemented method of claim 1 above, wherein the expressing comprises specifying a connective operator between actions within the arc language to express the sequence of actions.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The computer-implemented method of claim 2 above, wherein the connective operator comprises an ";" operator.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The computer-implemented method of claim 2 above, wherein the connective operator provides for data exchange between actions in the sequence of actions.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The computer-implemented method of claim 1 above, wherein a subsequent action in the sequence of actions is dispatched only when a previous action is completed.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The computer-implemented method of claim 1 above, wherein the behaviors are reactive behaviors.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The computer-implemented method of claim 1 above, wherein each arc in the arc language comprises an event-condition-actions triple.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The computer-implemented method of claim 7 above, wherein events return values.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The computer-implemented method of claim 7 above, wherein conditions invoke events.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The computer-implemented method of claim 1 above, wherein the creating further comprises specifying the behaviors of the objects within the object model using object integration diagrams with one or more of the objects.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A computer-implemented object modeling apparatus, comprising: (a) a computer; (b) means, performed by the computer, for creating an object model in a computer-implemented object oriented modeling system using an arc language to model behaviors of one or more objects and associate one or more finite state machines with the one or more objects within the object model; (c) means, performed by the computer, for expressing a sequence of actions without introducing an intermediate state using the arc language for the behaviors of the objects within the object model;</claim-text>
      <claim-text>and (d) means, performed by the computer, for executing the expressed sequence of actions in the computer-implemented object-oriented modeling system.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. An article of manufacture comprising a computer program carrier tangibly embodying one or more computer programs that, when executed, cause the computer to perform a method of object modeling, the method comprising: (a) creating an object model in a computer-implemented object oriented modeling system using an arc language to model behaviors of one or more objects and associate one or more finite state machines with the one or more objects within the object model; (b) expressing a sequence of actions without introducing an intermediate state using the arc language for the behaviors of the objects within the object mode;</claim-text>
      <claim-text>and (c) executing the expressed sequence of actions in the computer-implemented object-oriented modeling system.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The apparatus of claim 11 wherein the means for expressing comprise means for specifying a connective operator between actions within the arc language to express the sequence of actions.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The apparatus of claim 13 wherein the connective operator comprises an ";" operator.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The apparatus of claim 13 wherein the connective operator provides for data exchange between actions in the sequence of actions.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The apparatus of claim 11 wherein a subsequent action in the sequence of actions is dispatched only when a previous action is completed.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The apparatus of claim 11 wherein the behaviors are reactive behaviors.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The apparatus of claim 11 wherein each arc in the arc language comprises an event-conditions-actions triple.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The apparatus of claim 18 wherein events return values.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The apparatus of claim 18 wherein conditions invoke events.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The apparatus of claim 11 wherein the means for creating further comprise means for specifying the behaviors of the objects within the object model using object integration diagrams with one or more of the objects.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The article of manufacture of claim 12 wherein the expressing comprises specifying a connective operator between actions within the arc language to express the sequence of actions.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The article of manufacture of claim 22 wherein the connective operator comprises an ";" operator.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The article of manufacture of claim 22 wherein the connective operator provides for data exchange between actions in the sequence of actions.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The article of manufacture of claim 12 wherein a subsequent action in the sequence of actions is dispatched only when a previous action is completed.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The article of manufacture of claim 12 wherein the behaviors are reactive behaviors.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The article of manufacture of claim 12 wherein each arc in the arc language comprises an event-condition-actions triple.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The article of manufacture of claim 27 wherein events return values.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The article of manufacture of claim 27 wherein conditions invoke events.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. The article of manufacture of claim 12 wherein the creating further comprises specifying the behaviors of the objects within the object model using object integration diagrams with one or more of the objects.</claim-text>
    </claim>
  </claims>
</questel-patent-document>