<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185569B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185569</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185569</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22312936" extended-family-id="42113628">
      <document-id>
        <country>US</country>
        <doc-number>09106727</doc-number>
        <kind>A</kind>
        <date>19980629</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09106727</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43171919</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>10672798</doc-number>
        <kind>A</kind>
        <date>19980629</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09106727</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  17/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <further-classification sequence="1">
        <text>707999100</text>
        <class>707</class>
        <subclass>999100</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>707999101</text>
        <class>707</class>
        <subclass>999101</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>707E17011</text>
        <class>707</class>
        <subclass>E17011</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>711217000</text>
        <class>711</class>
        <subclass>217000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>711218000</text>
        <class>711</class>
        <subclass>218000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/30958</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30958</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99942</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99942</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>19</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>7</number-of-drawing-sheets>
      <number-of-figures>7</number-of-figures>
      <image-key data-format="questel">US6185569</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Linked data structure integrity verification system which verifies actual node information with expected node information stored in a table</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>SHIGA KOICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5559979</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5559979</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>MILES ROBERT S, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6035326</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6035326</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>WAGGENER JR WILLIAM N, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6049802</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6049802</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>DOUCEUR JOHN R</text>
          <document-id>
            <country>US</country>
            <doc-number>6067547</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6067547</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Microsoft Corporation</orgname>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>MICROSOFT</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>East, Jeffrey A.</name>
            <address>
              <address-1>Issaquah, WA, US</address-1>
              <city>Issaquah</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Lingelbach, Albert L.</name>
            <address>
              <address-1>New York, NY, US</address-1>
              <city>New York</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Lindell, Steven J.</name>
            <address>
              <address-1>Bellevue, WA, US</address-1>
              <city>Bellevue</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Graefe, Goetz</name>
            <address>
              <address-1>Bellevue, WA, US</address-1>
              <city>Bellevue</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="5">
          <addressbook lang="en">
            <name>Zastera, Craig G.</name>
            <address>
              <address-1>Woodinville, WA, US</address-1>
              <city>Woodinville</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="6">
          <addressbook lang="en">
            <name>Agarwal, Sameet H.</name>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Woodcock Washburn Kurtz Mackiewicz &amp; Norris LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Black, Thomas G.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A linked data structure verification system to verify the integrity of at least one linked data structure simultaneously by way of a verification setup phase and an integrity verification phase.
      <br/>
      Individual nodes are retrieved from a memory device and examined seriatim in optimal memory device location order.
      <br/>
      Nodes are retrieved and examined in optimal memory device location order for maximum memory device retrieval performance.
      <br/>
      Expected and/or actual node information about nodes in a given linked data structure are temporarily stored as records in an integrity verification table for only as much time as is necessary to verify any part of the node information prior to excising one or more unnecessary records from the integrity verification table.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">This invention relates to the field of linked data structures, and in particular to a system for verifying the integrity of administrative data for a variety of linked data structure types including, but not limited to, linked lists, indexed trees, and secondary index trees.</p>
    <p num="2">Problem</p>
    <p num="3">
      Linked data structures are logical arrangements of data that facilitate efficient and organized data storage, data manipulation, and data retrieval.
      <br/>
      The basic component of a linked data structure is known as an element or node.
      <br/>
      Individual nodes in a linked data structure are linked together by special fields called pointers that identify or "point to" neighboring nodes in a linked structure of nodes.
      <br/>
      A pointer is also sometimes referred to as reference.
    </p>
    <p num="4">
      One reason it is important that the pointers in each node of a linked data structure are accurate is because logically neighboring nodes of a linked data structure are not necessarily stored in adjacent physical locations on a memory device.
      <br/>
      Absent a guarantee of physical proximity from one node to the next on a memory device, it is difficult to know which node is actually the next logical node in a linked data structure if an invalid pointer exists.
      <br/>
      Thus, a pointer that does not correctly point to a next logical node within the linked data structure renders the entire linked data structure unreliable and unusable.
    </p>
    <p num="5">For these and other reasons, the general problem addressed by the invention disclosed herein is that of how to verify quickly and efficiently the integrity of a linked data structure.</p>
    <p num="6">
      The following text accompanying FIGS. 1-2 are representative examples of typical linked data structures and their general characteristics.
      <br/>
      The examples are presented for background purposes generally and to clarify terms used in this document specifically.
      <br/>
      Note that other types of linked data structures exist that are considered within the scope of this document yet have characteristics beyond those illustrated in FIGS. 1-2. Examples of other types of linked data structures include, but are not limited to, tagged structures, secondary index structures, and binary tree structures.
      <br/>
      Note also that the text accompanying FIGS. 1-2 is intended only to convey basic ideas and terms, and is not intended as a complete discussion of the flexibility and construction of any one or all linked data structures known in the art.
      <br/>
      The representative linked data structure types illustrated in the text accompanying FIGS. 1-12 include, but are not limited to, linked lists and index trees.
      <br/>
      Although linked data structure types are not limited to linked lists and index trees, these two linked data structure types are commonly understood structures existing in the art and are presented as a basis for discussion purposes and not as any limitation on the scope or field of use of the disclosed invention.
    </p>
    <p num="7">
      FIG. 1 illustrates a typical doubly linked list 100 in block diagram form.
      <br/>
      Doubly linked list 100 and linked lists generally are also known as a heap type structure.
      <br/>
      Doubly linked list 100 includes nodes 110-113 each stored in a discrete location of a memory device.
      <br/>
      Generally speaking, each of the respective nodes 110-113 include at least one pointer including a Forward Pointer (FP) 120-123 from any first node to a neighboring second node, and a corresponding Backward Pointer (BP) 130-133 from the second node back to the first node.
      <br/>
      The purpose of the pointers is to establish a logical chain from one node to the next and back again, so that the list of nodes 110-113 can be traversed in either a forward direction or backward direction.
    </p>
    <p num="8">
      For example, if the backward pointer 130 of node 110 points to node 113 and the forward pointer 123 of node 113 points to node 110, then the doubly linked list 100 is a continuous loop of chained nodes.
      <br/>
      However, if the backward pointer 130 of node 110 and the forward pointer 123 of node 113 are both NULL pointers, then the doubly linked list 100 has a special characteristic where there exists only one first node and one last node among a bounded linear chain of nodes 110-113.
      <br/>
      As illustrated in FIG. 1, node 110 is the first node of the linked list and node 113 is the last node of the linked list.
    </p>
    <p num="9">
      FIG. 2 illustrates a typical index tree in block diagram form.
      <br/>
      Index trees are also known as clustered index structures, trees, or in the present case a B-tree 200.
      <br/>
      Note that a B-tree and a binary tree are distinguishable in the art, and that the present discussion relates to B-trees.
    </p>
    <p num="10">
      B-tree 200 includes nodes 210-216 each stored in a discrete location of a memory device.
      <br/>
      Each of the nodes 210-213 are referred to in degrees of consanguinity, at least to the extent of parent, child, and siblings that each descend from a common ancestor called a root or root node.
      <br/>
      In the present example, the root node is node 210.
      <br/>
      Nodes 211-213 are siblings of each other as well as children of node 210.
      <br/>
      Further, nodes 214-216 are siblings of each other as well as children of parent node 212, and so on.
    </p>
    <p num="11">
      Each generation of the B-tree 200 is referred to as a level.
      <br/>
      Levels are numbered from the youngest generation, level 0, through the oldest generation, level n. There are three levels in B-tree 200, namely level 2 containing root node 210, level 1 containing nodes 211-213, and the level 0 containing nodes 214-216.
      <br/>
      Note also that nodes that have no children, such as level 0 nodes 214-216, are also referred to as leaf nodes because a leaf is as far down the branches of a tree as can be traversed.
    </p>
    <p num="12">
      A variety of pointers exist among the respective nodes 210-216 depending on the location of each node in the linked structure.
      <br/>
      The variety of pointers in the present example include left child pointers 220-223, right child pointers 230-233, inner child pointers 240-243, and doubly linked list style pointers such as forward pointers 250-255 and corresponding backward pointers 260-265 among the various levels within the linked structure.
      <br/>
      Note that although the present B-tree 200 example illustrates only three children for any one node, a B-tree can be constructed to have any number of children.
      <br/>
      Note also that each leaf node 214-216 can also contain any number of data fields other than the illustrated data fields 290-298, and one or more data fields 290-298 may exist that do not contain any data at all.
    </p>
    <p num="13">
      B-tree 200 is referred to as an index tree structure because each of the nodes 210-216 includes administrative data in an index field.
      <br/>
      An index field is also known as a key or key field.
      <br/>
      The purpose of an index field is to facilitate the search for a specific item of substantive data in a leaf node.
      <br/>
      In the present B-tree 200 example, the administrative data in nodes 210-216 are located in index fields 270-277 and 280-288, and the substantive data in leaf nodes 214-216 are located in data fields 290-298.
    </p>
    <p num="14">
      For example, consider a B-tree having a discrete piece of substantive data located in respective leaf nodes, and each leaf node is uniquely identified by a letter of the alphabet known as a key or index key.
      <br/>
      If the substantive data indexed by the letter L is desired, a traverse of B-tree 200 would begin from root node 210.
      <br/>
      Index field 270 would be examined and found less than letter L, then index field 271 would be examined and found less than letter L, then index field 272 would be examined and found greater than letter L. Thus the child pointer 240 of node 210 to node 212, indicated by index field 271 as the last index field less than the index letter L, would be followed to node 212.
      <br/>
      Similarly left child pointer 222 of node 212 would be followed to node 214, and again index field L is located along with its accompanying substantive data in data field 292.
      <br/>
      Because the entire traverse of the B-tree 200 example required visits to only two nodes, an indexed search is a significantly more efficient way to locate data in a linked data structure than a linear search for the same data in a linked list type data structure.
    </p>
    <p num="15">
      One notable linked data structure storage and indexing scheme that exists in addition to those discussed above, is the secondary index linked data structure.
      <br/>
      A secondary index linked data structure can use a B-tree 200 as a secondary index search tree to identify a specific leaf node.
      <br/>
      The specific leaf node of the secondary index search tree does not itself contain the desired data, and instead the leaf node points to some other element of an independent data structure that contains the actual substantive data.
      <br/>
      Therefore more than one secondary index search tree can point to the same data.
      <br/>
      In the case of more than one secondary index search tree pointing to the same data, each secondary index keys on a different field of the substantive record.
    </p>
    <p num="16">
      To recapitulate, the general problem with linked data structures, including but not limited to the linked data structures discussed above, is that if any pointer in a linked data structure becomes corrupted or otherwise invalid so that a pointer does not correctly point to what is intended as the next node or child node, then the integrity of the entire data structure is compromised.
      <br/>
      A compromised data structure is neither reliable nor usable.
      <br/>
      Although it is possible to identify an invalid pointer in a small linked data structure having only a few nodes, the task becomes very complex and costly in terms of time and/or computing resources for large linked data structures having hundreds of thousands of nodes, and more difficult still if more than one invalid pointer exists among the nodes.
      <br/>
      One common example of a pointer inconsistency is where a forward pointer from a first node points to a second node while the backward pointer from the second node points to some other third node.
      <br/>
      It is immediately apparent that the corresponding forward and backward pointers disagree and that significant additional investigation is required to determine which one of the pointers, or whether both of the pointers, are incorrect.
    </p>
    <p num="17">
      Existing techniques for verifying the integrity of a linked data structure include a pointer by pointer traversal of the linked data structure in a logical pointer order that follows from one node pointing to the next.
      <br/>
      However, logical pointer order verification traversals are undesirable because the pointers being used to traverse the linked data structure are the very pointers whose integrity is being verified.
      <br/>
      Thus, existing verification programs using this technique can be easily misled by an invalid pointer prior to the time the invalid pointer is identified.
    </p>
    <p num="18">
      Another reason existing logical pointer order verification traversals of a linked data structure are undesirable is because it is difficult to determine what type of pointer data should be cataloged and how much pointer data should be cataloged during a verification traversal.
      <br/>
      For example, a pointer inconsistency in a node of one branch of an index tree may not be apparent until another node of an entirely different branch of the index tree is investigated.
      <br/>
      This suggests that there is a need to save pointer data from each node in the index tree until all nodes in the index tree have been verified to be certain that all pointer errors have been properly identified.
      <br/>
      However, duplicating the entire set of pointer data from each node in a memory location separate from the index tree itself is highly resource intensive and cumbersome, particularly for very large data structures.
    </p>
    <p num="19">Another reason existing logical pointer order verification traversals are undesirable is that a full depth traversal of a linked data structure is extremely time and/or computing resource intensive due to the iterative branch by branch traversal required for index tree structures.</p>
    <p num="20">
      For these reasons, there exists an ongoing need for a fast and highly efficient linked data structure verification system that performs in a manner that maximizes verification accuracy while minimizing elapsed verification time, and minimizing the use of computing resources generally.
      <br/>
      A system of this type has heretofore not been known prior to the invention as disclosed below.
    </p>
    <p num="21">Solution</p>
    <p num="22">
      The above identified problems are solved and an advancement is achieved in the field of linked data structures due to the linked data structure verification system of the present invention.
      <br/>
      The linked data structure verification system of the present invention verifies the integrity of a linked data structure in two main phases that include a verification setup phase and an integrity verification phase.
      <br/>
      The two main phases can operate on more than one linked data structure at substantially the same time.
    </p>
    <p num="23">
      The verification setup phase operates in real time during the normal course of linked data structure processing as each node in a given linked data structure is added or removed from a linked data structure.
      <br/>
      Specifically, the verification setup phase maintains a real-time record of the node label and the physical memory location of each node of a linked data structure in a memory device.
      <br/>
      The real-time record is preferably stored in a portion of a memory that is separate from the linked data structure itself.
      <br/>
      The memory can be volatile or non-volatile memory.
    </p>
    <p num="24">
      The integrity verification phase operates on a linked data structure that is ideally in a stable state.
      <br/>
      Note, however, the verification phase can operate on a linked data structure as changes are occurring to the structure although care must be taken to track and account for any changes that occur after the verification phase begins.
      <br/>
      The stable state of a linked data structure is one where normal linked data structure operations are temporarily halted so that nodes are not being added or removed during integrity verification.
      <br/>
      Specifically, the integrity verification phase visits each node of a linked data structure in an optimal memory device access order rather than in a logical pointer by pointer order.
      <br/>
      For example, an optimal memory device access order for a traditional magnetic disk or optical disk, might be in physical memory location order of cylinder and/or head to minimize the seek time from one node to the next.
      <br/>
      As each node is encountered during traversal of the linked data structure in optimal memory device access order, pieces of node-defining data are temporarily cataloged in an integrity verification table only as long as is necessary to verify the pointer information for a given node.
      <br/>
      Once a discrete piece of node-defining data is verified, the data is excised from the integrity verification table.
      <br/>
      Excising information from the verification table means that the data is either deleted and/or incorporated within the scope of data that remains in the integrity verification table.
    </p>
    <p num="25">
      The optimal memory device access order for any given memory device is determined by knowledge of the access characteristics of a given memory device on which the linked data structure resides.
      <br/>
      Once the type of memory device is known, the node information needed for the integrity verification process is organized accordingly in a verification setup table during the verification setup phase.
    </p>
    <p num="26">
      The linked data structure verification system of the present invention holds several advantages over existing linked data structure verification systems.
      <br/>
      First, the on-the-fly excising of verification table data minimizes the total amount of memory used by the verification table at any given time.
      <br/>
      Second, traversing the nodes of a linked data structure in optimal memory device access order minimizes access time of node information because the memory device on which the linked data structure is stored is retrieving data in a manner that facilitates optimal node retrieval performance by the memory device.
      <br/>
      Optimal memory device access efficiency is most apparent on memory or storage devices where the access time to data on the device is significantly slower than processor access times.
      <br/>
      One example of such a storage device is a nonsolid state memory device such as a traditional magnetic disk or tape.
      <br/>
      Third, visiting the nodes of a linked data structure in optimal memory device access order eliminates reliance on node pointers that are used for traditional node traversals, thus eliminating certain validation errors and the resulting chance of wasted time and/or computing resources.
      <br/>
      Fourth, traversing the nodes of a linked data structure in optimal memory device access order permits the verification program to take advantage of read-ahead type Input/Output (I/O) operations that result in minimizing the time spent waiting for slower memory device I/O operations to complete.
    </p>
    <heading>BRIEF DESCRIPTION OF DRAWINGS</heading>
    <p num="27">
      FIG. 1 illustrates an example of a doubly linked list type linked data structure in block diagram form;
      <br/>
      FIG. 2 illustrates an example of an index tree type linked data structure in block diagram form;
      <br/>
      FIG. 3 illustrates an example of a computing system environment in block diagram form on which the claimed invention could be implemented;
      <br/>
      FIG. 4 illustrates an operational overview of the linked data structure verification system in flow diagram form;
      <br/>
      FIG. 5 illustrates the verification setup phase operational steps in flow diagram form;
      <br/>
      FIG. 6 illustrates an example of the verification setup phase for a magnetic disk memory device in block diagram form; and
      <br/>
      FIG. 7 illustrates the integrity verification phase operational steps in flow diagram form.
    </p>
    <heading>DETAILED DESCRIPTION</heading>
    <p num="28">Computing System Environment--FIG. 3</p>
    <p num="29">
      FIG. 3 illustrates an example of a computing system environment 300 on which the claimed invention could be implemented.
      <br/>
      The computing system environment 300 is only one example of a suitable computing environment for the claimed invention and is not intended to suggest any limitation as to the scope of use or functionality of the claimed invention.
      <br/>
      Neither should the computing environment 300 be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computing system environment 300.
    </p>
    <p num="30">
      The claimed invention is operational with numerous other general purpose or special purpose computing system environments or configurations.
      <br/>
      Examples of well known computing systems, environments, and/or configurations that may be suitable for use with the claimed invention can include, but are also not limited to, a general purpose Personal Computer (PC), hand-held or lap top computers, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network computers, Personal Communication Systems (PCS), Personal Digital Assistants (PDA), minicomputers, mainframe computers, distributed computing environments that include any one or more of the above computing systems or devices, and the like.
    </p>
    <p num="31">
      The claimed invention may also be described in the general context of computer-executable instructions that are executable on a PC.
      <br/>
      Such executable instructions include the instructions within program modules that are executed on a PC for example.
      <br/>
      Generally, program modules include, but are not limited to, routines, programs, objects, components, data structures, and the like that perform discrete tasks or implement abstract data types.
      <br/>
      The claimed invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network.
      <br/>
      In a distributed computing environment, program modules may be located in both local and remote memory devices.
    </p>
    <p num="32">
      The exemplary computing system environment 300 is a general purpose computing device such as PC 310.
      <br/>
      Components of PC 310 include, but are not limited to, a processing unit 320, a system memory 330, and a system bus 321.
      <br/>
      The system bus 321 communicatively connects the aforementioned components and numerous other cooperatively interactive components.
    </p>
    <p num="33">
      Processing unit 320 is the primary intelligence and controller for PC 310 and can be any one of many commercially available processors available in the industry.
      <br/>
      System bus 321 may be any combination of several types of bus structures including, but not limited to, a memory bus, a memory controller bus, a peripheral bus, and/or a local bus.
      <br/>
      System bus 321, also referred to as an expansion bus or I/O channel, can be based on any one of a variety of bus architectures including, but not limited to, Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA), Enhanced ISA (EISA), Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) also known as Mezzanine bus.
    </p>
    <p num="34">
      System memory 330 is a volatile memory that can include a Read Only Memory (ROM) 331 and/or a Random Access Memory (RAM) 332. ROM 331 typically includes a Basic Input/Output System (BIOS) 333. BIOS 333 is comprised of basic routines that control the transfer of data and programs between peripheral non-volatile memories that are accessible to PC 310 during start-up or boot operations.
      <br/>
      RAM 332 typically contains data and/or programs that are immediately accessible to and/or presently being operated on by processing unit 320.
      <br/>
      Types of data and/or programs in RAM 332 can include operating system programs 334, application programs 335, other program modules 336, and program data 337.
    </p>
    <p num="35">
      Other components in PC 310 include numerous peripheral devices that are accessible to processing unit 320 by way of system bus 321.
      <br/>
      The numerous peripheral devices are supported by appropriate interfaces that can include a first non-volatile memory interface 340 for non-removable non-volatile memory device support, a second non-volatile memory interface 350 for removable non-volatile memory device support, a user input interface 360 for serial device support, a network interface 370 for remote device communication device support, a video interface 390 for video input/output device support, and an output peripheral interface 395 for output device support.
    </p>
    <p num="36">
      Examples of a non-removable non-volatile memory device can include a magnetic disk device 341 or other large capacity read/write medium such as an optical disk, magnetic tape, optical tape, or solid state memory.
      <br/>
      Types of data often stored on a non-removable non-volatile memory device include persistent copies of programs and/or data being used and/or manipulated in RAM 332 such as operating system programs 344, application programs 345, other program modules 346, and program data 347.
    </p>
    <p num="37">
      One example of a removable non-volatile memory device can include a magnetic floppy disk device or hard disk device 351 that accepts removable magnetic media 352.
      <br/>
      Another example of a removable non-volatile memory device can include an optical disk device 355 that accepts removable optical media 356.
      <br/>
      Other types of removable media can include, but are not limited to, magnetic tape cassettes, flash memory cards, digital video disks, digital video tape, Bernoulli cartridge, solid state RAM, solid state ROM, and the like.
    </p>
    <p num="38">
      User input interface 360 supports user input devices that can include, but are not limited to, a pointing device 361 commonly referred to as a mouse or touch pad, and a keyboard 362.
      <br/>
      Other user input devices can include, but are not limited to, a microphone, joystick, game pad, neuro-stimulated sensor, and scanner, and may require other interface and bus structures such as a parallel port, game port or a Universal Serial Bus (USB) for example.
    </p>
    <p num="39">
      User input/output devices supported by video interface 390 can include a display monitor 391 or a video camera.
      <br/>
      Output peripheral interface 395 supports output devices such as printer 396 and speakers 397.
    </p>
    <p num="40">
      Network interface 370 supports communications access to a remote computing facility such as remote computer 380 by way of Local Area Network (LAN) 371 and/or Wide Area Network (WAN) 373, or other Intranet or Intemet connection.
      <br/>
      Other remote computing facility types for remote computer 380 can include, but are not limited to, a PC, server, router, printer, network PC, a peer device, or other common network node.
      <br/>
      A remote computer 380 can typically include many or all of the components described above for PC 310.
      <br/>
      Modulator/Demodulator (MODEM) 372 can also be used to facilitate communications to remote computer 380.
      <br/>
      Types of programs and/or data accessible from remote memory device 381 on remote computer 380 can include, but are not limited to, remote application programs 385 and remote program data 386.
    </p>
    <p num="41">Verification System Operational Overview--FIG. 4</p>
    <p num="42">
      FIG. 4 illustrates an overview of the operational steps 400 for the linked data structure verification system in flow diagram form.
      <br/>
      The operational steps 400 begin at step 408 and proceed to the verification setup phase that includes steps 417 and 421.
      <br/>
      At step 417, the verification setup table (VST) is generated and/or initialized for use prior to normal linked data structure (LDS) verification processing.
      <br/>
      The verification setup table can be maintained in volatile or non-volatile memory separate from the linked data structure itself.
      <br/>
      The verification setup table is presumed to exist at step 417.
      <br/>
      An example of a verification setup table is disclosed in the text accompanying FIG. 6.
    </p>
    <p num="43">
      Normal linked data structure processing begins at step 421 and includes adding, removing, updating, and manipulating nodes in a linked data structure pursuant to the ordinary operational directions of a controlling application, in addition to other program operations not involving linked data structures.
      <br/>
      Step 421 is considered part of the verification setup phase because a verification setup table is maintained during normal linked data structure processing for each linked data structure that is subject to integrity verification.
      <br/>
      The node information maintained in each record of a verification setup table can include, but is not limited to, a node name and a physical node address for an individual node.
      <br/>
      Details of the normal linked data structure processing portion of the verification setup phase is disclosed in the text accompanying FIGS. 5-6.
    </p>
    <p num="44">
      Note that maintaining the above mentioned node information in a verification setup table in real-time as nodes are added or removed from a structure is more reliable and efficient than traversing the structure to collect node information immediately prior to the integrity verification phase.
      <br/>
      One reason that maintaining the verification setup table in real-time is more reliable than gathering node information by traversal, is that a traditional node traversal relies on the very node pointers that have not yet been verified as being accurate.
      <br/>
      Thus, node information for certain nodes could be missing from the verification setup table altogether when the integrity verification phase begins.
      <br/>
      One reason maintaining the verification setup table in real-time is more efficient than gathering node information by an independent traversal, is that traversing and extracting node information for a very large data structure takes longer than updating the node information in the verification setup table as a node is being added or deleted from a data structure.
    </p>
    <p num="45">
      The integrity verification phase begins at step 427 in response to a user input command or any other stimulus, and ends at step 470.
      <br/>
      The integrity verification phase can also be initiated by any other automated or semi-automated means that satisfies user needs.
      <br/>
      Typically, the normal linked data structure processing of step 421 is halted prior to beginning the integrity verification phase, however, halting normal linked data structure processing is not mandatory.
      <br/>
      The advantage of halting linked data structure processing prior to the integrity verification phase, is that the structure being verified is not changing during the integrity verification process.
      <br/>
      Verifying the integrity of a live or non-static data structure means that nodes being added or deleted from the structure must be identified as they are added or deleted from the structure so that the integrity verification process can return to those nodes and/or their neighboring nodes to verify the relevant pointer data.
      <br/>
      In a worse case scenario, some portion or all of the data structure would need to be traversed to re-collect node information for a thorough integrity verification.
      <br/>
      One important aspect of the present invention is that the entries in a verification setup table are arranged in an order that facilitates optimal node retrieval performance by the memory device on which the linked data structure resides.
      <br/>
      The integrity verification phase operates on one or more linked data structure by retrieving individual nodes from among the combined set of nodes from a memory device in optimal memory device access order.
      <br/>
      As previously stated, the order that nodes are retrieved is defined by the order of entries in the verification setup table.
      <br/>
      Retrieving nodes in an optimal memory location order is dictated by the memory device configuration and other physical requirements that minimize the operational time required to execute the integrity verification phase.
      <br/>
      Note that optimal memory location order is dependent on the target memory device.
    </p>
    <p num="46">
      At step 435, an individual node is retrieved in optimal memory location order from the memory device on which it resides.
      <br/>
      At step 442, the actual node information in the retrieved node is examined to determine if any inconsistencies exist with respect to expected node information that is already known about the subject linked data structure.
      <br/>
      The expected node information exists in an integrity verification table (IVT) that is constructed during the integrity verification phase.
      <br/>
      Individual entries in an integrity verification table are called records and the information in an individual record may represent node information relating to more than one node.
      <br/>
      One purpose of the integrity verification table is to maintain a record of what is known to exist and what is expected to exist about a given linked data structure in as few records as possible.
      <br/>
      Details of the integrity verification phase operational steps are disclosed in the text accompanying FIG. 7.
    </p>
    <p num="47">
      If it is determined at decision step 450 upon review of the verification setup table contents that there are additional nodes in a given linked data structure to verify, then processing continues at step 435 as previously disclosed.
      <br/>
      Alternatively, if it is determined at decision step 450 upon review of the verification setup table contents that there are no additional nodes in a given linked data structure to verify, then processing continues at step 458.
    </p>
    <p num="48">
      At step 458, a final determination as to the validity of a given linked data structure is determined based on the contents of the record or records remaining in the integrity verification table once all nodes of a linked data structure are processed.
      <br/>
      Any final validity reporting is also generated at step 458.
      <br/>
      The integrity verification phase processing stops at step 470.
      <br/>
      However, normal linked data structure processing can resume at this point by returning to step 421.
    </p>
    <p num="49">
      Generally speaking, the valid or invalid result of an integrity verification is determined by the content of any record that remains in the integrity verification table at the end of verification processing depending on the type of structure being verified.
      <br/>
      For example, the meaning of any content in a remaining record can be different for a linked list data structure versus an index tree structure.
      <br/>
      More specifically, at the end of a valid integrity verification for a doubly linked list, the integrity verification table should contain only one record of a "forward pointer" type, where the identification field in the node matches the id of the linked data structure being verified, the pointer origin is the node name of the first node in the linked data structure, and the pointer destination is the node name of the last node in the linked data structure.
      <br/>
      At the end of a valid integrity verification for an index tree structure, the integrity verification table should contain only one record that represents a root node of the tree, where the identification field in the node matches the id of the linked data structure tree being verified, and the node name should be that of the root node of the tree.
    </p>
    <p num="50">Verification Setup Phase Operational Steps--FIGS. 5-6</p>
    <p num="51">
      FIG. 5 illustrates operational steps 500 for the normal linked data structure processing portion of the verification setup phase in flow diagram form.
      <br/>
      The operational steps 500 begin at step 508 and are the details of step 421 from FIG. 4.
      <br/>
      One basic purpose of the verification setup phase is to generate an optimally ordered set of node information in a verification setup table for at least one linked data structure that is the subject of an integrity verification.
      <br/>
      Factors that determine an optimal ordering of verification setup table contents are dictated by the configuration and other physical requirements of the memory device on which the linked data structure resides.
    </p>
    <p num="52">
      Note that the verification setup phase can simultaneously maintain a separate verification setup table for each linked data structure that is the subject of verification testing.
      <br/>
      One reason a separate verification setup table might be maintained for each linked data structure is because the linked data structures reside on separate memory devices and the purpose of the verification setup table is to contain optimal memory device access order information that can be used to facilitate maximum memory device retrieval performance when individual nodes are being retrieved from the memory device.
    </p>
    <p num="53">
      Alternatively, the verification setup phase can maintain a single verification setup table for multiple linked data structures that are subject to verification testing provided that the multiple linked data structures all reside on the same memory device.
      <br/>
      One reason a single verification setup table might be maintained is because the integrity verification phase can simultaneously verify multiple linked data structures that reside on the same memory device.
      <br/>
      Key to the efficiency of the simultaneous verification of multiple linked data structures is that the nodes of the multiple linked data structures are organized in a single verification setup table in optimal memory device access order independent of the logical linked data structure to which any one node is associated.
      <br/>
      Thus, memory device access performance is maximized by accessing each node in the optimal memory device access order.
    </p>
    <p num="54">
      Note also that individual linked data structures can be identified in a verification setup table by a unique linked data structure identification number.
      <br/>
      One reason for including a unique linked data structure identification number is so that a node associated with a first linked data structure can be distinguished from a node associated with a second linked data structure when both nodes are being cataloged independent of their logical linked data structure context.
      <br/>
      Having clarified these points, additional processing by operation steps 500 continues at step 515 as disclosed below.
    </p>
    <p num="55">
      If it is determined at decision step 515 that a node is being added to a linked data structure that is the subject of verification testing, then processing continues at step 521.
      <br/>
      At step 521 the verification setup phase identifies the node name or label of the node being added to the linked data structure and the physical address of the node's location on the memory device that contains the subject linked data structure.
      <br/>
      Note that the node name or label and the node address can be one in the same.
      <br/>
      At step 527, the node name and the node address are inserted as an entry in a verification setup table.
      <br/>
      Additional node information can also be stored in the verification setup table as needed to uniquely identify a node and/or its precise memory device location for a given linked data structure.
      <br/>
      Processing continues at step 538.
      <br/>
      Alternatively, if it is determined at decision step 515 that a node is not being added to a linked data structure that is the subject of verification testing, then processing continues at step 538.
    </p>
    <p num="56">
      If it is determined at decision step 538 that a node is being removed from a linked data structure that is the subject of verification testing, then the entry for that node is removed from the verification setup table.
      <br/>
      If no entry exists in the verification setup table for a given node, then an error has occurred.
      <br/>
      Processing continues at step 560.
      <br/>
      Alternatively, if it is determined at decision step 538 that a node is not being removed from a linked data structure that is the subject of verification testing, then processing continues at step 560.
    </p>
    <p num="57">
      If it is determined at decision step 560 that no integrity verification is being requested for a linked data structure for which a verification setup table is being maintained, then processing continues at step 515 as previously disclosed.
      <br/>
      Alternatively, if it is determined at decision step 560 that an integrity verification is being requested for a linked data structure for which a verification setup table is being maintained, then processing continues at step 568.
    </p>
    <p num="58">
      At step 568, the entries in the verification setup table being maintained for a given linked data structure must be ordered according to the optimal memory device access order if the entries in the verification setup table are not already so ordered.
      <br/>
      One reason the entries of a verification setup table might already be optimally ordered by the time verification setup phase processing reaches step 568 is because the node information entries were inserted into and removed from the verification setup table at steps 527 and 545 respectively in a manner that maintained optimal ordering at all times.
      <br/>
      However, this type of on-the-fly ordering might itself require a linked data structure implementation for the verification setup "table" if optimal performance is desirable in the overall verification setup phase implementation.
      <br/>
      One reason the entries of a verification setup table might not be optimally ordered by the time verification setup phase processing reaches step 568 is because the entries were inserted into and removed from the verification setup table at steps 527 and 545 respectively in the order of occurrence during normal linked data structure processing.
      <br/>
      In the latter case, the verification setup table need only be optimally ordered once in a manner that is most efficient for the specific verification setup table implementation.
      <br/>
      Whether the verification setup table is maintained in optimal order during verification setup phase processing or whether the verification setup table is order once at the completion of verification setup phase processing is an implementation specific performance preference.
      <br/>
      One alternative implementation of the present invention is to optimally order the verification setup table once at the end of verification setup phase processing.
    </p>
    <p num="59">Verification setup phase processing is complete at step 575 where processing returns to step 421 of FIG. 4.</p>
    <p num="60">
      FIG. 6 is a verification setup phase illustration 600 in block diagram.
      <br/>
      One purpose of the verification setup phase illustration 600 is to emphasize the advantages of arranging the node entries of a verification setup table in an optimal memory device access order that facilitates maximum memory device retrieval performance during the integrity verification phase.
      <br/>
      Factors that determine an optimal ordering of node information in a verification setup table vary from one memory device type to the next and must be accounted for in a specific verification setup phase implementation.
      <br/>
      One reason for identifying the physical location of a node on a memory device by a technique other than the ordinary logical node-by-node traversal of a linked data structure, is to eliminate reliance on the very node pointers whose integrity is being verified.
    </p>
    <p num="61">
      The verification setup phase illustration 600 includes an example of a memory device 630 also known as a storage device, and a verification setup table 610.
      <br/>
      The memory device 630 is a non-volatile memory on which a persistent copy of a linked data structure resides.
      <br/>
      A magnetic disk device is one common example of a nonvolatile memory used to store a persistent copy of a linked data structure.
      <br/>
      The nodes of a linked data structure are located throughout the memory device 630 in a manner that does not reflect the logical order of the linked data structure.
      <br/>
      For this reason, a first node may physically be a significant distance from a second node on the same memory device even though the first node and the second node are logical neighbors as far as the logical view of a linked data structure is concerned.
      <br/>
      The verification setup table 610 can be any data structure type that lends itself to ordered storage or to efficient sorting such as a table or a linked list.
    </p>
    <p num="62">
      For purpose of example, consider node 631 as the first node or Node-1 of a linked list where the node is physically located at cylinder 15, head 5, sector 1 of a magnetic disk device.
      <br/>
      Similarly, node 632 is identified as the second node or Node-2 of the same linked list and is physically located at cylinder 1, head 1, sector 1 of the magnetic disk, and node 633 is the n-th node or Node-n of the same linked list and is physically located at cylinder 14, head 1, sector 1.
      <br/>
      If the optimal retrieval order of nodes from memory device 630 is in ascending order of cylinder, head, and sector, then the optimal node retrieval order would be Node-2632 first, Node-n 633 second, and then Node-1631 third.
      <br/>
      Alternatively, retrieving the same three nodes in logical linked data structure order would cause the memory device 630 to retrieve the first node 631 first from cylinder 15, then move the read/write head armature to cylinder 1 to retrieve the second node 632, and then back again to cylinder 14 to retrieve the third node 633.
      <br/>
      Thus, the logical linked data structure order of node retrieval is extremely inefficient due to the disk-wide seeks necessary to locate and retrieve individual nodes, whereas retrieving nodes in optimal memory device access order requires a minimal amount of armature movement for the best possible retrieval performance.
      <br/>
      Verification setup table 610 illustrates node information entries 611-613 in the optimal memory device access order by memory device location 621-623 for each node.
      <br/>
      Other memory device examples exist that have different memory properties, yet are within the scope of the present invention.
    </p>
    <p num="63">Integrity Verification Phase Operational Steps--FIG. 7</p>
    <p num="64">
      FIG. 7 illustrates the operational steps 700 for the node information evaluation portion of the integrity verification phase in flow diagram form.
      <br/>
      The operational steps 700 begin at step 708 and are the details of step 442 from FIG. 4.
    </p>
    <p num="65">
      Note that the details of any one of the operational steps 700 may be more or less complex depending on the specific type of linked data structure being verified.
      <br/>
      For example, a doubly linked list type data structure is a simpler structural construction than an index tree.
      <br/>
      It follows then that an integrity verification phase implementation for a doubly linked list is less complex than for an index tree.
      <br/>
      Having clarified these points, additional processing by operation steps 700 continues at step 715 as disclosed below.
    </p>
    <p num="66">
      At step 715, the actual node information from a presently retrieved node is matched or compared with what is already known about the linked data structure that is the subject of the integrity verification.
      <br/>
      The information already known about the linked data structure is called the expected node information.
      <br/>
      That is, information from previously evaluated nodes contains information about neighboring nodes that have not yet been seen so that when a yet unseen neighboring node is retrieved for evaluation, certain expectations already exist about the information that should exist in the actual node itself.
      <br/>
      The expected node information is maintained in an integrity verification table (IVT).
    </p>
    <p num="67">
      An integrity verification table is preferably a key-addressable or indexed store such as a hash table or relational database.
      <br/>
      The purpose for keys or indexing in the integrity verification table is to facilitate rapid lookups of information about one or more nodes that share certain stated characteristics.
      <br/>
      The node information for a given node is an entry in the integrity verification table called a record.
      <br/>
      At most, there exists one record in an integrity verification table for every node that has been seen.
      <br/>
      However, the longer the integrity verification phase processing continues, the greater the likelihood that all information in a record has already been verified, in which case the record will be deleted at step 745.
    </p>
    <p num="68">
      Step 721 notes the beginning of generating results of the node information evaluation process.
      <br/>
      Note that results are continuously generated throughout the integrity verification process.
      <br/>
      A report that is generated contains relevant information about any inconsistency identified between the actual node information of a retrieved node and the known information that is expected in a retrieved node.
      <br/>
      The report may be as simple as a single error printed or stored in an error log for later analysis and/or correction by a user that has requested the integrity verification.
      <br/>
      The results generated from the integrity verification process can be reported at any time.
      <br/>
      For example, the results can be reported in real-time as the results become available during processing, or the results can be queued for subsequent reporting after the verification process is complete.
    </p>
    <p num="69">
      At step 737, a record is added to the integrity verification table for any actual node information that has not yet been seen by the integrity verification phase processing.
      <br/>
      The purpose of adding this information to the integrity verification table is to make sure that when related nodes are processed, the information that is expected to exist in the present actual node can be verified as correct in a sorted order.
    </p>
    <p num="70">
      At step 745, records are removed that contain actual node information that has already been processed or that is duplicative of node information already represented in the integrity verification table.
      <br/>
      The purpose of removing these types of records is to minimize the amount of memory required by the integrity verification table as well as the volume of information that exists in the integrity verification table at any one time.
    </p>
    <p num="71">
      At step 753, the expected node information in the integrity verification table is coalesced in view of the recently added actual node information from step 737 and/or the removed node information from step 745.
      <br/>
      Any unnecessary and/or duplicative node information remaining in the integrity verification table after the coalescing of step 753 can be removed from the table at step 760.
      <br/>
      The purpose of coalescing node information in the integrity verification table is to minimize the volume of expected node information by excising information that is no longer necessary or that is duplicative.
    </p>
    <p num="72">
      For example, consider the situation where the expected node information in an integrity verification table includes information about a first node in a doubly linked list that has a forward pointer to a second node, in addition to information about a third node that has a backward pointer to the same second node.
      <br/>
      The expected node information about the second node is that its forward pointer should point to the third node and its backward pointer should point to the first node.
      <br/>
      Once the actual node information for the second node is known and verified according to expectations, the actual node information for the second node is no longer needed and can be removed.
      <br/>
      Further, the individual records of node information relating to the first node and the third node can be coalesced into a single record containing expected backward pointer information and forward pointer information to a zeroth node and a fourth node respectively.
      <br/>
      The single coalesced record then compactly represents verified node information relating to three actual nodes of the linked data structure.
    </p>
    <p num="73">The operational steps 700 are complete at step 785 and processing returns to step 442 of FIG. 4.</p>
    <p num="74">Secondary Index Verification Operational Steps</p>
    <p num="75">
      The operational steps for verifying the integrity of a secondary index type linked data structure are fundamentally the same as are disclosed in the text accompanying FIGS. 4-5 and 7.
      <br/>
      However, just as the implementation of a heaped linked data structure requires different considerations from the implementation of an indexed linked data structure, a secondary index linked data structure requires different considerations from an indexed linked data structure.
      <br/>
      One key to the linked data structure verification system operational steps 400 is that the special considerations required from one linked data structure implementation to the next can be accommodated within the scope of the verification setup phase operational steps 500 and the integrity verification phase operational steps 700 as previously disclosed.
      <br/>
      Special considerations relating to a secondary index type lined data structure implementation are disclosed below.
    </p>
    <p num="76">
      A secondary index type linked data structure is an index tree construct where instead of the leaf nodes containing data, the leaf nodes contain pointers to the location of the data in a separate data structure.
      <br/>
      For this reason, the verification setup phase and integrity verification phase for a secondary index linked data structure are substantially similar to the index tree as previously disclosed.
      <br/>
      However, pointers among the two or more data structures must be verified simultaneously.
      <br/>
      Note also that there may be more than one index tree structure, for example, that each points to the same data in a separate data structure.
      <br/>
      In effect, a typical index tree structure as disclosed in FIG. 2 contains a two dimensional set of pointers among sibling and peer nodes, while a secondary index linked data structure contains the typical index tree structure pointers in addition to a set of third dimension pointers that reference nodes of an independent data structure.
    </p>
    <p num="77">
      The operational steps 500 of a verification setup phase for a secondary indexed data structure require that a verification setup table be maintained for node information entries relating to the basic index tree node information in addition to the secondary index pointer information as previously disclosed.
      <br/>
      The entries in the verification setup table are optimally ordered as disclosed in the text accompanying FIG. 5.
    </p>
    <p num="78">
      The operational steps 700 of an integrity verification phase for a secondary indexed data structure can proceed as disclosed in the text accompanying FIG. 7.
      <br/>
      Alternatively, operational steps 700 can be optimized with respect to the third dimensional pointer types that are the references between the base indexed structure and the secondary indexed structure.
    </p>
    <p num="79">
      Integrity verification phase differences for a secondary index linked data structure appear at step 427 of FIG. 4.
      <br/>
      At step 427, a secondary index verification table can be initialized in addition to the integrity verification table as previously disclosed.
      <br/>
      The secondary index verification table is a bit array that ideally has a bit position for each leaf node in a given secondary index structure.
      <br/>
      Thus, each bit in the secondary index verification table would correspond to a record in the integrity verification table.
      <br/>
      Note that the size of the bit array is dependent on the system resources that are available and the user's tolerance to the tradeoff between accuracy and efficiency of the verification system.
      <br/>
      The secondary index verification table is initialized to either all zeros or all ones at step 427 of FIG. 4.
      <br/>
      For purposes of the present discussion, assume that the secondary index verification table is initialized to all zeros.
    </p>
    <p num="80">
      At step 442 of FIG. 4, in addition to performing the integrity verification phase processing as disclosed in the operational steps 700 of FIG. 7, the secondary index verification table is used to verify the secondary index structure in the following manner.
      <br/>
      As each leaf node or data page is examined in order of its location on the memory device, the selected keys of the integrity verification indexing information are hashed into a fixed size value.
      <br/>
      The fixed size value is sufficient in size so that it can be used to address each bit in the secondary index verification table.
      <br/>
      Addressing each bit in the secondary index verification table is also referred to as indexing into the secondary index verification table.
      <br/>
      The bit located a given index position in the secondary index verification table is toggled to its binary opposite from 0-to-1 or 1-to-0, depending on the bits value at the time the indexing occurs.
      <br/>
      The type of hashing technique used is an implementation choice.
    </p>
    <p num="81">
      When all nodes have been processed and at the time the validity of the linked data structure is being determined in view of the contents of the integrity verification table at step 458 of FIG. 4, the secondary index verification table is also evaluated in the following manner.
      <br/>
      If all bits in the secondary index verification table are equal to the initialization value from step 427, then the integrity of the secondary index linked data structure is considered valid or verified.
      <br/>
      The probability of finding validity or a positive verification result is dependent on the number of leaf records in the secondary index and the number of bits in the secondary index verification table.
      <br/>
      However, if the initialization value from step 427 was zero and if any one bit in the secondary index verification table is not zero at the completion of the verification process, then the integrity of the secondary index linked data structure is considered invalid or not verifiable and the position of the non-zero bits indicate which node or nodes contain the invalid information.
    </p>
    <p num="82">
      The reason all bits in the secondary index verification table should match the initialization value of step 427 is because each bit should have been toggled twice, once for a given leaf node in the base index structure and once for a corresponding leaf node in the secondary index structure.
      <br/>
      Stated more generally, each bit in the secondary index verification table should be toggled an even number of times regardless of the number of secondary index structures that exist because pointers between such structures are in pairs, one pointing to a node in the indexed structure and one pointing away from a node in the data structure.
    </p>
    <p num="83">
      If errors are detected then a second pass of the indexed structure can be run to generate detailed error messages.
      <br/>
      When the records of the indexed structure are processed on a second pass, the hash value that is generated is checked against the corresponding secondary verification table value although the secondary verification table is not modified.
      <br/>
      In the event a bit in the secondary verification table is set in error, then the secondary index structure is searched for the key value for a data page, or the data record for an index page, using the normal index and/or data access code for the key or address respectively.
      <br/>
      If the resulting data record does not match the index record, then an error message is generated to report the fact.
    </p>
    <p num="84">Verification Process Alternatives</p>
    <p num="85">
      A multiple pass linked data structure verification process can be beneficial for linked data structures that are larger than are manageable for processing in a local memory.
      <br/>
      The amount of local memory that is required for verification processing can be determined from the number of nodes in the data structure and the key size.
      <br/>
      If the estimate of the necessary local memory size based on heuristics suggests that verification processing will require more memory than is available, then the index is broken into n sections that are substantially equal in size based on the key value using the upper levels of the data structure.
      <br/>
      Each of the n sections is checked in a separate pass over the index.
      <br/>
      Unconsolidated nodes at the boundaries are left in place for processing on a subsequent pass.
      <br/>
      Verification of links between pages can be segmented in a similar manner using ranges of page addresses as the segmentation criteria.
    </p>
    <p num="86">
      Linked data structure verification can also use the group aggregate function of a Structured Query Language (SQL) type query processor to validate large data structures.
      <br/>
      Using the node ID as an aggregate key, all the information for a node can be collected and aggregated using custom aggregate functions.
      <br/>
      At the end of the aggregation phase any nodes with conflicting or incomplete information can be printed using a custom SQL function to interpret the node state and/or generate error messages as appropriate.
    </p>
    <p num="87">Conclusion</p>
    <p num="88">
      The linked data structure verification system of the present invention verifies the integrity of a linked data structure by way of a verfication setup phase and an integrity verification phase.
      <br/>
      The verification setup phase operates during normal linked data structure processing to maintain a real-time record of the node name and the actual memory device location of each node associated with a given linked data structure.
      <br/>
      The integrity verification phase traverses each node of one or more linked data structures in optimal memory device access order to verify node information for each node.
      <br/>
      The node information is collected in an integrity verification table for only as long as it is needed prior to being excised during a coalescing step in the integrity verification phase.
    </p>
    <p num="89">Although specific embodiments are disclosed herein, it is expected that persons skilled in the art can and will make, use, and/or sell alternative linked structure verification systems that are within the scope of the following claims either literally or under the Doctrine of Equivalents.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A machine readable memory tangibly embodying instructions executable by a computer to perform a method for verifying integrity of a linked data structure that resides on a memory device, said linked data structure having a plurality of nodes and each of said plurality of nodes containing actual node information, said method comprising:</claim-text>
      <claim-text>generating a first table having a node address entry for a physical memory device location of each of said plurality of nodes in said linked data structure; retrieving actual node information for each of said plurality of nodes seriatim from said memory device in a retrieval order that facilitates optimal memory device retrieval performance in view of contents of said first table; maintaining a second table of a minimum store of expected node information that is indicative of at least one of said plurality of nodes in said linked data structure;</claim-text>
      <claim-text>and verifying said actual node information from a retrieved one of said plurality of nodes against said expected node information in said second table.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. A method according to claim 1 wherein said step of generating said first table includes: adding said node address entry to said first table in real time for each one of said plurality of nodes added to said linked data structure;</claim-text>
      <claim-text>and removing said node address entry from said first table in real time for each one of said plurality of nodes removed from said linked data structure.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. A method according to claim 2 wherein said step of adding includes: inserting each said node address entry to said first table in an optimal memory device access order dictated by characteristics of said memory device.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A method according to claim 1 wherein said step of retrieving includes: ordering each said node address entry of said first table in an optimal memory device access order dictated by requirements of said memory device at one time prior to retrieving any node for verification testing.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. A method according to claim 1 wherein said step of maintaining said second table includes: coalescing said actual node information from a retrieved one of said plurality of nodes into expected node information in said second table for each of said plurality of nodes retrieved from said memory device;</claim-text>
      <claim-text>and removing said actual node information from said second table that is duplicative of said expected node information in said second table, in response to said step of coalescing.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. A method according to claim 1 wherein said step of verifying includes: distinguishing expected node information from said actual node information; comparing said actual node information from a retrieved one of said plurality of nodes with expected node information in said second table; reporting inconsistencies that are identified between said actual node information and said expected node information.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. A method for simultaneously verifying integrity of at least one linked data structure comprising: cataloging node information for a plurality of nodes associated with each of said least one linked data structure on a memory device; retrieving each of said plurality of nodes seriatim from said memory device in an optimal memory device access order that facilitates optimal node retrieval performance independent of any logical linked data structure traversal and independent of any position of said plurality of nodes within any of said at least one linked data structure;</claim-text>
      <claim-text>and verifying node pointer integrity for each of said plurality of nodes based on a minimal store of node information knowledge.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A method according to claim 7 wherein said step of retrieving includes: generating a node address table having a node address entry for each of said plurality of nodes in said at least one linked data structure;</claim-text>
      <claim-text>and ordering said node address table in said optimal memory device access order prior to retrieving any one of said plurality of nodes.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. A method according to claim 7 wherein said step of verifying includes: comparing actual node information from a retrieved one of said plurality of nodes against expected node information already known about said plurality of nodes in any one of said at least one linked data structure; reporting any inconsistency between said actual node information and said expected node information in response to said comparing step; updating said expected node information with valid parts of said actual node information;</claim-text>
      <claim-text>and removing any parts of said actual node information that are duplicative of said expected node information in response to said updating step.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A method according to claim 7 including: generating at least one error message on a subsequent pass through said at least one linked data structure in response to said step of verifying.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A method according to claim 7 including: identifying large ones of said at least one linked data structure that exceed an available amount of local memory available to implement said step of verifying;</claim-text>
      <claim-text>and segmenting large ones of said at least one linked data structure into a plurality of segments that are each subject to said step of verifying.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A method according to claim 7 including: identifying large ones of said at least one linked data structure that exceed an available amount of local memory available to implement said step of verifying;</claim-text>
      <claim-text>and implementing a group aggregate function by way of a node identifier as an aggregate key to verify said large ones of said at least one linked data structure.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. A linked data structure verification system in a computing device, said computing device having access to a memory device on which at least one linked data structure resides, each of said at least one linked data structure having a membership of a plurality of nodes, said system comprising: a verification setup phase operable in real time during normal linked data structure processing, said verification setup phase includes:</claim-text>
      <claim-text>- means for generating a node address table having a node address entry for each of said plurality of nodes in said at least one linked data structure;</claim-text>
      <claim-text>and - means for ordering said node address table in a physical memory location retrieval order;</claim-text>
      <claim-text>and an integrity verification phase operable upon completion of said verification setup phase, said integrity verification phase includes: - means for retrieving each of said plurality of nodes seriatim from said memory device in said physical memory location retrieval order that facilitates optimal memory device retrieval performance; - means for comparing actual node information from a retrieved one of said plurality of nodes against expected node information already known about said plurality of nodes in any one of said at least one linked data structure; - means for reporting any inconsistency between said actual node information and said expected node information in response to said comparing means; - means for updating said expected node information with valid parts of said actual node information;</claim-text>
      <claim-text>and - means for removing any parts of said actual node information that are duplicative of said expected node information in response to said updating means.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A system according to claim 13 wherein said integrity verification phase includes: means for initializing a secondary index verification table of bits to a common bit value; means for hashing selected keys of node information into a hash value for each node retrieved from said memory device; means for indexing into said secondary index verification table based on said hash value to toggle a corresponding bit in said secondary index verification table;</claim-text>
      <claim-text>and means for verifying validity of node information for each of said plurality of nodes in view of said secondary index verification table contents.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A linked data structure verification system comprising: means for cataloging node information during normal linked data structure processing for each of a plurality nodes associated with at least one linked data structure on a memory device; means for retrieving actual node information for each of said plurality of nodes seriatim from said memory device in an optimal memory device access order that facilitates optimal node information retrieval performance independent of any logical node ordering in any of said at least one linked data structure; means for verifying said actual node information against a minimized store of expected node information related to any one of said plurality of nodes from any one of said at least one linked data structure; means for hashing at least one component of node information corresponding to a secondary index linked data structure into a secondary index hash table to verify any existing secondary index linked data structure node information.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. A system according to claim 15 wherein said means for cataloging includes: means for generating a verification setup table having a node information entry for each of said plurality of nodes in said at least one linked data structure;</claim-text>
      <claim-text>and means for ordering said verification setup table in said optimal memory device access order prior to an integrity verification phase.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. A system according to claim 15 wherein said means for verifying includes: means for generating said expected node information from said actual node information; means for comparing said actual node information from a retrieved one of said plurality of nodes against said expected node information already known about said plurality of nodes related to any one of said at least one linked data structure; means for reporting any inconsistency between said actual node information and said expected node information in response to said comparing step; means for coalescing said expected node information with valid parts of said actual node information into a minimal store of said expected node information;</claim-text>
      <claim-text>and means for removing any parts of said actual node information that are duplicative of said expected node information in response to said means for coalescing.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. A system according to claim 15 wherein said means for hashing includes: means for initializing a secondary index verification table of bits to a common bit initialization value; means for hashing said at least one component of node information into a hash value for each node retrieved from said memory device; means for indexing into said secondary index verification table based on said hash value to toggle a corresponding bit in said secondary index verification table;</claim-text>
      <claim-text>and means for verifying validity of secondary index linked data structure node information for each of said plurality of nodes in view of contents of said secondary index verification table.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. A system according to claim 18 wherein said means for verifying includes: means for recording an error for each bit in said secondary index verification table that does not match said common bit initialization value;</claim-text>
      <claim-text>and means for reporting each said error that is recorded from said means for recording.</claim-text>
    </claim>
  </claims>
</questel-patent-document>