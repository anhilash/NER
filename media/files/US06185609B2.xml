<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185609B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185609</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185609</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="25499467" extended-family-id="3874988">
      <document-id>
        <country>US</country>
        <doc-number>08957357</doc-number>
        <kind>A</kind>
        <date>19971024</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08957357</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>4006964</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>95735797</doc-number>
        <kind>A</kind>
        <date>19971024</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08957357</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  15/16        20060101AFI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>15</main-group>
        <subgroup>16</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/44        20060101ALI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>44</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   9/46        20060101ALI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>46</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="4">
        <text>G06F   9/54        20060101ALI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>54</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="5">
        <text>H04L  12/24        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>12</main-group>
        <subgroup>24</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="6">
        <text>H04L  12/26        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>12</main-group>
        <subgroup>26</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="7">
        <text>H04L  29/06        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>29</main-group>
        <subgroup>06</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>709219000</text>
        <class>709</class>
        <subclass>219000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>709203000</text>
        <class>709</class>
        <subclass>203000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-029/06</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>29</main-group>
        <subgroup>06</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131026</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-043/0817</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>43</main-group>
        <subgroup>0817</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131026</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-067/42</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>67</main-group>
        <subgroup>42</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131017</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>29</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>12</number-of-drawing-sheets>
      <number-of-figures>14</number-of-figures>
      <image-key data-format="questel">US6185609</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method, apparatus and program to provide client access to a management information service residing on a server in a computer network system</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>HILL RICHARD DOUGLAS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5724588</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5724588</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>FAYBISHENKO YAROSLAV</text>
          <document-id>
            <country>US</country>
            <doc-number>5757925</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5757925</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>CAVANAUGH III KEN M</text>
          <document-id>
            <country>US</country>
            <doc-number>5809507</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5809507</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>BENNETT CURTIS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5826085</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5826085</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>MARITZEN LYNN M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5899990</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5899990</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>LUDWIG PATRICK B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6006230</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6006230</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>Cornell, G. and Horstmann, C.S., "Remote Objects," Core Java. Mountain View: Sun Microsystems Press 643-681 (1997).</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>Van Der Linden, P., "Client/Server and the Intranet," Not Just Java. Mountain View: Sun Microsystems Press 199, 207-218 (1997).</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>Van Der Linden, P., "Java Language Specifics," Not Just Java. Mountain View: Sun Microsystems Press 136-157 (1997).</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Sun Microsystems, Inc.</orgname>
            <address>
              <address-1>Palo Alto, CA, US</address-1>
              <city>Palo Alto</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>SUN MICROSYSTEMS</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Rangarajan, Govindarajan</name>
            <address>
              <address-1>Sunnyvale, CA, US</address-1>
              <city>Sunnyvale</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Bapat, Subodh</name>
            <address>
              <address-1>Palo Alto, CA, US</address-1>
              <city>Palo Alto</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Ranganathan, Rajasekar</name>
            <address>
              <address-1>Union City, CA, US</address-1>
              <city>Union City</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Arora, Akhil</name>
            <address>
              <address-1>San Jose, CA, US</address-1>
              <city>San Jose</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Bayer Weaver &amp; Thomas, LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Lim, Krisna</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Techniques for providing a client program with remote access to information management services of a computer network are disclosed.
      <br/>
      An application programming interface can be provided to enable the client to remotely access the information management services.
      <br/>
      By using the application program interface the client can remotely invoke appropriate methods on the server to access the information management services.
      <br/>
      The application programming interface can be implemented as a thin-class.
      <br/>
      In addition, the communication between the server and the client programs is transparent to the applications that utilize the application programming interface.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS REFERENCE TO RELATED PATENT APPLICATIONS</heading>
    <p num="1">This patent application is related to the following copending, commonly assigned patent applications, the disclosures of which are incorporated herein by reference in their entirety:</p>
    <p num="2">
      U.S. patent application Ser.
      <br/>
      No. 08/958,377, now abandoned, entitled A METHOD, APPARATUS, SYSTEM &amp; PROGRAM PRODUCT FOR THIN-CLASSES IN A CLIENT-SERVER ENVIRONMENT, by: Govindarajan Rangarajan, Joe Scarpelli, Eugene Krivopaltsev, Alex Lefaive and Raghavendra Sondur, filed concurrently herewith.
    </p>
    <p num="3">
      U.S. patent application Ser.
      <br/>
      No. 08/957,794, still pending, entitled A METHOD, APPARATUS &amp; PROGRAM PRODUCT FOR INTERFACING A MULTI-THREADED, CLIENT-BASED API TO A SINGLE-THREADED, SERVER-BASED API, by: Govindarajan Rangarajan, Eugene Krivopaltsev, Sassan Shahriary, Joe Scarpelli, Subodh Bapat, Michael Moran and Raghavendra Sondur, filed concurrently herewith.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="4">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="5">
      This invention relates to the field of management information service (MIS) access mechanisms.
      <br/>
      In particular, the invention provides a JAVA application programmer with an interface to a MIS, such as the Solstice (tm)  Enterprise Manager (tm)  from Sun Microsystems Inc., to access records in the MIS.
    </p>
    <p num="6">2. Background</p>
    <p num="7">
      Object-oriented programming (OOP) languages associate an object's data with programmed-methods for operating on that object's data.
      <br/>
      Usually, OOP objects are instantiated in a heap memory area and are based on classes that reference the programmed-methods for the OOP object.
      <br/>
      Instantiated OOP objects contain data (in instance variables) specific to that particular instantiated OOP object.
      <br/>
      Conceptually, an OOP object contains object-related information (such as the number of instance variables in the object), the instance variables, and addresses of programmed-methods that access and/or manipulate the contents of the instance variables in the object.
      <br/>
      However, because objects often share programmed-methods and object-related information, this shared information is usually extracted into a class.
      <br/>
      Thus, the instantiated object simply contains its instance variables and a pointer to its class.
    </p>
    <p num="8">
      Smalltalk, Java and C++ are examples of OOP languages.
      <br/>
      Smalltalk was developed in the Learning Research Group at Xerox's Palo Alto Research Center (PARC) in the early 1970s. C++ was developed by Bjarne Stroustrup at the AT&amp;T Bell Laboratories in 1983 as an extension of the C programming language.
      <br/>
      Java is an OOP language with elements from C and C++ and includes highly tuned libraries for the internet environment.
      <br/>
      It was developed at Sun Microsystems and released in 1995.
    </p>
    <p num="9">Further information about OOP concepts may be found in Not Just Java by Peter van der Linden, Sun Microsystems Press/Prentice Hall PTR Corp., Upper Saddle River, N.J., (1997), ISBN 0-13-864638-4, pages 136-149.</p>
    <p num="10">
      A client/server computing environment allows a client computer to use a service or resource provided by a server computer.
      <br/>
      Generally many clients use the server computer.
      <br/>
      The client/server environment provides advantages well known in the art and described in Not Just Java at page 199.
      <br/>
      With the advent of programming environments that are independent of the computer used to execute them (for example, programming environments that include the Java Virtual Machine), client applications are being developed that execute on a variety of different computers.
      <br/>
      Because the executable code for these applications is independent of the computer architecture and operating system that execute the code, only one compilation of the executable code need be created.
      <br/>
      This compilation of the executable code can be transferred from storage on a server, over the network, to a client where the code is executed.
      <br/>
      Sometimes the client and server portions of an application execute on the same computer.
    </p>
    <p num="11">
      A "thin-client" is a networked client computer that does not have permanent local storage.
      <br/>
      Thus, the storage service is provided by a server computer termed a "thick-" or "fat-"server.
      <br/>
      Thin-clients read Java applications stored on the fat-server and locally execute them.
      <br/>
      These applications can, in turn, access data from the fat-server or other sources on the Internet.
      <br/>
      The thin-client/thick-server environment is described in Not Just Java at pages 207-218.
    </p>
    <p num="12">
      As previously mentioned, Java is an object-oriented programming language.
      <br/>
      Thus, it is useful to transport objects between the client and server.
      <br/>
      It is also advantageous to invoke an object's method that resides on one computer by a program executing on another computer.
      <br/>
      Java generally uses the remote method invocation (RMI) interface to provide this capability.
      <br/>
      The RMI interface is described in Core Java, by Cornell and Horstmann, 2nd edition, ISBN 0-13-596891-7, .COPYRGT. 1997 Sun Microsystems, Inc. at pages 643-681.
      <br/>
      Other interfaces exist (such as the CORBA standard) that provide similar functionality.
    </p>
    <p num="13">
      One difficulty with remote method invocation interfaces is that the application programmer must explicitly obtain a reference to a remote object before invoking that object's programmed-methods.
      <br/>
      This additional complexity increases the difficulty involved to create a networked application.
      <br/>
      In addition, the object's programmed-methods are either executed on the client or on the server dependent on the location of the object.
      <br/>
      Thus, simple programmed-methods, such as obtaining the value of an object's data, are high overhead operations if the object is located on the server because the client must cause the server to execute the programmed-method that returns the value.
      <br/>
      This value is then returned across the network to the client.
      <br/>
      These overheads impact the performance of the application on the thin-client.
      <br/>
      It would be advantageous to provide an object that extends across the client/server interface and that has the capability to automatically execute one of its programmed-methods on the client and another of its programmed-methods on the server.
      <br/>
      One aspect of the invention provides this capability.
    </p>
    <p num="14">
      Another problem with client-server systems, such as the previously described thin-client/fat-server system, is that the server portion of the system generally must invoke operations on an existing service--one that was not necessarily implemented to take advantage of modern computing environment features such as a multi-thread capability.
      <br/>
      Thus, the programmer generally limits the implementation of an application to the programming techniques allowed by the existing service.
      <br/>
      Because many existing server applications do not support thread-safe APIs, multiple client threads (either in the same server, or extending across multiple servers, or both) must synchronize access to the service so the client application can be written using the modern programming techniques.
      <br/>
      Thus, when the service is upgraded to use the new methodology, the existing client programs will not need to be modified to use the new capabilities of the service.
      <br/>
      In addition, many APIs are written in a programming language other than the language used to write an application.
      <br/>
      It is expensive to convert an API written in one language to another language.
      <br/>
      Thus it is advantageous to provide an API written in the new language that invokes the methods used by the corresponding API written in the original language.
      <br/>
      Threads are briefly discussed in Not Just Java at pages 149-156.
    </p>
    <p num="15">
      A network management information service is an example of a service that can be provided to a client by a server.
      <br/>
      Such a service, like the Solstice (tm)  Enterprise Manager (tm)  from Sun Microsystems Inc., gathers information about network devices, stores this information in a management information service (MIS), and provides this information to other applications.
      <br/>
      Monitoring this information in a thin-client/fat-server environment would allow a user or network administrator to monitor network from inexpensive thin-clients or from a Java enabled web browser.
      <br/>
      Such a network management application on a client must be able to request information about the network devices that are relevant to the network administrator.
      <br/>
      Such an application must also receive notification that a relevant event has occurred in the MIS regarding those devices.
      <br/>
      Thus, it would be advantageous to provide a technique that serializes clients' access to a shared service and that distributes events generated by the service to the clients that have registered to receive the events.
    </p>
    <p num="16">
      Yet another problem with client-server systems is that of the client performing operations on their server's MIS.
      <br/>
      In particular, sending large numbers of data records from a MIS system from the server to the client requires significant network bandwidth if the client and server reside on different computer systems.
      <br/>
      Also, if the client is a thin-client it may not have sufficient resources to timely process or store the data records.
      <br/>
      Thus, it would be advantageous for the server to provide those services that require extensive computational and I/O processing to the client through an API.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="17">
      The present invention provides an apparatus, method and computer program product for providing an application executing on a client, with an alarm API for interfacing to a MIS executing on a server.
      <br/>
      One aspect of the invention includes a computer controlled method for providing a client application with access to a management information service (MIS) provided by a server.
      <br/>
      The MIS contains data about a monitored condition.
      <br/>
      The computer controlled method includes the client application instantiating an application programmer interface (API) that comprises a logical object and includes the client application invoking a programmed-method of the logical object.
      <br/>
      In addition the server executes the programmed-method to access the MIS.
    </p>
    <p num="18">
      Another aspect of the invention includes an apparatus having a central processing unit (CPU) and a memory coupled to said CPU for providing a client application with access to a management information service (MIS) provided by a server.
      <br/>
      The MIS contains data about a monitored condition.
      <br/>
      The apparatus comprises an instantiation mechanism configured to instantiate, responsive to said client application, an application programmer interface (API).
      <br/>
      The API comprises a logical object.
      <br/>
      The apparatus also includes a method invocation mechanism configured to invoke a programmed-method of the logical object by the client application.
      <br/>
      In addition, the apparatus includes an execution mechanism configured to execute the programmed-method at the server to access the MIS.
    </p>
    <p num="19">
      Another aspect of the invention includes a computer program product embedded in a computer usable medium for causing a computer to provide a client application with access to a management information service (MIS) provided by a server.
      <br/>
      The MIS contains data about a monitored condition.
      <br/>
      When executed on a computer, the computer readable code causes a computer to effect an instantiation mechanism, a method invocation mechanism, and an execution mechanism.
      <br/>
      Each of these mechanisms have the same functions as the corresponding mechanisms for the previously described apparatus.
    </p>
    <p num="20">These and other features of the invention will become apparent when the following detailed description is read in combination with the accompanying figures.</p>
    <heading>DESCRIPTION OF THE DRAWINGS</heading>
    <p num="21">
      FIG. 1 illustrates a computer system capable of using the invention in accordance with a preferred embodiment;
      <br/>
      FIG. 2A illustrates a client-server architecture in accordance with a preferred embodiment;
      <br/>
      FIG. 2B illustrates an object-factory in accordance with a preferred embodiment;
      <br/>
      FIG. 2C illustrates a server object in accordance with a preferred embodiment;
      <br/>
      FIG. 3 illustrates a server-object creation process in accordance with a preferred embodiment;
      <br/>
      FIG. 4 illustrates a server-object initialization process in accordance with a preferred embodiment;
      <br/>
      FIG. 5 illustrates an API registration process in accordance with a preferred embodiment;
      <br/>
      FIG. 6 illustrates an API operation invocation process in accordance with a preferred embodiment;
      <br/>
      FIG. 7 illustrates a client event handler dispatch process in accordance with a preferred embodiment;
      <br/>
      FIG. 8 illustrates a client-resident event distribution process used to pass an event to the registered API in accordance with a preferred embodiment;
      <br/>
      FIG. 9 illustrates a server event handler process to pass an event to the client dispatcher in accordance with a preferred embodiment;
      <br/>
      FIG. 10 illustrates a constructor process for a logical object in accordance with a preferred embodiment;
      <br/>
      FIG. 11 illustrates an invocation process for a logical object in accordance with a preferred embodiment; and
      <br/>
      FIG. 12 illustrates operation of an application programmer interface having a logical object in accordance with a preferred embodiment.
    </p>
    <heading>DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
    <p num="22">Notations and Nomenclature</p>
    <p num="23">The following `notations and nomenclature` are provided to assist in the understanding of the present invention and the preferred embodiments thereof.</p>
    <p num="24">Application Programmer Interface (API)--The API is a definition for the classes and programmed-methods a programmer can use to implement an application.</p>
    <p num="25">Constructor--A programmed-method for initializing an instance of an object.</p>
    <p num="26">
      Framework--A framework is a set of classes that provide extensible facilities (using object-oriented methodologies) for performing services for the application program that uses the framework.
      <br/>
      Thus, frameworks are essentially groups of interconnected object classes that provide a pre-fabricated structure of portions of a working application.
      <br/>
      An API differs from a framework in that the framework is an implementation of the API.
      <br/>
      The framework also includes private methods and data that are not visible to the programmer who uses the API.
    </p>
    <p num="27">Java Native Interface (JNI)--An API that allows a Java program to invoke programmed-objects and other procedures that are not programmed in Java (for example, C or C++ procedures).</p>
    <p num="28">
      Logical Object--A composite object comprising one or more objects that cooperate in a client/server environment to provide an automatic network invocation of a remote programmed-method.
      <br/>
      The locality of the programmed-method (that is, whether it is located on the client or the server) is transparent to the programmer.
    </p>
    <p num="29">
      Management Information Service (MIS)--A MIS is a service provided by a server computer.
      <br/>
      Thus, the service is either a library or a framework that provides services to a client.
      <br/>
      The client and the server may reside in the same computer.
    </p>
    <p num="30">Programmed-method--A programmed-method is a procedure associated with an object-oriented object or class that performs a function on the object.</p>
    <p num="31">Remote Method Invocation (RMI)--A mechanism that allows distributed programming in a client/server environment using Java.</p>
    <p num="32">Topological node--A logical representation of a network device that is monitored by a management information server.</p>
    <p num="33">
      Procedure--A self-consistent sequence of steps leading to a desired result.
      <br/>
      These steps are those requiring physical manipulation of physical quantities.
      <br/>
      Usually these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated.
      <br/>
      These signals are referred to as bits, values, elements, symbols, characters, terms, numbers, or the like.
      <br/>
      It will be understood by those skilled in the art that all of these and similar terms are associated with the appropriate physical quantities and are merely convenient labels applied to these quantities.
    </p>
    <p num="34">Overview</p>
    <p num="35">
      The manipulations performed by a computer in executing programmed instructions are often referred to in terms, such as adding or comparing, that are commonly associated with mental operations performed by a human operator.
      <br/>
      In the present invention no such capability of a human operator is necessary in any of the operations described herein.
      <br/>
      The operations are machine operations.
      <br/>
      Useful machines for performing the operations of the invention include programmed general purpose digital computers or similar devices.
      <br/>
      In all cases the method of computation is distinguished from the method of operation in operating a computer.
      <br/>
      The present invention relates to method steps for operating a computer in processing electrical or other (e.g., mechanical, chemical) physical signals to generate other desired physical signals.
    </p>
    <p num="36">
      The invention also relates to apparatus for performing these operations.
      <br/>
      This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer as selectively activated or reconfigured by a computer program stored in the memory of a computer.
      <br/>
      The procedures presented herein are not inherently related to a particular computer or other apparatus.
      <br/>
      In particular, various general purpose machines may be used with programs written in accordance with the teachings herein, or it may prove more convenient to construct more specialized apparatus to perform the required method steps.
      <br/>
      The required structure for a variety of these machines will appear from the following description.
      <br/>
      Also, the invention may be embodied in a computer readable storage medium encoded with a program that causes a computer to perform the programmed logic.
    </p>
    <p num="37">Operating Environment</p>
    <p num="38">
      Some of the elements of a computer system, as indicated by general reference character 100, configured to support the invention are shown in FIG. 1 wherein a processor is shown, having a central processor unit (CPU) 103, a memory section 105 and an input/output (I/O) section 107.
      <br/>
      The I/O section 107 is connected to a keyboard 109, a display unit 111, a pointing device 113, a disk storage unit 115 and a CD-ROM drive unit 117.
      <br/>
      The CD-ROM drive unit 117 can read a CD-ROM medium 119 that typically contains a program and data 121.
      <br/>
      The CD-ROM drive unit 117, along with the CD-ROM medium 119, and the disk storage unit 115 comprise a filestorage mechanism.
      <br/>
      One skilled in the art will understand that the CD-ROM drive unit 117 can be replaced by a floppy disk, magnetic tape unit or similar device that accepts a removable media that can contain the program and data 121.
      <br/>
      In addition, the computer system 100 includes a network interface 123 that connects the processor 101 to a network 125.
      <br/>
      The network 125 can be used to communicate between the processor 101 and a networked computer 127.
      <br/>
      Such a computer system is an example of a system that is capable of executing procedures that embody the invention.
    </p>
    <p num="39">
      One skilled in the art will understand that client-server architectures enable the client program and the server program to be executed by the same computer or by separate networked computer systems.
      <br/>
      While the following description is cast within a networked computer system architecture, the description also applies to a single computer that hosts both the server and the client.
    </p>
    <p num="40">JAVA Management Adapter</p>
    <p num="41">
      FIG. 2A illustrates a client-server architecture, indicated by general reference character 200, that enables a multi-threaded client application programmed in one language to use a single threaded service provided by the server.
      <br/>
      The architecture 200 includes a client 201 that often is a computer or network appliance.
      <br/>
      One skilled in the art will understand that the subsequently described invention is applicable to fully featured large computers as well as thin-clients.
      <br/>
      The client 201 communicates to a server 203 that often is hosted on a computer separate from the computer that hosts the client 201.
      <br/>
      An application 205 executes in the client 201 and invokes procedures from an API 207.
      <br/>
      The API 207 can be an object-oriented framework or a procedural library.
      <br/>
      The API 207 communicates to a Java-Management-Adapter (JMA) 209 that resides on the server 203.
      <br/>
      The JMA 209 uses a Java-Native-Interface (JNI) 211 to access the functions of a portable management interface (PMI) 213. The PMI 213 is a multi-thread unsafe framework (written in C++) that provides access to a management information service (MIS) 215 (for example, Sun Microsystems Inc.'s Enterprise Manager (tm) ).
    </p>
    <p num="42">
      FIG. 2B illustrates a JMA architecture, indicated by general reference character 220, that includes a JMA dispatcher 221, a first server object 223 and a second server object 225.
      <br/>
      The client 201 communicates with the JMA dispatcher 221 to create server objects such as the first server object 223 and the second server object 225.
      <br/>
      A server object exists for each client that registers with the JMA dispatcher 221.
      <br/>
      The JMA dispatcher 221 is an object factory that creates a server object in the server 203 for each registered client.
    </p>
    <p num="43">
      FIG. 2C illustrates a server object environment, indicated by general reference character 230, that serializes access from a multi-threaded client to the MIS 215.
      <br/>
      The server object environment 230 includes a server object 231 that contains a `server event handler` thread 233 and a `controlling PMI` thread 235 that creates an exclusion lock 237.
      <br/>
      The exclusion lock 237 serializes a thread, such as a `PMI operation` thread 239 that operates on a JNI/PMI procedure 241.
      <br/>
      The `PMI operation` thread 239 is started by the `controlling PMI` thread 235 in response receipt, by the server object 231, of a request to perform an operation from the API 207.
      <br/>
      Once the `PMI operation` thread 239 obtains the exclusion lock 237 the `PMI operation` thread 239 can invoke a JNI/PMI procedure 241 to access the requested service.
    </p>
    <p num="44">The `server event handler` thread 233 receives event conditions from the JNI/PMI procedure 241 and passes these events to the client 201 associated with the server object 231.</p>
    <p num="45">
      FIG. 3 illustrates a server creation process, indicated by general reference character 300, used by the client portion of the JMA dispatcher to instantiate a JMA server object.
      <br/>
      The server creation process 300 initiates at a `start` terminal 301 and continues to a `receive newserver message` procedure 303 that receives a `new server` message.
      <br/>
      The `new server` message is processed by a `lookup host` procedure 305 that uses a uniform resource locator (URL) string supplied with the `new server` message to locate and make a connection with the server computer system.
      <br/>
      If no URL string is provided, the `lookup host` procedure 305 assumes that the service is located on the same computer as the client.
      <br/>
      Once the server system is located, the server creation process 300 continues to a `lookup JMA dispatcher` procedure 307 that locates the JMA dispatcher using methods well known in the art such as connecting to a known port, or by using a directory to find the dispatcher.
      <br/>
      Next, an `instantiate new server` procedure 309 causes the JMA dispatcher application on the server to instantiate a new server object on the server system.
      <br/>
      The new server object provides the desired services to the client.
      <br/>
      Then the server creation process 300 continues to a `lookup new server` procedure 311 that locates the just-created server object executing on the server computer system.
      <br/>
      Then the server creation process 300 continues to a `start eventdispatch thread` procedure 313 that initiates a thread used to dispatch events received by the just-created server to objects that have registered to receive specified events.
    </p>
    <p num="46">
      Once the client event dispatch thread is started by the `start eventdispatch thread` procedure 313 the server creation process 300 continues to a `connect with new server's event handler thread` procedure 315 that causes the event dispatch thread to connect with the server's event handling thread (subsequently described with respect to FIG. 4).
      <br/>
      Then the server creation process 300 completes through an `end` terminal 317.
    </p>
    <p num="47">
      FIG. 4 illustrates a server initialization process, indicated by general reference character 400, that is invoked by the `instantiate new server` procedure 309 of FIG. 3.
      <br/>
      The server initialization process 400 initiates at a `server object start` terminal 401 and continues to a `start initial PMI thread` process 403 that starts the initial PMI access thread.
      <br/>
      This thread is used to initialize the PMI through the JNI.
      <br/>
      This thread also establishes the locking mechanisms used to serialize access, by other PMI operation threads within the server object, to the PMI framework.
      <br/>
      One skilled in the art will understand that other thread-unsafe frameworks can be accessed using these techniques.
      <br/>
      Once the initial PMI thread is started, the server initialization process 400 continues to a `start event handler thread` process 405 that is used to route events generated by the MIS to the appropriate client.
      <br/>
      Then, a `connect with client's eventdispatch thread` process 407 waits until the `connect with new server's event handler thread` procedure 315 attempts a connection with the event handler thread that was started by the `start event handler thread` process 405.
      <br/>
      Once the server's event-handler thread is connected with the client's event dispatch thread, the server initialization process 400 completes though an `end` terminal 409.
      <br/>
      Once the server initialization process 400 completes, the server is able to receive, process, and return results for requests from applications executing on the client and is able to pass events from the server to the client.
    </p>
    <p num="48">
      FIG. 5 illustrates an API registration process, illustrated by general reference character 500, that registers an API, such as an alarm API, with the JMA.
      <br/>
      The API registration process 500 initiates at a `register API start` terminal 501 in response to the API invoking the registration process.
      <br/>
      The API registration process 500 continues to an `instantiate API service` procedure 503 that instantiates a JMA service for the requesting API.
      <br/>
      After the service is instantiated, the service starts an API service at a `start API service` procedure 505.
      <br/>
      The API service will be used to service requests made to the JMA from the API.
    </p>
    <p num="49">
      After the API service is started, the API registration process 500, returns the API handle at a return API service handle' procedure 507.
      <br/>
      The returned API handle corresponds to the API service instantiated at the `instantiate API service` procedure 503.
      <br/>
      The API registration process 500 completes through an `end` terminal 509.
      <br/>
      The API can request services (operations) from the JMA once the API is registered.
    </p>
    <p num="50">
      FIG. 6 illustrates an API operation process, indicated by general reference character 600, that processes a PMI invocation that resulted from an API operation.
      <br/>
      The API operation process 600 initiates at an `API operation start` terminal 601 in response to the API application requesting a JMA service that invokes a PMI service.
      <br/>
      The API operation process 600 continues to an `invoke lock PMI` procedure 603 that acquires the PMI lock established by the initial PMI thread created by the `start initial PMI thread` process 403 of FIG. 4.
      <br/>
      One skilled in the art will understand that the thread is suspended until the thread is able to acquire the lock.
      <br/>
      In addition, one skilled in the art will understand that the API service thread assigns a thread to effectuate the requested operation.
      <br/>
      Once the lock is acquired the API operation process 600 continues to an `invoke PMI operation` procedure 605.
      <br/>
      The `invoke PMI operation` procedure 605 now invokes the appropriate PMI operation from the PMI framework through the JNI.
      <br/>
      Once the PMI operation returns, a `release PMI lock` procedure 607 releases the PMI lock to allow other threads access to the PMI framework.
      <br/>
      If a result is returned by the PMI operation the operation result value is returned to the API application.
      <br/>
      Finally, the process completes through an `end` terminal 609.
      <br/>
      Thus, the API operation process 600 serializes access to the PMI framework and performs the operation requested by the API.
      <br/>
      In addition, one skilled in the art will understand that the operations used by the JMA can be applied to services other than the PMI framework and may be provided by a traditional routine library.
    </p>
    <p num="51">
      The JMA-API interface is optimized with respect to handling events.
      <br/>
      Instead of using RMI or other client/server object communication packages, this interface uses a TCP/IP socket or equivalent.
    </p>
    <p num="52">
      FIG. 7 illustrates a client event-dispatch process, indicated by general reference character 700, that processes events delivered by the server event handler thread that is subsequently described with respect to FIG. 9.
      <br/>
      The process 700 initiates at a `start` terminal 701 and continues to a `delay for server` procedure 703 that waits for the start of the server's event handler thread (invoked by the `start event handler thread` process 405 of FIG. 4).
      <br/>
      The `delay for server` procedure 703 completes when the process 700 receives the connection initiated by the `connect with client's eventdispatch thread` process 407.
      <br/>
      Once the process 700 detects that the server event handler has started, the process continues at a `start incoming event threads` procedure 705.
      <br/>
      The `start incoming event threads` procedure 705 generates enough threads to handle (at most) the maximum number of events expected during the time required to process the longest event.
      <br/>
      Next a `receive API event listener registration` procedure 707 waits for an API to register with the process 700.
      <br/>
      The event listener registration is sent by the `connect with new server's event handler thread` procedure 315 of FIG. 3.
      <br/>
      The `receive API event listener registration` procedure 707 stores the identification of the API and the event types that are of interest to the API.
      <br/>
      Next, the process 700 waits at an `event delivery` procedure 708 for receipt of an event generated and sent from any relevant event source (such as the MIS).
      <br/>
      Next, an `assign event to thread` procedure 709 assigns the event to a thread for processing.
      <br/>
      Once the event is assigned to a thread, the thread executes a `pass event to registered API` procedure 711 that determines which registered APIs (if any) have requested notification for the event and distributes the event to those APIs.
      <br/>
      Events are sent from the server's event handler process as is subsequently described with respect to FIG. 9.
      <br/>
      Then the process 700 continues to a `termination requested` decision procedure 713 that determines whether the process 700 is to terminate.
      <br/>
      If the process 700 is to continue, the process returns to the `assign event to thread` procedure 709 and wait for the next event.
      <br/>
      However, if the process is to terminate, it continues to a `stop threads` procedure 715 that kills the threads started at the `start incoming event threads` procedure 705.
      <br/>
      Then the process completes through an `end` terminal 717.
    </p>
    <p num="53">
      FIG. 8 illustrates a `pass event to API` process, indicated by general reference character 800, that is invoked by the `pass event to registered API` procedure 711 of FIG. 7.
      <br/>
      The process 800 initiates at a `start` terminal 801 and continues to an `event ID match` decision procedure 803 that examines the event to determine whether an API has registered for that particular type of event.
      <br/>
      If the `event ID match` decision procedure 803 successfully matches the event with a registered API, the process 800 continues to a `pass copy of event to APIs event handler` procedure 805 that passes a copy of the event to those APIs that have registered to receive events of that type.
      <br/>
      In a preferred embodiment this event communications is handled by a low overhead communication mechanism such as TCP/IP sockets or equivalent.
      <br/>
      Then the process 800 continues to a `dereference event` procedure 807 that dereferences the original event.
      <br/>
      If the `event ID match` decision procedure 803 determines that the event is not of interest to any of the registered APIs, the process simply continues to the `dereference event` procedure 807.
      <br/>
      After the `dereference event` procedure 807 finishes the process 800 completes through an `end` terminal 809.
    </p>
    <p num="54">
      FIG. 9 illustrates a `server event handler` process, indicated by general reference character 900, that receives an event that occurs on the server and passes the event to the client event-dispatch process 700 of FIG. 7.
      <br/>
      The `server event handler` process 900 initiates at a `start` terminal 901 and continues to a `receive event` procedure 903.
      <br/>
      The `receive event` procedure 903 receives an event generated at the server.
      <br/>
      Then a `send event to client` procedure 905 sends the event to the client's event dispatcher (previously described with respect to FIG. 7) where the event is received at the `event delivery` procedure 708.
      <br/>
      Then the `server event handler` process 900 completes through an `end` terminal 907.
    </p>
    <p num="55">Thin-Class</p>
    <p num="56">
      A thin-class is a logical class (that defines a logical object) that is implemented to reduce the resource usage on the client.
      <br/>
      One advantage of the thin-class is that it hides the complexity involved with programming distributed applications.
      <br/>
      The thin-class also makes the distributed nature of the object transparent to the programmer because the thin class automatically invokes the client-server communication mechanism (if required) to communicate to a programmed-method located on the server.
      <br/>
      The underlying transport mechanism used in the client-server communication is often the remote method invocation (RMI) mechanism, object request broker mechanism such as defined by the CORBA standard, or some other similar mechanism.
      <br/>
      Finally, the thin-class allows an API programmer to balance execution speed and memory usage required to effectuate the API by specifying the locality of the programmed-methods used in the class.
      <br/>
      Thus simple programmed-methods may be located at the client while more complex programmed-methods may be located at the server.
      <br/>
      The programmer of an application that uses a logical object of the API is completely unaware of the locality of the programmed-methods for that logical object.
    </p>
    <p num="57">
      FIG. 10 illustrates a `thin class constructor` process, indicated by general reference character 1000, used by a logical object when the logical object is instantiated.
      <br/>
      The `thin class constructor` process 1000 initiates at a `start` terminal 1001 and continues to an `instantiate local portion` procedure 1003.
      <br/>
      The `instantiate local portion` procedure 1003 creates an object on the client that provides programmed-methods for the logical object that execute on the client.
      <br/>
      These programmed-methods generally are those that are small enough and simple enough so that the thin-client's resources are not adversely affected by the instantiation of the object or execution of the associated programmed-methods.
      <br/>
      One example of such an object would be an object that contains limited private data and has programmed-methods that provide access to this private data.
      <br/>
      Such programmed-methods are generally small and execute sufficiently rapidly that they are appropriately implemented on the thin-client.
      <br/>
      Next, the `thin class constructor` process 1000 continues to an `initialize communication with server` procedure 1005 that initiates communication with the fat-server.
      <br/>
      This procedure generally locates the server host and connects to a known process.
      <br/>
      An `instantiate remote portion` procedure 1007 causes the known process to instantiate a remote portion of the logical object on the fat-server.
      <br/>
      The remote portion includes programmed-methods that would impact the operation of the thin-client.
      <br/>
      The API developer determines whether the thin-client or fat-server should execute the programmed-methods and implements the API accordingly.
      <br/>
      Finally, the `thin class constructor` process 1000 completes through an `end` terminal 1009.
      <br/>
      One skilled in the art will understand that the `thin class constructor` process 1000 creates object stubs and skeletons as appropriate when the client-server communication mechanism is RMI.
      <br/>
      Equivalent mechanisms exist, or can be constructed, for other client-server communication technologies.
    </p>
    <p num="58">
      FIG. 11 illustrates a logical object programmed-method invocation process, indicated by general reference character 1100, for invoking a logical object's programmed-method.
      <br/>
      The logical object programmed-method invocation process 1100 initiates at a `start` terminal 1101 and continues to a `remote method` decision procedure 1103.
      <br/>
      The `remote method` decision procedure 1103 determines whether the programmed-method to be executed is located in the client portion or in the server portion of the logical object.
      <br/>
      If the programmed-method is located in the client portion, the logical object programmed-method invocation process 1100 continues to an `invoke local method` procedure 1105 that dispatches the programmed-method resident in the client.
      <br/>
      The programmed-method executes in the client and using the data resident in the client portion of the logical object.
      <br/>
      Once the programmed-method returns, the logical object programmed-method invocation process 1100 completes through an `end` terminal 1107.
    </p>
    <p num="59">
      However, if the `remote method` decision procedure 1103 determines that the programmed-method to be executed resides in the server portion of the logical object, the logical object programmed-method invocation process 1100 continues to an `invoke stub method` procedure 1111.
      <br/>
      The `invoke stub method` procedure 1111 sends a copy of the logical object's instance variables in the client portion to the server portion and then invokes the stub object that corresponds to the skeleton object resident in the server portion of the logical object.
    </p>
    <p num="60">
      In an RMI embodiment, the `invoke stub method` procedure 1111 communicates with a skeleton object located within the server portion of the logical object.
      <br/>
      This communication causes an `invoke skeleton method` procedure 1113 to cause the remote programmed-method to execute.
      <br/>
      An `execute remote method` procedure 1115 executes the programmed-method in the server using the instance variable values sent by the `invoke stub method` procedure 1111.
      <br/>
      Next, a `send remote data` procedure 1117 sends the possibly modified instance variable data from the server portion of the logical object back to the client portion of the logical object to update the client's portion of the logical object.
      <br/>
      The logical object programmed-method invocation process 1100 then completes through the `end` terminal 1107.
    </p>
    <p num="61">One skilled in the art will understand that although the previous description is directed towards an embodiment that uses the RMI capabilities of Java, that the user of other object communication protocols, such as CORBA, are contemplated by the invention.</p>
    <p num="62">
      In addition, once the local and remote portions of the logical object are constructed, the application can invoke the API logical object's methods transparently as to whether the method is actually executed by the client or by the server.
      <br/>
      Thus, programming applications for thin-clients is greatly simplified by the use of APIs that implement thin-classes.
      <br/>
      Such an API hides the details of the client/server communication from the programmer and allows the programmer to transparently use the API without regard to any underlying inter-program communication issues.
      <br/>
      The programmer of an application that uses the API can transparently use the API objects without concern as to whether the object executes in the client or in the server and the method will be automatically executed on the server as appropriate.
      <br/>
      Instead this consideration is analyzed by the programmer of the API who determines which methods are to be executed in the client and the server.
      <br/>
      Some embodiments of the API allow dynamic determination of the locality of the logical object's methods.
      <br/>
      These embodiments determine the capabilities and resources of the client and determine the locality of the methods dependent on this determination.
    </p>
    <p num="63">The use of a thin-class also enables the underlying inter-program communication mechanism (i.e., RMI, CORBA or other mechanism) to be changed without requiring a change to the application program.</p>
    <heading>ALARM API</heading>
    <p num="64">
      One aspect of the invention is that of an alarm API.
      <br/>
      The alarm API provides the programmer with facilities for accessing a management information service (MIS) from a thin-client.
      <br/>
      Thus, an application designed to display alarm information about networked devices can use the alarm API to obtain information about those devices.
      <br/>
      The API is an implementation of the previously described thin-class.
    </p>
    <p num="65">
      The API programmer determines which methods are local (to be executed on the client) and which are remote (executed on the server).
      <br/>
      The programmer who uses the API need not understand where the programmed-method is executed.
      <br/>
      The server/client communication is transparent to the programmer who uses the API.
      <br/>
      Thus, even in very thin-clients programmers need not balance the tradeoffs generally required for using the thin-client as the API programmer has already done so.
    </p>
    <p num="66">
      The thin-client often receives an AlarmRecord in response to subsequently described methods.
      <br/>
      To minimize the amount of memory used in the thin-client and the bandwidth required between the thin-client and fat-server that contains the network database lo only selected portions of the AlarmRecord (the attributes-of-interest) are transferred.
      <br/>
      The selects which attributes-of-interest by specifying an argument of type AlarmRecordAttributeSet in the invocation of the appropriate programmed-methods.
    </p>
    <p num="67">In the following section, the term "method" is used to refer to a "programmed-method."</p>
    <p num="68">
      FIG. 12 illustrates a MIS access process, indicated by general reference character 1200, for providing a client with access to a MIS resident on a server.
      <br/>
      The process 1200 initiates at a `start` terminal 1201 by an application executing in the client and continues to an `instantiate API` procedure 1203.
      <br/>
      The `instantiate API` procedure 1203 instantiates an API in the client.
      <br/>
      Next, at a `specify attributes-of-interest` procedure 1205 the application specifies the attributes-of-interest.
      <br/>
      The attributes-of-interest specify which fields are included in records returned by the server.
      <br/>
      Next, the application invokes a method in the API at an `invoke API method` procedure 1207 that sends a message to the server to perform an operation.
      <br/>
      The server then executes the invoked method at an `execute API method` procedure 1209.
      <br/>
      This method accesses the MIS to obtain data and perform the desired operations on the data.
      <br/>
      Generally, this method generates results that are returned to the client at a `return values for attributes-of-interest` procedure 1211.
      <br/>
      Some methods recursively traverse the topology tree descending from a particular topological node in the network.
      <br/>
      These methods may return a result for each node traversed.
      <br/>
      The `return values for attributes-of-interest` procedure 1211 collects the values for the attributes-of-interest specified by the `specify attributes-of-interest` procedure 1205 and sends this information to the client where they can be accessed by the application.
      <br/>
      The returned information, for an alarm API, is in the form of alarm records.
      <br/>
      The process 1200 can return data about a monitored condition in the MIS.
      <br/>
      Where the MIS is a network MIS this data is often the status of a monitored device or topological node.
      <br/>
      This data can be provided to a user of the client application.
    </p>
    <p num="69">
      --      TABLE 1
      <br/>
      --      public class AlarmRecord implements Serializable +
      <br/>
      --         String getAckOperator ();
      <br/>
      --         boolean getAckState ();
      <br/>
      --         String getAckText ();
      <br/>
      --         Date getAckTime ();
      <br/>
      --         String getClearOperator ();
      <br/>
      --         boolean getClearState ();
      <br/>
      --         String getClearText ();
      <br/>
      --         Date getClearTime ();
      <br/>
      --         String getDisplayOperator ();
      <br/>
      --         boolean getDisplayState ();
      <br/>
      --         String getDisplayText ();
      <br/>
      --         Date getDisplayTime ();
      <br/>
      --         Date getEventTime ();
      <br/>
      --         int getEventType ();
      <br/>
      --         AlarmRecordId getLogRecordId ();
      <br/>
      --         Date getLoggingTime ();
      <br/>
      --         String getManagedObjectInstance ();
      <br/>
      --         EMSeverity getPerceivedSeverity ();
      <br/>
      --         String getProbableCause ();
      <br/>
      --         EMTopoNodeDn �� getTopoNodeDns ();
      <br/>
      --         String toString ();
      <br/>
      --      }
    </p>
    <p num="70">
      Table 1 is a listing of the public methods available to return data values from fields in the AlarmRecord.
      <br/>
      An exception occurs if an attempt is made to return a field that was not communicated to the client.
      <br/>
      In a preferred embodiment, the locality of each of these methods is on the client.
      <br/>
      The "String", "boolean", and "Date" types are well known Java data types.
      <br/>
      The AlarmRecordId type is an opaque object and EMSeverity is an instance of an object enumerated type that includes five values (critical, major, minor, warning and indeterminate), EMTopoNodeDn is an object that uniquely identifies a topology object.
    </p>
    <p num="71">The following describes the function of the public methods in the AlarmRecord.</p>
    <p num="72">
      getAckOperator ( )--This method returns a string that identifies the network administrator (a user) who acknowledged the alarm.
      <br/>
      getAckState ( )--This method returns a boolean that indicates whether the alarm has been acknowledged.
      <br/>
      getAckText ( )--This method returns a string that contains the user's message relating to the acknowledgment of the alarm.
      <br/>
      getAckTime ( )--This method returns the date and time when the user acknowledged the alarm.
      <br/>
      getClearOperator ( )--This method returns a string that identifies the user who cleared the alarm.
      <br/>
      getClearState ( )--This method returns a boolean that indicates whether the alarm has been cleared.
    </p>
    <p num="73">
      getClearText ( )--This method returns the text saved by the user who cleared the alarm relating to the clearing of the alarm.
      <br/>
      getClearTime ( )--This method returns the date and time when the user cleared the alarm.
      <br/>
      getDisplayOperator ( )--This method returns a string that identifies the user who added a comment string to the alarm.
      <br/>
      getDisplayState ( )--This method returns a boolean that indicates whether a user has added a comment string to the alarm.
      <br/>
      getDisplayText ( )--This method returns the comment string that was added to the alarm.
      <br/>
      getDisplayTime ( )--This method returns the date and time when the comment string was added to the alarm.
      <br/>
      getEventTime ( )--This method returns the date and time that the event occurred.
      <br/>
      getEventType ( )--This method identifies the alarm type.
      <br/>
      The alarm type indicates the type of the alarm.
      <br/>
      The alarm type indicates, without limitation, that the alarm is associated with the internet, communication, nerve center, quality of service, reoccurring error, equipment, or environment.
      <br/>
      getLogRecordId ( )--This method returns a unique AlarmRecordId identifier for this alarm record.
      <br/>
      getLoggingTime ( )--This method returns the date and time that the event was actually logged in the MIS.
      <br/>
      getManagedObjectInstance ( )--This method returns a string that is the fully distinguished name of the device that caused the alarm.
      <br/>
      getPerceivedSeverity ( )--This method returns the severity of the event.
      <br/>
      The severity values are defined in EMSeverity.
      <br/>
      getProbableCause ( )--This method returns a string that indicates the probable cause of the alarm.
      <br/>
      The probable cause strings are free-form text input by the network administrator.
      <br/>
      getTopoNodeDns ( )--This method returns an array of EMTopoNodeDn that contain the unique topology identifiers for the nodes affected by this alarm.
      <br/>
      toString ( )--This method returns a string that is a textual representation of the alarm record.
    </p>
    <p num="74">
      The AlarmLog class (shown in Table 2) provides a number of methods for obtaining information from and manipulating the alarm records within the MIS.
      <br/>
      In general, the locality of these methods are in the server (the exceptions are indicated).
      <br/>
      These methods are subsequently described.
      <br/>
      void clearAlarms (AlarmRecordId � �)--This method clears the alarms specified in the AlarmRecordId array.
      <br/>
      void deleteAlarms (AlarmRecordId � �)--This method deletes the alarms specified in the AlarmRecordId array.
      <br/>
      void acknowledgeAlarms (AlarmRecordId� �)--This method acknowledges the alarms specified in the AlarmRecordId array.
    </p>
    <p num="75">
      AlarmRecord � � getAlarms (AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains all alarms from the MIS.
      <br/>
      Each alarm contains only the alarm information specified by the "attrs" argument.
    </p>
    <p num="76">
      -- TABLE 2
      <br/>
      -- public class AlarmLog +
      <br/>
      --      AlarmLog (Platform platform);
      <br/>
      --      void clearAlarms (AlarmRecordId� �);
      <br/>
      --      void deleteAlarms (AlarmRecordId� �);
      <br/>
      --      void acknowledgeAlarms (AlarmRecordId� �);
      <br/>
      --      AlarmRecordId� � getAlarms (AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarms (AlarmRecordId� � alarmRecordIds,
      <br/>
      --                               AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarms (EMSeverity severity,
      <br/>
      --                               AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarms (String deviceFDN,
      <br/>
      --                               AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarms (EMTopoNodeDn deviceTopoNodeDn,
      <br/>
      --                               AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarms (String deviceFDN, EMSeverity severity,
      <br/>
      --                               AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarms (EMTopoNodeDn deviceTopoNodeDn,
      <br/>
      --                               EMSeverity severity,
      <br/>
      --                               AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarmsRecursive (
      <br/>
      --                           EMTopoNodeDn deviceTopoNodeDn,
      <br/>
      --                            AlarmRecordAttributeSet attrs);
      <br/>
      --      AlarmRecordId� � getAlarmsRecursive (
      <br/>
      --                           EMTopoNodeDn deviceTopoNodeDn,
      <br/>
      --                           EMSeverity severity,
      <br/>
      --                            AlarmRecordAttributeSet attrs);
      <br/>
      --      int getAlarmCount (String deviceFDN, EMSeverity severity);
      <br/>
      --      int getAlarmCount (EMTopoNodeDn deviceTopoNodeDn,
      <br/>
      --                           EMSeverity severity);
      <br/>
      --      int getAlarmCount (String deviceFDN);
      <br/>
      --      int getAlarmCount (EMTopoNodeDn deviceTopoNodeDn);
      <br/>
      --      int getAlarmCount (EMSeverity severity);
      <br/>
      --      int getAlarmCountRecursive (EMTopoNodeDn deviceTopoNodeDn);
      <br/>
      --      int getAlarmCountRecursive (EMTopoNodeDn deviceTopoNodeDn,
      <br/>
      --                              EMSeverity severity);
      <br/>
      --      int� � getAlarmCountRecursive (EMTopoNodeDn deviceTopoNodeDn,
      <br/>
      --                              EMSeverity� � severity);
      <br/>
      --      void setDisplayText (AlarmRecordId id, String displayText);
      <br/>
      --      void addAlarmListener (AlarmLogEventListener listener,
      <br/>
      --                       AlarmRecordAttributeSet attrs);
      <br/>
      --      void removeAlarmListener (AlarmLogEventListener listener);
      <br/>
      -- }
      <br/>
      AlarmRecord � � getAlarms (AlarmRecordId � � alarmRecordIds, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records identified by the alarmRecordIds array.
      <br/>
      Each alarm log record contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="77">
      AlarmRecord � � getAlarms (EMSeverity severity, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records that have the specified severity.
      <br/>
      Each alarm log record only contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="78">
      AlarmRecord � � getAlarms (String deviceFDN, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records for the device identified by the fully distinguished name string in the "deviceFDN" argument.
      <br/>
      Each alarm log record only contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="79">
      AlarmRecord � � getAlarms (EMTopoNodeDn deviceTopoNodeDn, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records for the topological node identified by the "deviceTopoNodeDn" argument.
      <br/>
      Each alarm log record only contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="80">
      AlarmRecord � � getAlarms (String deviceFDN, EMSeverity severity, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records for the specified fully distinguished device name that has a specified severity.
      <br/>
      Each alarm log record only contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="81">
      AlarmRecord � � getAlarms (EMTopoNodeDn deviceTopoNodeDn, EMSeverity severity, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records for the specified topological node that have the specified severity.
      <br/>
      Each alarm log record only contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="82">
      AlarmRecord � � getAlarmsRecursive (EMTopoNodeDn deviceTopoNodeDn, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records for the specified topological node and the alarm log records that are for topological nodes that are children of the specified topological node.
      <br/>
      Each alarm log record only contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="83">
      AlarmRecord � � getAlarmsRecursive (EMTopoNodeDn deviceTopoNodeDn, EMSeverity severity, AlarmRecordAttributeSet attrs)--This method returns an AlarmRecord array that contains the alarm log records for the specified topological node and the alarm log records that are for topological nodes that are children of the specified topological node; and that have the specified severity.
      <br/>
      Each alarm log record only contains the alarm information specified by the "attrs" argument.
    </p>
    <p num="84">
      The following methods return information about the number of alarms in the MIS.
      <br/>
      int getAlarmCount (String deviceFDN, EMSeverity severity)--This method returns an integer value of the number of alarms, of the specified severity, generated by the specified device.
      <br/>
      int getAlarmCount (EMTopoNodeDn deviceTopoNodeDn, EMSeverity severity)--This method returns an integer value of the number of alarms of the specified severity from the specified topological node.
      <br/>
      int getAlarmCount (String deviceFDN)--This method returns an integer value of the number of alarms from the specified device.
      <br/>
      int getAlarmCount (EMTopoNodeDn deviceTopoNodeDn)--This method returns an integer value of the number of alarms from the specified topological node.
      <br/>
      int getAlarmCount (EMSeverity severity)--This method returns an integer value of the number of alarms having a specified severity.
      <br/>
      int getAlarmCountRecursive (EMTopoNodeDn deviceTopoNodeDn)--This method returns an integer value of the number of alarms related to a specified topological node including the topological nodes that are children of the specified topological node.
      <br/>
      int getAlarmCountRecursive (EMTopoNodeDn deviceTopoNodeDn, EMSeverity severity)--This method returns an integer value of the number of alarms related to a specified topological node including the topological nodes that are children of the specified topological node that have the specified severity.
      <br/>
      int � � getAlarmCountRecursive (EMTopoNodeDn deviceTopoNodeDn, EMSeverity � � severity)--This method returns an array of integer values each being the number of alarms related to the specified topological node including the topological nodes that are children of the specified topological node that have the severities specified by the array of specified severities.
    </p>
    <p num="85">
      The following methods are used to perform miscellaneous functions.
      <br/>
      void setDisplayText (AlarmRecordId id, String displayText)--This method saves the displayText string into the record identified by id.
      <br/>
      This allows an operator to store a textual comment in the alarm record for retrieval by others.
      <br/>
      void addAlarmListener (AlarmLogEventListener listener, AlarmRecordAttributeSet attrs)--This method registers a method as an alarm listener with the MIS so that the MIS will send alarm objects to the registered method.
      <br/>
      The locality of this method is at the client.
      <br/>
      void removeAlarmListener (AlarmLogEventListener listener)--This method removes the previously registered alarm listener from the list of registered listeners.
      <br/>
      The locality of this method is at the client.
    </p>
    <p num="86">The AlarmLogEventListener class (Table 3) provides call-back methods responsive to particular events in the MIS.</p>
    <p num="87">
      --      TABLE 3
      <br/>
      --      public abstract class AlarmLogEventListener +
      <br/>
      --         void alarmRecordCreated (AlarmLogEvent event);
      <br/>
      --         void alarmRecordDeleted (AlarmLogEvent event);
      <br/>
      --         void alarmRecordModified (AlarmLogEvent event);
      <br/>
      --      }
      <br/>
      alarmRecordCreated (AlarmLogEvent event)--This call-back method is invoked on a registered alarm listener when a new alarm record is created in the MIS.
      <br/>
      The event argument is an object that provides access to the newly created alarm record.
      <br/>
      alarmRecordDeleted (AlarmLogEvent event)--This call-back method is invoked on a registered alarm listener when an existing alarm record is deleted in the MIS.
      <br/>
      The event argument is an object that identifies the deleted alarm record.
      <br/>
      alarmRecordModified (AlarmLogEvent event)--This call-back method is invoked on a registered alarm listener when an existing alarm record is modified in the MIS.
      <br/>
      The event argument is an object that provides access to the modified alarm record.
    </p>
    <p num="88">
      The AlarmLogEvent class (shown in Table 4) obtains information relating to MIS events.
      <br/>
      The locality of these method is at the client.
    </p>
    <p num="89">
      -- TABLE 4
      <br/>
      -- public class AlarmLogEvent implements java.io. Serializable +
      <br/>
      --      public static final int OBJECT_CREATED = 1
      <br/>
      --      public static final int OBJECT_DELETED = 2
      <br/>
      --      public static final int ATTR_VALUE_CHANGED = 3
      <br/>
      --      public static final int STATE_CHANGED = 4
      <br/>
      --      public static final int RELATIONSHIP_CHANGED = 5
      <br/>
      --      int getEventType( );
      <br/>
      --      AlarmRecord getAlarmRecord( );
      <br/>
      --      AlarmRecordId getAlarmRecordId( );
      <br/>
      -- }
      <br/>
      int getEventType ( )--This method returns an integer that classifies the returned event by returning one of the above defined values (OBJECT_CREATED, OBJECT_DELETED, ATTR_VALUE_CHANGED, STATE_CHANGED, RELATIONSHIP_CHANGED).
      <br/>
      int getAlarmRecord ( )--This method returns the AlarmRecord that was created or modified.
      <br/>
      int getAlarmRecordId ( )--This method returns the AlarmRecordId for the AlarmRecord that was created, deleted, or modified.
    </p>
    <p num="90">From the foregoing, it will be appreciated that the invention has (without limitation) the following advantages:</p>
    <p num="91">
      1.
      <br/>
      The invention provides an API that interfaces to a networked MIS.
    </p>
    <p num="92">2. The invention limits the amount of data that is sent from the server to the client by allowing the programmer to specify attributes-of-interest.</p>
    <p num="93">3. The invention locates recursive and other compute or I/O intensive operations at the server thus limiting the processing impact on the client and limiting the data flow over the client/server communication mechanism.</p>
    <p num="94">4. The invention provides a JAVA API that accesses a non-JAVA MIS.</p>
    <p num="95">
      Although the present invention has been described in terms of the presently preferred embodiments, one skilled in the art will understand that various modifications and alterations may be made without departing from the scope of the invention.
      <br/>
      Accordingly, the scope of the invention is not to be limited to the particular invention embodiments discussed herein, but should be defined only by the appended claims and equivalents thereof.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A computer controlled method for providing a client application with access to management information services (MIS) provided by a server, said MIS containing data about a monitored condition in a computer network, said method comprising steps of:</claim-text>
      <claim-text>(a) instantiating, by said client application, a logical object associated with said MIS; (b) invoking a programmed-method of said logical object by said client application;</claim-text>
      <claim-text>and (c) executing said programmed-method at said server to access said MIS.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The computer controlled method of claim 1 wherein said monitored condition is a status of a monitored device.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The computer controlled method of claim 1 wherein said monitored condition is a status of a topological node.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The computer controlled method of claim 1 further comprising: (d) returning said data to said client application after execution of said programmed-method.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The computer controlled method of claim 4 wherein said data comprises a plurality of attributes, and step (d) further comprises steps of: (d1) specifying an attribute of interest of said data;</claim-text>
      <claim-text>and (d2) returning said attribute of interest to said client application after execution of said programmed-method.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The computer controlled method of claim 4 further comprising: (e) presenting said data to a user of said client application.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The computer controlled method of claim 1 wherein step (c) further comprises recursively executing said programmed-method on a child node of a specified topological node.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. An apparatus having a central processing unit (CPU) and a memory coupled to said CPU for providing a client application with access to management information services (MIS) provided by a server, said MIS containing data about a monitored condition in a computer network, said apparatus comprises: an instantiation mechanism configured to instantiate, responsive to said client application, a logical object associated with said MIS; a method invocation mechanism configured in invoke a programmed-method of said logical object by said client application;</claim-text>
      <claim-text>and an execution mechanism configured to execute said programmed-method at said server to access said MIS.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The apparatus of claim 8 wherein said monitored condition is a status of a monitored device.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The apparatus of claim 8 wherein said monitored condition is a status of a topological node.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The apparatus of claim 8 further comprising: a data return mechanism configured to return said data to said client application after execution of said programmed-method at said server.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The apparatus of claim 11 wherein said data comprises a plurality of attributes, and step (d) further comprises steps of: an attribute specification mechanism configured to specify an attribute of interest of said data;</claim-text>
      <claim-text>and an attribute return mechanism configured to return said attribute of interest to said client application after execution of said programmed-method.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The computer controlled method of claim 8 wherein the execution mechanism further comprises a recursive mechanism configured to recursively execute said programmed-method on a child node of a specified topological node.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The apparatus of claim 11 further comprising: a data presentation mechanism configured to present said data to a user of said client application.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A computer program product comprising: a computer usable storage medium having computer readable code embodiment therein for causing a computer to provide a client application with access to management information services (MIS) provided by a server, said MIS containing data about a monitored condition in a computer network, said computer readable code comprising:</claim-text>
      <claim-text>- computer readable program code configured to cause said computer to effect an instantiation mechanism configured to instantiate, responsive to said client application, a logical object associated with said MIS; - computer readable program code configured to cause said computer to effect a method invocation mechanism configured to invoke a programmed-method said logical object by said client application;</claim-text>
      <claim-text>and - computer readable program code configured to cause said computer to effect an execution mechanism configured to execute said programmed-method at said server to access said MIS.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The computer program product of claim 15 wherein said monitored condition is a status of a monitored device.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The computer program product of claim 15 wherein said monitored condition is a status of a topological node.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The computer program product of claim 15 further comprising: computer readable program code configured to cause said computer to effect a data return mechanism configured to return said data to said client application after execution of said programmed-method at said server.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The computer program product of claim 18 wherein said data comprises a plurality of attributes, and step (d) further comprises steps of: computer readable program code configured to cause said computer to effect an attribute specification mechanism configured to specify an attribute of interest of said data;</claim-text>
      <claim-text>and computer readable program code configured to cause said computer to effect an attribute return mechanism configured to return said attribute of interest to said client application after execution of said programmed-method.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The computer program product of claim 18 further comprising: computer readable program code configured to cause said computer to effect a data presentation mechanism configured to present said data to a user of said client application.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The computer controlled method of claim 15 wherein the execution mechanism further comprises computer readable program code configured to cause said computer to effect a recursive mechanism configured to recursively execute said programmed-method on a child node of a specified topological node.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. A method for providing a client program with access to management information services of a computer network, the management information services being provided by a server program in the computer network, said method comprising: placing a remote method invocation call by the client program to access the management information services provided by the server program; invoking a method of a server program at the server program responsive to the remote method invocation call placed by the client program;</claim-text>
      <claim-text>and executing the method of the server program to access the management information services.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. A method of claim 22, wherein the remote method invocation call is placed by using an application programming interface.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A method of claim 22, wherein the method further comprises: specifying attributes of the management information services that are of interest;</claim-text>
      <claim-text>and returning the specified attributes to the client program after said executing of the method of the server program.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. A method of claim 22, wherein the management information services provides data about status of a monitored device or a topological node.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. A method of claim 24, wherein the returned attributes include at least a portion of an alarm information record or at least a portion of an alarm log record.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. A method of claim 24, wherein the returned attributes are a JAVA implemented alarm record class or a JAVA implemented alarm log class.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. A method of claim 22, wherein the method further comprises: returning data obtained by said executing of the procedure.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. A method of claim 22, wherein the method further comprises: instantiating at least one logical object associated with accessing the management information services.</claim-text>
    </claim>
  </claims>
</questel-patent-document>