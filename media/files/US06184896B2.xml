<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06184896B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06184896</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6184896</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="22853070" extended-family-id="14440370">
      <document-id>
        <country>US</country>
        <doc-number>09227428</doc-number>
        <kind>A</kind>
        <date>19990108</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09227428</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>14762942</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>22742899</doc-number>
        <kind>A</kind>
        <date>19990108</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09227428</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06T   3/60        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>3</main-group>
        <subgroup>60</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06T  15/00        20110101AFI20140220RHJP</text>
        <ipc-version-indicator>
          <date>20110101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>15</main-group>
        <subgroup>00</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06T  19/00        20110101ALI20140220RHJP</text>
        <ipc-version-indicator>
          <date>20110101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>19</main-group>
        <subgroup>00</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140220</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>345644000</text>
        <class>345</class>
        <subclass>644000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>345649000</text>
        <class>345</class>
        <subclass>649000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>345660000</text>
        <class>345</class>
        <subclass>660000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>382296000</text>
        <class>382</class>
        <subclass>296000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>382298000</text>
        <class>382</class>
        <subclass>298000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06T-003/60</text>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>3</main-group>
        <subgroup>60</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06T-003/60</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>3</main-group>
        <subgroup>60</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>29</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>10</number-of-drawing-sheets>
      <number-of-figures>13</number-of-figures>
      <image-key data-format="questel">US6184896</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">System and method for improved rendering of graphical rotations</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>PARK YOU-KEUN</text>
          <document-id>
            <country>US</country>
            <doc-number>5295237</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5295237</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>KABA JAMES T C</text>
          <document-id>
            <country>US</country>
            <doc-number>5568600</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5568600</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>SUGIURA MASATAKA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5581665</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5581665</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>SZELISKI RICHARD, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6018349</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6018349</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>LENGYEL JEROME E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6064393</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6064393</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Flusser, J., "Invariant shape description and measure of object similarity", Image Processing and its Applications, 1992, International Conference on 1992, pp. 139-142.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Johnson, M., "A fixed-point DSP for graphics engines", IEEE Micro, vol. 9 Issue: 4, Aug. 1989, pp. 63-77.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Sun Microsystems, Inc.</orgname>
            <address>
              <address-1>Palo Alto, CA, US</address-1>
              <city>Palo Alto</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>SUN MICROSYSTEMS</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Sowizral, Henry A.</name>
            <address>
              <address-1>Los Altos, CA, US</address-1>
              <city>Los Altos</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Zikan, Karel</name>
            <address>
              <address-1>Seattle, WA, US</address-1>
              <city>Seattle</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Conley, Rose &amp; Tayon P.C.</orgname>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>Hood, Jeffrey C.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Powell, Mark R.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>GRANTED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A system and method for rendering of graphical rotations.
      <br/>
      The system includes a processor coupled to system memory, a display device, and optionally a graphics accelerator.
      <br/>
      The processor operates on a matrix M with a matrix operator having the properties of consistency on rotations and attraction to rotations.
      <br/>
      The matrix operator may be applied more than once to achieve greater error attenuation.
      <br/>
      The processor, or alternatively the graphics accelerator, performs image graphical rendering calculations using resultant matrix L obtained from applying the matrix operator.
      <br/>
      A first approximate rotation representing a previous orientation for a graphical object, and a second approximate rotation matrix representing a desired rotation to be applied to the graphical object, are multiplied to obtain matrix M which represents an updated orientation for the graphical object.
      <br/>
      The second approximate rotation matrix is generated in response to a sensor input provided by a user or from orientation information stored in a data structure.
      <br/>
      Furthermore, an iterative method for generating a sequence of approximate rotation matrices in response to user input or stored control information, and for rendering a series of rotation updates of a graphical object on a display screen is also contemplated.
      <br/>
      The matrix M representing the result of a matrix multiplication step is updated periodically or pseudo-periodically using a matrix operator having the consistency and attraction properties.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates generally to the computation of rotations in any dimension, and more particularly, to graphics applications which require the multiplication of two or more rotation matrices or approximate rotation matrices.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      Modern computer graphics extensively uses matrices and matrix methods to represent graphical objects and operations.
      <br/>
      For example, in the context of 2D graphics, a point P may be represented as a column vector P=�x y�t, and multiplied by the rotation matrix  (Equation image '1' not included in text)
    </p>
    <p num="3">
      in order to achieve a counterclockwise rotation by angle  THETA .
      <br/>
      In other words, the point  (Equation image '2' not included in text)
    </p>
    <p num="4">is the rotated image of point P. It is noted that the superscript t associated with a matrix or vector argument indicates transposition.</p>
    <p num="5">Similarly, in the context of 3D graphics, a point P may be represented as a column vector P=�x y �t, and multiplied by a 3 * 3 rotation matrix R in order to achieve a 3D rotation; i.e. the resultant point P'=R * P is the rotated image of point P. For example, the matrix  (Equation image '3' not included in text)</p>
    <p num="6">achieves a rotation of angle  THETA  about the z axis when multiplied by point P. Rotations about the x and y axes respectively are achieved by the matrices  (Equation image '4' not included in text)</p>
    <p num="7">respectively.</p>
    <p num="8">
      It is a basic geometric fact that any 3D rotation can be achieved by applying in succession a rotation about the x axis, a rotation about the y axis, and a rotation about the z axis. �Similar statements can be made about any ordering of the axial rotations.� Thus, the rotation matrices may be defined as the set of all matrices generated by the products Rx (.o slashed.) * Ry ( PHI ) * Rz ( THETA ) where the angles .o slashed.,  PHI , and  THETA  vary freely.
      <br/>
      However, one may equivalently (and more usefully) characterize the rotation matrices as the set of matrices A which (a) are orthogonal and (b) have determinant equal to one.
      <br/>
      To say that a matrix A is orthogonal means that (i) all its rows have length one, and (ii) each row is perpendicular to the other rows.
      <br/>
      In mathematical notation, the orthogonality conditions (i) and (ii) may be summarized by the matrix equation AAt=I, where the matrix I is the identity matrix.
      <br/>
      Using the later characterization of rotation matrices as orthogonal matrices having determinant one, it is an elementary exercise to show that the product of two rotation matrices is itself a rotation matrix.
      <br/>
      In fact, a product of arbitrarily many rotation matrices is also a rotation matrix.
    </p>
    <p num="9">
      In graphical computing systems, it is quite typical to represent a graphical object as a collection of vertices +Pi }. In order to rotate the graphical object, each vertex Pi of the collection is multiplied by a rotation matrix R which represents the desired rotation.
      <br/>
      The resultant vertices P'i =RPi from the matrix multiplication may be used to render the rotated graphical object on a display screen.
    </p>
    <p num="10">
      FIG. 1 illustrates two successive rotations of a cube centered about the origin of a coordinate system +x,y,z}. In an initial orientation U0, the cube is aligned with edges parallel to the coordinate axes.
      <br/>
      A first rotation of the cube may be achieved by multiplying the vertices +Pi } of the cube in the initial orientation U0 by a first rotation matrix R1.
      <br/>
      For example, vertex P1 of the cube in orientation U0 may be represented as a column vector P1 =�x1 y1 z1 �t, where x1, y1, and z1 are the coordinates of vertex P1 with respect to the coordinate system +x,y,z}. The rotated image of vertex P1, depicted as vertex P'1 in orientation U1, is determined by the matrix-vector product P'1 =R1 * P1.
      <br/>
      Similarly, each vertex Pi of the cube in orientation U0 is multiplied by the rotation matrix R1 to determine a corresponding vertex P'i in orientation U1.
      <br/>
      The vertices +P'i } may be used to render the cube in orientation U1 on a display screen.
    </p>
    <p num="11">
      A second rotation may be achieved by multiplying the vertices +P'i } of the cube in orientation U1 by a second rotation matrix R2.
      <br/>
      Thus, the vertices +P"i } of the cube in orientation U2, i.e., after the second rotation, are given by P"i =R2 * P'i.
      <br/>
      It is noted that the combined effect of the two rotations may be achieved with a single rotation matrix R equal to the matrix product R2 R1 ; i.e., multiplying the vertices +Pi } of the cube in orientation U0 by the rotation matrix R=R2 R1 generates the corresponding vertices +Pi } in orientation U2.
      <br/>
      Thus, the rotation matrix R may be interpreted as a representation of orientation U2.
      <br/>
      In fact, each orientation Ui may be represented by the matrix required to generate the vertices of that orientation from the initial orientation U0.
      <br/>
      Thus, initial orientation U0 is represented by the identity matrix I, and orientation U1 is represented by the rotation matrix R1.
    </p>
    <p num="12">
      Quite often in computer graphics, it is desirable to apply a series of rotations in succession to a graphical object.
      <br/>
      As described above, the graphical object is typically represented in an initial orientation as a collection of vertices +Pi }. Given a series of rotation matrices R1,R2, . . . , Rn which represent the desired rotations, there are two fundamental methods for computing the vertices of the graphical object after each successive rotation.
      <br/>
      Let +Pi(k) } denote the vertices of the graphical object after the first k rotations have been applied where k varies from 1 to n. In a first method, the vertices of a current orientation are computed in terms of the vertices of the previous orientation.
      <br/>
      Namely,
      <br/>
      Pi(k) =Rk * Pi(k-1)
    </p>
    <p num="13">where Pi(0) =Pi. After the vertices +Pi(k) } are computed, they are typically used to render the updated orientation of the graphical object on a display screen.</p>
    <p num="14">
      In a second method, the succession of rotations may be generated by iteratively computing a sequence of matrices Uk according to the relation Uk =Rk Uk-1 with U0 =I.
      <br/>
      After matrix Uk is computed, the vertices +Pi(k) } of the graphical object in the kth orientation may be computed directly from the vertices +Pi } of the initial orientation using the relation
      <br/>
      Pi(k) =Uk * Pi.
    </p>
    <p num="15">
      Thus, the matrix Uk represents the orientation of the graphical object after the first k rotations have been applied.
      <br/>
      This second method for generating a series of rotations is generally preferred over the first method for reasons which will become fully apparent below.
    </p>
    <p num="16">
      By repeatedly applying the recursive relation Uk =Rk Uk-1 for successively decreasing values of the index k, it follows that
      <br/>
      Uk =Rk Rk-1 . . . R2 R1.
    </p>
    <p num="17">Since the arbitrary product of rotation matrices is itself a rotation matrix, each of the orientation matrices Uk is a rotation matrix, provided the matrix multiplications generating Uk are preformed on an ideal machine with infinite precision.</p>
    <p num="18">
      In actuality, however, one can only approximate the ideal situation.
      <br/>
      In general, the coefficients of a rotation matrix R cannot be represented exactly with finite precision memory.
      <br/>
      Thus, any memory representation R of a rotation matrix R must necessarily be approximate:
      <br/>
      R=R+ DELTA ,
    </p>
    <p num="19">
      where  DELTA  is an error matrix which includes numeric representation error.
      <br/>
      In addition to numeric representation error, there are situations where it is desirable to approximate a rotation matrix for the sake of computational efficiency.
      <br/>
      For example, in order to implement a rotation about one of the axes, say the z axis, through a small angle  DELTA  THETA , it is advantageous to approximate the z axis rotation matrix Rz ( DELTA  THETA ) using the small angle approximations
      <br/>
      sin ( DELTA  THETA ).apprxeq.
      <br/>
      DELTA  THETA ,
      <br/>
      cos ( DELTA  THETA ).apprxeq.1.
    </p>
    <p num="20">Namely,  (Equation image '5' not included in text)</p>
    <p num="21">
      A matrix-vector product computed with the approximation matrix Rz ( DELTA  THETA ) may be computed with two scalar multiplies, whereas a matrix-vector product computed with the original rotation matrix Rz ( DELTA  THETA ) requires four scalar multiplies.
      <br/>
      Thus, in order to implement a small angle rotation about one of the coordinate axes, it is quite typical to use an approximation to the axial rotation matrix.
    </p>
    <p num="22">
      Furthermore, consider the situation where a small angle rotation about the x axis is to be followed by a small angle rotation about the y axis.
      <br/>
      It is possible to implement this pair of rotations by multiplying each vertex Pi of a graphical object by the pair of axial rotations Rx ( DELTA .o slashed.) and Ry ( DELTA  PHI ), where  DELTA .o slashed. denotes the angle of rotation about the x axis, and  DELTA  PHI  denotes the angle of rotation about the y axis.
      <br/>
      This computation would require eight scalar multiplies and four scalar additions per vertex Pi.
      <br/>
      Alternatively, the same pair of rotations may be realized by the approximate rotation matrix  (Equation image '6' not included in text)
    </p>
    <p num="23">
      where  DELTA  PHI  denotes the angle of rotation about the x axis, and  DELTA  PHI  denotes the angle of rotation about the y axis.
      <br/>
      Approximation matrix Rxy is derived by computing the product of the axial rotations Rx ( DELTA .o slashed.) and Ry ( DELTA  PHI ), and making the small angle replacements for sine and cosine wherever possible.
      <br/>
      A matrix-vertex product evaluated using the approximate rotation matrix Rxy requires four scalar multiplies and three scalar additions.
      <br/>
      Thus, a computational advantage may arise from using the approximate rotation matrix Rxy instead of the separate axial rotations Rx ( DELTA .o slashed.) and Ry ( DELTA  PHI ) for generating the pair of successive rotations.
    </p>
    <p num="24">
      The use of computationally efficient approximations to rotation matrices is especially important for generating continuous real-time rotations of a graphical object.
      <br/>
      In order to create the illusion of continuous motion for a displayed graphical object, a graphical computing system typically displays multiple frames per second, where the graphical object differs by a slight rotation between successive frames.
      <br/>
      In order to generate the slight rotation between successive frames in real-time, an approximation to a true rotation matrix is quite frequently employed.
    </p>
    <p num="25">
      Furthermore, it is noted that a graphical computing system quite often includes a position tracking device such as a mouse or track ball.
      <br/>
      By reading the horizontal displacement  DELTA u and vertical displacement  DELTA v of the position tracking device over a small time interval  DELTA t, it is possible to generate an approximate rotation matrix which corresponds to the instantaneous motion of the position tracking device.
      <br/>
      For example, a graphical computing system may map the horizontal displacement  DELTA u and vertical displacement  DELTA v onto the approximate rotation matrix  (Equation image '7' not included in text)
    </p>
    <p num="26">
      using the relations
      <br/>
      DELTA .o slashed.= ALPHA  *  DELTA u,
      <br/>
      DELTA  PHI = BETA  *  DELTA v,
    </p>
    <p num="27">
      where  ALPHA  and  BETA  are proportionality constants.
      <br/>
      The approximate rotation matrix Rxy may then be used to generate a rotation of the graphical object between the current frame and the next frame to be displayed.
      <br/>
      By repeatedly reading the horizontal and vertical displacements from the position tracking device and applying the corresponding approximate rotation matrices Rxy to update successive frames, a graphical computing system may provide a user manipulating the position tracking device with continuous real-time control of the orientation of a displayed graphical object.
    </p>
    <p num="28">
      For the reasons elaborated above, in the context of any physical computation of a series of rotations, it is more realistic to consider a series of approximate rotation matrices R1, R2, . . . , Rn, where each approximate rotation matrix Ri deviates from the corresponding true rotation matrix Ri by an error matrix  DELTA i :
      <br/>
      Ri =Ri + DELTA i.
    </p>
    <p num="29">
      Error  DELTA i may include numerical representation error, approximation error, and/or measurement error (if the rotation matrix is derived from physical measurements).
      <br/>
      Furthermore, the matrices Uk which generate the vertices +Pi(k) } in the second method discussed above are approximated by matrices Uk computed according to the recursive relation Uk =Rk Uk-1 with U0 =I.
      <br/>
      If each matrix Uj departs from matrix Uj by error matrix  EPSILON j, i.e.,  EPSILON j =Uj -Uj, then
      <br/>
      Uk =Rk Uk-1 =(Rk + DELTA k)(Uk-1 + EPSILON k-1) =Rk Uk-1 +Rk EPSILON k-1 + EPSILON k Uk-1 + DELTA k EPSILON k-1 + DELTA c,
    </p>
    <p num="30">
      where  DELTA c is a computation error matrix due to performing the matrix multiplications with finite precision hardware.
      <br/>
      Since matrix Uk =Rk Uk-1 is a true rotation matrix, approximation matrix Uk departs from a true rotation by error
      <br/>
      EPSILON k =Uk -Uk =Rk EPSILON k-1 + DELTA k Uk-1 + DELTA k EPSILON k-1 + DELTA c.
    </p>
    <p num="31">
      The recursive structure of this equation implies that the approximation error  EPSILON k may grow at an exponential rate.
      <br/>
      Thus, as index k increases, the approximate orientation matrices Uk will eventually diverge significantly from being a true rotation matrix.
      <br/>
      In practice, this means that the rotated vertices +Pi(k) } generated from approximation matrix Uk may exhibit unwanted visual artifacts, i.e., visual features which are manifestly inconsistent with a physical rotation.
      <br/>
      A need therefore exists for a system and method which operates on an approximate rotation matrix M to produce a resultant matrix S(M) which is significantly closer to being a true rotation than the approximate rotation matrix M. In other words, a system and method is desired which compensates for the accumulated error in an approximate rotation matrix.
      <br/>
      Furthermore, a need exists for an improved multiplication operator on a pair of approximate rotation matrices A and B which could be used to estimate the ordinary matrix product AB, where the resultant L of the improved multiplication operator is closer to being a true rotation than the ordinary matrix product AB.
    </p>
    <heading>SUMMARY OF THE PRESENT INVENTION</heading>
    <p num="32">
      The present invention comprises a system and method for improved rendering of graphical rotations.
      <br/>
      The system includes a processor, a system memory, a display screen, and optionally a graphics accelerator.
      <br/>
      The processor executes a software program stored in system memory.
      <br/>
      The software program accesses a matrix M which resides in system memory.
      <br/>
      Alternatively, the matrix M may reside in a data cache or in registers internal to the processor.
      <br/>
      The processor, under control of the software program, applies a matrix operator to the matrix M, where the matrix operator has the properties of consistency on the set of rotation matrices, and attraction to the set of rotation matrices.
      <br/>
      The software program renders an image of the graphical object on the display screen using the matrix result L from applying the matrix operator.
      <br/>
      The attraction property of the operator implies that the matrix result L will be closer to being a true rotation than matrix M. Thus, the displayed image rendered using the resultant matrix L has a more accurate and visually satisfying appearance than would an image rendered using matrix M.
    </p>
    <p num="33">
      The matrix M may be obtained by multiplying two or more approximate rotation matrices.
      <br/>
      For example, a first approximate rotation matrix may represent an initial orientation for the graphical object, and a second approximate rotation matrix may represent a desired rotation to be applied to the graphical object.
      <br/>
      The second approximate rotation may be generated in response to a user input command via a mouse, track ball, or any of a variety of position/angle sensing devices.
    </p>
    <p num="34">
      The present invention also contemplates a system in which the processor, after having calculated the resultant matrix L by applying the operator to the matrix M, transmits the resultant matrix L to a graphics accelerator.
      <br/>
      The graphics accelerator then performs the computationally intensive task of rendering the graphical image corresponding to the resultant matrix L. This may involve multiplying the vertices of a graphical object by the resultant matrix L to obtain updated vertices.
    </p>
    <p num="35">
      The present invention also contemplates a method for improved rendering of a repetitive series of rotations of a graphical object on a display screen.
      <br/>
      A processor operating under the control of a software program iteratively performs a series of steps as follows:
    </p>
    <p num="36">
      (i) generate an approximate rotation matrix B;
      <br/>
      (ii) multiply the approximate rotation matrix B by a second approximate rotation matrix A to generate a matrix M;
      <br/>
      (iii) conditionally operate on the matrix M with a matrix operator S to obtain resultant matrix L, i.e., L &lt;-- S(M), where the matrix operator S exhibits the properties of consistency on the rotation matrices and attraction to the rotation matrices; and
      <br/>
      (iv) render an updated rotation for the graphical object using the if the matrix operator was not applied, or the resultant matrix L if the matrix operator was applied.
    </p>
    <p num="37">
      The rotation matrix B may be generated from user inputs supplied via a sensing device or from orientation information provided by a stored data structure.
      <br/>
      The matrix M from a current iteration may be assigned as the second approximate rotation matrix A for the next iteration, i.e., A &lt;-- M.
    </p>
    <p num="38">
      The step of operating on the matrix M with the matrix operator may be performed in every Nth iteration of the processing loop.
      <br/>
      The number N of iterations between updates may be any integer greater than or equal to one.
      <br/>
      The periodic (or pseudo-periodic) application of the matrix operator may advantageously control the computational and approximation errors which accumulate in matrix M through successive iterations.
    </p>
    <p num="39">Alternatively, the step of operating on the matrix M with the matrix operator may be performed in response to the detection of a predetermined amount of error in the matrix M, wherein error comprises a measure of the departure of matrix M from the set of rotations.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="40">
      FIG. 1 illustrates a pair of rotations applied in succession to a cube centered at the origin of a three-dimensional space;
      <br/>
      FIG. 2 illustrates a graphical computing system according to the present invention;
      <br/>
      FIG. 3 depicts a block diagram of the graphical computing system according to the present invention;
      <br/>
      FIG. 4 illustrates the property of consistency on the rotation group for a matrix operator;
      <br/>
      FIG. 5A illustrates the property of stability in a neighborhood of the rotation group for a matrix operator;
      <br/>
      FIG. 5B illustrates an alternative interpretation of the stability property;
      <br/>
      FIG. 6 illustrates the property of attraction to the rotation group for a matrix operator;
      <br/>
      FIG. 7 depicts one embodiment of a method for improved rendering of a rotation on a display screen based on a class of operators according to the present invention;
      <br/>
      FIG. 8 depicts an embodiment of a method for improved rendering of a rotation on a display screen, where a product of two approximate rotation matrices is projected closer to a rotation matrix;
      <br/>
      FIG. 9 depicts an embodiment of a method for improved rendering of a rotation on a display screen, where a product of a sequence of approximate rotation matrices is projected closer to a rotation matrix;
      <br/>
      FIG. 10 depicts an embodiment of a method for improved rendering of a continuous series of rotations on a display screen, where accumulated calculation and approximation errors are compensated by application of a matrix operator;
      <br/>
      FIG. 11A depicts an embodiment of a method for improved rendering of a continuous series of rotations on a display screen, where accumulated calculation and approximation error are compensated by application of a matrix operator on a periodic (or pseudo-periodic) basis; and
      <br/>
      FIG. 11B illustrates the embodiment of FIG. 7A from a geometric viewpoint.
    </p>
    <heading>DETAILED DESCRIPTION OF THE INVENTION</heading>
    <p num="41">
      Referring now to FIG. 2, a graphical computing system 80 according to the present invention is shown.
      <br/>
      As shown, graphical computing system 80 comprises a system unit 82, and a display device 84 coupled to the system unit 82.
      <br/>
      The display device 84 may be any of various types of video monitors or graphical displays.
      <br/>
      Various input devices may be connected to graphical computing system 80, including a keyboard 86 and/or a position tracking device 88.
      <br/>
      Examples of a position tracking device include a mouse, track ball, etc.
      <br/>
      Application software may be executed by graphical computing system 80 to display 3-D graphical objects on display device 84.
    </p>
    <p num="42">
      Referring now to FIG. 3, a simplified block diagram illustrating graphical computing system of FIG. 1 is shown.
      <br/>
      As shown, graphical computing system 80 includes a central processing unit (CPU) 102 coupled to a high speed bus or system bus 104.
      <br/>
      A system memory 106 is also preferably coupled to system bus 104.
      <br/>
      The system memory 106 may include any of various types of memory subsystems including random access memory and/or mass storage devices.
    </p>
    <p num="43">
      A optional 3-D graphics accelerator 112 may be coupled to system bus 104. �If 3D accelerator 112 is not included in graphical computing system 80, then display device 84 couples directly to system bus 104.� The 3-D graphics accelerator 112 may be coupled to system bus 104 by, for example, a cross bar switch or other bus connectivity logic.
      <br/>
      It is assumed that various other peripheral devices, or other buses, may be connected to system bus 104, as is well known in the art.
      <br/>
      It is noted that the 3-D graphics accelerator may be coupled to any of various buses, as desired.
      <br/>
      As shown, display device 84 connects to 3-D graphics accelerator 112.
      <br/>
      CPU 102 may transfer information to and from the graphics accelerator 112 according to a programmed input/output (I/O) protocol over the host bus 104.
      <br/>
      Furthermore, the graphics accelerator 112 may access system memory 106 according to a direct memory access (DMA) protocol or through intelligent bus mastering.
    </p>
    <p num="44">
      A three dimensional (3-D) graphics accelerator is a specialized graphics rendering subsystem for a computer system which is designed to off-load the 3-D rendering functions from the host processor, thus providing improved system performance.
      <br/>
      In a system with a 3-D graphics accelerator, an application program executing on the host processor of the computer system generates three dimensional geometry data that defines three dimensional graphics elements for output on a display device.
      <br/>
      The application program causes the host processor to transfer the geometry data to the graphics accelerator.
      <br/>
      The graphics accelerator receives the geometry data and renders the corresponding graphics elements on the display device.
      <br/>
      One of the goals of many computer graphics systems is to render objects that are realistic to the user.
      <br/>
      The problem of visual realism, however, is quite complex.
      <br/>
      Objects in the "real world" include an incredible amount of detail, including subtle variations in color, reflections, and surface irregularities.
      <br/>
      Applications which display three-dimensional graphics require a tremendous amount of processing capabilities.
      <br/>
      For example, for a computer system to generate smooth 3-D motion video, the computer system is required to maintain a frame rate or update rate of between 20 to 30 frames per second.
    </p>
    <p num="45">
      In many circumstances, a need arises for the ability to compose two rotations, or approximate rotations, to generate a composite rotation.
      <br/>
      Given two approximate rotation matrices A1 and A2, the product matrix A2 A1 represents the net effect of applying the two approximate rotations in succession.
    </p>
    <p num="46">
      A matrix U is said to be a rotation matrix if it obeys the properties UUt =I and det(U)=1. The set of all such rotation matrices is called the special orthogonal group SO(n) wherein n denotes the number of columns in the matrix U �or equivalently, the number of rows since U is a square matrix�. The following discussion will be presented in terms of 3 * 3 matrices and the special orthogonal group SO(3), since these are commonly utilized in 3-D computer graphics applications.
      <br/>
      However, this discussion directly generalizes to arbitrary dimensions n.
    </p>
    <p num="47">
      In order to discuss the amount of departure of a matrix from the group of rotations SO(3), one must be able to measure the distance between two matrices, or more fundamentally, to measure the length of a single matrix.
      <br/>
      Given a method for measuring the length of a matrix X, denoted .parallel.X.parallel., the distance between two matrices Y and Z may be calculated by measuring the length of the difference matrix, i.e. .parallel.Y-Z.parallel., wherein the matrix difference Y-Z is computed component-wise.
    </p>
    <p num="48">
      Suppose that the matrices A1 and A2 are approximations of rotation matrices U1 and U2 respectively, i.e. A1 =U1 + DELTA 1 and A2 =U2 + DELTA 2, where  DELTA 1 and  DELTA 2 are matrices which represent the respective approximation errors.
      <br/>
      The matrix product A2 A1 has the form
      <br/>
      A2 A1 =U2 U1 + DELTA 2 U1 +U2 DELTA 1 + DELTA 2 DELTA 1.
    </p>
    <p num="49">
      The last three terms represent the deviation of the product A2 A1 from a rotation matrix, since the product U2 U1 is a rotation matrix. �Recall that the product of two rotation matrices is itself a rotation matrix�. Notice that the two error matrices  DELTA 1 and  DELTA 2 each contribute linearly, and together they contribute quadratically to the deviation.
      <br/>
      Thus, this deviation may be significantly larger than either of the error matrices  DELTA 1 and  DELTA 2 :
      <br/>
      .parallel.A2 A1 -U2 U1.parallel.&gt;.parallel.
      <br/>
      DELTA 1.parallel.,.parallel.
      <br/>
      DELTA 2.parallel..
    </p>
    <p num="50">
      According to the present invention, there exist operators S which operate on the product A2 A1 so that the resultant matrix S(A2 A1) is closer to a rotation matrix than the product A2 A1.
      <br/>
      In fact, the class of operators S which are desirable have the following properties: (a) consistency on the rotation group SO(3), (b) stability in a neighborhood of the rotation group SO(3), and (c) attraction to the rotation group SO(3).
    </p>
    <p num="51">FIG. 4: Consistency on the Rotation Group SO(3)</p>
    <p num="52">
      Referring now FIG. 4, an illustration of a matrix operator being consistent on the rotation group is presented.
      <br/>
      The rotation group SO(3) is depicted as a circle for the sake of discussion.
      <br/>
      In reality, however, the rotation group SO(3) is a three-dimensional object residing in the nine-dimensional space consisting of all 3 x 3 matrices.
      <br/>
      An operator x on a pair of matrices is said to be consistent on the rotation group SO(3) if the operator reduces to ordinary matrix multiplication on rotation matrices.
      <br/>
      In other words, given arbitrary rotation matrices U1 and U2, the operator x is consistent on the rotation group if U2 xU1 =U2 U1. �Recall that the ordinary matrix product of two rotation matrices is another rotation matrix assuming infinite precision calculations.�
    </p>
    <p num="53">FIGS. 5A &amp; 5B: Stability within a Neighborhood of the Rotation Group</p>
    <p num="54">
      Referring now to FIG. 5A, an illustration of an operator being stable in a neighborhood of the rotation group is presented.
      <br/>
      An operator x is stable in a neighborhood of the rotation group if there exists an  EPSILON &gt;0 such that: if A1 and A2 are two matrices each within  EPSILON  distance of corresponding rotation matrices U1 and U2,
      <br/>
      .parallel.A1 -U1.parallel.&lt; EPSILON  and .parallel.A2 -U2.parallel.&lt; EPSILON ,
    </p>
    <p num="55">
      then the result A2 xA1 will also be within e distance of a rotation matrix,
      <br/>
      .parallel.A2 xA1 -U2 U1.parallel.&lt; EPSILON .
    </p>
    <p num="56">
      Referring now to FIG. 5B, a second way to visualize the stability property is illustrated.
      <br/>
      Intuitively, an operator x is stable if there exists a small enough neighborhood about the rotation group, depicted as an annular band around the rotation group SO(3), so that any two matrices A1 and A2 in this neighborhood will give a result A2 xA1 which is also within the neighborhood.
    </p>
    <p num="57">FIG. 6: Attraction to the Rotation Group</p>
    <p num="58">
      Referring now to FIG. 6, an illustration of the attraction property is provided.
      <br/>
      Given an operator x and a matrix A, one may construct a sequence An of matrices by repeatedly operating with the identity matrix I. Namely, let
      <br/>
      A1 =A,
    </p>
    <p num="59">
      and
      <br/>
      Ak+1 =Ak xI
    </p>
    <p num="60">
      Similarly, one may generate a sequence A'n by operating on the left with the identity matrix:
      <br/>
      A'1 =A,
    </p>
    <p num="61">
      and
      <br/>
      A'k+1 =IxA'k.
    </p>
    <p num="62">
      The operator x is said to have the property of attraction to the rotation group if one may guarantee the convergence of sequences An and A'n to a common rotation matrix by choosing the starting matrix A sufficiently close to a rotation matrix.
      <br/>
      In mathematical terms, an operator x is said to attract to the rotation group SO(3) if there exists an  EPSILON &gt;0 such that: for any matrix A within distance  EPSILON  of the rotation group, i.e.
      <br/>
      .parallel.A-U.parallel.&lt; EPSILON
    </p>
    <p num="63">
      for some U in the rotation group, the sequences An and A'n converge to some rotation Q in the rotation group:
      <br/>
      An --&gt; Q,
    </p>
    <p num="64">
      and
      <br/>
      A'n --&gt; Q.
    </p>
    <p num="65">EXAMPLE 1</p>
    <p num="66">An Operator Exhibiting the Properties of FIGS. 4-6</p>
    <p num="67">
      Given two arbitrary matrices A1 and A2, define an operator x according to the formulas:
      <br/>
      M=A2 A1,
    </p>
    <p num="68">and  (Equation image '8' not included in text)</p>
    <p num="69">
      This operator has the properties of consistency on the rotation group, stability in a neighborhood of the rotation group, and attraction to the rotation group as described above in connection with FIGS. 4-6. The consistency of the operator x may be observed as follows.
      <br/>
      Given two rotation matrices U1 and U2, it is an elementary exercise to show that the matrix M=U2 U1 is also a rotation matrix, i.e., matrix M obeys the orthogonality condition Mt M=I, where I is the identity matrix, and has determinant equal to one.
      <br/>
      Applying this fact to the defining relation for operator x, it follows that  (Equation image '9' not included in text)
    </p>
    <p num="70">as required for consistency.</p>
    <p num="71">It is noted that any operator  (Equation image '10' not included in text)</p>
    <p num="72">of the form  (Equation image '11' not included in text)</p>
    <p num="73">
      with appropriately chosen coefficients  ALPHA k may possess the properties of consistency on the rotation group, stability in a neighborhood of the rotation group, and attraction to the rotation group as described above.
      <br/>
      The integer n which specifies the number of terms in the operator  (Equation image '12' not included in text)
    </p>
    <p num="74">may take any integer value greater than or equal to one.</p>
    <p num="75">EXAMPLE 2</p>
    <p num="76">Another Operator Exhibiting the Properties of FIGS. 4-6</p>
    <p num="77">
      Given two arbitrary matrices A1 and A2, define an operator * according to the formulas:
      <br/>
      M=A2 A1,
    </p>
    <p num="78">and</p>
    <p num="79">(Equation image '13' not included in text)</p>
    <p num="80">
      where M-t denotes the inverse transpose of matrix M. This operator also has the properties of consistency on the rotation group, stability in a neighborhood of the rotation group, and attraction to the rotation group.
      <br/>
      The consistency property may be observed as follows.
      <br/>
      Given two rotation matrices U1 and U2, the product matrix M=U2 U1, as mentioned above, obeys the orthogonality condition MMt =I, or equivalently M-t =M.
      <br/>
      Thus,  (Equation image '14' not included in text)
    </p>
    <p num="81">as required for consistency.</p>
    <p num="82">The operators  (Equation image '15' not included in text)</p>
    <p num="83">
      introduced above may be advantageously used to yield matrices which are closer to being true rotations.
      <br/>
      Thus, they may serve to compensate the error accumulated in a matrix product of approximate rotations.
      <br/>
      Generally, operator x is preferred over operator *, since the former operator avoids the computation of a matrix inverse.
    </p>
    <p num="84">Embodiments of a Graphical Computing System and Method</p>
    <p num="85">
      As shown in FIG. 7, one embodiment of the present invention includes a system and method for improved rendering of a rotation on a display screen based on a class of operators which exhibit the properties of (i) consistency on the rotation group, and (ii) attraction to the rotation group.
      <br/>
      In step 220, a software program executing on central processing unit 102 operates on a matrix M with a matrix operator in the class defined above.
      <br/>
      It is assumed that the matrix M an approximate rotation matrix within the neighborhood of attraction to the rotation group for the matrix operator.
      <br/>
      In the preferred embodiment of step 220, the software program uses operator x discussed above in Example 1, i.e.  (Equation image '16' not included in text)
    </p>
    <p num="86">In alternate embodiments of step 220, one of the operators  (Equation image '17' not included in text)</p>
    <p num="87">with n larger than 1, or operator * of Example 2 may be used to operate on the matrix M.</p>
    <p num="88">
      Let L denote the matrix result of applying the matrix operator to the matrix M. Since the matrix operator has the property of attraction to the rotation group, the resultant matrix L will more closely approximate a true rotation matrix than the matrix M. Thus, in step 230, the software program renders a rotated image of a graphical object on display screen 84 using the resultant matrix L instead of the matrix M. Step 230 includes multiplying the vertices of the graphical object by resultant matrix L to generate updated vertices in the rotated orientation.
      <br/>
      Since matrix L is closer to a true rotation matrix than matrix M, the rotated image of the graphical object rendered on the basis of matrix L will appear less distorted than if the image were rendered on the basis of matrix M.
    </p>
    <p num="89">
      In an alternate embodiment of step 230, software program provides the resultant matrix L to graphics accelerator 112.
      <br/>
      Graphics Accelerator 112 performs the matrix-vertex multiplications using the resultant matrix L. The updated vertices are supplied to the display device 84.
    </p>
    <p num="90">
      In one embodiment of step 220, the matrix operator is applied more than once.
      <br/>
      In other words, the matrix operator may be applied to the matrix M to generate a first resultant matrix L1.
      <br/>
      The matrix operator may be applied a second time to first resultant matrix L1 to generate a second resultant matrix L2.
      <br/>
      After each successive application of the matrix operator, the resultant matrix Lk approximates a true rotation more accurately than the previous resultant matrix Lk-1.
      <br/>
      The final resultant matrix Lfinal may be used to render the rotated image of the graphical object on the display device 84.
    </p>
    <p num="91">
      Referring now to FIG. 8, a second embodiment of the present invention is presented.
      <br/>
      In step 300, a software program executing on CPU 102 receives a user input from position tracking device 88.
      <br/>
      The user input may represent a desired rotation to be applied to a graphical object.
      <br/>
      In step 305, the software program generates a first approximate rotation matrix corresponding to the user input.
      <br/>
      In step 310, the software program accesses a second approximate rotation matrix which may represent the current orientation of the graphical object.
      <br/>
      In step 315, the software program multiplies the first approximate rotation operand and the second approximate rotation operand to generate a matrix M.
    </p>
    <p num="92">
      In step 420, the software program operates on the matrix M with a matrix operator having the properties (i) and (ii) described above.
      <br/>
      In the preferred embodiment of step 420, the software program uses operator x discussed above in Example 1.
      <br/>
      In alternate embodiments of step 420, one of the operators  (Equation image '18' not included in text)
    </p>
    <p num="93">with n larger than 1, or operator * of Example 2 may be used to operate on the matrix M.</p>
    <p num="94">
      Let L denote the matrix result of applying the matrix operator to the matrix M. In step 430, the resultant matrix L is used in place of matrix M to render a rotated image of a graphical object on a display screen.
      <br/>
      Since the resultant matrix L is closer to a true rotation matrix than the matrix M, the rendering of the updated orientation of the displayed graphical object using the resultant matrix L will exhibit a more accurate appearance (less distortion) than if the matrix M were used for rendering the updated orientation.
    </p>
    <p num="95">
      In an alternate embodiment of step 430, the software program provides the resultant matrix L to graphics accelerator 112.
      <br/>
      Graphics accelerator 112 performs the rendering calculations to generate the rotated vertices of the graphical object using the resultant matrix L. Thus, the host processor 102 may advantageously operate with increased efficiency since it is liberated from computationally intensive task of performing the display rendering calculations.
    </p>
    <p num="96">
      Referring now to FIG. 9, a third embodiment of the present invention is presented.
      <br/>
      In step 510, a software program executing on CPU 102 generates a sequence of approximate rotation matrices B1, B2, . . . , Bn based on a sequence of user inputs.
      <br/>
      In one embodiment of step 510, the software program reads a horizontal displacement  DELTA u and a vertical displacement  DELTA v of position tracking device 88 over a small time interval  DELTA t, and uses the displacements  DELTA u and  DELTA v to generate an approximate rotation matrix.
      <br/>
      For example, the software program may map the horizontal displacement  DELTA u and vertical displacement  DELTA v onto the dual axis approximate rotation matrix  (Equation image '19' not included in text)
    </p>
    <p num="97">
      using the relations
      <br/>
      DELTA .o slashed.= ALPHA  *  DELTA u,
      <br/>
      DELTA  PHI = BETA  *  DELTA V,
    </p>
    <p num="98">
      where  ALPHA  and  BETA  are proportionality constants.
      <br/>
      The sequence of approximate rotation matrices B1, B2, . . . , Bn may be generated by repeatedly reading position tracking device 88 and mapping each reading or set of readings onto a corresponding approximate rotation matrix.
    </p>
    <p num="99">
      In a second embodiment of step 510, the sequence of approximate rotation matrices B1, B2, . . . , Bn may be generated by reading a series of input values from one or more sensing systems configured to detect the orientation of the user's head and/or eyes.
      <br/>
      As the user moves his/her head and/or eyes, the one or more sensing systems report this orientation information as a set of sensor measurements.
      <br/>
      The software program repeatedly reads the sensor measurements and maps each set of sensor measurements onto an approximate rotation matrix Bk which corresponds to the instantaneous change in orientation of the user's head and/or eyes in physical space.
      <br/>
      This embodiment may be especially useful in virtual reality systems.
    </p>
    <p num="100">
      In a third embodiment of step 510, the sequence of approximate rotation matrices B1, B2, . . . , Bn are generated from information stored in a data structure in system memory 106.
      <br/>
      The data structure may store a sequence of entries where each entry determines one of the approximate rotation matrices Bk.
      <br/>
      For example, each entry may store an angle and an indication of one of the axes.
      <br/>
      In this case, the software program reads the angle and axis indication, and generates the corresponding axial rotation matrix for each entry in the data structure.
    </p>
    <p num="101">
      In step 520, the software program multiplies an initial approximate rotation matrix and the sequence of approximate rotation matrices B1, B2, . . . , Bn to obtain a matrix M. The initial approximate rotation matrix may represent the initial orientation of a graphical object.
      <br/>
      In step 620, the software program operates on the matrix M with an operator having properties (i) and (ii) described above.
    </p>
    <p num="102">
      In step 620, the software program renders a rotated image of the graphical object on display screen 84 using the resultant matrix L in place of matrix M. Since resultant matrix L is closer to a true rotation than matrix M, the rotated image rendered using resultant matrix L appears more naturally consistent with a physical rotation than if matrix M were used.
      <br/>
      In an alternate embodiment of step 620, the software program provides the resultant matrix L to graphics accelerator 112, and graphics accelerator 112 performs the rendering of the rotated image.
    </p>
    <p num="103">
      Referring now to FIG. 10, a fourth embodiment of the present invention is presented.
      <br/>
      In this embodiment, the software program cyclically performs steps 720-740 and steps 820-840.
      <br/>
      In step 710, the software program accesses an initial approximate rotation matrix A which represents the initial orientation of a graphical object.
      <br/>
      In step 720, the software program receives an input from an input device such as position tracking device 88 or virtual reality sensor subsystem.
      <br/>
      In step 730, the software program generates an approximate rotation matrix B using the input value(s) read from the input device.
      <br/>
      In step 740, the software program multiplies the initial approximate rotation matrix A and the approximate rotation matrix B to obtain a matrix M. It is noted that in a first cycle of FIG. 10, the initial approximate rotation matrix A may be the identity matrix.
      <br/>
      In this case, the multiplication of step 740 is trivial and need not be performed. �Any matrix times the identity matrix is equal to itself�.
    </p>
    <p num="104">
      In step 820, the software program operates on matrix M with a matrix operator which exhibits properties (i) and (ii) described above.
      <br/>
      Let L denote the resultant matrix from the matrix operator.
      <br/>
      In step 830, the software program renders a rotated image of the graphical object on a display screen using the resultant matrix L. Since resultant matrix L more closely approximates a rotation than matrix M, the rotated image generated using resultant matrix L has an appearance which is more realistic and consistent with a physical rotation than if matrix M were used to generate the image.
    </p>
    <p num="105">
      In an alternate embodiment of step 830, the software program provides the resultant matrix L to the graphics accelerator 112.
      <br/>
      Graphics accelerator 112 then performs the computationally intensive matrix-vector multiplications required for rendering the rotated image of the graphical object.
    </p>
    <p num="106">In step 840, the resultant matrix L from the matrix operator is assigned as the initial matrix A for the next cycle of FIG. 10. Thus, it is apparent that the errors which accumulate in the multiplication step 740 are compensated by the application of the matrix operator in step 820 for each cycle of FIG. 10.</p>
    <p num="107">
      Referring now to FIG. 11A, a fifth embodiment of the present invention is presented.
      <br/>
      In this embodiment, the software program cyclically performs steps 920-970.
      <br/>
      In step 910, the software program accesses an initial approximate rotation matrix A which represents the initial orientation of a graphical object.
      <br/>
      In step 920, the software program generates an approximate rotation matrix B. As discussed above, the software program may use input value(s) to generate the approximate rotation matrix B. In step 930, the software program multiplies the initial approximate rotation matrix A and the approximate rotation matrix B to obtain a matrix M. It is noted that in a first cycle of FIG. 11A, the initial approximate rotation matrix A may be the identity matrix.
      <br/>
      In this case, the multiplication of step 930 is trivial and need not be performed. �Any matrix times the identity matrix is equal to itself�. Step 940 is included to indicate that step 950 is performed for every Nth cycle through the flowchart of FIG. 11A. If the integer N is equal to one, then step 950 is performed in every cycle through the flowchart.
      <br/>
      The integer N is greater than or equal to one.
    </p>
    <p num="108">
      In step 950, the software program updates the matrix M by operating on the matrix M using an operator having the properties (i) and (ii) described above.
      <br/>
      In other words, the matrix result of operating on matrix M is assigned as the new value of matrix M, i.e., M &lt;-- Operator(M).
    </p>
    <p num="109">
      In step 960, the matrix M (which has perhaps been updated in step 950) is used to render a rotated image of a graphical object on display device 82.
      <br/>
      Since the matrix M is updated by application of the matrix operator after every Nth cycle of the processing loop, the accumulation of approximation and calculation errors may be advantageously controlled.
      <br/>
      Therefore, the displayed image of the graphical object in step 960 maintains a realistic appearance free from unwanted visual artifacts.
    </p>
    <p num="110">In step 970, the matrix M is assigned to be the initial matrix A for the next cycle of FIG. 11A.</p>
    <p num="111">
      The number N of computation cycles between compensation step 950 may be any integer greater than or equal to one.
      <br/>
      By choosing the integer N appropriately, the error accumulated in matrix M may be controlled so that matrix M remains within the neighborhood of attraction to SO(3) as described in connection with FIG. 6.
      <br/>
      Thus, the present embodiment provides a mechanism for controlling and decreasing the error associated with the multiplication of a series of approximate rotation matrices.
    </p>
    <p num="112">
      The present invention also contemplates alternative embodiments where the number N of iterations between application of the matrix operation is adaptively controlled.
      <br/>
      Smaller value of N may be used in situations where the approximation and calculation errors accumulate quickly.
      <br/>
      Correspondingly larger values of N may be used in situations where these errors accumulate more slowly.
      <br/>
      In one alternate embodiment, the error in matrix M, i.e., the amount by which it departs from a rotation matrix, is estimated.
      <br/>
      The result of the estimate is used to control when and/or how frequently the step 950 is performed.
    </p>
    <p num="113">
      In FIG. 11B, the initial approximate rotation matrix A, and the successive products
      <br/>
      C0 =A,
      <br/>
      C1 =B1 A,
      <br/>
      C2 =B2 (B1 A),
      <br/>
      Cn =Bn (Bn-1 . . . B2 B1 A)=M
    </p>
    <p num="114">
      generated from the sequence of approximate rotation matrices B1, B2, . . . , Bn in successive cycles of multiplication step 930 are shown as separate points which diverge from the rotation group SO(3).
      <br/>
      This divergence represents the accumulation of approximation and calculation errors.
      <br/>
      The application of the matrix operator sends matrix M to the resultant matrix L. Observe that resultant matrix L more closely approximates a rotation matrix since it is closer to the rotation group.
      <br/>
      The resultant matrix L is used to initiate the second series of N multiplication cycles of FIG. 11A. The second series of successive products terminates with matrix M'. An application of the matrix operator sends matrix M' to resultant matrix L'. By periodically (or pseudo-periodically) applying the matrix operator, the deviation of the intermediate approximate rotation matrices Ci from the rotation group may be controlled to within a predetermined limit  ETA .
      <br/>
      In other words, each of the successive product matrices Ci will approximate a rotation to within the predetermined limit  ETA : .parallel.Ci -Ui.parallel.&lt; ETA
    </p>
    <p num="115">for some corresponding rotation matrix Ui.</p>
    <p num="116">In one embodiment of step 950, the matrix operator is applied more than once so that the resultant matrix L closer to a rotation matrix than if only one application of the matrix operator were performed.</p>
    <p num="117">
      It is noted that the methods connected with FIGS. 7-11 may be realized in graphics accelerator 112.
      <br/>
      Such a realization may be especially advantageous for performing rotations in real-time, or for performing a series of rotations on graphical objects with a large number of vertices.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for improved rendering of a rotation of a graphical object on a display screen, the method comprising:</claim-text>
      <claim-text>operating on a matrix M with a matrix operator which exhibits a first property of consistency on the rotation group and a second property of attraction to the rotation group, wherein the step of operating on the matrix M with the matrix operator produces a resultant matrix L; rendering a rotated image of the graphical object on a display screen using the resultant matrix L in place of said matrix M.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein said operating on the matrix M with a matrix operator comprises calculating the resultant matrix L according to the formula  (Equation image '20' not included in text)</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3.</claim-text>
      <claim-text>The method of claim 1, wherein said operating on the matrix M with a matrix operator comprises calculating the resultant matrix L according to the formula  (Equation image '21' not included in text)</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4.</claim-text>
      <claim-text>The method of claim 1, wherein said operating on the matrix M with a matrix operator comprises calculating the resultant matrix L according to a formula of the form  (Equation image '22' not included in text)</claim-text>
      <claim-text>wherein the integer n is greater than or equal to one, wherein the coefficients  ALPHA k are predetermined constants.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 1, wherein said operating on the matrix M with a matrix operator includes applying the matrix operator a plurality of times to generate the resultant matrix L.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 1, wherein said rendering a rotated image of the graphical object on a display screen using the resultant matrix L includes multiplying one or more vertices of the graphical object with the resultant matrix L to obtain rotated vertices for the graphical object.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 1, further comprising: receiving a first user input; generating a first approximate rotation matrix using the first user input; accessing a second approximate rotation matrix; multiplying the first approximate rotation matrix and the second approximate rotation matrix to generate the matrix M.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 7, wherein the user input is supplied by a mouse.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 7, wherein the user input is supplied by a sliding ball.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of claim 7, wherein the first user input represents a desired rotation to be applied to a graphical object.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 1, further comprising: generating a sequence of approximate rotation matrices B1, B2, . . . , Bn ; multiplying an initial approximate rotation matrix and the sequence of approximate rotation matrices B1, B2, . . . , Bn to obtain the matrix M.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 11, further comprising receiving a sequence of sensor inputs from a sensing device, wherein said generating a sequence of approximate rotation matrices B1, B2, . . . , Bn is controlled by said sensor inputs.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 12, wherein the sequence of sensor inputs are successive horizontal and vertical displacements of a position tracking device being manipulated by a user.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 13, wherein the position tracking device is a mouse.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method of claim 13, wherein the position tracking device is a sliding ball.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 12, wherein the sensing device and said display screen are incorporated in a virtual reality system.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. A method for improved rendering of a repetitive series of rotations on a display screen, the method comprising: generating an approximate rotation matrices B; multiplying the approximate rotation matrix B by a second approximate rotation matrix A to generate a matrix M; rendering a rotated image of the graphical object on a display screen using the matrix M; iteratively performing said generating, said multiplying, and said rendering; wherein said matrix M from a current iteration of said iteratively performing is used as said second approximate rotation matrix A in a subsequent iteration of said iteratively performing; updating the matrix M by operating on matrix M with an operator which exhibits a property of consistency on the set of rotations, and a property of attraction to the set of rotations, wherein said updating is performed after said multiplying and before said rendering in response to affirmative result of an update test.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method claim 17, wherein said updating the matrix M by operating on said matrix M with said operator includes applying the matrix operator a plurality of times.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method of claim 17, wherein each cycle of said iteratively performing further includes receiving one or more sensor input values from a sensing unit before said generating an approximate rotation matrix B, wherein said generating of said approximate rotation matrix B corresponds to said one or more input values.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The method of claim 19, wherein said sensing unit is a mouse.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The method of claim 19, wherein said sensing unit is a track ball.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The method of claim 17, wherein said update test comprises detecting if a current iteration index is N larger than a previous iteration index for which said updating was performed.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The method of claim 22, wherein said update test comprises estimating an amount of error in matrix M.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A system with improved rotation rendering of a graphical object, the system comprising: a memory which stores a matrix M; a processor coupled to the memory, wherein said processor is operable to transform the matrix M with a matrix operator which exhibits a first property of consistency on the rotation group and a second property of attraction to the rotation group, wherein said transforming of the matrix M with the matrix operator produces a resultant matrix L; a display screen coupled to the processor, wherein the display screen is operable to display a rotated image of the graphical object, wherein the rotated image is rendered using the resultant matrix L.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The system of claim 24, wherein the processor is configured to execute a software program, wherein said processor, under control of said software program, is operable to render the rotated image of the graphical object using the resultant matrix L.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The system of claim 25, wherein the rendering of said rotated image includes multiplying a plurality of vertices of the graphical object by said resultant matrix L.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The system of claim 24 further comprising a graphics accelerator coupled to said processor, wherein said processor is configured to transmit said resultant matrix L to said graphics accelerator, wherein said graphics accelerator is configured (a) to render the rotated image of the graphical object under said resultant matrix L, and (b) to transmit data corresponding to said rotated image to said display screen.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The system of claim 24 further comprising an input unit, wherein said processor, under control of said software program, is operable (a) to read one or more sensor input values from said input unit, (b) to generate a first approximate rotation matrix corresponding to said one or more sensor input values, (c) to access a second approximate rotation matrix from the memory, and (d) to generate the matrix M by multiplying said first approximate rotation matrix and said second approximate rotation matrix.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The system of claim 27, wherein said second approximate rotation matrix is a representation of an initial orientation for the graphical object, and said first approximate rotation matrix represents a desired rotation to be applied to the graphical object.</claim-text>
    </claim>
  </claims>
</questel-patent-document>