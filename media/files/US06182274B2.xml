<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182274B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182274</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182274</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="25299175" extended-family-id="17764222">
      <document-id>
        <country>US</country>
        <doc-number>08846869</doc-number>
        <kind>A</kind>
        <date>19970501</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08846869</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>18222489</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>84686997</doc-number>
        <kind>A</kind>
        <date>19970501</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08846869</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/44        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>44</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/06        20060101AFI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>06</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>717104000</text>
        <class>717</class>
        <subclass>104000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>717108000</text>
        <class>717</class>
        <subclass>108000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-008/36</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>36</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-008/36</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>36</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>16</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>5</number-of-drawing-sheets>
      <number-of-figures>5</number-of-figures>
      <image-key data-format="questel">US6182274</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Reusing code in object-oriented program development</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>NAITO ICHIRO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5191646</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5191646</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>MCKEEMAN WILLIAM M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5313387</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5313387</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>MATSUZUKI TADAO</text>
          <document-id>
            <country>US</country>
            <doc-number>5522078</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5522078</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>FRID-NIELSEN LARS K</text>
          <document-id>
            <country>US</country>
            <doc-number>5557730</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5557730</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>TAKAYA MASAHIRO</text>
          <document-id>
            <country>US</country>
            <doc-number>5625844</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5625844</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>BROMAN DAVID MICHAEL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5754858</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5754858</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>RUBIN BRADLEY SCOTT</text>
          <document-id>
            <country>US</country>
            <doc-number>5778378</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5778378</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>ROSE JOHN R, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5790861</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5790861</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>CAVANAUGH III KEN M</text>
          <document-id>
            <country>US</country>
            <doc-number>5809507</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5809507</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>KLENCKE DAVID L</text>
          <document-id>
            <country>US</country>
            <doc-number>5867709</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5867709</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="11">
          <text>SOLTON RANDOLPH T, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5911070</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5911070</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="12">
          <text>JORDAN MICHAEL J</text>
          <document-id>
            <country>US</country>
            <doc-number>5911071</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5911071</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="13">
          <text>CLINE OWEN RICHARD, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5926637</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5926637</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="14">
          <text>MIURA TAKASHI</text>
          <document-id>
            <country>US</country>
            <doc-number>5930505</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5930505</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="15">
          <text>DIGITAL EQUIPMENT CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0406028</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-406028</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>"Rational Rose-Using Rational Rose 4.0"; Rational Software Corporation; Revision 4.0; pp. xi-xvi, 1-85, 185-197, Nov. 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Rational Rose/C++ -Round Trip Engineering with Rational Rose/C++; Rational Software Corporation; Revision 4.0; pp. 5-51 and 217-227, Nov. 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Channon, D.; "Persistence for C++"; Dr. Dobbs Journal; vol. 21, No. 10, pp. 46-52, Oct. 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>"IBM/JOSS Object Services Persistence Service Specification-Submission to the Object Management Group"; International Business Machines Corporations; SunSoft Inc.; pp. 1-43, Nov. 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>Millard, B., Dasgupta, P., Rao, S., Kuramkote, R., Run-Time Support and Storage Management for Memory-Mapped Persistent Objects, Proceedings the 13th International Conference on Distributed Computing Systems, pp. 508-515, May 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="6">
          <text>Harrison, W., Ossher, H., Attaching Instance Variables to Method Realizations Instead of Classes, Proceedings of the 1992 International Conference on Computer Languages, pp. 291-299, Apr. 1992.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Lau, Christina</name>
            <address>
              <address-1>Scarborough, CA</address-1>
              <city>Scarborough</city>
              <country>CA</country>
            </address>
          </addressbook>
          <nationality>
            <country>CA</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Duffield, Edward H.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Hafiz, Tariq R.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method and system for reusing code extensions prepared by a user or developer are disclosed.
      <br/>
      The extensions are handled as method implementations and stored in the method body, in a persistent storage model.
      <br/>
      Thus when the source code is regenerated after a change is made to the metadata in an object, its method body attribute is retrieved intact and the user/developer does not need to re-enter the extensions into the object to be edited.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates in general to the data processing fields and relates in particular to the field of object-oriented programming development systems.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      Object-oriented development tools commonly include tools which build core portions of programming applications.
      <br/>
      Typically, a builder tool has a user interface that collects a certain amount of input from the developer for which it creates some skeleton code.
      <br/>
      This input is metadata.
      <br/>
      More generally, metadata is self-descriptive information that can describe both services and information.
      <br/>
      Typically, the generated code does not make up the entire application; thus the user/developer must extend the generated code by using a source editor.
      <br/>
      An example of such an extension is business logic that computes the salary of an employee.
      <br/>
      Having prepared the code extensions, the developer will build, that is, compile and link the application using the traditional compiler.
    </p>
    <p num="3">
      One problem with the traditional method is that when the metadata is changed, the user must re-generate the code.
      <br/>
      Re-generation will overwrite such code extensions, and thus the extensions need to be re-entered at each code re-generation, either by manual re-input or by cutting and pasting from another file; otherwise the editor will simply enter a null and the previously entered code extensions will be lost.
    </p>
    <p num="4">
      An additional problem is that traditional builders generate language-specific code.
      <br/>
      For example, one form of application wizard generates only C++ code, and thus the generated code can be used only by a C++ compiler.
    </p>
    <p num="5">
      Accordingly, it is an object of the present invention to provide a system that enables the persistent storage and recovery of all such edited code.
      <br/>
      It is a further object of the present invention to provide a system that enables the storage of such code extensions in a way that is independent of the language in which those code extensions are written.
      <br/>
      It is a further object of the present invention to provide a mechanism for storing edited code as metadata in support of the development of complex applications using a layered data model for the handling and storage of application development metadata.
      <br/>
      A general form of such a data model is described in Canadian Patent Application No. 2,201,278, (CA9-97-003), "Hierarchical Metadata Store for an Integrated Development Environment", filed on Mar. 27, 1997.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="6">Accordingly, the present invention provides, in an object-oriented development system having components that generate skeleton code, a method of storing interface definition and implementation information comprising providing an in-memory storage area and a persistent storage area, retaining the interface definition and implementation information in an in-memory storage area, upon an instruction from a user application following preparation of a modified file containing updates to the information, storing the interface definition and implementation information as meta-data in a persistent storage area, recovering the interface definition and implementation information from the persistent storage area; and writing the interface definition and implementation information to the modified file.</p>
    <p num="7">The present invention further provides an object-oriented application development system providing components that generate skeleton code, the system comprising an in-memory data storage area; a persistent data storage area; application program interfaces providing storage capability for interface and implementation information as metadata in either of the storage areas; an editor for modifying code in at least one component; and means for retrieving the information from the persistent storage area.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="8">
      FIG. 1 is a schematic drawing of an object-oriented persistent and in-memory data model upon which the system of the invention is built;
      <br/>
      FIG. 2 illustrates a main window displayed by software implementing a preferred embodiment of the invention;
      <br/>
      FIG. 3 is an illustration of the derived classes of an object-oriented data model in accordance with a preferred embodiment of the invention; and
      <br/>
      FIG. 4 is an example of a file according to preferred embodiment of the invention that illustrates what model objects are instantiated for the interface definition language (IDL) constructs in an example file.
      <br/>
      FIG. 5 illustrates the relationships in a preferred embodiment of the invention between an interface class and other elements of the application system.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="9">
      The preferred embodiment of the invention uses the interaction between an object-oriented in-memory data model and an object-oriented persistent data model and provides application programming interfaces (APIs) to store both the interface and implementation information, including business logic, into the data model.
      <br/>
      An object builder tools helps users build business objects in an application development environment.
      <br/>
      The APIs can be invoked by user interface components as well as by components that are not part of the user interface, for example a parser or an importer.
      <br/>
      A user running the object builder tool can view and modify the contents of an interface definition language (IDL) file in the object-oriented persistent data model.
      <br/>
      From within the object builder tool the user can also edit the method implementation; the method implementation is stored in the persistent data model.
      <br/>
      If the user regenerates the source code and modifies some information in the interface definition, she can regenerate the interface and the implementation including the previously added code which has been retrieved from the object builder tools persistent data model.
      <br/>
      Referring now to FIG. 1, the overall architecture of the object-oriented persistent data model and development tools is shown according to a preferred embodiment.
      <br/>
      Element 1 includes various parsers and importers that handle previously prepared code.
      <br/>
      For example, a user at viewer editor can invoke the IDL parser 1 to parse an IDL file into in-memory model 4.
      <br/>
      Various builder tools 2, sometimes called SmartGuides or wizards, are forms of automatic code generating mechanisms that prompt the user or developer for input and then store the metadata in the builder tools in-memory model 4.
      <br/>
      Additional code can also be entered directly by the user, for example by the edit pane shows in FIG. 2, into original files, or files prepared by parsers and importers 1 or SmartGuides 2.
      <br/>
      Code prepared by all of these methods is retained in persistent model 4.
      <br/>
      The in-memory model 4 provides an abstraction for representing interface definition language and Java definitions, supports undo functions and queries, and isolates the parsers and importers 1, wizards 2 and viewers and editors 3 from the implementation details in object-oriented persistent data model 5.
      <br/>
      The persistent data model provides, among other things, a set of base classes for managing persistence, code generation and development builds.
      <br/>
      Preferably, each tool provides concrete implementations of the base classes for storing its own data.
      <br/>
      The persistent data managed by the persistent data model 5 are stored in persistent storage 6, preferably a moving storage unit, for example a hard disk drive.
    </p>
    <p num="10">
      FIG. 2 illustrates a display window as implemented in software using a preferred embodiment of the invention.
      <br/>
      Main window 20, which is visible to the user who is using the major functions of the development systems, includes file pane 21 that displays a list of files in the tree view as is known to those skilled in the art.
      <br/>
      Each file is represented by a node in the tree.
      <br/>
      A file node, for example "Dog", represents a file that is usable by an object-oriented development system, preferably an interface definition language (IDL) file or a Java file.
      <br/>
      The tree in tree pane 21 can be expanded or contracted in known fashion to represent one or more nodes.
      <br/>
      For example, an IDL file node can be expanded to nodes that represent modules and interfaces that are contained within the IDL file.
      <br/>
      As a further example, a Java file node can be expanded to nodes that represent interfaces that are contained within the Java file.
      <br/>
      Each node is associated with actions that can be invoked in respect of that node.
      <br/>
      For example, if the node "Animal" is selected, the action "Open" is available by known methods, for example an action bar, that will launch the corresponding builders that are associated with the node; using a builder, the user can enter metadata, for example attribute names, attribute types, method names, parameters or constructed types.
      <br/>
      File pane 21, like all of the panes in window 20, is scrollable by known methods if the information represented in the pane exceeds the size of the pane on the screen.
    </p>
    <p num="11">
      Relationship pane 22 displays the inheritance relationships between the node selected in file pane 21 and other files and module with which is associated by inheritance.
      <br/>
      For example, if a file or a module is selected in file pane 21, all the interfaces within the file or the module and their inheritance relationships will be displayed in relationship pane 22.
      <br/>
      If an interface node is selected in file pane 21, only the interface node is displayed in relationship pane 22.
      <br/>
      Method pane 23, displays a list of methods of a class that is selected in relationship pane 22.
      <br/>
      For example, if the class "Dog" is selected in pane 22, then the methods that have been implemented for the class "Dog" are displayed in method pane 23, namely "bark", "sleeper", and "eat".
    </p>
    <p num="12">
      In edit pane 24, an editor window is displayed that allows the user to type in or amend the method implementation of a method that is selected in method pane 23.
      <br/>
      In the example shown here, "bark" is selected in method pane 23, and the code for the method implementation is displayed in edit pane 24.
      <br/>
      Because the method implementation is stored in the persistent data model 5 of FIG. 1 according to a preferred embodiment of the invention, the action of selecting a method in method pane 23 allows the stored method implementation to be retrieved by a function of the persistent data model and displayed in edit pane 24.
      <br/>
      Whenever the source code of the application being developed is regenerated, the method implementation in edit pane 24 is saved in the persistent data model 5.
    </p>
    <p num="13">
      FIG. 3 illustrates a group of derived classes that are utilized in implementing a preferred embodiment of the invention.
      <br/>
      All of the classes illustrated in FIG. 3 are derived from the superclass DMPersistent Object 31.
      <br/>
      The class DMMethod 32 is used to model a method, and includes the attributes shown in the table below.
      <br/>
      Most of these attributes are used in ways known to the person skilled in the art, except that the attribute MethodBody is the method implementation that the user enters in an edit session shown in panel 24 in FIG. 2, the MethodBody is saved as an integral part of each member of the class DMMethod and thus is recoverable at any time for regeneration of the source code.
      <br/>
      Preferably, the MethodBody is stored as a string binary large object (string blob).
      <br/>
      Saving it as a string enables the MethodBody to be recovered as a string and thus is independent of the language in which the string is expressed.
      <br/>
      The string can contain statements in any appropriate language, for example Smalitalk, C++ or lava.
      <br/>
      Therefore, no matter the environment in which the user is working, the user can save and retrieve code in the MethodBody that is appropriate to that environment.
    </p>
    <p num="14">
      --
      <br/>
      -- DMMethod
      <br/>
      -- Attribute Name        Description
      <br/>
      -- name                  The name of the method
      <br/>
      -- OB::TypeString        The method return type. (eg. int, or
      <br/>
      --                       Employee).
      <br/>
      -- Oneway                A flag in the IDL case to indicate whether
      <br/>
      --                       this is a oneway or not.
      <br/>
      -- DMMethod::varExceptions This is a string blob that return the list of
      <br/>
      --                       exceptions raised by this method.
      <br/>
      -- OB::Context           This is a string blob that returns the list of
      <br/>
      --                       contexts for this method in IDL case.
      <br/>
      -- MethodBody            The method implementation that the user
      <br/>
      --                       enters in the edit session.
      <br/>
      -- ImplInterface         For Java, this flag indicates whether this
      <br/>
      --                       method implements one of the methods in its
      <br/>
      --                       inherited interfaces.
    </p>
    <p num="15">
      The class DMArg 33 is used to model a parameter, and includes the attributes name, OB::Typestring, and directional attribute, which define respectively the name of the parameter; the parameter type, for example int; and the direction of the parameter, namely in, out or inout.
      <br/>
      The class DMArg 33 operates in ways known to the persons skilled in the art.
    </p>
    <p num="16">
      The class DMType 34 models a type and includes the attribute part, which relate to the class DM part which will be described below; and qualifiers.
      <br/>
      Qualifiers are used in a way known to the person skilled in the art, and can include all appropriate declaration qualifiers, for example, * and const.
      <br/>
      The class DMFile 36 is used to model a list of include files for an IDL file, or a list of import statements for a Java file.
      <br/>
      The class DMFile 36 has, as its only property, the attribute name, which is the name of an include file or an import statement.
    </p>
    <p num="17">The superclass DMNameScope 35 provides the scope of the class name used in the in memory data model 4 and the persistent model 5 in FIG. 1.</p>
    <p num="18">
      The class DMNSGroup 37 represents a grouping construct and defines a name scope.
      <br/>
      It is an abstract concept, and its concrete implementation OBFileGroup 39 is used to model a file level construct, for example an IDL file or a Java file.
      <br/>
      The class OBFileGroup 39 can contain a collection of classes used in the in-memory data model, for example OBFile 42, OBModule 43, OBinterface 44, OBSimpleType 45, OBExcepdion 46, OBTypedef 48, OBEnum 50, OBStruct 52 or OBUnion 54.
      <br/>
      The class OBFileGroup 39 has a one-to-one relationship to OBFile 42 and a one-to-many relationship with each of OBModule 43, OBinterface 44, OBSimpleType 45, OBException 46, ObTypedef 48, OBEnum 50, OBStruct 52 and OBUnion 54.
      <br/>
      The relationships are ownership relationships, and when the OBFileGroup object is destructed, all of its contained elements will also be destructed.
    </p>
    <p num="19">
      The class DMModel 38 represents the model instance root.
      <br/>
      A user of the model attaches to a specific mode instance using methods in the class DMModel 38.
    </p>
    <p num="20">
      OBApplication Family 40 is a model for the objects that are saved onto a storage medium for product distribution, for example, a CD-ROM disk.
      <br/>
      These objects are then installed selectively in a target machine in a software installation step as is known in the art.
    </p>
    <p num="21">
      DMPart 41 is a part construct and models behaviour for other model objects by way of various relationships.
      <br/>
      The behaviour model includes, for example, inheritance, data member and method.
    </p>
    <p num="22">
      In a preferred embodiment of the invention, several classes derive from DMPart 41.
      <br/>
      The class OBFile 42 is used to model an IDL or Java file; each instantiation of OBFileGroup 39 contains one and only one OBFile 42.
      <br/>
      The attributes of the OBFile class are shown in the table below.
    </p>
    <p num="23">
      --
      <br/>
      -- Attribute Name   Description
      <br/>
      -- name             The name of the file
      <br/>
      -- FileType         The type of the file.
      <br/>
      The value can be either Idl or
      <br/>
      --                  Java.
      <br/>
      -- PackageName      The name of the Package for Java
      <br/>
      -- Framework        A flag to indicate whether this is a framework
      <br/>
      -- OBFile::hasPublic A flag to indicate whether this Java file contains a
      <br/>
      --                  public interface.
      <br/>
      -- OB::ForwardDecl  A blob containing the list of forward declarations for
      <br/>
      --                  this scope.
    </p>
    <p num="24">The class OBModule 43 is used for modelling a module, and includes the attributes name and OB::ForwardDecl, which is a binary large object containing a list of forward declarations.</p>
    <p num="25">
      The class OBinterface 44 is used to model an interface.
      <br/>
      Its attributes include name, OBlnterface::is Public and OB::ForwardDecl which is described above.
      <br/>
      The attribute OBlnterface::is Public is a flag which indicates whether the interface is a public interface or not, in the lava implementation of the invention.
    </p>
    <p num="26">
      The class OBlnterface 44 can contain attribute declarations, method declarations and constant declarations for both Java application and interface definition language applications; for interface definition language applications it can also contain type declarations, for example Typedef, Enum, Struct and Union, as well as Exception declarations.
      <br/>
      An OBlnterface 42 scopes interface level constants, attributes, methods, typedefs, enums, structs, unions, exceptions and an interface parents.
      <br/>
      FIG. 5 illustrates, in a preferred embodiment, the relationship name for navigation from the OBInterface to the interface level objects, namely DMMethod, DMDataMember, OBException, OBEnum, OBTypedef, OBStruct, and OBUnion.
    </p>
    <p num="27">
      The class OBSimpleType 45 is used to model any primitive data type that is not otherwise defined by the persistent data model.
      <br/>
      Examples of such primitive datatypes in interface Definition Language, include "any", or "octet", or, in Java, the primitive datatype "byte".
      <br/>
      The class OBSimpleType 45 has a property which stores the name of the primitive data type.
    </p>
    <p num="28">
      The class OBException 46 is used to model an IDL exception definition, in ways common to the object-oriented programming art.
      <br/>
      It stores the name of the exception.
    </p>
    <p num="29">
      The class OBTypedef 48 is used to model an IDLTypeDef definition.
      <br/>
      The class contains the following properties: name, which is the name of the TypeDef; type qualifier which is a flag indicating this TypeDef is a TypeDef of a basic type, for example short, or a bounded sequence, or an unbounded sequence or an array; and size, which indicates the number of elements found if the defined type is a bounded sequence or array.
      <br/>
      The size attribute is not necessary if the defined TypeDef is a basic type or a bounded sequence.
    </p>
    <p num="30">
      The classes OBEnum 50, OBStruct 52 and OBUnion 54 are used to model IDL Enums Structs and Unions.
      <br/>
      The classes OBTypedef 48 OBEnum 50, OBStruct 52 and OBUnion 54 all operate through the corresponding persistent data model classes DMTypedef 47, DMEnum 49, DMStruct 51 and DMUnion 53.
      <br/>
      The classes whose names begin with "OB" in the preferred embodiment are concrete implementations of the superclasses whose names begin with "DM".
      <br/>
      The DM superclasses are not instantiated themselves.
    </p>
    <p num="31">
      The class DMSubpart 60 is a model type.
      <br/>
      DMDataMember 61 is a concrete implementation of DMSubPart 60.
      <br/>
      DMDataMember 61 is instantiated by the object builder tool in a preferred embodiment of the invention.
      <br/>
      DMDataMember 61 is used to model constants, attributes, struct, data members, and enums, that is enumerators.
      <br/>
      In the preferred embodiment, DMDataMember 61 includes the attributes shown in the table below.
    </p>
    <p num="32">
      In that table, Getimpi is a string that stores the get implementation for attributes that represent essential state of the object.
      <br/>
      Setimpi is a string that stores the set implementation for attributes that represent the essential state of the object.
    </p>
    <p num="33">
      --
      <br/>
      -- Attribute Name Description
      <br/>
      -- name           The name of the corresponding item.
      <br/>
      -- OB::TypeString The type of the corresponding item. (e.g. int, or
      <br/>
      --                Employee).
      <br/>
      -- ReadOnly       Applies only to IDL attribute.
      <br/>
      Set to 1 if it is read
      <br/>
      --                only.
      <br/>
      Set to 0 otherwise.
      <br/>
      -- Static         A flag for Java case to indicate that static modifier
      <br/>
      -- GetImpl        For attributes in IDL, and public attributes in Java, this
      <br/>
      --                property contains the Getter implementation.
      <br/>
      -- SetImpl        For attributes in IDL, and public attributes in Java, tis
      <br/>
      --                property contains the Setter implementation.
    </p>
    <p num="34">
      In the preferred embodiment of the invention described herein, each object that is created by the object builder tool in the persistent data model has a unique name.
      <br/>
      The unique name is formed by concatenadng its name with its contained path.
      <br/>
      When an IDL file or a Java file is added, an OBFileGroup object representing the group, and an OBFile object representing the file are created.
      <br/>
      For example, to add "F1.idl", the system creates an OBFileGroup object of name "::F1".
      <br/>
      The "::" is appended by the persistent data model framework.
      <br/>
      Since the OBFileObject is scoped by the OBFileGroup object, its unique name becomes "::F1::F1".
      <br/>
      If an interface is added, for example "Person" to "F1.idl" and OBinterface object will be created, and its unique name will be "::F1::F1::Person".
      <br/>
      The unique naming scheme allows the system to employ name scoping across files, modules and interfaces.
      <br/>
      For example, if "F2.ldl" also contains the "person" interface, its unique name will be "::F2::F2::Person".
      <br/>
      Thus a desired model object can always be located by searching for its unique name in the part group in which it is located.
    </p>
    <p num="35">
      The persistent model classes described above with respect to FIG. 3 handle the storage of the objects that make up the programming system being developed; the classes handle the streaming in and the streaming out of the data bits.
      <br/>
      The invention also uses an in-memory model that sits on top of the persistent classes.
      <br/>
      The in-memory model provides a simple add, update, delete, and query interface for the viewers, editors, parsers and importers shown in FIG. 1.
      <br/>
      The in-memory model isolates each component from the underlying persistent data model implementation artifacts.
    </p>
    <p num="36">
      The in-memory model is the layer that handles the translation from a user-friendly form, for example "F1 " to the persistent model form, for example "::F1::F1".
      <br/>
      The in-memory model also acts as a cache.
      <br/>
      That is, the in-memory model stores the data collected by the various user interface dialog.
      <br/>
      Each in-memory model class has input and output APls for its required metadata.
      <br/>
      The metadata remains in the in-memory model object until the user or developer indicates that a change made on the screen is to be adopted, for example by pressing the OK button in a user dialog box; at that point, the appropriate persistent model objects and model object relationships are created.
      <br/>
      If the user does not wish to make the changes permanent, for example, by clicking on the cancel button in the user interface dialogue, the system does not instantiate the persistent model objects and the model relationships.
    </p>
    <p num="37">In a preferred embodiment, the invention includes the following classes in its in-memory model.</p>
    <p num="38">
      The class IXORepository provides an encapsulation for the model as a whole.
      <br/>
      It creates and stores the DMModel object and provides query functions by means known in the art to locate all the files that are contained in the model or to find a specific file by name in the model.
    </p>
    <p num="39">
      The class IXOFileGroup creates and stores the OBFileGroup object.
      <br/>
      It provides an emit method that can be called to generate a code for the interface and implementation that are associated with a specific file group.
    </p>
    <p num="40">
      The class IXOFile creates and stores the OBFile object that represents an IDL or Lava file.
      <br/>
      It also creates an DMFile object for each include or import statement.
      <br/>
      It provides methods to add and to query module, interface, constant, typedef, struct, enum, union, and exception that are scoped at the specific file level.
    </p>
    <p num="41">
      The class IXOModule creates and it stores the OBModule object that represents an IDL module.
      <br/>
      It provides methods to add and query module, interface, constant, typedef, struct, enum, union, and exception that are scoped at the specific module level.
      <br/>
      The class IXOLInterface creates and stores the OBInterface object that represents an IDL interface or a lava interface.
      <br/>
      This class provides methods to add, query and find attribute, method, constant, typedef, struct, enum, union, and exception that are scoped at the specific interface level.
      <br/>
      The class IXOInterface also provides methods to add and to query the parent interfaces of the specific interface.
      <br/>
      When a parent interface is added, any method that needs to overwritten or implemented from the parent class will result in a DMMethod object being created and added to this class.
    </p>
    <p num="42">
      The class IXOType encapsulates a type definition and an IXOType object is created for each of the following cases or events: the type of an attribute, the return type of a method, the type of a parameter, the type of a struct data member, the type of an exception data member, the type of a union data member and the type of a TypeDef.
      <br/>
      In order to add any of these objects to the persistent data model, the DMPart object representing its type must already have been added to the persistent model.
      <br/>
      The IXOType class provides operations to locate the DMPart that represents the type, or to add an empty OBinterface object that represents the type.
    </p>
    <p num="43">The class IXOMember creates and stores the DMDataMember and associates it with a DMPart.</p>
    <p num="44">
      The class IXOConstant is derived from IXOMember.
      <br/>
      It is used to represent an IDL constant.
      <br/>
      Each IDL constant has a name, a type, and a value.
      <br/>
      This class called a method IXOMember::to cdm to create the persistent data model DMDataMember object, and then adds the required constant declaration qualifier, and the constant value.
    </p>
    <p num="45">
      The class IXOAttribute is derived from IXOConstant and is used to represent an IDL attribute or a Java member.
      <br/>
      Optionally, if the class represents a Java data member, initialization values can also be included in the attributes of this class.
    </p>
    <p num="46">
      The class IXOOperation creates and stores the DMMethod object that represents an IDL method or Java method and it provides methods to add and query the list of parameters associated with the method.
      <br/>
      It also provides methods to get and set the method implementation for the corresponding method.
    </p>
    <p num="47">The class IXOParameter creates and stores the object DMArg 33 in FIG. 3, that represents an IDL or Java parameter.</p>
    <p num="48">
      The class IXOException creates and stores the object OBException 46 that represents an IDL exception.
      <br/>
      The class IXOException also provides methods to add and query the list of exception members that are scoped by the specific exception.
      <br/>
      It also delegates to the IXOMember class the task of creating its exception members.
    </p>
    <p num="49">
      The class IXOEnum creates and stores the object OBEnum 50 that represents an IDL Enum.
      <br/>
      It provides methods to add and query the list of enumerators and members that are scoped by this enum type.
      <br/>
      It delegates to the IXOMember class the task of creating its enumerators.
    </p>
    <p num="50">
      The class IXOStruct creates and stores the OBStruct 52 object that represents an IDL struct.
      <br/>
      It provides methods to add and query the list of struct members that are scoped by the specific structure.
      <br/>
      It delegates to the IXOMember the task of creating its struct members.
    </p>
    <p num="51">
      The class IXOUnion creates and stores the OBUnion 54 object that represents an IDL union.
      <br/>
      It also provides methods to add and query the list of union members that are scoped by this union.
      <br/>
      It delegates to the IXOUnion member class the task of creating its union members.
    </p>
    <p num="52">
      The class IXOUnion member is derived from IXOMember, and is used to represent an IDL union member.
      <br/>
      Each IDL union member has a case label, a name and a type.
      <br/>
      This class calls the method IXOMember::to CDM, which creates the DMDataMember object for the union member and then adds the case label value to the DMDataMember object thus created.
      <br/>
      Finally, the class IXOTypeDef creates and stores the object OBTypedef 48 that represents an IDL typedef.
    </p>
    <p num="53">
      FIG. 4 is an example of an IDL file test.IDL and the model objects that are instantiated by a preferred embodiment of the invention for each of the elements in the file test.IDL. On the left side of the figure are shown code fragments that implement some of the elements described above and opposite them on the right side of FIG. 4 are shown the objects that are created in the preferred embodiment of the invention.
      <br/>
      The objects are shown as types, and, (the instances of those types that are created by the system).
      <br/>
      The statement - include "SomObj.idl" tells the system to add the header file SomObj.idl and creates an instance test.idl of the object OBFileGroup.
      <br/>
      It also creates an instance test.idl of the object OBFile, and an instance SomObj.idl of the object DMFile.
      <br/>
      Similarly, instances of other classes are created by the system for each of the statements within the file test.idl.
    </p>
    <p num="54">Example</p>
    <p num="55">Shown below is an example of a code fragment created by a typical application according to the prior art, and similar code fragment created according to the preferred embodiment of the invention.</p>
    <p num="56">For example, a developer creates an IDL file, a.idl, containing the following code:</p>
    <p num="57">
      --
      <br/>
      -- interface A
      <br/>
      --      +
      <br/>
      --         void print ()
      <br/>
      --      }
    </p>
    <p num="58">Upon generation of an object in source code relating to the above code fragment, a prior art system would create an implementation file, a.cpp containing the following code:</p>
    <p num="59">
      --
      <br/>
      -- void A::print ()
      <br/>
      --      +
      <br/>
      --         cout &lt;&lt; "hello";
      <br/>
      --      }
    </p>
    <p num="60">At a later date, the developer adds a parameter to the IDL file, and produces the following code in the file a.idl:</p>
    <p num="61">
      --
      <br/>
      -- interface A
      <br/>
      --      +
      <br/>
      --         void print (in short p1);
      <br/>
      --      }
    </p>
    <p num="62">The prior art system would take this change and regenerate the a.cpp file without the text that was intended to be displayed on the screen, and would contain the code shown below:</p>
    <p num="63">
      --
      <br/>
      -- void A::print(in short p1)
      <br/>
      --      +
      <br/>
      --         (nulls)
      <br/>
      --      }
    </p>
    <p num="64">Thus, when the user has changed the parameter list for the print statement, the prior art process has overwritten the text that the user had previously entered with nulls, and the user is required to re-enter the text in the a.cpp file.</p>
    <p num="65">Using the preferred embodiment of the invention, the user prepares an IDL file containing the same code, as below:</p>
    <p num="66">
      --
      <br/>
      -- interface A
      <br/>
      --      +
      <br/>
      --         void print ()
      <br/>
      --      }
    </p>
    <p num="67">
      The system creates a class called OBInterface in the in-memory model, and, in the persistent model, instances of the class DMMethod and the class DMArg.
      <br/>
      As described above, the instance of DMMethod includes the attribute MethodBody which contains the method implementation that the user entered in the edit session, namely `cout&lt;&lt;"hello";`.
    </p>
    <p num="68">The method implementation in the MethodBody includes:</p>
    <p num="69">
      --
      <br/>
      -- void A::print ()
      <br/>
      --      +
      <br/>
      --         cout &lt; &lt; "hello";
      <br/>
      --      }
    </p>
    <p num="70">When the user decides to make the change permanent, for example by clicking on the Ol( button in a user dialogue box, the DMMethod including the MethodBody is saved in the persistent data model.</p>
    <p num="71">When the user makes the change to add a parameter at a later date, for example, to change the print statement from having no parameters to having the parameter in short p1, the MethodBody is not changed by the system.</p>
    <p num="72">The generated a.IDL file would include the code below:</p>
    <p num="73">
      --
      <br/>
      -- interface A
      <br/>
      --      +
      <br/>
      --         void print (in short p1);
      <br/>
      --      }
    </p>
    <p num="74">Thus the text that the user previously entered is recovered in the form below for viewing and for further editing at the option of the user.</p>
    <p num="75">
      --
      <br/>
      -- void A::print(in short p1)
      <br/>
      --      +
      <br/>
      --         cout &lt; &lt; "hello";
      <br/>
      --      }
    </p>
    <p num="76">
      As described above, the MethodBody is saved as a string binary large object, and therefore is not changed by the system except upon being edited by the user.
      <br/>
      Because the MethodBody is a string, it can contain material that can be used in any platform upon which the user is working.
      <br/>
      For example, it can contain Java code or C++ code or a combination of text and code an individual language.
    </p>
    <p num="77">
      An advantage of the invention is that the user does not have to re-enter large amounts of text and code from IDL files that previously would overwrite text that was entered by way of an editor.
      <br/>
      A further advantage is that the invention is inherently independent of the language used because the code and text entered by means of an editor is stored as string data in the MethodBody attribute of the instances of a DMMethod class, and is retrieved in the same way.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>The embodiments of the invention in which an exclusive property or privilege is claimed are defined as follows:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>In an object-oriented development system having components that generate skeleton source code, a method of storing interface definition information and implementation information comprising:</claim-text>
      <claim-text>a) providing an in-memory storage model and a persistent storage model; b) retaining said interface definition information and implementation information in a method body in said in-memory storage model; c) upon an instruction from a user application following preparation of a modified file containing updates to said implementation information, storing said interface definition and updated implementation information as meta-data in said persistent storage model; d) recovering said interface definition and updated implementation information from said persistent storage model;</claim-text>
      <claim-text>and e) regenerating skeleton code containing said modified implementation information.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. A method as claimed in claim 1, wherein said implementation informaton is stored as an attribute of an instance of a class.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. A method as claimed in claim 1, wherein said implementation information is stored as a binary large object block.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A method as claimed in claim 3, wherein said implementation information comprises a text string.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. An object-oriented application development system providing components that generate skeleton source code, said system comprising: a) an in-memory data storage area; b) a persistent data storage area; c) application program interfaces providing storage capability for interface definition information and implementation information as metadata in a method body in either of said storage areas; d) an editor for modifying code in at least one component of the implementation information; e) means for retrieving said information from the persistent data storage area;</claim-text>
      <claim-text>and f) means for regenerating said skeleton source code.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. A system as claimed in claim 5, wherein said persistent data storage area is provided in a persistent data model.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. A system as claimed in claim 5 wherein said implementation information is stored as an attribute of an instance of a class.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A system as claimed in claim 5 to 7 wherein said implementation information is stored in the form of a binary large object block.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. A system as claimed in claim 8 wherein said implementation information comprises a block of code in a high level computer language.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A system as claimed in claim 7 wherein said metadata is stored as method implementation information.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A system as claimed in any of claim 7 to 10 wherein said implementation information comprises business logic.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A system as claimed in any of claim 7 to 11 wherein said implementation information comprises a text string.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. In an object-oriented programming system having a persistent data model, a graphical editor for application programs, comprising machine executable instructions for: displaying a graphical file tree structure in an applications program under development; monitoring user input requesting the display of an object from said file tree structure, and, responsive to said request, highlighting said object in said file tree display; displaying the inheritance relationships of the requested object in said file tree and displaying a list of methods in a class corresponding to a user's selection of one of said displayed inheritance relationships; displaying for editing a stored method implementation representing a method selected from said displayed list of methods; saving the edited method implementation as metadata within said object in said persistent data model;</claim-text>
      <claim-text>and regenerating the source code of said application program under development.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A computer-readable memory for storing the statements or instructions for use in the execution in a computer of any one of the systems of claims 2-9 or 13.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. In an object-oriented programming system having a persistent data model, a method of graphically editing application programs, said method comprising: displaying a graphical file tree structure in an applications program under development; monitoring user input requesting the display of an object from said file tree structure, and, responsive to said request, highlighting said object in said file tree display; displaying the inheritance relationships of the requested object in said file tree and displaying a list of methods in a class corresponding to a user's selection of one of said displayed inheritance relationships; displaying for editing a stored method implementation representing a method selected from said displayed list of methods; saving the edited method implementation as metadata within said object in said persistent data model;</claim-text>
      <claim-text>and regenerating the source code of said application program under development.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. A computer-readable medium having executable statements or instructions for performing the methods of any one of claims 1, 2, 3, 8 and 15.</claim-text>
    </claim>
  </claims>
</questel-patent-document>