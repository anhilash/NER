<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185304B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185304</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185304</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="21839670" extended-family-id="42113311">
      <document-id>
        <country>US</country>
        <doc-number>09027765</doc-number>
        <kind>A</kind>
        <date>19980223</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09027765</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43171462</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>2776598</doc-number>
        <kind>A</kind>
        <date>19980223</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09027765</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H04L   9/06        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>06</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>380037000</text>
        <class>380</class>
        <subclass>037000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>380259000</text>
        <class>380</class>
        <subclass>259000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-009/002</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>002</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130619</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-009/0625</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>9</main-group>
        <subgroup>0625</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130619</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-2209/24</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>2209</main-group>
        <subgroup>24</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130619</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>29</number-of-claims>
    <exemplary-claim>3</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>9</number-of-drawing-sheets>
      <number-of-figures>9</number-of-figures>
      <image-key data-format="questel">US6185304</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and apparatus for a symmetric block cipher using multiple stages</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>BECKER WOLFRAM</text>
          <document-id>
            <country>US</country>
            <doc-number>4157454</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4157454</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>ADAMS CARLISLE M</text>
          <document-id>
            <country>US</country>
            <doc-number>5511123</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5511123</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>RIVEST RONALD L</text>
          <document-id>
            <country>US</country>
            <doc-number>5724428</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5724428</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Even and Goldreich, On The Power of Cascade Ciphers, 1983.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>John Savard, Cypto Compendium, httpo://home ecn.ab.ca/~jsavard/crypto/co041203.htm, 1998.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Matthew Kwan, The Design of the ICE encrytpion Algorithm, Proceeding of Fast Software, 1997.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>B. Schneier, Description of a New Variable-Length Key, 64-Bit Block Cipher (Bowfish), Dec. 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>Y. Zheng, On the Construction of Block Ciphers Provably Secure and Not Relying on Any Unproved Hypotheses, 1989.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="6">
          <text>B. Schneier, et. al., Unbalanced Feistel Networks an Block-Cipher Design, 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="7">
          <text>B. Schneier, Applied Cryptography, 2e, John Wiley pp. 193, 198-201, 347, 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="8">
          <text>Adina Di Porto, Vino: A Block Cipher including Variable Permutations, 1993.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Coppersmith, Don</name>
            <address>
              <address-1>Ossining, NY, US</address-1>
              <city>Ossining</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Gennaro, Rosario</name>
            <address>
              <address-1>New York, NY, US</address-1>
              <city>New York</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Halevi, Shai</name>
            <address>
              <address-1>Heartsdale, NY, US</address-1>
              <city>Heartsdale</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Jutla, Charanjit S.</name>
            <address>
              <address-1>Elmsford, NY, US</address-1>
              <city>Elmsford</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="5">
          <addressbook lang="en">
            <name>Matyas, Jr., Stephen M.</name>
            <address>
              <address-1>Manassas, VA, US</address-1>
              <city>Manassas</city>
              <state>VA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="6">
          <addressbook lang="en">
            <name>O'Connor, Luke James</name>
            <address>
              <address-1>Adliswil, CH</address-1>
              <city>Adliswil</city>
              <country>CH</country>
            </address>
          </addressbook>
          <nationality>
            <country>CH</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="7">
          <addressbook lang="en">
            <name>Peyravian, Mohammed</name>
            <address>
              <address-1>Cary, NC, US</address-1>
              <city>Cary</city>
              <state>NC</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="8">
          <addressbook lang="en">
            <name>Safford, David Robert</name>
            <address>
              <address-1>Brewster, NY, US</address-1>
              <city>Brewster</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="9">
          <addressbook lang="en">
            <name>Zunic, Nevenko</name>
            <address>
              <address-1>Wappingers Falls, NY, US</address-1>
              <city>Wappingers Falls</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Ray-Yarletts, Jeanine S.</name>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>Doubet, Marcia L.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Hayes, Gail O.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      The present invention provides a technique, system, and computer program for a symmetric key block cipher.
      <br/>
      Variable block sizes and key sizes are supported, as well as a variable number of rounds.
      <br/>
      The cipher uses multiple stages of processing, where the stages have different structures and different subround functions, to provide excellent resistance to both linear and differential attacks.
      <br/>
      Feistel Type-3 networks are used, with different networks during different stages.
      <br/>
      The number of rounds may vary among stages.
      <br/>
      Subkeys are used in some, but not all, stages.
      <br/>
      The variable-length keys can be precomputed.
      <br/>
      A novel manner of using multiplication in a cipher is defined.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      1.
      <br/>
      Related Invention
    </p>
    <p num="2">
      IBM application Ser.
      <br/>
      No. 09/027,769 entitled "Method and Apparatus for a Symmetric Block Cipher using Multiple Stages with Type-1 and Type-3 Feistel Networks", filed Feb. 23, 1998.
    </p>
    <p num="3">2. Field of the Invention</p>
    <p num="4">
      The present invention relates to cryptography, and deals more particularly with a system and method for a symmetric key block cipher.
      <br/>
      This cipher uses multiple stages, where the stages have different structures and different subround functions.
      <br/>
      The cipher allows the block size, key size, and number of rounds per stage of ciphering to vary.
    </p>
    <p num="5">3. Description of the Related Art</p>
    <p num="6">
      Cryptography is a security mechanism for protecting information from unintended disclosure by transforming the information into a form that is unreadable to humans, and unreadable to machines that are not specially adapted to reversing the transformation back to the original information content.
      <br/>
      The cryptographic transformation can be performed on data that is to be transmitted electronically, such as an electronic mail message, and is equally useful for data that is to be securely stored, such as the account records for customers of a bank or credit company.
    </p>
    <p num="7">
      In addition to preventing unintended disclosure, cryptography also provides a mechanism for preventing unauthorized alteration of data transmitted or stored in electronic form.
      <br/>
      After the data has been transformed cryptographically, an unauthorized person is unlikely to be able to determine how to alter the data, because the specific data portion of interest cannot be recognized.
      <br/>
      Even if the unauthorized user knew the position of the data portion within a data file or message, this position may have been changed by the transformation, preventing the unauthorized person from merely substituting data in place.
      <br/>
      If an alteration to the transformed data is made by the unauthorized user despite the foregoing difficulties, the fact of the alteration will be readily detectable, so that the data will be considered untrustworthy and not relied upon.
      <br/>
      This detection occurs when the transformation is reversed: the encrypted data will not reverse to its original contents properly if it has been altered.
      <br/>
      The same principle prevents unauthorized addition of characters to the data, and deletion of characters from the data, once it has been transformed.
    </p>
    <p num="8">
      The transformation process preformed on the original data is referred to as "encryption".
      <br/>
      The process of reversing the transformation, to restore the original data, is referred to as "decryption".
      <br/>
      The terms "encipher" and "decipher" are also used to describe these processes, respectively.
      <br/>
      A mechanism that can both encipher and decipher is referred to as a "cipher".
    </p>
    <p num="9">
      Data encryption systems are well known in the data processing art.
      <br/>
      In general, such systems operate by performing an encryption operation on a plaintext input block, using an encryption key, to produce a ciphertext output block. "Plaintext" refers to the fact that the data is in plain, unencrypted form. "Ciphertext" indicates that the data is in enciphered, or encrypted, form.
      <br/>
      The receiver of an encrypted message performs a corresponding decryption operation, using a decryption key, to recover the original plaintext block.
    </p>
    <p num="10">
      A cipher to be used in a computer system can be implemented in hardware, in software, or in a combination of hardware and software.
      <br/>
      Hardware chips are available that implement various ciphers.
      <br/>
      Software algorithms are known in the art as well.
    </p>
    <p num="11">
      Encryption systems fall into two general categories.
      <br/>
      Symmetric (or secret key) encryption systems use the same secret key for both encrypting and decrypting messages.
      <br/>
      An example of a symmetric encryption system is the Data Encryption Standard (DES) system, which is a United States federal standard described in NBS FIPS Pub 46.
      <br/>
      In the DES system, a key having 56 independently specifiable bits is used to convert 64-bit plaintext blocks to ciphertext blocks, or vice versa.
    </p>
    <p num="12">
      Asymmetric (or public key) encryption systems, on the other hand, use different keys that are not feasibly derivable from one another for encryption and decryption.
      <br/>
      A person wishing to receive messages generates a pair of corresponding encryption and decryption keys.
      <br/>
      The encryption key is made public, while the corresponding decryption key is kept secret.
      <br/>
      Anyone wishing to communicate with the receiver may encrypt a message using the receiver's public key.
      <br/>
      Only the receiver may decrypt the message, however, since only he has the private key.
      <br/>
      Perhaps the best-known asymmetric encryption system is the RSA encryption system, named after its originators Rivest, Shamir, and Adleman.
    </p>
    <p num="13">The category of symmetric encryption systems can be further subdivided into those which operate on fixed size blocks of data (block ciphers), and those which operate on arbitrary length streams of data (stream ciphers).</p>
    <p num="14">
      While there are many method of symmetric key block encryption, most popular methods (for example, DES, CAST, RC5, and Blowfish) are based on Type-2 Fiestel Networks.
      <br/>
      A Type-2 Fiestel Network consists of dividing the data to be encrypted into two halves, and then performing some number of rounds, where each round consists of transforming the left half of the data based on the right half of the data, and then transforming the right half based on the modified left half.
      <br/>
      The two transformations are called subrounds; in the case of RC5, for example, there are two subrounds in each of 16 full rounds.
      <br/>
      These transformations must be invertible.
      <br/>
      That is, it must be possible to perform some set of operations during decryption that will reverse the transformations performed during encryption.
      <br/>
      In a standard Feistel network, some non-invertible function of one half of the data is simply exclusive-OR'd with the other half, as the exclusive OR operation provides invertibility, but any invertible function may be used in the general case.
    </p>
    <p num="15">
      Feistel Networks are not limited to this case of dividing the data into two equal halves.
      <br/>
      Alternatively, in a Type-1 Feistel the data is divided into n equal words, where n&gt;2.
      <br/>
      If these words are labeled A(1) to A(n), then a full round consists of n subrounds, where each subround consists of transforming word A(i) based on the value of word A(i-1) (with A(1) transformed by A(n)).
    </p>
    <p num="16">
      Similarly, a Type-3 Feistel can be constructed in which the data is divided into n equal words, where n&gt;2, but in which each word is used to transform more than one (possibly all) of the other words.
      <br/>
      For example, A(1) could be used to transform A(1), A(3), and A(4) in one subround.
      <br/>
      A full round consists of n such subrounds.
    </p>
    <p num="17">
      Feistel based ciphers typically add additional invertible transformations before, and/or after, each full round.
      <br/>
      For example, some ciphers exclusive-OR the entire data block with subkey data before the first round, to complicate certain attacks. "Subkey" refers to using a different key during different rounds, where the subkey values are derived from an input key.
    </p>
    <p num="18">
      The distinguishing features of different Feistel based ciphers are determined by the choice of the function used to modify a given data word in each subround.
      <br/>
      Different functions provide different tradeoffs between speed, data size, and security.
    </p>
    <p num="19">
      Many ciphers, such as DES and CAST, base their subround functions on a construct called a substitution box, or S-box, which is an array of data elements.
      <br/>
      In operation, a cipher block data word is used as an index into the S-box, and the value at that location is then used as the output value.
      <br/>
      The entries in the S-box are carefully chosen to have good properties for resistance to various attacks, including differential and linear analysis.
      <br/>
      Some desirable properties of S-boxes include that if the input words vary by one bit, on average, half the output bits should change, so that even small changes in the input data rapidly spread to all the output bits.
      <br/>
      Also, the entries in the S-box should be chosen to have little correlation to the index, to provide good resistance to linear attacks.
      <br/>
      While S-box based functions may provide excellent security, they tend to be slow in software implementations, especially on processors with small register sets, due to the costs of index calculation, and the corresponding higher use of register resources.
    </p>
    <p num="20">
      Other ciphers, such as RC5, base their subround functions on bit-wise rotations, in which one data word is used to specify an amount to rotate the target word.
      <br/>
      Data-dependent rotation provides a very fast subround function, as there are no index calculations and no memory references needed, and all the operations can be kept within the registers.
      <br/>
      Data-dependent rotations, however, tend to have relatively poor resistance to differential attacks, requiring more rounds to ensure security.
    </p>
    <p num="21">
      There are also a few ciphers, most notably IDEA and its variants, which use integer multiplication in their round functions.
      <br/>
      Because of the good diffusion properties of the multiplication operation, the round functions of these ciphers have very good resistance to differential attacks.
      <br/>
      On the other hand, to achieve this resistance these ciphers implement a multiplication in an algebraic field, which forces them to perform operations modulo some prime number. (Typically, this prime is chosen as 216 +1).
      <br/>
      This modular arithmetic complicates operation of the round function and causes a significant slowdown of the cipher.
      <br/>
      Also, the complicated round function of these ciphers, and in particular the fact that data words are multiplied by each other, makes it harder to analyze their properties and evaluate their security.
    </p>
    <p num="22">
      In view of the above, a stronger, more flexible algorithm is needed.
      <br/>
      One way to make a cipher stronger is to increase the number of rounds of ciphering performed: with each successive transformation, the resulting encryption becomes more difficult to break.
      <br/>
      Another way to increase the strength is to increase the size of the key.
      <br/>
      Since the contents of the key remain secret, increasing the size adds another level of difficulty for anyone trying to deduce what transformations may have been performed on the original data, because they are unlikely to guess the random number combination making up the key.
      <br/>
      Yet another way to increase algorithm strength is to increase the size of the "block" on which the cipher performs its transformations.
      <br/>
      A block is the unit of original data processed during one ciphering operation.
      <br/>
      The larger the block size, the more difficult it becomes for an adversary to construct a dictionary of plaintext and matching ciphertext, for a given key, large enough to pose a threat to the security of the algorithm.
      <br/>
      Further, different keys (i.e., subkeys) can be used for each round, increasing the number of random number combinations that would have to be correctly guessed in order to break the cipher.
    </p>
    <p num="23">
      It will be appreciated that when a cipher allows varying the number of rounds, the key size, the key values, and the block size at the same time, an incredibly difficult challenge is presented to a person attempting to discover the original data contents from an encrypted result.
      <br/>
      It will also be appreciated that the computations involved to cipher the data are quite complex, and that while performing more rounds of ciphering increases the strength of the result, it also causes computation time to increase.
      <br/>
      When data is very sensitive, this time spent in ciphering will be warranted.
      <br/>
      It may be, however, that less sensitive data does not warrant the added time and expense of many rounds of ciphering.
      <br/>
      By providing an algorithm where the number of rounds, the key size and values, and the block size are variable, the ultimate choice between the level of security required and the amount of computation time utilized rests with the user.
      <br/>
      By allowing the number of rounds per stage, key size, and block size to vary, the cipher of the present invention becomes, in effect, scalable in three dimensions.
    </p>
    <p num="24">
      Existing symmetric key block ciphers may provide for variation in the key size, the block size, and the number of rounds of ciphering, but these ciphers define a single type of round function, and iterate that function repeatedly.
      <br/>
      Existing ciphers tend to avoid use of multiplication in the round functions, because existing ways of using multiplication in ciphers tend to operate inefficiently.
      <br/>
      Further, use of S-boxes in existing ciphers tends to be inefficient, because subkeys are used as indices to access the S-boxes.
    </p>
    <p num="25">Accordingly, a need exists for an improved and more flexible symmetric block cipher which offers excellent resistance to linear and differential attacks; operates quickly and efficiently while using S-boxes; uses multiplication in a fast and efficient round function; and supports a variable length key, variable length block, and a variable number of rounds per stage.</p>
    <p num="26">
      The technique of the present invention achieves these objectives by using multiple stages while using the fast operations of table lookup, exclusive OR, addition, subtraction, multiplication, and data-dependent rotation, thereby minimizing the time required to encrypt and decrypt data.
      <br/>
      Multiplication is fast because of a novel manner of using multiplication in an algebraic ring.
      <br/>
      Table lookup using S-boxes is made faster because some rounds access the S-boxes without using subkeys.
      <br/>
      The data-independent sub-keys can be precomputed, further minimizing the time required for encryption and decryption.
      <br/>
      A minimal amount of computer storage is required for data used in the operation of the cipher.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="27">An object of the present invention is to provide a technique whereby data can be encrypted in such a manner as to make discovery of the underlying data contents, other than by use of the corresponding decryption technique, computationally infeasible.</p>
    <p num="28">Another object of the present invention is to provide a technique whereby encryption is accomplished using a symmetric key block cipher with a strength better than that of existing symmetric block ciphers, with significantly improved efficiency.</p>
    <p num="29">Another object of the present invention is to provide a solution that does not use a significant amount of computer storage, in order to maximize the number of environments in which the solution can be used, including limited-storage devices such as those known as "Smart Cards".</p>
    <p num="30">Another object of the present invention is to provide a technique whereby decryption of the encrypted data restores the data to its original contents, in an efficient and error-free manner.</p>
    <p num="31">Another object of the present invention is to provide a solution that can be implemented in hardware or in software.</p>
    <p num="32">Another object of the present invention is to provide a solution that allows precomputing the subkeys to be used for each round of ciphering, in order to minimize the time required for encrypting or decrypting an individual file or message.</p>
    <p num="33">
      Still another object of the present invention is to provide a technique whereby the cipher used for encryption and decryption uses multiple stages, where the stages have different structures and different subround functions.
      <br/>
      This use of differing structures makes the cipher much more resistant to attack, because an attack that is successful against one structure must then be successful against the next structure as well--which is incredibly difficult to accomplish.
      <br/>
      Thus, any weakness that exists in one of the structures will be cancelled out by the other structure(s).
    </p>
    <p num="34">
      A further object of the present invention is to provide a technique whereby the cipher uses a variable number of rounds per stage of processing during encryption and decryption, a variable length block of data as the unit to be encrypted and decrypted, and a variable length key.
      <br/>
      Allowing these factors to vary will provide the user with choices that will not only affect execution time and strength of security for any given use of the cipher, but will also allow variation between subsequent uses of the cipher, further increasing the difficulty of breaking encrypted data from a given source.
      <br/>
      The variation capability makes the cipher scalable in three dimensions, providing the user with flexibility to tune the algorithm to achieve the proper trade-off between execution time required and security achieved, in order to meet the needs of his particular application.
    </p>
    <p num="35">Yet another object of the present invention is to provide a technique whereby particular values for the variable information used by the algorithm--i.e., key length, block length, and number of rounds per stage--can be factored into the software or hardware implementation, as fixed values, in order to optimize performance.</p>
    <p num="36">
      This invention describes a novel Feistel based symmetric block cipher, using a hybrid structure where use of multiple stages provides multiple different Type-3 rounds, and uses different subround functions in different stages.
      <br/>
      By using several stages, each with rounds having different structure and functions, the overall cipher can provide a better combination of attributes than a cipher based on a single structure and round function.
    </p>
    <p num="37">
      In the preferred embodiment, this design divides the encryption operation into five stages.
      <br/>
      In the first and fifth stages, a single round is performed, in which a word of subkey data is added to each of the input data words.
      <br/>
      These first and last stages provide some resistance to chosen plaintext attacks.
      <br/>
      The second and fourth stages each consist of two full Type-3 Feistel rounds of (unkeyed) S-box based mixing, using two "8 * 32" S-boxes, each with 256 entries of 4-byte values. ("8 * 32" refers to the fact that the S-box takes an 8-bit input, and returns a 32-bit output.) These stages provide rapid mixing to offer resistance to differential attacks.
      <br/>
      By keeping these rounds unkeyed, the performance penalty of S-box operations is minimized, while still providing good differential properties.
    </p>
    <p num="38">
      In the preferred embodiment, the middle (third) stage consists of four full rounds of Type-3 Feistel, each consisting of four subrounds.
      <br/>
      The subround function is based on a novel combination of multiplication of data words by subkey words, and data-dependent rotations.
      <br/>
      This stage provides the bulk of the keyed non-linearity, with very fast rounds.
      <br/>
      A forward function is used in this stage, whereby integer multiplication modulo 2x is used, where x is the number of bits in the word size.
      <br/>
      Using an algebraic ring in this manner allows the result to have the strong encryption strength achieved with multiplication, with very fast and efficient processing, without requiring an inversion operation during decryption.
    </p>
    <p num="39">Other objects and advantages of the present invention will be set forth in part in the description and in the drawings which follow and, in part, will be obvious from the description or may be learned by practice of the invention.</p>
    <p num="40">
      To achieve the foregoing objects, and in accordance with the purpose of the invention as broadly described herein, the present invention provides a technique, system, and method for implementing a symmetric key block cipher supporting a plurality of stages, a variable length input key, a variable length block, and a variable number of rounds in each of the stages, and where the stages have differing structures and a plurality of subrounds in the rounds have differing subround functions, comprising a subprocess for accessing and retrieving values in two substitution boxes (S-boxes); a subprocess for generating a plurality of subkeys using the input key and a pseudorandom function; a subprocess for encrypting a plurality of input data words of a plurality of input data blocks of an input data file using the S-boxes and a plurality of the generated subkeys, producing a corresponding plurality of encrypted data words of a plurality of encrypted data blocks of an encrypted data file.
      <br/>
      The subprocess for encrypting comprises a first set of stages, wherein at least two of the structures comprise a Type-3 Feistel network.
      <br/>
      The cipher further comprises a subprocess for decrypting each of the encrypted data words using the S-boxes and the plurality of generated subkeys, resulting in restoration of the plurality of input data words.
      <br/>
      The subprocess for decrypting comprises a second set of stages, wherein at least two of the structures comprises an inverse of the Type-3 Feistel networks.
      <br/>
      Preferably, each set of stages is comprised of five stages, where the first stage for encryption comprises a subprocess for performing addition using subkeys; the second stage comprises a subprocess for performing unkeyed Feistel Type-3 mixing using the S-boxes; the third stage comprises a subprocess for performing a Feistel Type-3 multiplication using subkeys, as well as data-dependent rotation; the fourth stage comprises a subprocess for performing a second unkeyed Feistel Type-3 mixing using the S-boxes; and the fifth stage comprises a subprocess for performing addition using subkeys.
      <br/>
      The stages for decryption are these inverse of these encryption stages.
      <br/>
      Preferably, the first and fifth stages comprise a single round; the second and fourth stages comprise two rounds, and the third stage comprises four rounds.
      <br/>
      The subround operations preferably are taken from the set comprising table lookup using said S-boxes, exclusive OR, addition (with subtraction as an inverse), multiplication and data-dependent rotation.
      <br/>
      The table lookup operation is preferably performed without use of subkeys.
      <br/>
      The data-dependent rotation operation preferably places a value specifying an amount of rotation in a single register, where that register is used when performing the rotation.
      <br/>
      A multiplication product is preferably used to specify the amount of rotation for the data-dependent rotation.
      <br/>
      The multiplication product may be formed by multiplying one of the input data words by one of the subkeys.
      <br/>
      Further, the multiplication operation is preferably performed in an algebraic ring.
      <br/>
      Optionally, the cipher implementation may be optimized by having values entered before a final production of the code, to fix one or more of the variables supported.
      <br/>
      One or more of the subprocesses may be embodied in a hardware chip.
      <br/>
      A novel manner of using multiplication in a cipher is defined.
    </p>
    <p num="41">The present invention will now be described with reference to the following drawings, in which like reference numbers denote the same element throughout.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="42">
      FIG. 1 is a prior art block diagram of a computer workstation environment in which the present invention may be practiced;
      <br/>
      FIG. 2 is a prior art diagram of a networked computing environment in which the present invention may be practiced;
      <br/>
      FIG. 3 illustrates the stages of operation used by the present invention for encrypting a block of plaintext into a block of ciphertext;
      <br/>
      FIG. 4 shows a flow diagram of the process used during Stage 2 of the preferred embodiment of the present invention, to complete a round of encryption;
      <br/>
      FIG. 5 shows a flow diagram of the process used during Stage 4 to complete a round of encryption;
      <br/>
      FIG. 6A shows a flow diagram of the process used during Stage 3 to complete a full round of encryption;
      <br/>
      FIG. 6B shows a flow diagram of the process used during each subround of Stage 3 encryption; and
      <br/>
      FIGS. 7A and 7B show an example of substitution boxes that may be used with the present invention.
    </p>
    <heading>DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="43">
      FIG. 1 illustrates a representative workstation hardware environment in which the present invention may be practiced.
      <br/>
      The environment of FIG. 1 comprises a representative single user computer workstation 10, such as a personal computer, including related peripheral devices.
      <br/>
      The workstation 10 includes a microprocessor 12 and a bus 14 employed to connect and enable communication between the microprocessor 12 and the components of the workstation 10 in accordance with known techniques.
      <br/>
      The workstation 10 typically includes a user interface adapter 16, which connects the microprocessor 12 via the bus 14 to one or more interface devices, such as a keyboard 18, mouse 20, and/or other interface devices 22, which can be any user interface device, such as a touch sensitive screen, digitized entry pad, etc.
      <br/>
      The bus 14 also connects a display device 24, such as an LCD screen or monitor, to the microprocessor 12 via a display adapter 26.
      <br/>
      The bus 14 also connects the microprocessor 12 to memory 28 and long-term storage 30 which can include a hard drive, diskette drive, tape drive, etc.
    </p>
    <p num="44">
      The workstation 10 communicates via a communications channel 32 with other computers or networks of computers.
      <br/>
      The workstation 10 may be associated with such other computers in a local area network (LAN) or a wide area network, or the workstation 10 can be a client in a client/server arrangement with another computer, etc.
      <br/>
      All of these configurations, as well as the appropriate communications hardware and software, are known in the art.
    </p>
    <p num="45">
      FIG. 2 illustrates a data processing network 40 in which the present invention may be practiced.
      <br/>
      The data processing network 40 includes a plurality of individual networks, including LANs 42 and 44, each of which includes a plurality of individual workstations 10.
      <br/>
      Alternatively, as those skilled in the art will appreciate, a LAN may comprise a plurality of intelligent workstations coupled to a host processor.
    </p>
    <p num="46">
      Still referring to FIG. 2, the data processing network 40 may also include multiple mainframe computers, such as a mainframe computer 46, which may be preferably coupled to the LAN 44 by means of a communications link 48.
      <br/>
      The mainframe computer 46 may be implemented utilizing an Enterprise Systems Architecture/370, or an Enterprise Systems Architecture/390 computer available from the International Business Machines Corporation (IBM).
      <br/>
      Depending on the application, a midrange computer, such as an Application System/400 (also known as an AS/400) may be employed. "Enterprise Systems Architecture/370" is a trademark of IBM; "Enterprise Systems Architecture/390", "Application System/400", and "AS/400" are registered trademarks of IBM.
    </p>
    <p num="47">
      The mainframe computer 46 may also be coupled to a storage device 50, which may serve as remote storage for the LAN 44.
      <br/>
      Similarly, the LAN 44 may be coupled to a communications link 52 through a subsystem control unit/communication controller 54 and a communications link 56 to a gateway server 58.
      <br/>
      The gateway server 58 is preferably an individual computer or intelligent workstation which serves to link the LAN 42 to the LAN 44.
    </p>
    <p num="48">
      Those skilled in the art will appreciate that the mainframe computer 46 may be located a great geographic distance from the LAN 44, and similarly, the LAN 44 may be located a substantial distance from the LAN 42.
      <br/>
      For example, the LAN 42 may be located in California, while the LAN 44 may be located in Texas, and the mainframe computer 46 may be located in New York.
    </p>
    <p num="49">
      Software programming code which embodies the present invention is typically accessed by the microprocessor 12 of the workstation 10 from long-term storage media 30 of some type, such as a CD-ROM drive or hard drive.
      <br/>
      In a client-server environment, such software programming code may be stored with storage associated with a server.
      <br/>
      The software programming code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, hard drive, or CD-ROM.
      <br/>
      The code may be distributed on such media, or may be distributed to users from the memory or storage of one computer system over a network of some type to other computer systems for use by users of such other systems.
      <br/>
      Alternatively, the programming code may be embodied in the memory 28, and accessed by the microprocessor 12 using the bus 14.
      <br/>
      The techniques and methods for embodying software programming code in memory, on physical media, and/or distributing software code via networks are well known and will not be further discussed herein.
    </p>
    <p num="50">
      The encrypted data resulting from use of the present invention may be stored on any of the various media types used by the long-term storage 30, or may be sent from the workstation 10 to another computer or workstation of the network illustrated in FIG. 2 over the communications channel 32, for storage by that other computer or workstation.
      <br/>
      The encrypted data may be decrypted at the same computer or workstation where it was encrypted, or it may be decrypted at a different computer or workstation.
    </p>
    <p num="51">
      In a hardware solution, the present invention may be embodied in the processor 12 of the workstation 10.
      <br/>
      Techniques for implementing logic functions in processors are well known in the art.
    </p>
    <p num="52">The preferred embodiment of the present invention will now be discussed with reference to FIGS. 3 through 7.</p>
    <p num="53">
      In the preferred embodiment, the present invention is implemented as a computer software program.
      <br/>
      This software performs the derivation of subkeys from an input key for use during the rounds of the cipher, the encrypting of the data contents, and the decrypting of the data contents.
      <br/>
      The data may represent a message to be communicated over a network.
      <br/>
      The message may represent any of a number of types of information, such as conversational text sent as electronic mail, or a purchase request containing the buyer's credit card or account data.
      <br/>
      Alternatively, the data may be a conventional data file.
      <br/>
      Examples of this type of data include patient medical history, customer credit history, income tax and earnings data, and any conceivable stored information that needs to be protected from unintended disclosure.
      <br/>
      This type of data may be encrypted for transmission over a network, or it may be encrypted merely for secure storage.
      <br/>
      For ease of reference, the input data file or message will be referred to herein as an "input file".
    </p>
    <p num="54">
      The present invention encrypts and subsequently decrypts the data using a symmetric key block-oriented cipher.
      <br/>
      The concepts of block-oriented ciphers and symmetric keys are well known in the art.
    </p>
    <p num="55">
      The present invention also provides a technique for using variable block sizes, variable key sizes, and a variable number of rounds of cipher processing per stage.
      <br/>
      The purpose of allowing these variables is to give the user of the cipher the flexibility to choose trade-offs between the increased computing time required (for example, as the number of processing rounds increases) and the strength of the resulting encryption.
    </p>
    <p num="56">
      Optionally, the present invention allows the software or hardware implementation of the cipher algorithm to be optimized for particular values of the variables.
      <br/>
      This is done by allowing a user of the cipher to enter values for block size, key size, and/or number of rounds per stage before the final step of producing the cipher implementation.
      <br/>
      The final implementation then treats the values as being fixed, and is optimized for those fixed values.
    </p>
    <p num="57">
      Decryption of data is accomplished in the present invention using the inverse of the data encryption, where the stages used for encryption are performed in reverse order, and the operations performed in each stage are inverted.
      <br/>
      By performing inverse processing, in inverse order, the encrypted data is restored to its original content.
    </p>
    <p num="58">
      The inventive concepts of the present invention define a general approach which can be used with data blocks and keys of differing sizes, and with varying number of rounds per stage.
      <br/>
      For the description of the preferred embodiment, specific values will be used to facilitate description of the processing, although the same methods can be applied with other values.
      <br/>
      The descriptions will all use "C" programming language syntax. (Standard "C" language coding has been used, except where indicated by the phrase "pseudo-code".
      <br/>
      Refer to any "C" language programming manual for an explanation of the syntax used in the "C" language statements.)
    </p>
    <p num="59">
      Specific functions are shown for each of the round functions in the 5 stages of the preferred embodiment.
      <br/>
      However, changes may be made to those round functions without deviating from the inventive concepts of the present invention.
    </p>
    <p num="60">For this description of the design, the variables w, k, d, r1, r2, and n have the following definitions, and are described using the following values:</p>
    <p num="61">
      w=number of bits per word=32,
      <br/>
      k=number of words in the key=4, (for a 128-bit key)
      <br/>
      d=number of words in the data block=4, (for a 128-bit block)
      <br/>
      r1=number of rounds in each mixing stage=2,
      <br/>
      r2=number of rounds in the center stage=4, and
      <br/>
      n=number of words in the expanded key=(2*d)+(8*r2).
    </p>
    <p num="62">
      Arrays K�k�, D�d�, E�n�, S0�256�, and S1�256� are defined as follows:
      <br/>
      K�k� is the key (an array of k w-bit words),
      <br/>
      D�d� is the data (an array of d w-bit words),
      <br/>
      E�n� is the expanded key (an array of n w-bit words),
      <br/>
      S0�256� is S-box 0 (an array of 256 w-bit words), and
      <br/>
      S1�256� is S-box 1 (an array of 256 w-bit words). (FIGS. 7A and 7B show possible examples of S0 and S1 that were randomly generated.
      <br/>
      Other values may be used instead of those shown, without deviating from the inventive concepts of the present invention.)
    </p>
    <p num="63">
      The cipher uses two rotation functions, which are defined as follows:
      <br/>
      ROTATE (x, y, w) rotates the w-bit word x by (y mod w) locations to the left;
      <br/>
      IROTATE (x, y, w) rotates the w-bit word x by (y mod w) locations to the right.
    </p>
    <p num="64">The cipher has three major component functions: key setup, encryption, and decryption.</p>
    <p num="65">
      Note that the processes shown for the stages do not show a user entering particular values to be used for the variables (defining the block size, key size, and number of rounds per stage), nor a value to be used for the key.
      <br/>
      The user will have been prompted to enter these values upon invoking the cipher function, or the values will be read from a file.
      <br/>
      Alternatively, if an optimized implementation of the cipher is being used, the user will have been prompted to enter one or more of these values before the final step of producing the cipher implementation (e.g. compiling the cipher code) has completed.
      <br/>
      Techniques for entering values required by an implementation are well known in the art.
    </p>
    <p num="66">Key Setup Phase</p>
    <p num="67">
      Subkeys are generated using an input key.
      <br/>
      A user of the invention may be prompted, for example from a computer terminal, to enter the input key.
      <br/>
      Alternatively, the input key could be read from a file stored on disk, or passed as a parameter to a computer program embodying the present invention.
      <br/>
      The key setup phase may be performed immediately prior to the encryption phase when encrypting a particular input file, or the subkeys may be generated well in advance of the encryption.
      <br/>
      In the latter case, the subkeys would be stored for later use, in order to minimize the time required to encrypt a data file.
      <br/>
      Regardless of when the subkeys are generated, the generation process follows the same steps.
    </p>
    <p num="68">
      An expansion process is performed on the input key, to create an expanded key array (as previously defined).
      <br/>
      Expanding the input key in this manner allows greater randomness for the subkeys used during the encryption rounds, without requiring a key of very large size to be input to the cipher.
      <br/>
      For example, in the preferred embodiment, the input key is 128 bits long (4 words, each having 32 bits), whereas the expanded key is 1280 bits long (using the formulas defined above, 40 words each having 32 bits).
      <br/>
      The entries in this expanded key array are then used as subkeys in the key-dependent rounds of encryption, and the corresponding rounds of decryption.
      <br/>
      Techniques for key expansion are well known in the art.
      <br/>
      The following is one way of expanding keys for use with the present invention.
    </p>
    <p num="69">
      Key setup is performed by filling the expanded key array with values generated using iterated pseudorandom functions that use a counter, i, and the input key K as parameters, as specified with the following pseudo-code:
      <br/>
      for (i=0; i&lt;n; i++)
    </p>
    <p num="70">- E�i�=PRF (i, K);</p>
    <p num="71">
      where PRF is some pseudorandom function using the concatenation of input parameters i and K, returning a word.
      <br/>
      It will be understood by one skilled in the art that this pseudo-code indicates that the value used for the counter begins at zero; increases by one for each iteration; and that the iterative process is repeated for each value from zero up through and including the value (n-1).
      <br/>
      Thus, a value is assigned to each of the n words of the expanded key array.
      <br/>
      Alternatively, a pseudorandom function may be used that returns more than one word.
      <br/>
      In that situation, the pseudo-code would need to be changed.
      <br/>
      The following example assumes a different pseudorandom function, referred to as PRF1, which uses the concatenation of input parameters i and K, and returns a value of size x:
    </p>
    <p num="72">
      --
      <br/>
      -- for(i = 0;i &lt; n; i += x)    +
      <br/>
      --    temp = PRF1 (i, K);    /* where temp is an array of size x */
      <br/>
      --    for (j = 0;j &lt; x;j++)
      <br/>
      --      E�i + j� = temp �j�; }
    </p>
    <p num="73">
      In the preferred embodiment, the pseudorandom function is the secure hashing function commonly referred to as "SHA-1".
      <br/>
      This hashing function is defined in NIST FIPS 180-1, titled "Secure Hash Standard".
      <br/>
      The SHA-1 function returns a 5-word result each time it is invoked.
      <br/>
      For this function, and any other pseudorandom function which returns more than one word, the preferred embodiment key setup phase "tiles" the output values into the expanded key array, as indicated by the pseudo-code shown above using PRF1.
      <br/>
      That is, the multi-word output is used as multiple sequential array elements, following the sequential group of elements created from the prior invocation of the pseudorandom function.
      <br/>
      For example, the value returned from the first invocation of SHA-1 is used as elements E�0� through E�4�, the value returned from the second invocation is used as elements E�5� through E�9�, etc.
      <br/>
      When the pseudorandom function returns more than one word, the preferred embodiment discards any unneeded words from the end of the returned value that exceed the dimension of the expanded key array.
      <br/>
      Using the dimensions given previously as values for describing the preferred embodiment, the expanded key array has 40 words.
      <br/>
      Since this is a multiple of 5, no words of the final invocation are discarded.
    </p>
    <p num="74">Encryption Phase</p>
    <p num="75">
      Encryption is performed in multiple stages.
      <br/>
      According to the preferred embodiment, five stages are used, as diagrammed in FIG. 3.
      <br/>
      Each of these five stages is performed for each input block of plaintext.
      <br/>
      FIG. 3 shows that from the plaintext words (referred to as D�0� through D�3� in FIG. 3), application of the five stages creates the output block of ciphertext (referred to as c�0� through c�3� in FIG. 3).
      <br/>
      As previously stated, the number of words per block used by the present invention is variable: four-word blocks are shown in FIG. 3 as an illustrative block size.
    </p>
    <p num="76">
      While the preferred embodiment is described using five stages, more stages may be added without deviating from the inventive concepts of the present invention.
      <br/>
      For example, the operations of Stage 1 could be repeated following operation of Stage 2, and the operation of Stage 5 could be performed prior to operation of Stage 4 as well as after Stage 4.
    </p>
    <p num="77">
      The stages of the preferred embodiment are described using a general approach to subkey usage, whereby subkeys are accessed in sequential groups.
      <br/>
      Alternative approaches to selecting subkeys may be used without deviating from the inventive concepts of the present invention.
      <br/>
      For example, instead of using each subkey sequentially within a group, an index might be used to cause selection of every other subkey, or every third subkey, or perhaps generating an index number randomly.
      <br/>
      When the subkeys are chosen from a greater range of indices in this manner, then the size of the subkey group used will need to expand accordingly; or, the group size might be retained, with the subkeys within that group being re-used.
      <br/>
      The description of the encryption stages gives more detail about how subkey selection might be altered to fit within the approach defined for that stage.
      <br/>
      It will be obvious to one of ordinary skill in the art that any such alterations to the preferred embodiment subkey selection for encryption must be reflected also in the decryption stages.
    </p>
    <p num="78">Each of the five stages of the preferred embodiment will now be described in detail.</p>
    <p num="79">Encryption Stages 1 and 5</p>
    <p num="80">
      Stages 1 and 5 of the preferred embodiment consist of simply adding one subkey word to each of the data words, which in "C" code can be specified as:
      <br/>
      /* Stage 1: add subkeys to all data words */
      <br/>
      for (j=0; j&lt;d; j++)
      <br/>
      - D�j�+=E�j�;
      <br/>
      /* Stage 5: add subkeys to all data words */
      <br/>
      for (j=0; j&lt;d; j++)
      <br/>
      - D�j�+=E�d+(8*r2)�;
    </p>
    <p num="81">
      As will be understood by one skilled in the art, the result of the "C" code for stage 1 is to iterate d times, where d is the number of words in each block, using an iteration counter, j. The d iterations together comprise the single round of Stage 1 processing of the preferred embodiment.
      <br/>
      Each word D�0� through D�d-1� from the data block has the corresponding word E�0� through E�d-1� from the expanded key array added to it.
      <br/>
      The result of this addition is then used as the new value of the data block word D�0� through D�d-1�. When 4-word blocks are used, the first 4 subkeys (elements E�0� through E�3�) are used each time the Stage 1 process is performed.
    </p>
    <p num="82">
      The result of the "C" code for stage 5 is also to iterate d times, using an iteration counter j. These d iterations comprise the single round of Stage 5 processing of the preferred embodiment.
      <br/>
      Each word D�0� through D�d-1� from the data block has the corresponding word E�d+(8*r2)� through E�(d+(8*r2))+d-1� from the expanded key array added to it.
      <br/>
      The result of this addition is then used as the new value of the data block word D�0� through D�d-1�. When 4-word blocks are used, the last 4 subkeys (elements E�n-3� through E�n�) are used each time the Stage 5 process is performed.
    </p>
    <p num="83">
      While the preferred embodiment of Stages 1 and 5 uses 1 round (having d subrounds), the number of rounds can be increased without deviating from the inventive concepts of the present invention.
      <br/>
      For example, another round of subkey addition could be performed, using a different group of subkeys.
    </p>
    <p num="84">
      Subkey selection for Stages 1 and 5 might be altered to use different subkeys.
      <br/>
      Instead of using j as an index into the subkey array, Stage 1 might use (2*j), or (3*j), etc. If a sufficiently large value is used, then the computation needs to ensure that indices beyond the maximum size of the expanded key array are adjusted, to select a subkey within the proper range.
      <br/>
      For example, if the computation result is described as some value "x", then the index �x mod ((2*d)+(8*r2))� will ensure that x is a valid index for the expanded key array.
      <br/>
      Since Decryption Stage 5 uses the same subkeys used by Encryption Stage 1, in the same order, any changes made to the selection computation need to be factored into the decryption computations as well.
      <br/>
      For example, if (2*j) is used in encryption, then (2*j) is used in decryption to select those same subkeys.
    </p>
    <p num="85">
      As shown in FIG. 3, the new data block created by operation of Stage 1 becomes the input to Stage 2.
      <br/>
      The input to Stage 5 comes from the output of Stage 4, and the output of Stage 5 is used as the resulting ciphertext block for the block of data being encrypted.
    </p>
    <p num="86">Encryption Stages 2 and 4</p>
    <p num="87">
      Stages 2 and 4 each perform an unkeyed Type-3 Feistel mixing, each using r1 rounds of mixing.
      <br/>
      In the preferred embodiment, r1=2.
      <br/>
      For each round of mixing, each subround consists of taking one of the data words, and using each of its bytes as an index into an S-box, then taking the word in that S-box entry, and either adding or exclusive OR'ing it into one of the other data words.
      <br/>
      Each full round consists of doing d such subrounds, where each subround uses a different data word as source.
    </p>
    <p num="88">
      Between the subrounds, 2 simple feedback addition or subtraction operations are added.
      <br/>
      This provides some of the strength of a full round, without the expense.
    </p>
    <p num="89">
      In the preferred embodiment, each data word has 4 bytes, and each round has 4 subrounds.
      <br/>
      A diagram of a full Stage 2 mixing round using 4-byte data words and 4 subrounds is given in FIG. 4, and a full Stage 4 mixing round is shown in FIG. 5.
      <br/>
      In "C" code, Stages 2 and 4 can be specified as:
      <br/>
      /* Stage 2: for each of r1 mixing rounds . . . */
      <br/>
      for (i=0; i&lt;r1; i++) +
      <br/>
      - /* Data word D�0� is used to mix D�1�, D�2�, D�3� */
      <br/>
      - mixSubRound (D, 0, 1, 2, 3);
      <br/>
      - D�0�+=D�3�;
      <br/>
      - /* Data word D�1� is used to mix D�2�, D�3�, D�0� */
      <br/>
      - mixSubRound (D, 1, 2, 3, 0);
      <br/>
      - D�1�+=D�2�;
      <br/>
      - /* Data word D�2� is used to mix D�3�, D�0�, D�1� */
      <br/>
      - mixSubRound (D, 2, 3, 0, 1);
      <br/>
      - /* Data word D�3� is used to mix D�0�, D�1�, D�2� */
      <br/>
      - mixSubRound (D, 3, 0, 1, 2);
      <br/>
      }
      <br/>
      /* Stage 4: for each of r1 inverse mixing rounds . . .*/
      <br/>
      for (i=0; i&lt;r1; i++) +
      <br/>
      - /* Data word D�3� is used to inversely mix D�0�, D�1�, D�2� */
      <br/>
      - inverseMixSubRound (D, 3, 0, 1, 2);
      <br/>
      - /* Data word D�2� is used to inversely mix D�3�, D�0�, D�1� */
      <br/>
      - inverseMixSubRound (D, 2, 3, 0, 1);
      <br/>
      - D�1�-=D�2�;
      <br/>
      - /* Data word D�1� is used to inversely mix D�2�, D�3�, D�0� */
      <br/>
      - inverseMixSubRound (D, 1, 2, 3, 0);
      <br/>
      - D�0�-=D�3�;
      <br/>
      - /* Data word D�0� is used to inversely mix D�1�, D�2�, D�3� */
      <br/>
      - inverseMixSubRound (D, 0, 1, 2, 3);
      <br/>
      }
    </p>
    <p num="90">
      As can be seen from these "C" language statements, Stage 2 and Stage 4 are very similar, but with a different ordering.
      <br/>
      There are many ways in which ordering could be changed without deviating from the inventive concepts of the present invention: the preferred embodiment shows one example, which is to use inversion.
    </p>
    <p num="91">
      The function "mixSubRound", used for each of the four subrounds of Stage 2 as shown above, is specified in "C" code as:
      <br/>
      /* Data word D�src� is used to mix D�dst1�, D�dst2�, D�dst3�.
      <br/>
      * Each byte of D�src� is used as an index into an S-box, taking the
      <br/>
      * output word, and adding or exclusive OR'ing it into one of the other three
      <br/>
      * data words.
      <br/>
      Two S-boxes are used to avoid cancellations.
      <br/>
      * Notice that at the end of this subround, the D�src� data word is rotated
      <br/>
      * 24 locations to the left.
      <br/>
      */
      <br/>
      mixSubRound(WORD D� �, int src, dst1, dst2, dst3)
      <br/>
      +
      <br/>
      - D�dst1� =S0 �D�src� &amp;255�;
      <br/>
      - D�src�=ROTATE (D�src�, 8, w);
      <br/>
      - D�dst1�+=S1 �D�src� &amp;255�;
      <br/>
      - D�src�=ROTATE (D�src�, 8, w);
      <br/>
      - D�dst2�+=S0 �D�src� &amp;255�;
      <br/>
      - D�src�=ROTATE (D�src�, 8, w);
      <br/>
      - D�dst3� =S1 �D�src� &amp;255�;
      <br/>
      }
    </p>
    <p num="92">
      The function "inverseMixSubRound", used for each of the four subrounds of Stage 4 as shown above, is specified in "C" code as:
      <br/>
      /* Data word D�src� is used to inversely mix D�dst1�, D�dst2�, D�dst3�.
      <br/>
      * Each byte of D�src� is used as an index into an S-box, taking the
      <br/>
      * output word, and subtracting or exclusive OR'ing it into one of the other three
      <br/>
      * data words.
      <br/>
      Two S-boxes are used to avoid cancellations.
      <br/>
      * Notice that at the end of this subround, the D�src� data word is rotated
      <br/>
      * 24 locations to the right.
      <br/>
      */
      <br/>
      inverseMixSubRound(WORD D� �, int src, dst1, dst2, dst3)
      <br/>
      +
      <br/>
      - D�dst3� =S1 �D�src� &amp;255�;
      <br/>
      - D�src�=IROTATE (D�src�, 8, w);
      <br/>
      - D�dst2�-=S0 �D�src� &amp;255�;
      <br/>
      - D�src�=IROTATE (D�src�, 8, w);
      <br/>
      - D�dst1�-=S1 �D�src� &amp;255�;
      <br/>
      - D�src�=IROTATE (D�src�, 8, w);
      <br/>
      - D�dst1� =S0 �D�src� &amp;255�;
      <br/>
      }
    </p>
    <p num="93">
      As will be understood by one skilled in the art, the processing of Stage 2 as defined by the above "C" language statements (and as shown in FIG. 4) performs one subround for each data word of the data block.
      <br/>
      Four subrounds are shown, for the example where each data block has 4 data words.
      <br/>
      The first subround mixes word D�0�; the second subround mixes D�1�; the third subround mixes D�2�; and the fourth subround mixes D�3�.
    </p>
    <p num="94">
      As an example of the operation of the subround function, consider the first subround of Stage 2, using data blocks which have 4 data words each.
      <br/>
      This first subround invokes the mixing function using the parameters (D, 0, 1, 2, 3), as shown above.
      <br/>
      The first operation of the mixing function "mixSubRound", shown as the first line of "C" code, masks off all but the low-order 8 bits of D�0�, by performing an AND operation where the two operands are D�0� and 255.
      <br/>
      Thus, the last byte of D�0� is isolated from the other bytes.
      <br/>
      The value in this byte is then used as the 8-bit index into S-box zero.
      <br/>
      A 32-bit value is retrieved as a result of this index operation.
      <br/>
      That 32-bit value is exclusive OR'd with the 32-bit value in D�1�. The result of this exclusive OR operation becomes the new value of D�1�. The second operation of the mixing function, shown as the second line of "C" code, rotates D�0� 8 positions to the left.
      <br/>
      The third operation of the mixing function, shown as the third line of"C" code, uses this rotated D�0� and again masks off all but the low-order 8 bits.
      <br/>
      Because of the prior rotation, a different byte of D�0� is now isolated by this masking operation.
      <br/>
      That byte is used as an index into S-box one.
      <br/>
      The 32-bit value retrieved is added to the value of D�1�, and the result becomes the new value of D�1�. In the fourth operation, D�0� is again rotated 8 positions to the left, so that the fifth operation will isolate a different byte.
      <br/>
      In the fifth operation, the low-order byte from D�0� is used to index into S-box zero, and the value retrieved is added to D�2�, forming the new value for D�2�. In the sixth operation, D�0� is rotated a final time, so that the remaining unused byte rotates into the low-order 8 bits.
      <br/>
      The seventh operation isolates this byte, and uses it to index into S-box one.
      <br/>
      The retrieved value is then exclusive OR'd with D�3�, forming a new value for D�3�. Invocation of mixSubRound is then complete, and control returns to the main processing routine of Stage 2.
      <br/>
      As seen in the "C" code, after returning to the main processing, the value now stored in D�3� is added to the value in D�0� as the first-described feedback operation, forming a new value for D�0�.
    </p>
    <p num="95">
      The other three subrounds of processing in Stage 2 are analogous to the first, with two exceptions.
      <br/>
      First, the data words are passed as parameters in different orders in each subround, as indicated.
      <br/>
      Second, an addition operation is used as a feedback operation following the first and second invocations of mixSubRound (as shown in the "C" code and described above for subround 1), but no such addition operation is used following the third or fourth invocations.
    </p>
    <p num="96">
      It will be obvious to one skilled in the art how to change the definition and invocation of mixSubRound if blocks of different size, or data words of different size, are used.
      <br/>
      For example, if blocks of 8 words were used (instead of blocks of 4 words), mixSubRound would be invoked 8 times. (In other words, there would be 8 subrounds, each subround comprising an invocation of the mixing function.) The value passed as the parameter designated "src" would typically begin at 0, and proceed sequentially through 7.
      <br/>
      The parameters designated "dst1", "dst2", and "dst3" could be left as they are, passing various combinations of the values between 0 and 3.
      <br/>
      Alternatively, each invocation could use 3 parameters chosen from the range 0 through 7 (and chosen to be distinct from the value used for "src"), meaning that each of the 8 words is being used in transformation, but not to transform every one of the seven other words.
      <br/>
      Or, mixSubRound could be redefined to accept more parameters.
      <br/>
      If it was desired to use all 8 words to mix every other word, then 4 more parameters would be added to the definition of (and to each invocation of) mixSubRound, so that all 8 words were passed on each invocation, in varying order.
      <br/>
      Additional statements would need to be added to mixSubRound to use the additional parameters.
      <br/>
      For example, each exclusive OR and each addition operation might be replaced by two such operations, while still using 4 retrieved S-box values, so that each retrieved value was factored into 2 different parameters.
      <br/>
      Or, the rotation operations could be changed to use 4 bit positions, giving 8 different values to use for indexing the S-boxes.
      <br/>
      Then, a different retrieved value could be used in each of 8 exclusive OR or addition operations, each operation being performed on a different parameter.
    </p>
    <p num="97">
      As will be understood by one skilled in the art, the processing of Encryption Stage 4 as defined by the above "C" language statements performs one subround for each data word of the data block.
      <br/>
      Four subrounds are shown, for the example where each data block has 4 data words.
      <br/>
      The first subround inversely mixes word D�3�; the second subround inversely mixes D�2�; the third subround inversely mixes D�1�; and the fourth subround inversely mixes D�0�.
    </p>
    <p num="98">
      As stated previously, the operation of Stage 4 is similar to that of Stage 2, except that a different ordering is used.
      <br/>
      In the preferred embodiment, inversion is used.
      <br/>
      Therefore, 2 subtraction operations are used as the 2 feefback operations between rounds, instead of 2 addition operations.
      <br/>
      The function "inverseMixSubRound" rotates values to the right, instead of to the left, and replaces the addition operations of "mixSubRound" with subtraction.
    </p>
    <p num="99">
      As an example of the operation of the subround function during Stage 4, consider the first subround, using data blocks which have 4 data words each.
      <br/>
      This first subround invokes the inverse mixing function using the parameters (D, 3, 0, 1, 2), as shown above.
      <br/>
      The first operation of the inverse mixing function "inverseMixSubRound", shown as the first line of "C" code, masks off all but the low-order 8 bits of D�3�, by performing an AND operation where the two operands are D�3� and 255.
      <br/>
      Thus, the last byte of D�3� is isolated from the other bytes.
      <br/>
      The value in this byte is then used as the 8-bit index into S-box one.
      <br/>
      A 32-bit value is retrieved as a result of this index operation.
      <br/>
      That 32-bit value is exclusive OR'd with the 32-bit value in D�2�. The result of this exclusive OR operation becomes the new value of D�2�. The second operation of the inverse mixing function, shown as the second line of "C" code, uses the function IROTATE to rotate D�3� 8 positions to the right.
      <br/>
      The third operation of the inverse mixing function, shown as the third line of "C" code, uses this rotated D�3� and again masks off all but the low-order 8 bits.
      <br/>
      Because of the prior rotation, a different byte of D�3� is now isolated by this masking operation.
      <br/>
      That byte is used as an index into S-box zero.
      <br/>
      The 32-bit value retrieved is subtracted from the value of D�1�, and the result becomes the new value of D�1�. In the fourth operation, D�3� is again rotated 8 positions to the right, so that the fifth operation will isolate a different byte.
      <br/>
      In the fifth operation, the low-order byte from D�3� is used to index into S-box one, and the value retrieved is subtracted from D�0�, forming the new value for D�0�. In the sixth operation, D�3� is rotated a final time, so that the remaining unused byte rotates into the low-order 8 bits.
      <br/>
      The seventh operation isolates this byte, and uses it to index into S-box zero.
      <br/>
      The retrieved value is then exclusive OR'd with D�0�, forming a new value for D�0�. Invocation of inverseMixSubRound is then complete, and control returns to the main processing routine of Stage 4.
    </p>
    <p num="100">
      The other three subrounds of processing in Stage 4 are analogous to the first, with two exceptions.
      <br/>
      First, the data words are passed as parameters in different orders in each subround, as indicated.
      <br/>
      Second, a subtraction operation is used as a feedback operation following the second and third invocations of inverseMixSubRound (as shown in the "C" code), but no such subtraction operation is used following the first or fourth invocations.
    </p>
    <p num="101">
      It will be obvious to one skilled in the art how to change the definition and invocation of inverseMixSubRound if blocks of different size, or data words of different size, are used.
      <br/>
      It will also be obvious that if the definition and invocation of mixSubRound is changed for Stage 2, as described above, then corresponding changes would be made to Stage 4.
      <br/>
      Refer to the prior discussion of changing mixSubRound for a discussion of possible changes that might be made.
    </p>
    <p num="102">The output of Stage 2 is used as the input to Stage 3, as shown in FIG. 3; similarly, the input to Stage 4 is the output of Stage 3.</p>
    <p num="103">
      The mixing operations of Stages 2 and 4 increase resistance of the cipher output to differential attacks.
      <br/>
      Since subkeys are not used in these stages, the processing within each stage is very fast.
    </p>
    <p num="104">Encryption Stage 3</p>
    <p num="105">
      Stage 3 consists of r2 rounds of a keyed Type-3 Feistel.
      <br/>
      In the preferred embodiment, r2=4, and the round function is based on a subround function comprising a combination of multiplication and data-dependent rotation.
      <br/>
      A subround is performed for each of d data words in the block.
      <br/>
      Other operations could be added to Stage 3 without deviating from the inventive concepts of the present invention.
      <br/>
      For example, S-box lookup operations could be added.
    </p>
    <p num="106">
      Stage 3 implements a forward function, whereby integer multiplication modulo 2w is used, where w is the number of bits in the word size.
      <br/>
      Using an algebraic ring in this manner allows the result to have the strong encryption strength achieved with multiplication, with very fast and efficient processing.
      <br/>
      By using this multiplication in a forward function, there is not a requirement for an inversion operation during decryption.
    </p>
    <p num="107">
      The structure used for a full round of Stage 3 processing is diagrammed in FIG. 6A; the detailed operation of each subround is shown in FIG. 6B. The processing of Stage 3 (corresponding to the diagram in FIG. 6A) can be specified by the following "C" code:
      <br/>
      /* Stage 3: processes each of r2 rounds . . . */
      <br/>
      for (i=0; i&lt;r2; i++) +
      <br/>
      - /* D�0� modifies D�1�, D�2�, and D�3� */
      <br/>
      - D�0�+=E�(8*i)+d�;
      <br/>
      - subRound (D, 0, 1, 2, 3, E�(8*i)+d+1�);
      <br/>
      - /* D�1� modifies D�2�, D�3�, and D�0� */
      <br/>
      - D�1�+=E�(8*i)+d+2�;
      <br/>
      - subRound (D, 1, 2, 3, 0, E�(8*i)+d+3�);
      <br/>
      - /* D�2� modifies D�3�, D�0�, and D�1� */
      <br/>
      - D�2�+=E�(8*i)+d+4�;
      <br/>
      - subRound (D, 2, 3, 0, 1, E�(8*i)+d+5�);
      <br/>
      - /* D�3� modifies D�0�, D�1�, and D�2� */
      <br/>
      - D�3�+=E�(8*i)+d+6�;
      <br/>
      - subRound (D, 3, 0, 1, 2, E�(8*i)+d+7�);
      <br/>
      }
    </p>
    <p num="108">
      As will be understood by one skilled in the art, this "C" language code specifies the processing for 4 subrounds.
      <br/>
      The processing for each subround is similar, with the only differences being the order in which the data words are used as parameters and the use of different subkeys in each subround.
    </p>
    <p num="109">
      In the first subround, processing begins by adding a subkey to the value of data word D�0�. For the first round, using the example where the number of data words in a block, d,=4, the particular subkey used is the subkey having index 4 in the expanded key array. (For the first round, i=0, so that the expression "(8*i)+d" used to index into the key array evaluates to (8*0)+4=4.) Next, the subRound function is invoked, passing the data block, 4 integers used to specify the order of processing for the data words (in this case, the integers 0, 1, 2, and 3), and another subkey.
      <br/>
      The subkey used this time is the one next following the subkey that was used in the addition operation just performed.
      <br/>
      Thus, for the first round, the subkey having index 5 will be used in the subRound function.
    </p>
    <p num="110">
      As stated, processing for the other subrounds is analogous, having the differences previously stated, and performing the operations as shown in the "C" code.
      <br/>
      By the end of a full round of Stage 3 processing, a subkey has been added to each data word, and then that updated data word has been used to modify each other data word in a key-dependent manner.
      <br/>
      The eight operations used for the mainline Stage 3 processing use 8 different subkeys, arranged sequentially in the expanded key array.
      <br/>
      The next of the r2 rounds proceeds as the first round, except that a new group of 8 subkeys is used.
      <br/>
      These 8 subkeys sequentially follow the 8 used in the first subround.
      <br/>
      When r2=4, the subkeys used (in order) for the total of 16 subrounds are those having indices from 4 though 35, inclusive.
    </p>
    <p num="111">
      As stated earlier, a different approach to subkey selection may be used without deviating from the inventive concepts of this invention.
      <br/>
      For example, instead of the coding shown above which increments the subkey index by one for each usage (first in the addition operations, then in the subRound invocation), the amount of increment could be some different number, such as even numbers in sequence, or odd numbers in sequence, etc.
      <br/>
      Corresponding changes must then be made to the Stage 3 decryption subkey selection computations.
    </p>
    <p num="112">
      The detailed operation of the "subRound" function, shown in FIG. 6B, can be specified by the following pseudo-code:
      <br/>
      /* Data word D�in� is used to modify D�out1�, D�out2�, and D�out3� */
      <br/>
      void subRound (WORD D� �, int in, out1, out2, out3, WORD keyWord)
    </p>
    <p num="113">
      --
      <br/>
      -- +
      <br/>
      --  temp1 = D�in�; /* three temporary variables are needed */
      <br/>
      --  temp2 = D�in�;
      <br/>
      --  temp3 = D�in�;
      <br/>
      --  keyWord .vertline.=1; /* the keyWord must be an ODD integer */
      <br/>
      --  temp2 *= keyWord; /* the data * key multiplication */
      <br/>
      --  ROTATE (temp2, 5, w); /* followed by left rotation */
      <br/>
      --  temp3  = temp2; /* the result is XOR'd into temp3 */
      <br/>
      --  ROTATE (temp1,  /* and also used to rotate temp1 */
      <br/>
      --  temp2, w);
      <br/>
      --  temp2  = temp1; /* which is then XOR'd into temp2 */
      <br/>
      --  ROTATE (temp3, 4, w); /* temp3 is rotated */
      <br/>
      --  ROTATE (temp1, temp3, /* and then used to rotate temp1 */
      <br/>
      --  w);
      <br/>
      --  temp3 += temp1; /* which is then added back to temp3 */
      <br/>
      --  D�out1� += temp1; /* modify each of the other 3 data words */
      <br/>
      --  D�out2�  = temp2;
      <br/>
      --  D�out3� += temp3;
      <br/>
      -- }
    </p>
    <p num="114">
      As will be understood by one skilled in the art, the subRound function begins by making 3 separate copies of the data word D�in�, which is the data word to be used in modifying the other data words of the block for this particular subround.
      <br/>
      Then, the integer value 1 is OR'd with the subkey passed as the value of the parameter keyWord, to ensure that the subkey is an odd integer.
      <br/>
      Next, the original value of D�in� stored in temp2 is multiplied by this subkey, and the result in temp2 is rotated 5 positions to the left.
      <br/>
      The original value of D�in� stored in temp3 is then exclusive OR'd with this rotated temp2 value, forming a new value for temp3.
      <br/>
      The original value of D�in� stored in temp1 is then rotated to the left, where the value in temp2 is used to specify the amount of rotation.
      <br/>
      After the left rotation, the updated value in temp1 is exclusive OR'd with the value in temp2.
      <br/>
      Next, temp3 is rotated by 4 positions to the left, and this rotated value is then used to specify how many positions to the left temp1 should be rotated.
      <br/>
      Following these two rotation operations, the new value of temp1 is added to the new value of temp3, to form yet another value for temp3.
      <br/>
      Finally, the three modified versions of the original D�in�, which are stored in temp1, temp2, and temp3, are used to modify the other 3 data words.
      <br/>
      The data word passed as the first of these 3 input parameters, D�out1�, is modified by having the value in temp1 added to it.
      <br/>
      The data word passed as the second of these 3 parameters, D�out2�, is modified by being exclusive OR'd with the value in temp2.
      <br/>
      The data word passed as the third of these 3 parameters, D�out3�, is modified by having the value in temp3 added to it.
      <br/>
      The processing of the subRound function is now complete for this subround.
      <br/>
      All other subrounds are processed in an identical manner.
    </p>
    <p num="115">Decryption</p>
    <p num="116">
      Decryption is simply the reverse of encryption, running the same operations in the reverse order, reversing the addition and subtraction operations.
      <br/>
      Referring to the diagrams in FIGS. 3-6, the decryption process corresponds to using the operations shown in the diagrams, with these changes: (1) the order of the stages is reversed; (2) the operations are processed from the bottom of the diagrams towards the top (except in FIG. 6A, which is changed from left-to-right encryption processing to right-to-left decryption processing); (3) each addition or subtraction operation is replaced by a subtraction or addition operation, respectively; and (4) each rotation operation rotates to the right instead of to the left.
      <br/>
      Note: An exception to this statement is the processing shown in FIG. 6B. Because the processing used therein for Stage 3 encryption is a forward function, it is not necessary to change the direction of rotation (nor to invert the multiplication operations) when implementing the inverse function for decryption.
      <br/>
      The decryption process will now be described in detail, using "C" language statements to describe the preferred embodiment.
    </p>
    <p num="117">
      The preferred embodiment of the decryption phase is described using five stages, to correspond to the preferred embodiment on the encryption phase which was described using five stages.
      <br/>
      It will be understood by one skilled in the art that any changes made to the preferred embodiment of the encryption phase (according to the alternatives discussed herein, for example changing the block size) must be reflected by corresponding changes to the decryption phase.
      <br/>
      Note that the stage numbering used to describe the decryption phase uses numbers 1 through 5, in that order (where the decryption stages 1 through 5 correspond to encryption stages 5 though 1, in descending order).
    </p>
    <p num="118">Decryption Stages 1 and 5</p>
    <p num="119">
      Decryption Stages 1 and 5 of the preferred embodiment consist of simply subtracting one subkey word from each of the data words, which in "C" code can be specified as:
      <br/>
      /* Decryption Stage 1: subtract subkeys from all data words */
      <br/>
      for (j=0; j&lt;d; j++)
      <br/>
      - D�j�-=E�d+(8*r2)+j�;
      <br/>
      /* Decryption Stage 5: subtract subkeys from all data words */
      <br/>
      for (j=0; j&lt;d; j++)
      <br/>
      - D�j�-=E�j�;
    </p>
    <p num="120">
      As will be understood by one skilled in the art, the result of the "C" code for stage 1 is to iterate d times, where d is the number of words in each block, using an iteration counter, j. The d iterations together comprise the single round of Stage 1 processing of the preferred embodiment.
      <br/>
      Each word D�0� through D�d-1� from the data block has the corresponding word E�d*(r2+1)� through E�(d*(r2+1))+d-1� from the expanded key array subtracted from it.
      <br/>
      The result of this subtraction is then used as the new value of the data block word D�0� through D�d-1�. When 4-word blocks are used, the last 4 subkeys (elements E�n-3� through E�n�) are used each time the Stage 1 process is performed.
    </p>
    <p num="121">
      The result of the "C" code for stage 5 is also to iterate d times, using an iteration counter j. These d iterations comprise the single round of Stage 5 processing of the preferred embodiment.
      <br/>
      Each word D�0� through D�d-1� from the data block has the corresponding word E�0� through E�d-1� from the expanded key array subtracted from it.
      <br/>
      The result of this subtraction is then used as the new value of the data block word D�0� through D�d-1�. When 4-word blocks are used, the first 4 subkeys (elements E�0� through E�3�) are used each time the Stage 5 process is performed.
    </p>
    <p num="122">
      The new data block created by operation of Stage 1 becomes the input to Stage 2.
      <br/>
      The input to Stage 5 comes from the output of Stage 4, and the output of Stage 5 is used as the resulting plaintext block for the block of data being decrypted.
    </p>
    <p num="123">Decryption Stages 2 and 4</p>
    <p num="124">
      Stages 2 and 4 are identical to Stages 2 and 4 of encryption.
      <br/>
      Stage 2 decryption uses mixing, with addition and left rotation.
      <br/>
      This corresponds to the inverse of Encryption Stage 4.
      <br/>
      Stage 4 decryption uses inverse mixing, with subtraction and right rotation.
      <br/>
      This corresponds to the inverse of Encryption Stage 2.
      <br/>
      Again, each of these stages uses r1 rounds of inverse mixing.
      <br/>
      In the preferred embodiment, r1=2.
      <br/>
      Each full round consists d subrounds, where each subround uses a different data word as source.
    </p>
    <p num="125">Refer to the description of Encryption Stages 2 and 4, above, for "C" language statements showing a specification that can be used for Decryption Stages 2 and 4, respectively, and for a detailed description of the operation of the stages.</p>
    <p num="126">
      As stated previously, the diagram shown in FIG. 4 for encryption Stage 2 can be used to illustrate decryption, for decryption Stage 4, by reading the diagram from the bottom up, changing addition to subtraction, and changing left rotation to right rotation.
      <br/>
      Similarly, the diagram shown in FIG. 5 for encryption Stage 4 can be used to illustrate decryption Stage 2, by making similar changes as for FIG. 4.
    </p>
    <p num="127">The output of Stage 2 is used as the input to Stage 3, as shown in FIG. 3; similarly, the input to Stage 4 is the output of Stage 3.</p>
    <p num="128">Decryption Stage 3</p>
    <p num="129">
      Decryption Stage 3 consists of r2 rounds of a keyed Type-3 Feistel, based on a subround function consisting of a combination of multiplication and data-dependent rotations.
      <br/>
      In the preferred embodiment, r2=4.
      <br/>
      A subround is performed for each of d data words in the block.
      <br/>
      Note that because the function "subRound" used in Encryption Stage 3 is a forward function, it is not necessary to invert the multiplication or data-dependent rotation operations when implementing the inverse function in "inverseSubRound".
    </p>
    <p num="130">
      The structure used for a full round of Decryption Stage 3 can be specified by the following "C" code:
      <br/>
      /* Decryption Stage 3: processes each of r2 rounds . . . */
      <br/>
      for (i=r2-1; i&gt;=0; i - - - ) +
      <br/>
      - /* D�3� modifies D�0�, D�1�, and D�2� */
      <br/>
      - inverseSubRound (D, 3, 0, 1, 2, E�(8*i)+d+7�);
      <br/>
      - D�3�-=E�(8*i)+d+6�;
      <br/>
      - /* D�2� modifies D�3�, D�0�, and D�1� */
      <br/>
      - inverseSubRound (D, 2, 3, 0, 1, E�(8*i)+d+5�);
      <br/>
      - D�2�-=E�(8*i)+d+4�;
      <br/>
      - /* D�1� modifies D�2�, D�3�, and D�0� */
      <br/>
      - inverseSubRound (D, 1, 2, 3, 0, E�(8*i)+d+3�);
      <br/>
      - D�1�-=E�(8*i)+d+2�;
      <br/>
      - /* D�0� modifies D�1�, D�2�, and D�3� */
      <br/>
      - inverseSubRound (D, 0, 1, 2, 3, E�(8*i)+d+1�);
      <br/>
      - D�0�-=E�(8*i)+d�;
      <br/>
      }
    </p>
    <p num="131">
      As will be understood by one skilled in the art, this "C" language code specifies the processing for 4 subrounds.
      <br/>
      As in encryption Stage 3, the processing for each subround is similar, with the only differences being the order in which the data words are used as parameters and the use of different subkeys in each subround.
      <br/>
      As previously indicated, these statements (and those shown below for the function inverseSubRound) correspond to the diagrams shown for encryption in FIGS. 6A and 6B, if the diagram in FIG. 6A is read from right to left, and addition and subtraction are reversed.
    </p>
    <p num="132">
      In the first subround of decryption, processing begins by invoking the function "inverseSubRound".
      <br/>
      This function (defined below) performs the inverse operations of the operations performed during encryption (in the encryption function "subRound").
      <br/>
      This function is invoked once for each subround, where the parameters passed as integers to specify the order of processing data bytes are passed in the same order as the order in which they were passed during encryption, but with that particular arrangement of parameters passed for a different subround: the order of subrounds is reversed from the order used during encryption.
      <br/>
      Thus, the first subround of decryption passes the integers 3, 0, 1, 2, which were the integers passed for the fourth subround of encryption, and so forth.
      <br/>
      A subkey is also passed as a parameter to this inverseSubRound function.
      <br/>
      The arithmetic expression used to specify the index for the subkey is the same as the expression used during encryption for that particular arrangement of parameters.
      <br/>
      Following invocation of inverseSubRound, a subkey is subtracted from the value of data word D�3�. This will be the subkey next preceding the subkey that was used in the function invocation.
      <br/>
      For the first round, using the example where the number of data words in a block,d=4 and the number of rounds r2=4, the particular subkey used in the function invocation is the subkey having index 35 in the expanded key array. (For the first round, i=3, so that the expression "(8*i)+d+7" used to index into the key array evaluates to (8*3)+4+7 =35.) Thus, for the subtraction operation of the first round, the next preceding subkey is the one having index 34.
    </p>
    <p num="133">
      As stated, decryption processing for the other subrounds is analogous, having the differences previously stated, and performing the operations as shown in the "C" code.
      <br/>
      By the end of a full round of Decryption Stage 3 processing, each data word has been used to modify each other data word in a key-dependent manner, and then a subkey has been subtracted from the value of that modifying data word.
      <br/>
      The eight operations used for the mainline Decryption Stage 3 processing use 8 different subkeys, arranged in sequentially descending order in the expanded key array.
      <br/>
      The next of the r2 rounds proceeds as the first round, except that a new group of 8 subkeys is used.
      <br/>
      These 8 subkeys sequentially precede the 8 used in the first subround.
      <br/>
      When r2=4, the subkeys used (in order) for the total of 16 subrounds are those having indices from 35 counting down though 28, inclusive, and then from 27 down through 20, etc., until the final group from 11 down through 4 is processed.
    </p>
    <p num="134">The detailed operation of the "inverseSubRound" function can be specified by the following pseudo-code:</p>
    <p num="135">
      --
      <br/>
      -- /* Data word D�in� is used to modify D�out1�, D�out2�, and D�out3� */
      <br/>
      -- void inverse SubRound (WORD D��, int in, out1, out2, out3,
      <br/>
      -- WORD keyWord)
      <br/>
      -- +
      <br/>
      --  temp1 = D�out1�; /* three temporary variables are needed */
      <br/>
      --  temp2 = D�out2�;
      <br/>
      --  temp3 = D�out3�;
      <br/>
      --  keyWord .vertline.=1; /* the keyWord must be an ODD integer */
      <br/>
      --  temp2 *= keyWord; /* the data * key multiplication */
      <br/>
      --  ROTATE (temp2, 5, w); /* followed by left rotation */
      <br/>
      --  temp3  = temp2; /* the result is XOR'd into temp3 */
      <br/>
      --  ROTATE (temp1,  /* and also used to rotate temp1 */
      <br/>
      --  temp2, w);
      <br/>
      --  temp2  = temp1; /*which is then XOR'd into temp2 */
      <br/>
      --  ROTATE (temp3, 4, w); /* temp3 is rotated */
      <br/>
      --  ROTATE (temp1, temp3, /* and then used to rotate temp1 */
      <br/>
      --  w);
      <br/>
      --  temp3 += temp1; /* which is then added back to temp3 */
      <br/>
      --  D�out1� -= temp1; /*modify each of the other 3 data words */
      <br/>
      --  D�out2�  = temp2;
      <br/>
      --  D�out3� -= temp3;
      <br/>
      -- }
    </p>
    <p num="136">
      As will be understood by one skilled in the art, the inverseSubRound function is very similar to the subRound function used in encryption.
      <br/>
      This similarity is because the function implemented therein is a forward function.
      <br/>
      Thus, the operations within the forward function itself are not being inverted: only the operations following the forward function (that is, the assignment statements performed before returning from the function invocation) are inverted. inverseSubRound begins by making 3 separate copies of the data word D�in�, which is the data word to be used in modifying the other data words of the block for this particular subround.
      <br/>
      Then, the integer value 1 is OR'd with the subkey passed as the value of the parameter keyword, to ensure that the subkey is an odd integer.
      <br/>
      Next, the original value of D�in� stored in temp2 is multiplied by this subkey, and the result in temp2 is rotated 5 positions to the left.
      <br/>
      The original value of D�in� stored in temp3 is then exclusive OR'd with this rotated temp2 value, forming a new value for temp3.
      <br/>
      The original value of D�in� stored in temp1 is then rotated to the left, where the value in temp2 is used to specify the amount of rotation.
      <br/>
      After the left rotation, the updated value in temp1 is exclusive OR'd with the value in temp2.
      <br/>
      Next, temp3 is rotated by 4 positions to the left, and this rotated value is then used to specify how many positions to the left temp1 should be rotated.
      <br/>
      Following these two rotation operations, the new value of temp1 is added to the new value of temp3, to form yet another value for temp3. (This statement, being part of the forward function, does not get inverted from the encryption statement.) Finally, the three modified versions of the original D�in�, which are stored in temp1, temp2, and temp3, are used to modify the other 3 data words.
      <br/>
      These three statements are inverted from their corresponding encryption statement.
      <br/>
      Note that since the statements are independent of one another, the order of the three statements has not been inverted herein.
      <br/>
      Alternatively, the order could be inverted, without changing the functioning of the statements.
      <br/>
      The data word passed as the first of these 3 input parameters, D�out1�, is modified by having the value in temp1 subtracted from it.
      <br/>
      The data word passed as the second of these 3 parameters, D�out2�, is modified by being exclusive OR'd with the value in temp2.
      <br/>
      The data word passed as the third of these 3 parameters, D�out3�, is modified by having the value in temp3 subtracted from it.
      <br/>
      The processing of the inverseSubRound function is now complete for this subround.
      <br/>
      All other subrounds are processed in an identical manner.
    </p>
    <p num="137">
      While the preferred embodiment of the present invention has been described, additional variations and modifications in that embodiment may occur to those skilled in the art once they learn of the basic inventive concepts.
      <br/>
      Therefore, it is intended that the appended claims shall be construed to include both the preferred embodiment and all such variations and modifications as fall within the spirit and scope of the invention.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>We claim:</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3.</claim-text>
      <claim-text>A method of carrying out a symmetric key block cipher using multiple stages, comprising the steps of: performing a first simple arithmetic operation in a first stage; performing a Type-3 Feistel unkeyed mixing operation in a second stage; performing a Type-3 Feistel keyed transform in a third stage; performing a Type-3 Feistel unkeyed inverse mixing operation in a fourth stage;</claim-text>
      <claim-text>and performing a second simple arithmetic operation in a fifth stage, wherein the first simple arithmetic operation and the second simple arithmetic operation may be identical.</claim-text>
      <claim-text>1. A method of encrypting an input file comprising a plurality of blocks using a symmetric key block cipher having an odd number of stages, wherein the odd number is at least 5, comprising the steps of:</claim-text>
      <claim-text>performing a simple arithmetic operation in a first even number of the stages; performing, in a second even number of the stages, an identical number of:</claim-text>
      <claim-text>(1) a Type-3 Feistel unkeyed mixing operation and (2) a Type-3 Feistel unkeyed inverse mixing operation, wherein the first even number and the second even number may be identical;</claim-text>
      <claim-text>and performing a Type-3 Feistel keyed transform in a remaining number of the stages.</claim-text>
      <claim-text>2. The method according to claim 1, wherein the stages in a first half of the first even number and of the second even number are performed during a first half of the odd number of stages, and the stages in a second half of the first even number and of the second even number are performed during a second half of the odd number of stages.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method according to claim 3, wherein one or more of the steps is embodied in a hardware chip.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method according to claim 3, wherein: the first simple arithmetic operation is one of (1) an addition operation, (2) a subtraction operation, or (3) an exclusive OR operation;</claim-text>
      <claim-text>and the second simple arithmetic operation is one of (1) the addition operation, (2) the subtraction operation, or (3) the exclusive OR operation.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method according to claim 5, wherein operands of the first and second simple arithmetic operations are a word being used to encipher a selected data block and a generated key value which has a length identical to that of the word.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method according to claim 3, wherein a plurality of first feedback operations are performed between distinct rounds of the Type-3 Feistel unkeyed mixing operation, and a plurality of second feedback operations are performed between distinct rounds of the Type-3 Feistel unkeyed inverse mixing operation.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method according to claim 7, wherein the first feedback operation is an addition operation and the second feedback operation is a subtraction operation.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method according to claim 3, wherein the Type-3 Feistel unkeyed mixing operation and the Type-3 Feistel unkeyed inverse mixing operation retrieve values from 2 substitution boxes.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method according to claim 3, wherein a round function of the Type-3 Feistel keyed transform comprises a forward function using (1) an integer multiplication modulo 2x operation with a generated key value, where x is a bit length of a word from a block being enciphered, and (2) a data-dependent rotation operation.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method according to claim 3, wherein the cipher supports a variable number of rounds in at least one of the stages, a variable length of generated key values to be used with the cipher in at least the Type-3 Feistel keyed transform, and a variable length of input blocks to be enciphered.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A system for carrying out a symmetric key block cipher using multiple stages, comprising: means for performing a simple arithmetic operation in a first stage; means for performing a Type-3 Feistel unkeyed mixing operation in a second stage; means for performing a Type-3 Feistel keyed transform in a third stage; means for performing a Type-3 Feistel unkeyed inverse mixing operation in a fourth stage;</claim-text>
      <claim-text>and means for performing the simple arithmetic operation in a fifth stage.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The system according to claim 12, wherein the simple arithmetic operation is one of (1) an addition operation, (2) a subtraction operation, or (3) an exclusive OR operation.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The system according to claim 13, wherein operands of the simple arithmetic operation are a word being used to encipher a selected data block and a generated key value which has a length identical to that of the word.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The system according to claim 12, wherein a plurality of first feedback operations are performed between distinct rounds of the Type-3 Feistel unkeyed mixing operation, and a plurality of second feedback operations are performed between distinct rounds of the Type-3 Feistel unkeyed inverse mixing operation.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The system according to claim 15, wherein the first feedback operation is an addition operation and the second feedback operation is a subtraction operation.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The system according to claim 12, wherein the Type-3 Feistel unkeyed mixing operation and the Type-3 Feistel unkeyed inverse mixing operation retrieve values from 2 substitution boxes.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The system according to claim 12, wherein a round function of the Type-3 Feistel keyed transform comprises a forward function using (1) an integer multiplication modulo 2x operation with a generated key value, where x is a bit length of a word from a block being enciphered, and (2) a data-dependent rotation operation.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The system according to claim 12, wherein the cipher supports a variable number of rounds in at least one of the stages, a variable length of generated key values to be used with the cipher in at least the Type-3 Feistel keyed transform, and a variable length of input blocks to be enciphered.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The system according to claim 12, wherein one or more of the means is embodied in a hardware chip.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. A computer program product for carrying out a symmetric key block cipher using multiple stages with a computer, the computer program product embodied on a computer-readable medium and comprising: computer-readable program code means for performing a simple arithmetic operation in a first stage; computer-readable program code means for performing a Type-3 Feistel unkeyed mixing operation in a second stage; computer-readable program code means for performing a Type-3 Feistel keyed transform in a third stage, computer-readable program code means for performing a Type-3 Feistel unkeyed inverse mixing operation in a fourth stage;</claim-text>
      <claim-text>and computer-readable program code means for performing the simple arithmetic operation in a fifth stage.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The computer program product according to claim 21, wherein the simple arithmetic operation is one of (1) an addition operation, (2) a subtraction operation, or (3) an exclusive OR operation.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The computer program product according to claim 22, wherein operands of the simple arithmetic operation are a word being used to encipher a selected data block and a generated key value which has a length identical to that of the word.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The computer program product according to claim 21, wherein a plurality of first feedback operations are performed between distinct rounds of the Type-3 Feistel unkeyed mixing operation, and a plurality of second feedback operations are performed between distinct rounds of the Type-3 Feistel unkeyed inverse mixing operation.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The computer program product according to claim 24, wherein the first feedback operation is an addition operation and the second feedback operation is a subtraction operation.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The computer program product according to claim 21, wherein the Type-3 Feistel unkeyed mixing operation and the Type-3 Feistel unkeyed inverse mixing operation retrieve values from 2 substitution boxes.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The computer program product according to claim 21, wherein a round function of the Type-3 Feistel keyed transform comprises a forward function using (1) an integer multiplication modulo 2x operation with a generated key value, where x is a bit length of a word from a block being enciphered, and (2) a data-dependent rotation operation.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The computer program product according to claim 21, wherein the cipher supports a variable number of rounds in at least one of the stages, a variable length of generated key values to be used with the cipher in at least the Type-3 Feistel keyed transform, and a variable length of input blocks to be enciphered.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The computer program product according to claim 21, wherein one or more of the computer-readable program code means is embodied in a hardware chip.</claim-text>
    </claim>
  </claims>
</questel-patent-document>