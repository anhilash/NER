<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06181353B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06181353</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6181353</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="12486711" extended-family-id="21095875">
      <document-id>
        <country>US</country>
        <doc-number>08792833</doc-number>
        <kind>A</kind>
        <date>19970130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08792833</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>21633111</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>JP</country>
        <doc-number>3704896</doc-number>
        <kind>A</kind>
        <date>19960201</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1996JP-0037048</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H04N   5/278       20060101AFI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>N</subclass>
        <main-group>5</main-group>
        <subgroup>278</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G09G   5/30        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>09</class>
        <subclass>G</subclass>
        <main-group>5</main-group>
        <subgroup>30</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G09G   5/42        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>09</class>
        <subclass>G</subclass>
        <main-group>5</main-group>
        <subgroup>42</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="4">
        <text>H04N   5/445       20110101ALI20101215RHJP</text>
        <ipc-version-indicator>
          <date>20110101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>N</subclass>
        <main-group>5</main-group>
        <subgroup>445</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20101215</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>345537000</text>
        <class>345</class>
        <subclass>537000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>348E05100</text>
        <class>348</class>
        <subclass>E05100</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>375E07026</text>
        <class>375</class>
        <subclass>E07026</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G09G-005/42</classification-symbol>
        <section>G</section>
        <class>09</class>
        <subclass>G</subclass>
        <main-group>5</main-group>
        <subgroup>42</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130822</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G09G-2340/02</classification-symbol>
        <section>G</section>
        <class>09</class>
        <subclass>G</subclass>
        <main-group>2340</main-group>
        <subgroup>02</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130822</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04N-005/44504</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>N</subclass>
        <main-group>5</main-group>
        <subgroup>44504</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130822</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04N-019/00</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>N</subclass>
        <main-group>19</main-group>
        <subgroup>00</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130507</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>27</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>13</number-of-drawing-sheets>
      <number-of-figures>26</number-of-figures>
      <image-key data-format="questel">US6181353</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">On-screen display device using horizontal scan line memories</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>TAKEDA GENYO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4367466</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4367466</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>PASIERB JR JOHN J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4398189</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4398189</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>MAYER STEVEN T, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4435779</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4435779</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>NGUYEN JULIEN T</text>
          <document-id>
            <country>US</country>
            <doc-number>5404437</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5404437</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>BEYERS JR BILLY W, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5534942</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5534942</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>MOFFAT GUY</text>
          <document-id>
            <country>US</country>
            <doc-number>5587726</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5587726</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>KNOX MICHAEL DWAYNE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5640502</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5640502</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>FUJITA RYO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5666520</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5666520</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>EHLERS STEVEN B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5717904</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5717904</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>NGUYEN JULIEN T</text>
          <document-id>
            <country>US</country>
            <doc-number>5821947</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5821947</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant app-type="applicant" sequence="1">
          <addressbook lang="en">
            <name>KURISU MOTOHIRO</name>
          </addressbook>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Kurisu, Motohiro</name>
            <address>
              <address-1>Chigasaki City, Kenagawa-Ken 253, JP</address-1>
              <city>Chigasaki City, Kenagawa-Ken 253</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Cantor Colburn LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Hjerpe, Richard A.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      An on-screen display system using scan line memories.
      <br/>
      Complex on-screen display, comprising multiple layers of on-screen display, is achieved using a pixel memory having a maximum capacity of two horizontal lines of display data.
      <br/>
      Compressed display data (e.g. character, icon, etc.) is read from RAM and expanded into pixel registers.
      <br/>
      Pixel data from the pixel registers is forwarded to pixel memory for on-screen display.
      <br/>
      The pixel memory is also written back into one of the pixel registers and the pixel registers are overlaid to form complex on-screen display data.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND</heading>
    <p num="1">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="2">The invention relates in general to on-screen display (OSD) and in particular to a device that performs complex, overlaying of characters, graphics, etc. utilizing a small-scale display scan memory.</p>
    <p num="3">2. Prior Art</p>
    <p num="4">
      Conventional OSD devices have generally been designed to first store in display memory simple object characters, their colors and other very basic attributes.
      <br/>
      These OSD devices then read the display data from the display memory, according to incoming horizontal and vertical synchronizing pulses, retrieve corresponding font data from a character generator ROM and finally display the characters with the specified colors and other attributes.
      <br/>
      These steps require specialized hardware OSD circuitry.
    </p>
    <p num="5">A more recent architecture is based on a bit map display system, where complex OSD is made possible by allocating each pixel multiple bits in a large-scale, external, video display memory, that is controlled by a dedicated, graphics controller integrated circuit.</p>
    <p num="6">
      The extensive use of hardware circuitry in the conventional OSD devices has not only inherently limited their complex OSD capabilities, but have made them much less flexible, requiring extensive redesigning every time improvements are called for.
      <br/>
      The bit map display system, while allowing complex OSD, make their host products costly because they require a large-scale, external memory and a dedicated integrated circuit for fast display data generation.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="7">
      The present invention uses a hybrid OSD device architecture to meet complex on-screen display needs more flexibly than the conventional, dedicated OSD hardware.
      <br/>
      The present invention uses high speed, dynamic pixel generation circuitry, built around a microprocessor and software to eliminate the need for large-scale display memory.
      <br/>
      This reduction in memory results in a substantially lower cost than bit map display system.
    </p>
    <p num="8">
      To achieve complex OSD, the invention uses a two scan line display memory as a pixel memory.
      <br/>
      The memory devices each hold data representing one horizontal scan line.
      <br/>
      This small-scale memory is combined with the following components:
    </p>
    <p num="9">
      a) A RAM memory space holding compressed, hierarchically-structured and multiple-type display data;
      <br/>
      b) A ROM memory space holding character fonts, graphics icon data and dynamic pixel generation software;
      <br/>
      c) A dedicated, high speed, dynamic pixel generation circuit;
      <br/>
      d) color palette registers;
      <br/>
      e) on-screen display circuits; and
      <br/>
      f) either a microprocessor or a sequence circuit with equivalent computational capabilities.
    </p>
    <p num="10">
      The major components of the invention will be briefly described.
      <br/>
      The display pixel memory holds pixel data for two horizontal scan lines.
      <br/>
      A data block represents sixteen (16) pixels, each pixel being allocated four (4) bits.
      <br/>
      A sixteen pixel array (64 bits) is manipulated in a single cycle.
      <br/>
      If the horizontal resolution is 640 pixels, the total capacity of the display pixel memory is 2 * 4 * 640 bits (2 lines, 4 bits per pixel, 640 pixels per line).
    </p>
    <p num="11">
      The compressed, multiple-typed, display data in the RAM memory space includes:
      <br/>
      a) character display data including attributes and character data;
      <br/>
      b) icon display data (icon number);
      <br/>
      c) button display data (display frame type and coordinates) for buttons that may be selected by a user through a graphical user interface;
      <br/>
      d) cursor display data (cursor type and coordinates);
      <br/>
      e) half-tone display data (coordinates for partial-brightness display).
    </p>
    <p num="12">
      The ROM memory device keeps the following data:
      <br/>
      a) character font pattern;
      <br/>
      b) graphics icon data (definitions of all pixels in the individual icon, using 4 bits for each pixel);
      <br/>
      c) dynamic pixel generation control software.
    </p>
    <p num="13">
      In the example provided below, fonts are sixteen (16) pixels wide and either eight (8), sixteen (16), or thirty-two (32) pixels tall.
      <br/>
      If the font is ten (10) or twenty (20) pixels tall, the excess data exceeding the integral power of two (e.g. 8 or 16) is separately defined, to minimize the pixel data block.
      <br/>
      For example, ten words of pixel data are separated into eight words and two words of data because the character font can be placed in any location of the memory, so eight words of data are placed in one memory area and the remaining two words are placed in another area.
      <br/>
      The graphics icons use four 16 bit-words for a single scan line and may be eight, sixteen or thirty-two pixels tall, similar to the character font.
      <br/>
      As described with respect to the character font, excess bits may be stored in a separate area.
    </p>
    <p num="14">
      The dedicated, high speed, dynamic display generation circuit consists of two modules.
      <br/>
      One module is the font address/attribute data separation circuit, which separates the character data from the attribute data.
      <br/>
      The font address/attribute data separation circuit also calculates the character font address from the separated character data and an offset address stored in an offset address register to determine the address of the character font in the ROM memory.
      <br/>
      The other module is a dynamic pixel generation circuit which generates pixel data in a single clock cycle based on the separated attribute data and the character data read from the ROM memory.
    </p>
    <p num="15">
      The font address/attribute data separation circuit includes:
      <br/>
      a) a scan line register to point to the current relative scan line position within a font;
      <br/>
      b) an AND circuit and a shifter circuit for extracting character data;
      <br/>
      c) an offset address register for holding the starting memory address of the character data;
      <br/>
      d) a compressed display data register for loading the compressed character display data;
      <br/>
      e) two attribute registers for holding color and some attributes; and
      <br/>
      f) a font address register.
    </p>
    <p num="16">
      The dynamic pixel generation circuit includes:
      <br/>
      a) a pair of character font registers;
      <br/>
      b) a right/left fringe and immediate value generation circuit;
      <br/>
      c) a right barrel shifter and smoothing circuits;
      <br/>
      d) a pair of mixer registers;
      <br/>
      e) a pair of 4 * 16-bit pixel registers;
      <br/>
      f) a pixel mode register for specifying a pixel generation mode; and
      <br/>
      g) a pixel generation command decoder circuit.
    </p>
    <p num="17">
      There are fourteen color palette registers, each of which holds six bits; two each for the red, the green and the blue component of RGB.
      <br/>
      Each pixel is represented by a four bit color data.
      <br/>
      If the four-bit pixel data is all zeros (0000), a transparent pixel is "displayed", resulting effectively in no overwriting of the background for that pixel position.
      <br/>
      If set to (0001), the pixel color is black.
      <br/>
      The remaining 14 four bit combinations (0010-1111) are used to access one of the color palette registers.
      <br/>
      The display circuits include a dot clock counter, circuits to control the display start position and the maximum display width, and timing signal generation circuits for the OSD display.
      <br/>
      A microprocessor or a sequence circuit implements the display software and transfers the sixteen bits of data to each module.
    </p>
    <p num="18">
      Two horizontal scans of display pixel memory have a particular role respectively in a single horizontal period.
      <br/>
      One of the pixel memories is used to display the complex pixel pattern on the display device and the other pixel memory holds newly generated display data.
      <br/>
      The process is repeatedly implemented at the input of the horizontal sync signal and is continued through the vertical region.
      <br/>
      By using this technique, and without having a large scale display memory, the complex OSD display process is carried out in real time by following the horizontal sync signal.
    </p>
    <p num="19">
      The RAM in the microprocessor maintains multi-layer structured display data which are compressed in several different formats.
      <br/>
      The compressed data is expanded in order and the expanded pixel data is stored into pixel memory.
      <br/>
      The newly generated pixel data is held in a first pixel register group and another pixel register group holds the previously generated pixel data read from the pixel memory.
      <br/>
      The contents of the two pixel register groups are overlaid and the result is stored into pixel memory.
      <br/>
      Thus, the complex OSD is processed by overlaying newly expanded display data layer by layer.
    </p>
    <p num="20">
      The compressed display data, including character data and the attribute data, is provided to the font address / attribute data separation circuit and the current attribute data is separated to attribute register A. At the same time, the previous attribute register A is pushed onto attribute register B. Also, the character font address is generated by the shifted character data with the current scan line data specifying the location of the font.
      <br/>
      Then the font data is read from the ROM to the font register.
      <br/>
      Finally, a pixel generation command is issued to a pixel array generator which utilizes the font data and a pair of attribute data to generate the character pixel data.
      <br/>
      Sixteen pixels generated in a single cycle are transferred to the pixel memory.
      <br/>
      Accordingly, multiple pixels are manipulated in a single cycle.
    </p>
    <p num="21">
      This invention enables complex OSD similar to a bit map memory system by utilizing flexible software techniques for combining scan line memories, a display circuit, high speed pixel generation circuits and a microprocessor.
      <br/>
      Multi-layer OSD can be achieved by using a single cycle pixel overlay circuit in real time with pixels being expanded out of compressed display data defined in different formats.
      <br/>
      New OSD functional upgrades can be easily accommodated by updating the software driver.
      <br/>
      If it becomes difficult to improve the display quality by altering the software, it is easy to redesign the system by changing a portion of pixel generation circuit because the OSD functions are implemented separately in each functional block.
      <br/>
      The number of character font, total number of graphics icons and the size of the multi-structured compressed display data can be defined by software so that memory such as ROM and RAM in the CPU is not wasted.
      <br/>
      On the other hand, an ordinal CPU can handle real time OSD by properly utilizing the single cycle font address/attribute data separation circuit and the single cycle pixel generation circuit.
      <br/>
      In addition, the OSD system requires only two scan lines of display memory thereby significantly reducing the system cost.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="22">
      FIG. 1 is an example of a three layer OSD.
      <br/>
      FIG. 2 is a block diagram of the overall OSD system.
      <br/>
      FIG. 3 is a block diagram of the OSD logic unit.
      <br/>
      FIG. 4 is a block diagram illustrating the font address/attribute data separation circuit.
      <br/>
      FIG. 5 is a block diagram illustrating the font shifter/fringe generation circuit.
      <br/>
      FIG. 6 is a block diagram of the interaction between pixel registers A, B and mixer registers AH and BH.
      <br/>
      FIG. 7 is a block diagram of the pixel registers and pixel memories.
      <br/>
      FIG. 8 is a block diagram of the OSD display circuits and color palettes.
      <br/>
      FIG. 9 is a functional flow chart of pixel generation when a pixel generation command is executed.
      <br/>
      FIG. 10 is a block diagram of pixel register bits A and B and associated circuity.
      <br/>
      FIG. 11 illustrates the pixel register content during a single cycle pixel generation including a shift operation.
      <br/>
      FIG. 12 illustrates a pixel overlay operation between Pixel Registers A0-A3 and Pixel Registers B0-B3.
      <br/>
      FIG. 13a illustrates the character fringe effect.
      <br/>
      FIG. 13b is a schematic diagram of the circuitry for producing the fringe effect.
      <br/>
      FIG. 14a illustrates character smoothing.
      <br/>
      FIG. 14b is a schematic diagram of the character smoothing circuit.
      <br/>
      FIG. 15 illustrates the relationship between a character font in ROM and the font pattern.
      <br/>
      FIG. 16 is a block diagram of the pixel mode register, the pixel generation command register and the pixel generation command decoder.
      <br/>
      FIG. 17a illustrates the horizontal and vertical sync signals for field 1.
      <br/>
      FIG. 17b illustrates the horizontal and vertical sync signals for field 2.
      <br/>
      FIG. 17c illustrates the compressed display data format.
      <br/>
      FIG. 17d is a block diagram of the pixel memories and associated circuitry.
      <br/>
      FIG. 18 is a flowchart of a multi-layer display operation.
      <br/>
      FIG. 19 illustrates three different types of display format.
      <br/>
      FIG. 20 is a flowchart of half-tone and cursor display.
      <br/>
      FIG. 21 is a flowchart of character and button display.
    </p>
    <heading>DETAILED DESCRIPTION OF THE INVENTION</heading>
    <p num="23">
      FIG. 1 is an example of an on-screen display including three layers of complex patterns.
      <br/>
      The pixel values of a portion of each pattern are shown in the right hand side of FIG. 1.
      <br/>
      The vertical display position 101 of the button display 105 is determined by counting the number of the interrupt requests from the horizontal scan signals.
      <br/>
      The horizontal display position 102 is detected by hardware circuits which count the dot or pixel clock (e.g. the minimum unit of a character font).
      <br/>
      In this example, the bottom layer of character font has two colors, a foreground color 103 and a background color 104.
      <br/>
      Each pixel is represented by four bits and sixteen pixels are manipulated at once.
      <br/>
      Four sixteen bit words of data are provided to Pixel Memory 0701 to Pixel Memory 3716.
      <br/>
      A pixel having a display data of "0000" means a transparent display on the screen, i.e., no display.
      <br/>
      Pixel display data of "0001", is black, that is, the lowest RGB level output.
      <br/>
      The remaining four bit combinations (0010-1111) of pixel display data selects one of the 14 color palettes consisting of six bits for RGB colors.
      <br/>
      Pixel display data "1111" is assigned to white as shown in the example illustrated in FIG. 1.
      <br/>
      The button display 105 on the middle layer is structured by both white at the top and right, and black at the bottom and left.
      <br/>
      The cursor display 106 on the top layer is white.
    </p>
    <p num="24">
      FIG. 2 is a block diagram of the overall OSD system.
      <br/>
      The major system components are a microprocessor 200 and an OSD unit 204.
      <br/>
      The microprocessor includes CPU 201, program ROM 202 and RAM 203.
      <br/>
      The character font and icon data are stored in the program ROM and the plurality of compressed display data are stored in the RAM.
      <br/>
      The OSD unit includes pixel generator circuits 205, two banks of pixel memory 206 and 207, fourteen color palettes 209 and OSD display circuits 208 which display the pixel memory data on the screen at the proper horizontal timing.
    </p>
    <p num="25">
      The pixel generator circuits 205 implement a) address generation of character font in ROM, b) single cycle of pixel generation, c) pixel overlay, d) pixel shift operations and e) data transfer between the pixel registers and pixel memory.
      <br/>
      Two banks of pixel memory are used for two horizontal lines of pixel display.
      <br/>
      The OSD block and microprocessor are connected by a sixteen bit register bus with address bus, read and write control signals and two interrupt inputs.
      <br/>
      HSYNC (horizontal sync signal) and VSYNC (vertical sync signal) are properly modified with the appropriate polarity and are fed into the microprocessor as the interrupts.
    </p>
    <p num="26">
      FIG. 3 is a block diagram of the OSD logic unit.
      <br/>
      The font address/attribute data separation circuits 300 separates the font address, which identifies a ROM location assigned as the font area, and attribute data when the compressed sixteen bits of display data, including the character font and color attribute, are written to a compressed display data register 409.
      <br/>
      A font shifter/fringe generator 301 handles fringe processing for the character pattern and also performs barrel shifting of the font pattern.
      <br/>
      Two groups of pixel registers are used for pixel overlay.
      <br/>
      The shifted font and the fringe data are matrix-crossed with color information specified by two attribute registers.
      <br/>
      The manipulation result is transferred into the pixel registers in a single cycle.
      <br/>
      The pixel generation command decoder 306, whose mode is specified by the pixel mode register 1601, controls blocks of 301, 302, 206 and 207 when a sixteen bit pixel generation command is issued into the pixel generation command register 1602.
      <br/>
      Pixel memory banks 206 and 207 each consists of 160 sixteen bit words (for a 640 pixel horizontal display) for a total of 320 words.
      <br/>
      One of the two banks of the pixel memory is used for displaying pixels, while pixel data is generated into the other bank.
      <br/>
      The role of each pixel memory bank is switched alternately as the horizontal sync signal is detected.
      <br/>
      The OSD display circuit 208 sends the display timing signals to one of the pixel memories and directs four words of pixel data to the shift register/palette color circuits 303.
      <br/>
      The four words of pixel data are latched into the shift registers 303 and four shifted bits selects one of the palette registers at the rate of the dot (or pixel) clock.
      <br/>
      If the four bits are either "0000" or "0001", the palette register is not accessed.
      <br/>
      Rather, when the data is "0000", the RGB and super impose signals are turned off to create a "transparent" overlay.
      <br/>
      If the pixel data is "0001", black is displayed by setting RGB output to the lowest level and setting the super impose signal to a high level.
      <br/>
      By assigning one of the pixel data ("0000") to transparent, or no overlay, the system does not require additional memory units for storing super impose control data.
      <br/>
      The remaining fourteen pixel data combinations (0010-1111) select one of fourteen color palettes, each containing six bits made up of 2 bits for red, 2 bits for green and 2 bits for blue.
    </p>
    <p num="27">
      FIG. 4 is a block diagram of the font address/attribute data separation circuits 300.
      <br/>
      When compressed data including attribute data and character data is written to the compressed display data register 409, the attribute data and character data are separated respectively to the attribute register A 406 and the font address register 404.
    </p>
    <p num="28">
      The separated character data is first synthesized with scan line register 402, then the result is added to offset address register 401.
      <br/>
      As described above, the scan line register points to the current relative scan line position within a font.
      <br/>
      The valid bit width for a scan line and the maximum character kind are specified in the access mode register 408.
      <br/>
      The attribute data is assigned at the upper portion of sixteen bits and the character data is placed in the lower portion as shown in FIG. 17c. If the number of characters is increased (requiring more than bits 0-6 shown in FIG. 17c), the attribute data cannot be contained in the same word as the character data.
      <br/>
      In this situation, the attribute data and character data may be defined in two words separately.
      <br/>
      In this situation, the attribute data should not be extracted in the font address/attribute data separation circuit because the character data and attribute data are already in separate words.
      <br/>
      To accommodate this situation, one bit can be designated a control bit for no attribute separation and stored in the access mode register 408.
    </p>
    <p num="29">
      When the compressed display data is written to the designated register, only the character portion is first separated by font address/attribute data separation/shifter circuit 400.
      <br/>
      Then the character data is shifted to the left with the valid width of scan line register 402 specified in access mode register 408.
      <br/>
      If the current font in vertical direction is eight dots long, the three bits of Scan Line Register is valid and as a consequence, the character data is shifted three bits left.
      <br/>
      Four bits shift for sixteen dots length and five bits shift is accommodated for thirty-two dots length.
      <br/>
      The shifted character data and the scan line register value are combined in a single word by placing the scan line register value at an end of the character data.
    </p>
    <p num="30">
      In multi-color icon display, each pixel has its own color as opposed to a single foreground color and a single background color.
      <br/>
      For multi-color icon display, the system accesses four words of pixel data rather than a word of character font.
      <br/>
      The particular multi-color icon should be numbered similar to the character font access.
      <br/>
      Accordingly, the result of synthesized icon data and scan line register data is further shifted two bits left.
      <br/>
      The separated address and offset address register 401 are added by address adder 403 and the result is loaded into the font address register 404.
      <br/>
      The offset address register 401 can be used in two ways.
      <br/>
      First, the offset address register can define the character and icon fonts in any position of program ROM by using an offset value to locate the character or font data in the ROM.
      <br/>
      Second, the offset address register defines where any fragment portion of a character or icon, which exceeds an integral of two's power, is stored.
      <br/>
      The excess portion of the fonts exceeding the predetermined font heights (e.g. bottom two pixels for a ten pixel high font or the bottom four pixels of a twenty pixel high font) are collected in one area of the ROM so as to not waste memory space between character fonts.
      <br/>
      Thus, the two groups of font data are properly accessed by changing the offset address value.
    </p>
    <p num="31">
      The adder/subtracter 405 increments or decrements the font address when the CPU reads an address from the font address register.
      <br/>
      The modes of increment address, decrement address, and no action are stored in the access mode register 408.
      <br/>
      This feature is useful when accessing a block of data for fetching graphics icon data or accessing a previous or subsequent character font for fringe processing or smoothing processing.
    </p>
    <p num="32">
      The attribute portion is stored in attribute register A after the non-attribute data has been separated.
      <br/>
      The previous value in attribute register A is then transferred to attribute register B at the same time.
      <br/>
      The same kind of operation, i.e. register pushing, occurs when sixteen-bits of data is written to attribute register A through normal register access.
      <br/>
      Thus, the current attribute is held in the attribute register A and the previous attribute is held in attribute register B. The previous attribute is used to specify the attribute color for the left portion of a font when the character font is shifted.
      <br/>
      The shift operation is described below with reference to FIG. 11.
    </p>
    <p num="33">
      FIG. 5 illustrates the font shifter/fringe generator 301 in detail.
      <br/>
      Font register A 500 holds current font data defined in program ROM and font register B 501 maintains the font for one scan line before (or after) the current font data for fringe processing and size doubling/smoothing processing.
      <br/>
      AND/OR circuits 502 and 503 are used to blink the character or to overlay an underline prior to pixel generation.
      <br/>
      The right/left fringe+immediate value generation circuits 504 implement the left side fringe processing, right side fringe processing and both direction fringe processing, as well as immediate data generation of "AAAA" and "5555" hex half tone patterns.
      <br/>
      It also includes a data inversion function for the font data when the pixel generation command is issued.
      <br/>
      Right barrel shifter and smoothing circuits 505 execute a right shift or font size doubling/smoothing for font data A and B. The right shift operation is used to create italic font by incrementally shifting portions of the font to the right.
      <br/>
      Right barrel shifter+ * 2 smoothing circuits 505 generate a thirty-two bit output.
    </p>
    <p num="34">
      Mixer Register AL 506 temporarily stores the lower sixteen bits of the current font data after the shift operation as shown in FIG. 11. Mixer Register BL 507 stores the lower sixteen bits of previous font data for fringe processing.
      <br/>
      These two sixteen bit registers are selected by multiplexer 508 and are combined by multiplexer 509 to provide the upper 16 bits of font data as shown in FIG. 11. The ratio of bits taken from the current and previous font data is specified by shift distributor 510 derived from a four bit shift value stored in pixel mode register 1601(shown in FIG. 16).
      <br/>
      The value in the shift value stored in the pixel mode register is modified so that an appropriate italic character is generated.
      <br/>
      Thus, the shift value at the top of the character is greater than the shift value at the bottom of the character.
      <br/>
      The multiplexer 509 combines both the current and previous font data.
      <br/>
      The lower bits exceeding the upper sixteen bits are re-stored to either mixer register AL or BL and the upper sixteen bits are stored to mixer registers AH, BH and pixel registers along with color attribute data as described below with reference to FIG. 6.
    </p>
    <p num="35">
      FIG. 6 is a block diagram of pixel registers A, B identified as 605-608 and mixer register AH 601, mixer register BH 602 and associated circuitry.
      <br/>
      The pixel registers A and B are loaded in a single cycle from shifted font data and color data after a pixel generation command is issued.
      <br/>
      The minimum unit of a pixel register circuit (e.g. one bit storage) is shown in FIG. 10 and includes a multiplexers 1000, 1001 and 1002 and pixel register bit A 1003 and B 1004 with the associated logic circuits.
      <br/>
      The color data in FIG. 6 includes data of past background color, past foreground color, current background color and current foreground color as shown in FIG. 10. The font data including the current and previous display pattern selects either a foreground or background color out of the current and previous color attributes.
      <br/>
      Mixer register AH 601 and shift distributor 510 are used to perform a pixel overlay between pixel registers A and B. The overlay is performed when the word provided by bit distributor 603 is a "1".
      <br/>
      In case of fringe synthesis, mixer register BH 602 and shift distributor 510 are ANDed with bit distributor 604 to generate fringe pixels in the pixel registers.
      <br/>
      Each pixel register can be read from or written to via the register bus.
    </p>
    <p num="36">
      FIG. 7 illustrates the relationship between pixel registers and the pixel memories.
      <br/>
      The operation of pixel registers A0 and B0 is identical to pixel registers A1-A3 and B1-B3.
      <br/>
      Address bus multiplexers 720 and 721 select either a register address or an OSD address when the pixel memory is accessed.
      <br/>
      If a pixel memory bank selection bit is zero in the pixel mode register 1601, the register address is connected to pixel memory bank 0 (pixel register data is loaded into pixel memory bank 0) and the OSD address is connected to pixel memory bank 1 (display data is retrieved from pixel memory bank 1).
      <br/>
      The OSD address is generated by OSD display circuits 208 and is updated at display timing.
      <br/>
      If the pixel memory bank selection bit is one, then the register address is connected to pixel memory bank 1 and the OSD address is connected to pixel memory bank 0.
      <br/>
      Data bus multiplexers 703 and 704 work in a similar manner to couple the pixel memory banks to the pixel registers or to the shift register circuits 722 as needed.
    </p>
    <p num="37">
      The data in pixel memory which is accessed by an OSD address is stored into shift register circuits 722 at the proper display timing and subsequently the pixel memory content is reset to zero by "0" data output circuits 723 immediately after the pixel memory data is loaded into the shift register circuits 722.
      <br/>
      This reset operation eliminates wasting time for pixel memory initialization.
      <br/>
      The four bit output of the shift register circuits 722 selects one of the palette registers as a pixel color for display.
    </p>
    <p num="38">
      FIG. 8 is a block diagram of the OSD display circuits and color palettes.
      <br/>
      A Horizontal sync signal, i.e. HSYNC, initializes the dot clock counter circuits 800, counter control circuits 801 and display timing+RGB output unit 802.
      <br/>
      The dot clock, DOTCK, is a synchronized signal for the incoming HSYNC pulse.
      <br/>
      After the input of horizontal sync signal, the dot clock counter is incremented by DOTCK.
      <br/>
      A flag is sent to the counter control circuits 801 when the value in dot clock counter is equal to a display start position 804.
      <br/>
      The comparison between the counter value and the start position is done by comparator 805.
      <br/>
      Then the OSD address "0" is set to pixel memory bank after the dot clock counter is reset.
      <br/>
      Four words of sixteen bits of pixel data are fetched from the pixel memory into the shift register circuits 722 after the sixteen dot clock pulses.
      <br/>
      The shifted four bits selects one of the color palettes 803 and generates output pixels through the display timing+RGB output circuits 802.
      <br/>
      The display start bit 806 identifies the pixel position in the beginning and the end of display column.
      <br/>
      If the display start bit is "0", then the display column spans from the first bit of a first character to a first bit of a subsequent character.
      <br/>
      When the display start bit is an intermediate value (e.g. 8), the display column spans form the 8th bit of a first character to the 8th bit of a subsequent character.
      <br/>
      The maximum display column 807 specifies the width of a valid display column.
      <br/>
      When the dot clock counter is identical to the maximum display column width 807, comparator 805 sends a flag to the counter control circuits 801 to shuts off the OSD display at the proper pixel position.
    </p>
    <p num="39">
      FIG. 9 is a functional diagram of the pixel generation process when a pixel generation command is executed.
      <br/>
      The pixel generation command carries out single cycle pixel data generation from the character font data and attribute data.
      <br/>
      In the functional diagram, the character font is held in font register A 500 and is shifted by barrel-shifter 505.
      <br/>
      The result is combined with mixer register AL 506 by multiplexer 509.
      <br/>
      The mixer register AL holds the past font data.
      <br/>
      The new shifted result is then stored back to mixer register AH 904 and AL.
      <br/>
      The attribute registers A 406 and B 407 store current and past foreground and background colors which are selected by the foreground/background color selectors 907 and 908.
      <br/>
      The current/past color bit map generation circuits 909 properly distributes one of the four kind of colors, including current foreground color, current background color, past foreground color and past background color, based on the ratio of past to current data.
      <br/>
      If the font data output by multiplexor 509 is a one, then the foreground color is selected.
      <br/>
      Otherwise, the background color is selected.
      <br/>
      A sixteen pixel array, each pixel having four bits, is stored into pixel registers A and B 910.
    </p>
    <p num="40">
      FIG. 10 illustrates the minimum unit of storage (e.g. one bit) in pixel registers A and B with the associated circuity.
      <br/>
      The pixel register A 1003 and B 1006 are made from D-type flip-flops with three inputs and the current value is maintained while E1 and E0 strobe inputs are equal to 00 in binary format.
      <br/>
      The following combination describes the D-FF operation.
    </p>
    <p num="41">
      E1 E0 Q(D-FF)
      <br/>
      0 0 Q (Keep current status)
      <br/>
      0 1 D0 (Store D0 value)
      <br/>
      1 0 D1 (Store D1 value)
      <br/>
      1 1 D2 (Store D2 value)
    </p>
    <p num="42">
      The clock signal is a trigger input for either a pixel generation command or for accessing the flip-flop.
      <br/>
      The multiplexer 1000 selects one source of data from the I/O register bus, the pixel memory, the shifted font data or the pixel register B. The register bus input at multiplexer 1000 is a data bus for direct access of the pixel registers from the CPU.
      <br/>
      The pixel memory data bus is used for pixel memory reading and the pixel register B input is for pixel overlay of pixel register A. Valid data is provided on the shifted data bus when the pixel generation command is issued.
      <br/>
      When expanded font data is stored into either pixel register A or B, the control signals used include enabling register writing to pixel registers A and B, shift distributor bits and decoded signals from the pixel generation command such as a shift distributor enable A and B signals.
    </p>
    <p num="43">
      In case of a single cycle pixel data generation by font register A and attribute register A and B, multiplexer 1001 selects either past or current color data in response to the shift distributor bits and also selects either foreground or background color based on font data after the barrel shifting operation.
      <br/>
      When fringe processing is enabled, mixer register BH provides a fringe selection bit and the fringe bit, properly defined as pixel data 0001, is stored to the pixel register to represent a black pixel.
      <br/>
      The multiplexer 1002 is used to overlay the fringe data, i.e. black pixels, into the pixel register.
      <br/>
      To store the output of multiplexor 1001 and multiplexer 1002, pixel generation A and B strobes are applied to pixel register A and B.
    </p>
    <p num="44">
      When the content of pixel register B is overlaid into pixel register A, the contents of pixel register B 1003 are selected by multiplexer 1000 at input D3 and is stored back to the pixel register A 1006.
      <br/>
      The control signals used to perform the overlay operation are the content of mixer register AH, the decoded data of the pixel generation command, and the right/left mask data ANDed together.
      <br/>
      Then the result of the AND operation provides a color mixture signal at AND-OR circuit 1005.
      <br/>
      In this way, the appropriate pixels from pixel register B are selected and stored over the data in pixel register A.
    </p>
    <p num="45">
      The D2 inputs of pixel registers A and B are used to transfer pixel data between pixel registers A and B. The following operations may be performed.
      <br/>
      1) Pixel Register A=Pixel Register B (load pixel register A into pixel register B).
      <br/>
      2) Pixel Register B=Pixel Register A (load pixel register B into pixel register A).
      <br/>
      3) Pixel Register A&lt; &gt;Pixel Register B (swap contents of pixel registers A and B).
    </p>
    <p num="46">
      FIG. 11 illustrates the generation of pixel register data in a single cycle including a shift operation.
      <br/>
      In this example, the shift value in the pixel mode register is five.
      <br/>
      FIG. 11 illustrates the generation of pixel data from font register A to pixel registers A0-A3.
      <br/>
      The contents of font register A are stored to mixer register AH after a five bit barrel-shift to the right.
      <br/>
      At the same time, the mixer register AL stores the five bits that were shifted out of mixer register AH.
      <br/>
      The five bits from mixer register BL, corresponding to past font data, are stored in mixer register AH.
      <br/>
      The shaded bits in FIG. 11 indicate the current manipulated font and the unshaded bits represent past manipulated font data.
      <br/>
      Attribute register A holds the current color data and attribute register B holds the past color data.
      <br/>
      If a bit in mixer register AH is one, then foreground color (either past or current depending on the bit location) is synthesized as pixel data in the pixel register.
      <br/>
      Otherwise, background color (either past or current depending on the bit location) is stored in the pixel register.
      <br/>
      As shown in FIG. 11, the pixel registers have a four bit depth and are filled in a single cycle in response to the pixel generation command.
    </p>
    <p num="47">
      FIG. 12 illustrates the pixel overlay operation in the right direction between pixel registers A0-A3 and pixel registers B0-B3.
      <br/>
      As described above, the shift value in this example is five bits.
      <br/>
      A right mask data is set to 07FF hex (00000111111111) so the bit data is "1" from bit position 10 to bit position 0.
      <br/>
      When the mask data bit and the mixer register AH bit are both "1", the pixel overlay is enabled.
      <br/>
      Thus, the shaded bits in mixer register AH correspond to shaded pixel data in pixel registers A0-A3 which is overlaid on the contents of pixel registers B0-B3.
      <br/>
      The left half of FIG. 12 indicates the contents of pixel registers A and B before the pixel overlay operation and the right half of FIG. 12 shows result of the overlay operation.
      <br/>
      The data at bit register positions 0, 3, 4, 7 and 10 in pixel register A is placed over the corresponding locations in pixel register B and this result is stored in pixel register A. The system provides three kinds of pixel overlay including the overlay in the right direction, overlay in the left direction and overlay in both directions.
    </p>
    <p num="48">
      FIG. 13(a) illustrates the character fringe effect performed by fringe generator 504.
      <br/>
      FIG. 13(b) is a schematic diagram of the fringe generation circuitry.
      <br/>
      Pixel 1301 is a left fringe pixel, pixel 1302 is a right fringe pixel and pixel 1303 is an upper fringe pixel.
      <br/>
      FIG. 13(b) is an exemplary circuit showing one bit of fringe generation for all possible cases.
      <br/>
      The font A pixel, labeled Font A (N BIT), is the current pixel and the fringe circuit will not produce a fringe pixel if the current pixel (FONT A N BIT) is a "1".
      <br/>
      Font B identifies pixels either one scan line before or after against the current scan line.
      <br/>
      The pixel to the left of the current pixel is labeled FONT A N+1 BIT and the AND circuit 1305 is for right fringe generation if right fringe generation is enabled.
      <br/>
      The pixel to the right of the current pixel is labeled FONT A N-1 BIT and the AND circuit 1306 is for left fringe generation if left fringe generation is enabled.
      <br/>
      The AND circuit 1304 is for bottom-right fringe generation based on the status of the pixel below and to the left of the current pixel (FONT B N+1 BIT).
      <br/>
      All of the fringe data are ORed by OR circuits 1307 and 1308.
      <br/>
      Accordingly, if the fringe operation is enabled and the current font data (FONT A N BIT) is zero, the fringe bit becomes one.
      <br/>
      Other fringe bits for upper, lower etc. are similarly produced.
    </p>
    <p num="49">
      FIG. 14a illustrates character smoothing/size doubling process and FIG. 14b is a schematic diagram of the circuit for performing the smoothing/doubling.
      <br/>
      The circuit expands each pixel to two pixels and inserts smoothing pixels where necessary.
      <br/>
      In FIG. 14a, 1400 represents on original pixels.
      <br/>
      Pixels 1401 and 1408 are smoothing pixels added by the smoothing circuit.
      <br/>
      Font A means the current display font and Font B means the display font either one scan line before or after the current scan line.
      <br/>
      The N bit position is the current pixel position and N+1 bit position means the pixel to the left of the current pixel and N-1 bit position means the pixel to the right of the current pixel.
      <br/>
      If font A is one, the pixel is expanded into two "1" pixels by OR circuits 1404 and 1407.
      <br/>
      Or circuit 1404 produces a 1 when a smoothing pixel is needed to the right of the current pixel and this smoothing pixel.
      <br/>
      Or circuit 1407 produces a 1 when a smoothing pixel is need to the left of polo the current pixel.
      <br/>
      AND circuit 1402 generates smoothing pixel 1401 and AND circuit 1405 generates smoothing pixel 1408.
      <br/>
      The smoothing operation is enabled by AND gates 1403 and 1406 circuits.
    </p>
    <p num="50">
      FIG. 15 illustrates a relationship between character font in program ROM and the font pattern.
      <br/>
      The beginning address of font area (shaded in FIG. 15) can be adjusted by setting the proper offset address 401 in offset address register shown in FIG. 4.
      <br/>
      In the example shown in FIG. 15, the expanded font pattern is 16 pixels wide and 16 pixels high.
      <br/>
      The scan line refers to the current row in the font pattern.
      <br/>
      By defining multiple offset addresses, any font pattern exceeding the integral power of two (e.g. any bits over 16) can be defined in different area.
      <br/>
      In addition, the offset address can be used to define completely different kinds of data such as graphics icons and sprite cursor display stored in separate areas of memory.
    </p>
    <p num="51">
      FIG. 16 is a block diagram of the pixel mode register 1601, the pixel generation command register 1602 and the pixel generation command decoder 1600.
      <br/>
      Pixel mode register 1601 and pixel generation command register 1602 are decoded at pixel generation command decoder 1600 to produce pixel generation commands and control signals which are sent to font shifter/fringe generator 301, the pixel registers A and B 302, and the pixel memory banks A and B 206 and 207.
      <br/>
      Pixel generation decoder unit 1600 initiates three kinds of operations described below.
    </p>
    <p num="52">Character font generation 1603--create pixel data from character font data A and attribute data A and B.</p>
    <p num="53">Fringe generation 1604--generate fringe data from character font data A and B.</p>
    <p num="54">Pixel Register Setting 1605--store pixel data corresponding to the immediate value dat, font A data or font B data into the pixel registers.</p>
    <p num="55">These commands are executed in single cycle and the decoded signals control the pixel generation logic unit.</p>
    <p num="56">
      FIG. 17a illustrates the VSYNC, HSYNC and field (odd field) 1 timing signals.
      <br/>
      FIG. 17b illustrates the VSYNC, HSYNC and field 2 (even field) timing signals.
      <br/>
      FIG. 17c illustrates the compressed display data format before expansion into the pixel registers.
      <br/>
      FIG. 17d is a block diagram of the flow of data through the system.
      <br/>
      The field 1 and field 2 are detected by the phase difference between VSYNC and HSYNC in the video signal.
      <br/>
      If the HSYNC signal is present one half cycle of the HSYNC period after the VSYNC is received, then the field is identified as field 1.
      <br/>
      Otherwise, the field is identified as field 2.
    </p>
    <p num="57">
      FIG. 17c illustrates an example of the character display format stored in the compressed display data area in RAM.
      <br/>
      Bit 15 is a sub-color and bits 14-11 are the four bits of main color.
      <br/>
      Either the sub-color or the main color can be assigned to the foreground or background in a character font.
      <br/>
      If the main color is assigned to the foreground, then the sub-color is assigned to the background and vise-versa.
      <br/>
      The four bits of main color provides the four bits of pixel data.
      <br/>
      The one bit of sub-color selects one of two pre-defined four bit pixel data stored in a sub-color register.
      <br/>
      Bit 10 is a button selection bit and creates a button color over the pixel register by forcing all the font data to one if the button selection bit is one.
      <br/>
      Bit 9 is used to identify either blink mode or bit inversion mode.
      <br/>
      If bit 9 is one, then either a blinking function of font A/B or an inverting function, where foreground and background colors are reversed, is implemented depending on the system configuration.
      <br/>
      The underline bit 8 ORs sixteen bits of pixel data having the foreground color over the character font data to create and underline.
      <br/>
      Bit 7 enables a shift-operation for creating an italic character display.
      <br/>
      If bit 7 is activated, the barrel-shifter shifts the font data to create an italic font.
      <br/>
      Bits 10-7 are either enabled or disabled by values stored in the pixel mode register 1601 so that the process timing is properly controlled by software.
      <br/>
      The remaining bits 6-0 are used as character data.
      <br/>
      It is understood that bits 6-0 may define characters, icons, graphics, etc.
      <br/>
      Accordingly, the term "character" is intended to encompass alphanumeric characters, icons, cursors, graphics and any other patterns that may be displayed.
      <br/>
      If the number of defined characters exceeds 128, (e.g. 1024 characters are necessary), the compressed data format can be two split into two words of data, one for the character data and the other for the attribute data.
      <br/>
      Of course, unnecessary attributes may be eliminated to free additional bits for defining additional character.
    </p>
    <p num="58">
      FIG. 17d is a block diagram illustrating the process of converting compressed font data to pixel data.
      <br/>
      The font address/attribute data separation circuit generates the font address and the attribute data.
      <br/>
      The pixel data generation process 1701 converts the character font to 16 bit by 4 bit pixel data arrays and the result is written to pixel register groups A or B. Finally, the content of the pixel registers is stored into either pixel memory bank 0 or bank 1 at the proper timing.
      <br/>
      By reading pixel data back into the pixel registers and applying the pixel overlay process, the complex (e.g. multi layer) on-screen display is carried out.
    </p>
    <p num="59">
      FIG. 18 is a flowchart of the multi-layer display process.
      <br/>
      The process begins at step 1800 after the CPU is reset.
      <br/>
      The OSD hardware registers are initialized at 1801 and the proper display data from the first layer to third layer is loaded to the compressed display RAM area at 1802.
      <br/>
      Then at step 1803, the context switch and working RAMs are initialized as follows.
      <br/>
      hsync_line=1, field1=0, frame=0, context_sw=BEFORE_SYNC
    </p>
    <p num="60">After the VSYNC and HSYNC interrupts are enabled, the initialization completes.</p>
    <p num="61">
      When a VSYNC interrupt is detected at step 1804, the validity of interrupt is first checked at 1805.
      <br/>
      If value of hsync_line is too small, indicating that the end of the screen has not been reached, the VSYNC interrupt is ignored to maintain software service dependent upon the VSYNC and HSYNC signals.
      <br/>
      The system eliminates noisy V sync pulses and raises the noise immunity to provide enough time for the background job.
      <br/>
      If the VSYNC interrupt is valid, the field 1/field 2 detection and frame are revised at step 1800.
      <br/>
      In addition, the hsync_line=1 and context_sw=BEFORE_DISPLAY-1 are set at steps 1807 and 1808.
    </p>
    <p num="62">
      When an HSYNC interrupt occurs, hsync_line is automatically incremented at 1810 and context_sw value is loaded into the program counter to provide the branching address for the various display routines.
      <br/>
      If the context_sw is equal to BEFORE_SYNC, then the process is immediately over as shown at steps 1812 and 1826.
      <br/>
      If context_sw is BEFORE_DISPLAY-1, flow proceeds to step 1813.
      <br/>
      At step 1814, hsync_line is compared to BEFORE_DISPLAY-1.
      <br/>
      If hsync_line is less than BEFORE_DISPLAY-1, then the process is over and flow proceeds to step 1826.
      <br/>
      If hsync_line is equal to or and greater than BEFORE_DISPLAY-1, then the working parameters in RAM for display are initialized at step 1815.
      <br/>
      The two banks of pixel memory are reset at step 1816 and pixel memory bank 0 is selected at step 1817.
      <br/>
      At step 1818, the following data are initialized.
    </p>
    <p num="63">
      context_sw=DISPLAYING
      <br/>
      half_sw=HALF-TONE_DISPLAY
      <br/>
      disp_sw=CHARACTER_DISPLAY
      <br/>
      scan_line=0
      <br/>
      cursor_sw=CURSOR_DISPLAY.
    </p>
    <p num="64">At step 1825, the OSD display registers such as display start position, maximum display column, display start bit position, maximum display column and double scan mode are initialized.</p>
    <p num="65">
      In display mode, commencing at step 1819, pixel display data is generated and overlaid subsequently from the first layer at step 1820, the second layer at step 1821 and the third layer at step 1822 in order.
      <br/>
      When the display process is over, the DISPLAY_END value is loaded to context_sw at step 1824.
      <br/>
      The HSYNC interrupt service routine immediately ends the process upon BEFORE_SYNC or DISPLAY_END status.
    </p>
    <p num="66">
      FIG. 19 illustrates three different types of display formats.
      <br/>
      Format 1901 is the bottom layer display having a half-tone format.
      <br/>
      The half-tone format includes a half-tone control word defining the number of half-tone regions, the start position (X, Y) and the end position (X, Y).
      <br/>
      The middle layer display format 1902 consists of character and button data.
      <br/>
      The data contains a) page control word including the number of display rows and display start position; b) row control word including the number of display columns, display size and display start column; c) attribute and character data; d) button control word including a button start position, end position and depress/raise button option.
      <br/>
      The third display format is the cursor data format 1903 displayed on the top layer.
      <br/>
      The cursor control word includes cursor font, width and length.
      <br/>
      The cursor start position specifies the vertical and horizontal position of the cursor.
      <br/>
      Other display formats, which are designated by the user through software, may be used for different display patterns.
    </p>
    <p num="67">
      FIG. 20 is a flow chart of half-tone display and cursor display.
      <br/>
      The half-tone display begins at step 2000 and proceeds to step 2001 where the program counter value is set equal to half_sw.
      <br/>
      Then the current half-tone parameters are loaded at step 2002 and if it is in the region of cursor display, flow proceeds to step 2004.
      <br/>
      At step 2004, the exclusive-OR operation (XOR) is performed between the frame value and the hsync_line value.
      <br/>
      If the result of the XOR is "1", the process stores an AAAA hex pattern of transparent and black color data into pixel memory.
      <br/>
      Otherwise, the process stores a 5555 hex pattern of transparent and black color data into the memory.
      <br/>
      This establishes a black and white mesh pattern at every horizontal period and also compensates for the phase of each frame.
      <br/>
      If the half-tone region is not within the cursor display region, step 2003 leads to step 2008 which detects whether current half-tone region has been exited.
      <br/>
      If not, the process ends.
      <br/>
      If at step 2008, the current position exceeds the current half-tone region, the process flows to the next half-tone region defined by the start and end positions for the next half-tone region in data 1901.
      <br/>
      If all half-tone regions have been processed, half_sw is set to HALF_TONE_END and the process is completed.
    </p>
    <p num="68">
      FIG. 21 is a flow chart of the character display process along with button display.
      <br/>
      The second layer of character font display 2100 starts by setting the program counter to disp_sw and proceeding to step 2102.
      <br/>
      The current character control word is loaded at step 2103 and the display start column, the maximum size of display column and the number of buttons display are set to the designated working RAMs.
      <br/>
      The character and attribute data are converted to pixel data through steps 2104 to 2110.
      <br/>
      The character and attribute data are read and the reading pointer is incremented at step 2104.
      <br/>
      The read data is written to the compressed display data register and the attribute and font address are separated in single cycle at step 2105.
      <br/>
      The character font is read from program ROM by using the separated font address and is transferred to font register A at step 2106.
      <br/>
      The pixel generation command is issued at step 2107, and the pixel data is stored to pixel register B while at the same time the pixel memory previously generated is read back to pixel register A. The two pixel registers are overlaid at step 2108 and the result of pixel register A is written to the pixel memory.
      <br/>
      At step 2109, the pixel memory address is incremented.
      <br/>
      When all the columns have been processed, flow proceeds to step 2111.
    </p>
    <p num="69">
      The button display is processed through steps 2111 to 2116.
      <br/>
      The current button control word is loaded at step 2111 and the designated pixel memory address is calculated at step 2112.
      <br/>
      The button display data is generated to pixel register B and mixer register AH.
      <br/>
      The pixel memory data is read to pixel register A at step 2113 and is overlaid by the pixel register B at step 2114.
      <br/>
      The result is written back to the pixel memory at step 2115.
      <br/>
      Step 2116 checks whether all the buttons have been displayed.
    </p>
    <p num="70">
      After the button display process is completed, scan_line is incremented at step 2117 and if it exceeds the maximum scan line value, scan_line is initialized to 0.
      <br/>
      When all rows of character display are done, disp_sw is set to CHARACTER_DISPLAY_END and the character display process is completed.
    </p>
    <p num="71">
      The final layer of display data is the cursor display shown in steps 2013-2021 of FIG. 20. The cursor display routine begins at step 2013 and flows to step 2014 where the program counter is set to cursor_sw.
      <br/>
      The cursor position in the third layer of display is tested at step 2016.
      <br/>
      The cursor pixel data is overlaid into the pixel memory at step 2017 and the cursor_line value is incremented at step 2018.
      <br/>
      When the display process exceeds the maximum cursor line at step 2019, then CURSOR_END value is loaded into cursor_sw of context switch RAM, indicating the end of cursor process.
    </p>
    <p num="72">
      If the picture resolution is enhanced by increasing the scan line frequency by n-times, the on-screen display system may be used to generate the same on-screen display data over n lines.
      <br/>
      The sync pulse interrupt will occur once every n-lines as opposed to every line.
      <br/>
      In addition, the zero data output circuit 723 will not clear the pixel memory until the last of n-lines has been displayed.
    </p>
    <p num="73">
      The present invention provides for complex OSD without requiring a large array of memory.
      <br/>
      The system uses a pixel memory having a maximum capacity of two horizontal lines of display data.
      <br/>
      This reduction is the amount memory substantially reduces the cost of the system.
    </p>
    <p num="74">
      While preferred embodiments have been shown and described, various modifications and substitutions may be made thereto without departing from the spirit and scope of the invention.
      <br/>
      Accordingly, it is to be understood that the present invention has been described by way of illustration and not limitation.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>An on-screen display system for use with a display, the system comprising:</claim-text>
      <claim-text>a memory for storing compressed display data; pixel generator for generating pixel data based on the compressed display data; pixel memory coupled to said pixel generator for receiving said pixel data, said pixel memory having a capacity to store pixel data for a predetermined number of horizontal scan lines, said pixel memory including a first pixel memory and a second pixel memory, wherein said pixel memory has a maximum capacity to store pixel data for two horizontal scan lines;</claim-text>
      <claim-text>and on-screen display device for receiving pixel data from said pixel memory and generating display signals for displaying said pixel data on the display wherein the on-screen display device alternately</claim-text>
      <claim-text>- retrieves the contents of said first pixel memory while said second pixel memory receives pixel data from said pixel generator;</claim-text>
      <claim-text>and - retrieves the contents of said second pixel memory while said first pixel memory receives pixel data from said pixel generator; said on-screen display device alternating between said first pixel memory and said second pixel memory in response to a horizontal sync signal.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The on-screen display system of claim 1 wherein said compressed display data includes a display data address and attribute data and said on-screen display system further comprises a separator which retrieves the compressed display data from said memory, separates the display data address from said attribute data and provides the separated display data address and attribute data to said pixel generator.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The on-screen display system of claim 2 further comprising a display memory for storing display data, said separator comprising: an offset address register for storing an offset address; an address manipulator for performing an arithmetic operation between the offset address to the display data address;</claim-text>
      <claim-text>and a font address register for storing the sum of the display data address and the offset address to identify an address in the display memory.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The on-screen display system of claim 3 further comprising an access mode register which stores a value for instructing said address manipulator to perform one of addition and subtraction.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The on-screen display system of claim 2 further comprising a first attribute register for storing current attribute data and a second attribute register for storing previous attribute data.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The on-screen display system of claim 4 wherein said access mode register further stores a value indicating the maximum display data height.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The on-screen display system of claim 1 further comprising: a first pixel register for storing pixel data generated by said pixel generator and coupled to said pixel generator and said pixel memory;</claim-text>
      <claim-text>and a second pixel register for storing pixel data generated by said pixel generator and coupled to said pixel generator and said pixel memory.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The on-screen display system of claim 7 wherein the contents of said second pixel register and said first pixel register are mixed to create mixed pixel data and the mixed pixel data is stored in said first pixel register.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The on-screen display system of claim 8 wherein multiple layers of pixel data are mixed during a horizontal scan line.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The on-screen display system of claim 8 further comprising a mixer register for controlling the mixing of the contents of said first pixel register and said second pixel register.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The on-screen display system of claim 2 wherein said attribute data includes a bit for designating a blink operation.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The on-screen display system of claim 2 wherein said attribute data includes a bit for designating an underline operation.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The on-screen display system of claim 2 wherein said pixel generator retrieves display data from a display memory based on said display data address and further comprises a fringe generator for generating fringe pixels based on the display data.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The on-screen display system of claim 2 further comprising a half-tone generator for producing of half-tone pixel data.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The on-screen display system of claim 14 wherein said half-tone pixel data comprises pixel data alternatively having a no display value and a color value.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The on-screen display system of claim 2 wherein said pixel generator retrieves display data from a display memory based on said display data address and further comprises a smoother for smoothing the display data.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The on-screen display system of claim 16 wherein said smoother doubles the size of the display data.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The on-screen display system of claim 7 further comprising a data transfer device for transferring pixel data between said first and second pixel registers and said pixel memory in a single clock cycle.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The on-screen display system of claim 1 further comprising a zero data output device for clearing the contents of said pixel memory data after transfer of said pixel data from said pixel memory to said on-screen display device.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The on-screen display system of claim 19 wherein said zero data output device clears the contents of said pixel memory data after n lines of pixel data are displayed.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The on-screen display system of claim 1 wherein said on-screen display device receives pixel data from said pixel memory once every n scan lines.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The on-screen display system of claim 5 wherein the pixel generator copies the contents of the first attribute register to the second attribute register.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The on-screen display system of claim 1 wherein said on-screen display device defines an on-screen display area by storing a display start position and a display start bit.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The on-screen display system of claim 7 wherein said pixel memory comprises a first pixel memory and a second pixel memory, wherein the on-screen display unit alternately, retrieves the contents of said first pixel memory as the contents of the first pixel register are stored in said second pixel memory;</claim-text>
      <claim-text>and retrieves the contents of said second pixel memory as the contents of the first pixel register are stored in said first pixel memory.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The on-screen display system of claim 2 wherein said attribute data includes a main color identifier for instructing the on-screen display circuitry to prevent display of said pixel data.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The on-screen display system of claim 2 wherein said attribute data includes a main color identifier and a subcolor identifier, the main color identifier corresponding to a foreground color and the subcolor identifier corresponding to a background color.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The on-screen display system of claim 1 wherein said compressed display data is stored in a plurality of formats.</claim-text>
    </claim>
  </claims>
</questel-patent-document>