<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182261B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182261</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182261</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22687066" extended-family-id="1287455">
      <document-id>
        <country>US</country>
        <doc-number>09350941</doc-number>
        <kind>A</kind>
        <date>19990709</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09350941</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>1335844</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>35094199</doc-number>
        <kind>A</kind>
        <date>19990709</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09350941</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>18697198</doc-number>
        <kind>A</kind>
        <date>19981105</date>
        <priority-linkage-type>2</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1998US-09186971</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H03M  13/29        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>29</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>H03M  13/45        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>45</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>714758000</text>
        <class>714</class>
        <subclass>758000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>714776000</text>
        <class>714</class>
        <subclass>776000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>714792000</text>
        <class>714</class>
        <subclass>792000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>714794000</text>
        <class>714</class>
        <subclass>794000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>H03M-013/29T3</text>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>013</main-group>
        <subgroup>29T3</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>H03M-013/29</text>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>29</subgroup>
      </classification-ecla>
      <classification-ecla sequence="3">
        <text>H04L-001/00B5E5S</text>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>001</main-group>
        <subgroup>00B5E5S</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H03M-013/2975</classification-symbol>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>2975</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H03M-013/29</classification-symbol>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>29</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-001/0051</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>1</main-group>
        <subgroup>0051</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>29</number-of-claims>
    <exemplary-claim>13</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>5</number-of-drawing-sheets>
      <number-of-figures>5</number-of-figures>
      <image-key data-format="questel">US6182261</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Efficient iterative decoding</invention-title>
    <references-cited>
      <citation srep-phase="applicant">
        <patcit num="1">
          <text>BERROU CLAUDE</text>
          <document-id>
            <country>US</country>
            <doc-number>5446747</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5446747</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="2">
          <text>PYNDIAH RAMESH, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5563897</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5563897</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>"An Introduction to Turbo Codes", M. Valenti, Bradley Dept. of Elect. Eng., Virginia Polytechnic Inst. &amp; S.U., Blacksburg, Virginia.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>1996 IEEE Transactions on Information Theory, vol. 42, No. 2, "Iterative Decoding of Binary Block and Convolutional Codes", J.Hagenauer et al., pp. 429-445.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>1998 International Journal of Satellite Communications, vol.16, "Implementation and Performance of a Turbo/Map Decoder", S. Pietrobon, pp. 23-46.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>1998 IEEE Workshop on Signal Processing Systems (SiPS) Proceedings in Boston, MA on Oct. 8-10 1998, "VLSI Design and Implementation of Low-Complexity Adaptive Turbo-Code Encoder and Decoder for Wireless Mobile Communication Applications", S. Hong et al., pp. 233-242.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>Benedetto, et al. "Iterative Decoding of Serially Concatenated Codes with Interleavers and Comparison With Turbo Codes" IEEE pp. 654-658 (Mar. 1997).</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <continuation-in-part>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>18697198</doc-number>
              <kind>A</kind>
              <date>19981105</date>
            </document-id>
          </parent-doc>
        </relation>
      </continuation-in-part>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>QUALCOMM Incorporated</orgname>
            <address>
              <address-1>San Diego, CA, US</address-1>
              <city>San Diego</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>QUALCOMM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Haller, Haggai H.</name>
            <address>
              <address-1>Haifa, IL</address-1>
              <city>Haifa</city>
              <country>IL</country>
            </address>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Stein, Jeremy M.</name>
            <address>
              <address-1>Haifa, IL</address-1>
              <city>Haifa</city>
              <country>IL</country>
            </address>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Wadsworth, Philip R.</name>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>Rouse, Thomas R.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Baker, Stephen M.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>GRANTED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Apparatus for iterative decoding of a sequence of signal packets coded in accordance with a multi-component coding scheme.
      <br/>
      The apparatus includes a plurality of decoders, each of which performs a respective different decoding method on one of the signal packets, such that the plurality of decoders operate substantially concurrently.
      <br/>
      Iterative decoding may be stopped if a predefined threshold maximum number of iterations is reached, or if the previous two decoder iterations have satisfactory cyclic redundancy checks (CRC), or if the input frame buffer to the decoder is filled to within a predefined percentage of its storage capacity.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS-REFERENCE TO RELATED APPLICATION</heading>
    <p num="1">
      This application is a continuation-in-part of co-pending U.S. application Ser.
      <br/>
      No. 09/186,971, filed on Nov. 5, 1998.
    </p>
    <heading>FIELD OF THE INVENTION</heading>
    <p num="2">The present invention relates generally to iterative decoding, and specifically to fast iterative decoding of multiple-component codes.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="3">
      Transmission of digital data is inherently prone to interference which may introduce errors into the transmitted data.
      <br/>
      Error detection schemes have been suggested to determine as reliably as possible whether errors have been introduced into the transmitted data.
      <br/>
      For example, it is common to transmit the data in packets, and add to each packet a CRC (cyclic redundancy check) field, for example of a length of 16 bits, which carries a checksum of the data of the packet.
      <br/>
      When a receiver receives the data, it calculates the same checksum on the received data and verifies whether the result of its calculation is identical to the checksum in the CRC field.
    </p>
    <p num="4">
      When the transmitted data is not used on-line, it is possible to request re-transmission of erroneous data when errors are detected.
      <br/>
      However, when the transmission is performed on-line such as in telephone lines, cellular phones, remote video systems, etc., it is not possible to request re-transmission.
    </p>
    <p num="5">
      Convolution codes have been introduced to allow receivers of digital data to correctly determine the transmitted data even when errors may have occurred during transmission.
      <br/>
      The convolution codes introduce redundancy into the transmitted data and pack the transmitted data into packets in which the value of each bit is dependent on earlier bits in the sequence.
      <br/>
      Thus, when a few errors occur, the receiver can still deduce the original data by tracing back possible sequences in the received data.
    </p>
    <p num="6">
      To further improve the performance of a transmission channel, some coding schemes include interleavers, which mix up the order of the bits in the packet during coding.
      <br/>
      Thus, when interference destroys a few adjacent bits during transmission, the effect of the interference is spread out over the entire original packet and can more readily be overcome by the decoding process.
      <br/>
      Other improvements may include multiple-component codes which include coding the packet more than once in parallel or in series.
      <br/>
      For example, U.S. Pat. No. 5,446,747, which is incorporated herein by reference, describes an error correction method using at least two convolutional codings in parallel.
      <br/>
      Such parallel encoding is known in the art as "Turbo coding."
    </p>
    <p num="7">
      For multiple component codes, optimal decoding is often a very complex task, and may require large periods of time, not usually available for on-line decoding.
      <br/>
      In order to overcome this problem, iterative decoding techniques have been developed.
      <br/>
      Rather than determining immediately whether received bits are zero or one, the receiver assigns each bit a value on a multi-level scale representative of the probability that the bit is one.
      <br/>
      A common scale, referred to as LLR probabilities, represents each bit by an integer in the range +-32,31}. The value of 31 signifies that the transmitted bit was a zero with very high probability, and the value of -32 signifies that the transmitted bit was a one, with very high probability.
      <br/>
      A value of zero indicates that the value is indeterminate.
    </p>
    <p num="8">
      Data represented on the multi-level scale is referred to as "soft data," and iterative decoding is usually soft-in/soft-out, i.e., the decoding process receives a sequence of inputs corresponding to probabilities for the bit values and provides as output corrected probabilities taking into account constraints of the code.
      <br/>
      Generally, a decoder which performs iterative decoding, uses soft data from former iterations to decode the soft data read by the receiver.
      <br/>
      A method of iterative decoding is described, for example, in U.S. Pat. No. 5,563,897, which is incorporated herein by reference.
    </p>
    <p num="9">
      During iterative decoding of multiple-component codes, the decoder uses results from decoding of one code to improve the decoding of the second code.
      <br/>
      When parallel encoders are used, as in Turbo coding, two corresponding decoders may conveniently be used in parallel for this purpose.
    </p>
    <p num="10">
      The iterative decoding is carried out for a plurality of iterations until it is believed that the soft data closely represents the transmitted data.
      <br/>
      Those bits which have a probability indicating that they are closer to one (for example, between 0 and 31 on the scale described above) are assigned binary zero, and the rest of the bits are assigned binary one.
    </p>
    <p num="11">
      Generally, the iterative process is repeated a predetermined number of times.
      <br/>
      According to "An Introduction to Turbo Codes," by Matthew C. Valenti, which can be found at &lt;&lt;http://lamarr.mprg.ee.vt.edu/documents/turbo.pdf&gt;&gt;, and is incorporated herein by reference, the predetermined number of iterations is about 18.
      <br/>
      However, this article further states that in many cases as few as 6 iterations can provide satisfactory performance. "Iterative Decoding of Binary Block Codes," by Joachim Hagenauer, Elke Offer and Lutz Papke, IEEE Trans. of Information Theory, Vol. 42, No. 2, pp. 429-445 (March 1996), which is incorporated herein by reference, suggests using a cross entropy criteria to determine when to stop the iterative decoding process individually for each packet.
      <br/>
      Thus, the calculation power of a decoder may be used more efficiently than when all packets are decoded using the same number of iterations.
      <br/>
      However, the cross entropy criterion is in itself very complex, reducing substantially the gain in efficiency in applying variable numbers of iterations.
    </p>
    <p num="12">
      In one commonly-used multiple-component coding scheme, the packet is first encoded by a first "outer" coding scheme.
      <br/>
      Thereafter, it is interleaved and is then encoded by a second "inner" coding scheme.
      <br/>
      During decoding, the inner code is first decoded, the result is de-interleaved, and then the outer code is decoded.
      <br/>
      The results of decoding the outer code are thereafter used in a second iteration of decoding the inner code to improve its results.
      <br/>
      This process is continued iteratively until the coded packet is satisfactorily decoded.
    </p>
    <p num="13">
      The above-described decoding scheme is typically implemented by a single hardware decoder, which alternately decodes the inner and outer codes.
      <br/>
      However, when very fast decoding is needed, and the inner and outer codes are substantially different, the computational load is generally beyond the capability of a single decoder of conventional design.
      <br/>
      Therefore, it has been suggested to use a decoder including two processors, one for the inner code and one for the outer code.
      <br/>
      However, this results in having each of the processors idle half of the time, while it waits for results from the other processor.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="14">It is an object of some aspects of the present invention to provide methods and apparatus for fast iterative decoding of codes based on two or more different convolutional encoding schemes.</p>
    <p num="15">It is another object of some aspects of the present invention to provide apparatus for efficient iterative decoding of convolution codes.</p>
    <p num="16">It is a further object of some aspects of the present invention to provide an efficient method for determining how many iterations are needed for reliable decoding of a packet.</p>
    <p num="17">
      In exemplary embodiments of the present invention, the decoding time allotted for decoding each code in a multi-code series or parallel coding scheme is made substantially equal.
      <br/>
      A decoder including two processors receives two packets of data in sequence and decodes them simultaneously.
      <br/>
      While one packet is being decoded in a first processor, the second processor decodes the second packet.
      <br/>
      When both processors finish a single iteration, the packets are switched between the processors, and another iteration is performed.
      <br/>
      Thus, both processors are substantially constantly in use, and codes may be decoded twice as fast as in prior art schemes of comparable hardware complexity.
      <br/>
      Preferably, both processors operate concurrently at least 50% of their operation time on any input packet.
    </p>
    <p num="18">
      In some embodiments of the present invention, the two packets are decoded independently of each other, so that termination of decoding of the packets is independent.
      <br/>
      When a first packet is finished being decoded, a new packet may enter one of the decoders, regardless of whether the second packet has finished being decoded.
    </p>
    <p num="19">
      In some embodiments of the present invention, the multi-code scheme includes an inner coding scheme and an outer coding scheme.
      <br/>
      Preferably, the inner and outer coding schemes are chosen such that the decoding time of a single iteration of both of them is approximately the same.
      <br/>
      Alternatively or additionally, the processor that finishes an iteration first waits for the second processor to finish processing, and then the packets are switched between the decoders.
      <br/>
      Preferably, the inner and outer coding schemes are different and cannot easily be decoded by the same processor.
    </p>
    <p num="20">
      In another aspect of the present invention, during decoding of each packet, a simple method is used for determining when to stop the iterative process.
      <br/>
      A termination checking procedure is preferably performed after each iteration, and includes determining a minimal absolute probability value associated with any of the bits in the packet.
      <br/>
      When the minimal absolute probability value is above a predetermined threshold, indicating that all of the bits have been assigned either the value "1" or "0" with relatively high probability, the iterative process is terminated.
    </p>
    <p num="21">
      Alternatively or additionally, each packet is transmitted with a CRC field.
      <br/>
      After each decoding iteration, the termination checking procedure checks whether the CRC value computed from the data to be output from that iteration is compatible with the CRC field.
      <br/>
      Preferably, the checking procedure checks the CRC field only when the minimal probability value is above the threshold.
      <br/>
      If the CRC field is compatible with the extracted data, the iteration procedure is terminated.
    </p>
    <p num="22">
      In some embodiments of the present invention, the checking procedure is begun only after a minimal initial number of iterations, in order to reduce the probability of the CRC check returning an apparently "correct" result although the decoded data is incorrect.
      <br/>
      Preferably, the minimal number of iterations is between four and eight.
      <br/>
      The number of iterations is preferably chosen to be a number of iterations which for most packets does not bring the minimal probability value above the threshold.
      <br/>
      Further preferably, the iterative process is terminated after a maximal number of iterations regardless of any other conditions.
      <br/>
      Preferably, the maximal number of iterations is between 20 and 30.
    </p>
    <p num="23">
      In other embodiments of the present invention, the minimal absolute probability value may be replaced by an average probability value, by a median probability value, or by any other value indicative of the progress of the iterative decoding process.
      <br/>
      For example, when it is desired to minimize a bit error (BER) criterion rather than a packet error rate, the minimal absolute value is preferably replaced by a next-to-minimum value, i.e., the lowest value after ignoring one or two exceptions.
    </p>
    <p num="24">There is therefore provided in accordance with one embodiment of the present invention, apparatus for iterative decoding of a sequence of signal packets coded in accordance with a multi-component coding scheme, including a plurality of decoders, each of which performs a respective different decoding method on one of the signal packets, such that the plurality of decoders operate substantially concurrently.</p>
    <p num="25">Preferably, the plurality of decoders operate concurrently on different, respective packets.</p>
    <p num="26">Preferably, the plurality of decoders operate concurrently during at least 50% of the operation time during which the apparatus decodes the sequence.</p>
    <p num="27">Further preferably, the plurality of decoders operate concurrently during substantially the entire operation time of the apparatus.</p>
    <p num="28">Preferably, each of the plurality of decoders receives as its input a packet processed by another one of the plurality of decoders in most of the iterations.</p>
    <p num="29">Preferably, the plurality of decoders includes two decoders.</p>
    <p num="30">Preferably, the apparatus further includes a plurality of memory units to which the decoders output the packets after decoding.</p>
    <p num="31">Preferably, the packets are interleaved or de-interleaved after decoding.</p>
    <p num="32">Preferably, each of the plurality of decoders requires a generally equal decoding time to that of the other decoders.</p>
    <p num="33">Preferably, the multi-component coding scheme includes a parallel coding scheme.</p>
    <p num="34">Alternatively, the multi-component coding scheme includes a serial coding scheme.</p>
    <p num="35">Preferably, the plurality of decoders include APP decoders.</p>
    <p num="36">There is further provided in accordance with another embodiment of the present invention, a method of decoding a sequence of packets of data, coded in accordance with a multi-component coding scheme including inner and outer codes, including decoding a first packet in a first decoder, which decodes the inner code to generate a first decoded output packet, and decoding the first decoded output packet in a second decoder, which decodes the outer code, while substantially concurrently decoding a second packet in the first decoder.</p>
    <p num="37">Preferably, the method includes outputting the first packet from the second decoder to the first decoder, so as to repeat decoding the inner code.</p>
    <p num="38">Preferably, the method includes repeatedly decoding the first and second packets in the first and second decoders in alternation.</p>
    <p num="39">Preferably, the method includes de-interleaving the first output packet before decoding it in the second decoder.</p>
    <p num="40">Preferably, the multi-component coding scheme includes a serial-coding scheme.</p>
    <p num="41">There is further provided in accordance with another embodiment of the present invention, in a system for iterative decoding of a packet of soft data in which each bit is represented by a probability value, a method for determining after which of a plurality of iterations to terminate the decoding, including determining a probability value of the bits in the packet, and deciding to terminate the decoding only if the probability value is above a predetermined value.</p>
    <p num="42">Preferably, determining the probability value includes determining a minimal probability of the hard data values of the bits in the packet.</p>
    <p num="43">Preferably, determining the minimal probability value includes determining a minimal absolute log probability value.</p>
    <p num="44">Preferably, the method includes verifying that an error detection field in the packet is correct, and deciding to terminate includes deciding to terminate only if the error detection field is correct.</p>
    <p num="45">Preferably, verifying that the error detection field is correct is performed when the probability value is above the predetermined value.</p>
    <p num="46">Preferably, determining the probability value is performed only after a predetermined number of decoding iterations performed on the packet.</p>
    <p num="47">Preferably, determining the probability value includes determining the probability value on a decoded copy of the bits in the packet.</p>
    <p num="48">Alternatively or additionally, determining the probability value includes determining the probability value on a coded copy of the bits in the packet.</p>
    <p num="49">There is further provided in accordance with another embodiment of the present invention, apparatus for iterative decoding of coded packets including for each bit a probability value, including a decoder which performs iterations of decoding the packet, and a control unit which determines whether an additional iteration is to be performed by the decoder responsive to the probability values of the bits in the packet.</p>
    <p num="50">Preferably, the control unit causes the decoder to perform a predetermined number of iterations without checking the packet.</p>
    <p num="51">Preferably, the control unit determines whether an additional iteration is to be performed by the decoder responsive to an error detection field in the packet if the probability values fulfill a predetermined condition.</p>
    <p num="52">Preferably, the control unit does not initiate an additional iteration by the decoder if the error detection field is correct.</p>
    <p num="53">Preferably, the decoder includes an APP decoder.</p>
    <p num="54">Preferably, the control unit calculates a minimal probability of the hard data values of the bits in the packet and determines whether an additional iteration is to be performed responsive to the minimal probability.</p>
    <p num="55">Further preferably, the control unit calculates a minimal absolute log probability value.</p>
    <p num="56">Preferably, the control unit calculates the minimal probability based on a probability value of either a decoded or coded copy of the packet.</p>
    <p num="57">In accordance with one aspect of the present invention, there is advantageously further provided a method of terminating an iterative decoding process being performed on a packet in an iterative decoder, comprising the steps of determining whether a number of decoding iterations equals a predefined maximum number of iterations; determining whether a packet storage element coupled to an input of the iterative decoder is filled to within a predefined percentage of the storage capacity of the packet storage element; determining whether the number of decoding iterations equals a predefined minimum number of iterations; determining whether an error-detection measure has been satisfied for at least one previous packet; and terminating the iterative decoding process for the packet if (1) the number of decoding iterations equals the predefined maximum number of iterations, or if (2) the packet storage element is filled to within the predefined percentage of the storage capacity of the packet storage element, or if (3) the number of decoding iterations equals the predefined minimum number of iterations, and the error-detection measure has been satisfied for the at least one previous packet.</p>
    <p num="58">In accordance with another aspect of the present invention, there is advantageously further provided an iterative decoder, comprising first and second decoding means for performing an iterative decoding process on a packet; packet storage means coupled to the first and second decoding means; means for determining whether a number of decoding iterations equals a predefined maximum number of iterations; means for determining whether the packet storage means is filled to within a predefined percentage of the storage capacity of the packet storage means; means for determining whether the number of decoding iterations equals a predefined minimum number of iterations; means for determining whether an error-detection measure has been satisfied for at least one previous packet; and means for terminating the iterative decoding process for the packet if: (1) the number of decoding iterations equals the predefined maximum number of iterations, or (2) the packet storage means is filled to within the predefined percentage of the storage capacity of the packet storage means, or (3) the number of decoding iterations equals the predefined minimum number of iterations, and if the error-detection measure has been satisfied for the at least one previous packet.</p>
    <p num="59">In accordance with another aspect of the present invention, there is advantageously further provided an iterative decoder, comprising first and second decoders; an interleaver coupled to the first and second decoders and configured to interleave bits within a packet that was decoded by the second decoder and to provide the interleaved packet to the first decoder; a de-interleaver coupled to the first and second decoders and configured to de-interleave bits within a packet that was decoded by the first decoder and to provide the de-interleaved packet to the second decoder; an error-detection module coupled to the second decoder; an input packet buffer coupled to the first decoder; and a control unit coupled to the first and second decoders, the interleaver, the de-interleaver, the error-detection module, and the input packet buffer, the control unit being configured to terminate an iterative decoding process being performed on a packet if: (1) a number of decoding iterations equals a predefined maximum number of iterations, or (2) the error-detection module generates a satisfactory error-detection measure for two previous packets, or (3) the input packet buffer is filled to within a predefined percentage of the storage capacity of the input packet buffer.</p>
    <p num="60">In accordance with another aspect of the present invention, there is advantageously further provided: A method of terminating an iterative decoding process being performed on a packet in an iterative decoder, comprising the steps of determining whether a number of decoding iterations equals a predefined maximum number of iterations; determining whether a packet storage element coupled to an input of the iterative decoder is filled to within a predefined percentage of the storage capacity of the packet storage element; determining whether the number of decoding iterations is greater than or equal to a predefined minimum number of iterations; determining whether an error-detection measure has been satisfied for at least one previous packet; and terminating the iterative decoding process for the packet if: (1) the number of decoding iterations equals the predefined maximum number of iterations, or (2) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the packet storage element is filled to within the predefined percentage of the storage capacity of the packet storage element, or: (3) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the error-detection measure has been satisfied for the at least one previous packet.</p>
    <p num="61">In accordance with another aspect of the present invention, there is advantageously further provided an iterative decoder, comprising first and second decoding means for performing an iterative decoding process on a packet; packet storage means coupled to the first and second decoding means; means for determining whether a number of decoding iterations equals a predefined maximum number of iterations; means for determining whether the packet storage means is filled to within a predefined percentage of the storage capacity of the packet storage means; means for determining whether the number of decoding iterations is greater than or equal to a predefined minimum number of iterations; means for determining whether an error-detection measure has been satisfied for at least one previous packet; and means for terminating the iterative decoding process for the packet if: (1) the number of decoding iterations equals the predefined maximum number of iterations, or (2) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the packet storage means is filled to within the predefined percentage of the storage capacity of the packet storage means, or (3) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the error-detection measure has been satisfied for the at least one previous packet.</p>
    <p num="62">The present invention will be more fully understood from the following detailed description of the preferred embodiments thereof, taken together with the drawings, in which:</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="63">
      FIG. 1 is a block diagram of an iterative decoder, in accordance with one embodiment of the present invention;
      <br/>
      FIG. 2 is a flow chart of actions performed by a decoder to determine whether to stop decoding a packet, in accordance with one embodiment of the present invention;
      <br/>
      FIG. 3 is a block diagram of an iterative decoder, in accordance with another embodiment of the present invention;
      <br/>
      FIG. 4 is a flow chart of actions performed by a decoder to determine whether to stop decoding a packet, in accordance with another embodiment of the present invention; and
      <br/>
      FIG. 5 is a flow chart of actions performed by a decoder to determine whether to stop decoding a packet, in accordance with another embodiment of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
    <p num="64">
      FIG. 1 is a block diagram of a decoding processor 50, in accordance with an embodiment of the present invention.
      <br/>
      Processor 50 is preferably part of a digital receiver which receives analog signals.
      <br/>
      The received signals are digitized and preferably transformed to a scale in the range +-32,31} representing probability values in a logarithmic scale, as is known in the art.
      <br/>
      Alternatively, the scale may be in any other range and/or may be a non-logarithmic scale.
      <br/>
      Preferably, decoding processor 50 receives the digitized signals from a demodulator or channel de-interleaver (not shown), as is known in the art.
      <br/>
      The received digital signals were encoded before sending in accordance with a multi-code scheme, preferably including in series an outer coding scheme, interleaving, and an inner coding scheme.
      <br/>
      Alternatively or additionally, the multi-code scheme includes a Turbo code scheme, or any other suitable iterative scheme.
    </p>
    <p num="65">
      The digitized data incoming to processor 50 is accumulated in two parallel buffers 62 and 64, wherein buffer 62 receives a first packet of data and buffer 64 receives a second packet.
      <br/>
      An inner decoder 68, which decodes the inner code, is connected alternately to buffers 62 and 64 via a switch 66.
      <br/>
      Decoder 68 is preferably an A Posteriori Probability (APP) decoder, also termed a Maximum A Posteriori (MAP) decoder.
      <br/>
      Such decoders are known in the art and are described, for example, in "Implementation and Performance of a Turbo/Map Decoder," by Steven S. Pietrobon, International Journal of Satellite Communications, vol. 16, 1998, pp.23-46, which is incorporated herein by reference, as well as in a U.S. patent application having Ser.
      <br/>
      No. 09/186,753, filed Nov. 5, 1998 and entitled "Efficient Trellis State Metric Normalization," which is assigned to the assignee of the present invention and is incorporated herein by reference.
      <br/>
      Further alternatively, decoder 68 may comprise other decoders known in the art including SOVA decoders.
    </p>
    <p num="66">
      Two dual-port memories, preferably RAMs 52 and 54, are connected alternately to inner decoder 68 through two switches 56 and 58.
      <br/>
      Preferably, switch 56 conveys decoded output from decoder 68 to one of RAMs 52 and 54, while switch 58 conveys input to decoder 68 from the same one of the RAMs.
      <br/>
      Preferably, the output from decoder 68 is de-interleaved by a de-interleaver 72 upon its entrance to RAM 52 or 54 or upon its exit therefrom.
      <br/>
      Likewise, the input to decoder 68 through switch 58 is preferably interleaved by interleavers 74 associated with RAMs 52 and 54.
    </p>
    <p num="67">
      An outer APP (or MAP) decoder 70, preferably similar to decoder 68 in structure although directed to decoding a different code, i.e., the outer code, is connected alternately to RAMs 52 and 54 via a switch 76.
      <br/>
      Preferably, decoder 70 comprises two output lines: a first output line 90 which provides probability information on coded signals for further processing, and a second output line 92 which provides probability information on decoded data signals.
      <br/>
      A switch 78 connected to output line 90 preferably alternately directs output from decoder 70 to interleavers 74 of RAMs 52 and 54.
      <br/>
      After a sufficient number of iterations in processor 50, the output from decoder 70 on output line 92 is preferably passed to a decision unit 80, which converts soft data to hard data.
      <br/>
      Preferably, the hard data is passed to a CRC checking unit 83 which determines and checks the CRC of the decoded packet.
    </p>
    <p num="68">
      Preferably, decoder 68 outputs the decoded data as extrinsic information, i.e., as the difference between the LLR probabilities of its input data from switch 58 and its calculated improved LLR probabilities, as is known in the art and defined, for example, in the above mentioned publication by Hagenauer et al.
      <br/>
      Decoder 70, on the other hand, preferably has two output lines 90 and 92, as described above, one of which (preferably line 92) conveys extrinsic information as feedback to decoder 68 and the other of which (preferably line 90) conveys a priori probability information, i.e., the calculated LLR probabilities, to decision unit 80.
    </p>
    <p num="69">
      The decoded hard data is preferably output from decoding unit 50 via a switch 86 which directs the output on two separate lines 82 and 84, depending on in which of buffers 62 and 64 the original packet was stored.
      <br/>
      Preferably, a control unit 88 controls the operation of decoders 68 and 70, the states of the switches, and other operations of processor 50.
    </p>
    <p num="70">
      During operation, two successive packets of data are input to buffers 62 and 64, respectively.
      <br/>
      Switches 66 and 56 are set to their upper states (as shown in FIG. 1), and decoder 68 performs a first cycle in which a first inner decoding iteration on the packet in buffer 62.
      <br/>
      In the first inner decoding iteration, decoder 68 receives the input packet from buffer 62 and generates an output packet in RAM 52.
      <br/>
      The output packet is preferably de-interleaved in RAM 52 by de-interleaver 72, thus preparing the packet for input to decoder 70.
      <br/>
      The state of switch 58 does not affect the operation of decoder 68 and therefore does not matter or is disconnected.
    </p>
    <p num="71">
      Thereafter, switches 56 and 66 are brought to their lower state, and switches 76 and 78 are brought to their upper states.
      <br/>
      At this point control unit 88 initiates operation of both decoders 68 and 70.
      <br/>
      Decoder 68 performs a first inner decoding iteration on the packet in buffer 64 and generates an output packet in RAM 54.
      <br/>
      The output packet is preferably de-interleaved by de-interleaver 72 on its way into RAM 54 in preparation for input to decoder 70 during the next cycle of the processor.
      <br/>
      Alternatively or additionally, de-interleaver 72 de-interleaves the packet on its way out of RAM 54.
      <br/>
      Concurrently, decoder 70 performs a first outer decoding iteration on the packet in RAM 52.
      <br/>
      Decoder 72 operates on the de-interleaved packet in RAM 52 and generates an output packet back in RAM 52.
      <br/>
      The output packet is interleaved, by interleaver 74 associated with RAM 52, in preparation for re-use by decoder 68.
    </p>
    <p num="72">
      In a third operation cycle, switches 56, 58 and 66 are brought to their upper state and switches 76 and 78 are brought to their lower state, as in the first cycle.
      <br/>
      Decoder 68 receives input from both buffer 62 and RAM 52 and performs a second inner decoding iteration on the packet in buffer 62.
      <br/>
      The output packet is passed to RAM 52 as in the first inner decoding iteration.
      <br/>
      Concurrently, decoder 70 performs a first outer decoding iteration on the packet from buffer 64.
      <br/>
      The output is returned to RAM 54 to be interleaved by unit 74 in preparation for use by decoder 68.
      <br/>
      Thereafter the states of switches 56, 58, 66, 76 and 78 are changed, decoder 68 operates on the packet in buffer 64 and decoder 70 operates on the packet from buffer 62.
      <br/>
      Thus, decoders 68 and 70 interchangeably perform decoding iterations on the packets in buffer 62 and 64.
      <br/>
      Both of decoders 68 and 70 operate concurrently; and thus, using the same amount of hardware as processors known in the art, it is possible to achieve twice the decoding speed.
    </p>
    <p num="73">
      Control unit 88 decides when to terminate the decoding of the packets, preferably in accordance with a method described hereinbelow.
      <br/>
      The output from decoder 70 is passed both through switch 78 and to decision unit 80, which derives hard data (0's and 1's) from the signs of the soft data in the packet, as described hereinabove or as is generally known in the art.
      <br/>
      The hard data is passed to CRC checking unit 83 which determines the CRC and passes it to control unit 88.
      <br/>
      According to the CRC and other information, control unit 88 decides whether to perform another decoding iteration as described further hereinbelow.
    </p>
    <p num="74">
      Alternatively or additionally, after a predetermined number of decoding iterations, the decoding of each packet is terminated.
      <br/>
      Switch 86 is set on whichever of the two lines 82 or 84 the packet is to be output, and preferably switch 78 is disconnected.
      <br/>
      The output from decoder 70 is passed to decision unit 80, and from there is output via lines 82 or 84.
      <br/>
      At substantially the same time, a new packet of data is input to buffer 62 or 64 in which the now-decoded packet was originally stored, and the decoding process is continued.
      <br/>
      Preferably, new packets are sequentially loaded into each of buffers 62 and 64 and then processed by decoder 68 independently of one other.
      <br/>
      Alternatively, buffers 62 and 64 are filled with new packets one after the other in immediate succession, so that two new packets enter the decoding process in immediately successive cycles.
    </p>
    <p num="75">
      FIG. 2 is a flow chart illustrating an iterative decoding method performed by decoder 70 under supervision of control unit 88, in accordance with one embodiment of the present invention.
      <br/>
      Preferably, for each new packet entering processor 50, a counter of the number of decoding iterations performed is set to zero.
      <br/>
      For each outer decoding iteration of the packet, the counter is incremented.
      <br/>
      Until the counter reaches a predetermined minimum number of iterations (TR), the packet is automatically passed back from decoder 70 to decoder 68 for another decoding iteration.
      <br/>
      Preferably, the predetermined number (TR) is set to the minimal number of iterations which may achieve a sufficient decoding quality suitable for output.
      <br/>
      Further preferably, the predetermined number (TR) is between four and eight.
    </p>
    <p num="76">
      After the predetermined number of initial iterations have been performed, decoder 70 and/or control unit 88 determines the minimal absolute value of the LLR probability values L of the bits in the packet, min(.vertline.L.vertline.), i.e., the LLR probability value among all of the bits in the packet that is closest to zero. (As noted hereinabove, the bit probabilities are measured in the log domain on a scale of -32 to 31, with the extrema of the scale corresponding to high probabilities of a one or a zero, respectively.) The minimal LLR probability represents a level of confidence that the LLR probability represents the correct hard bit value.
      <br/>
      Therefore, if the minimal LLR probability value is not above a predetermined absolute probability threshold, the decoding process continues.
      <br/>
      However, if the minimal LLR probability value is above the predetermined threshold, the CRC of the packet is preferably verified, and the decoding of the packet is terminated if the CRC is correct.
    </p>
    <p num="77">
      Preferably, the minimal absolute value is calculated from the decoded data LLR probabilities on output line 90.
      <br/>
      Alternatively or additionally, the minimal absolute value is calculated from the coded data LLR a priori probabilities which corresponds to the extrinsic information on line 92, as described hereinabove and as is known in the art.
    </p>
    <p num="78">
      Alternatively, decoder 70 checks either the minimum probability value or the CRC code, but not both.
      <br/>
      Further alternatively, any other measure of the progress of convergence of the probability values to the extrema is used instead of the minimum value.
      <br/>
      For example, the average or the median of the probability values of the bits may be compared to a different respective threshold.
      <br/>
      It is noted, however, that using the minimum is simple and generally requires less time to compute.
      <br/>
      In one embodiment of the present invention, instead of first calculating the minimum and only then comparing to the threshold, the probabilities are compared in sequence to the minimum threshold.
      <br/>
      If a bit with a probability lower than the threshold is found, the checking is terminated and another iteration is performed.
    </p>
    <p num="79">
      Further, alternatively or additionally, the minimum probability is adjusted to ignore outliers.
      <br/>
      Preferably, a predetermined number of probability values beneath the minimum value are ignored.
    </p>
    <p num="80">Further alternatively or additionally, the minimum or average probability is calculated on a subset of the bits in the packet, preferably on a random subset.</p>
    <p num="81">
      It is noted that the method described hereinabove of determining when to terminate the iterative decoding, is not limited to use only with decoding processor 50.
      <br/>
      The above method may be used in any iterative decoder, including Turbo code decoders and Turbo-style decoders.
    </p>
    <p num="82">
      It is further noted that although the above description refers to decoding methods using LLR probabilities in the log domain, the methods of the present invention may be used with other probability representations.
      <br/>
      Particularly, the methods of the present invention may be used with decoders, such as DSP floating-point-arithmetic decoders, which represent probabilities in the normal range, i.e., between 0 and 1.
      <br/>
      In such decoders, the method of choosing the minimum probability is adjusted so that the minimum is chosen relative to a hard data decision (`0` or `1`) represented by the probabilities.
    </p>
    <p num="83">
      In another embodiment of the present invention, an iterative decoding system 100 includes a frame buffer 102, an inner decoder 104, an interleaver 106, a de-interleaver 108, an outer decoder 110, a decision unit 112, a CRC checking unit 114, and a control unit 116, as shown in FIG. 3.
      <br/>
      The interleaver 106 and the de-interleaver 108 may advantageously be implemented with RAM memory.
      <br/>
      The system 100 is advantageously part of a digital receiver that receives analog signals.
      <br/>
      The received signals are digitized and advantageously transformed to a scale in the range +-32,31} representing probability values in a logarithmic scale, as is known in the art.
      <br/>
      Alternatively, the scale may be in any other range and/or may be a non-logarithmic scale.
    </p>
    <p num="84">
      Advantageously, the iterative decoding system 100 receives the digitized signals from a demodulator or channel de-interleaver (not shown), as is known in the art.
      <br/>
      The received digital signals were encoded before being transmitted in accordance with a multi-code scheme, advantageously including in series an outer coding scheme, interleaving, and an inner coding scheme.
      <br/>
      Alternatively or additionally, the multi-code scheme includes a Turbo code scheme, or any other suitable iterative scheme.
    </p>
    <p num="85">
      The digitized data incoming to the system 100 is accumulated in the frame buffer 102, which receives the data in packets.
      <br/>
      The frame buffer 102 may advantageously be implemented with FIFO.
      <br/>
      The frame buffer 102 is configured to send a hardware control signal, denoted FAST_DECODE and described hereinbelow, to the control unit 116.
      <br/>
      The inner decoder 104, which decodes the inner code, is coupled to the frame buffer 102.
      <br/>
      The decoder 104 is advantageously an APP decoder (or MAP decoder), as known in the art.
      <br/>
      Further alternatively, the inner decoder 104 may comprise other decoders known in the art including, e.g., SOVA decoders.
    </p>
    <p num="86">
      The inner decoder 104 is coupled to the de-interleaver 108.
      <br/>
      A decoded data signal is output from the inner decoder 104 and is de-interleaved by the de-interleaver 108.
      <br/>
      The de-interleaver 108 is coupled to the outer decoder 110.
    </p>
    <p num="87">
      The outer APP (or MAP) decoder 110, which is advantageously similar to the inner decoder 104 in structure although directed to decoding a different code (i.e., the outer code), is also coupled to the interleaver 106.
      <br/>
      The interleaver 106 is advantageously a pseudo-random interleaver, but may in the alternative be a block interleaver or a convolutional interleaver.
      <br/>
      Advantageously, the outer decoder 110 includes two output lines: a first output line that is connected to the interleaver 106, providing probability information on coded signals for further processing, and a second output line that is connected to the decision unit 112, providing probability information on decoded data signals.
      <br/>
      After a sufficient number of iterations in the decoding system 100, the output from the outer decoder 110 on the second output line is advantageously passed to the decision unit 112, which converts soft data to hard data.
      <br/>
      Advantageously, the hard data is passed to the CRC checking unit 114, which determines and checks the CRC of the decoded packet.
    </p>
    <p num="88">
      Advantageously, the inner decoder 104 outputs the decoded data as extrinsic information, i.e., as the difference between the LLR probabilities of its input data and its calculated improved LLR probabilities, as is known in the art and defined, for example, in the above-mentioned publication by Hagenauer et al.
      <br/>
      The outer decoder 110, on the other hand, advantageously includes two output lines, as described above, one of which conveys extrinsic information as feedback to the inner decoder 104, and the other of which conveys a priori probability information, i.e., the calculated LLR probabilities, to the decision unit 112.
    </p>
    <p num="89">
      The decoded hard data is advantageously output from the decoding system 100 under the control of the control unit 116.
      <br/>
      The control unit 116 also controls other operations of the iterative decoding system 100.
      <br/>
      The control unit 100 may advantageously be a microprocessor.
      <br/>
      In the alternative, the control unit 116 may be implemented with any conventional processor, controller, microcontroller, or state machine.
    </p>
    <p num="90">
      When both decoders 104, 110 have decoded a packet, the decoding system 100 has performed one iteration.
      <br/>
      The control unit 116 decides when to terminate the decoding of the packets, advantageously in accordance with method steps described hereinbelow.
      <br/>
      The output from the outer decoder 110 is passed to the decision unit 112, which derives hard data (0's and 1's) from the signs of the soft data in the packet, as described hereinabove or as is generally known in the art.
      <br/>
      The hard data is passed to the CRC checking unit 114, which determines the CRC in accordance with known methods and passes the CRC to the control unit 116.
      <br/>
      Based upon the CRC and other information, the control unit 116 decides whether to perform another decoding iteration as described further hereinbelow.
    </p>
    <p num="91">
      Alternatively or additionally, after a predetermined number of decoding iterations, the decoding of each packet is terminated.
      <br/>
      The output from the inner decoder 110 is passed to the decision unit 112, and from there is output from the decoding system 100.
      <br/>
      At substantially the same time, a new packet of data is input to the frame buffer 102 (in which the now-decoded packet was originally stored), and the decoding process is continued.
    </p>
    <p num="92">
      In accordance with one embodiment, the iterative decoding system 100, under the supervision of the control unit 116, performs the algorithm steps illustrated in the flow chart of FIG. 4 to stop the process of iteratively decoding a data packet.
      <br/>
      In step 200 a counter (not shown) of the number of decoding iterations performed is set to zero for each new packet that enters the system.
      <br/>
      The current iteration number is denoted ITER_NUM.
      <br/>
      The system then proceeds to step 202 and begins a decoding iteration.
      <br/>
      The system then proceeds to step 204 and increments the current iteration number, ITER_NUM.
      <br/>
      For each outer decoding iteration of the packet, the counter is incremented.
      <br/>
      Until the counter reaches a predefined minimum number of iterations, MIN_ITER_NUM, the packet is automatically passed back from the outer decoder to the inner decoder for another decoding iteration.
      <br/>
      Advantageously, the predefined minimum number of iterations, MIN_ITER_NUM, is set to the minimal number of iterations that may achieve a sufficient decoding quality suitable for output.
      <br/>
      Further advantageously, the predefined minimum number of iterations, MIN_ITER_NUM, is between four and eight.
      <br/>
      In one embodiment the predefined minimum number of iterations, MIN_ITER_NUM, is a four-bit frame parameter.
      <br/>
      After incrementing the current iteration number, ITER_NUM, the system proceeds to step 206.
    </p>
    <p num="93">
      In step 206 the system determines whether the current iteration number, ITER_NUM, is equal to a predefined maximum number of iterations, MAX_ITER_NUM.
      <br/>
      Advantageously, the predefined maximum number of iterations, MAX_ITER_NUM, is between twelve and sixteen.
      <br/>
      In one embodiment the predefined maximum number of iterations, MAX_ITER_NUM, is a four-bit frame parameter.
      <br/>
      If the current iteration number, ITER_NUM, is equal to the predefined maximum number of iterations, MAX_ITER_NUM, the system proceeds to step 208.
      <br/>
      In step 208 the system stops performing decoding iterations on the data packet.
      <br/>
      If, on the other hand, the current iteration number, ITER_NUM, is not equal to the predefined maximum number of iterations, MAX_ITER_NUM, the system proceeds to step 210.
    </p>
    <p num="94">
      In step 210 the system determines whether the current iteration number, ITER_NUM, is greater than or equal to the predefined minimum number of iterations, MIN_ITER_NUM.
      <br/>
      If the current iteration number, ITER_NUM, is greater than or equal to the predefined minimum number of iterations, MIN_ITER_NUM, the system proceeds to step 212.
      <br/>
      If, on the other hand, the current iteration number, ITER_NUM, is not greater than or equal to the predefined minimum number of iterations, MIN_ITER_NUM, the system returns to step 202 to perform another decoding iteration.
    </p>
    <p num="95">
      In step 212 the system determines whether a condition flag denoted CRC_CHECK_MODE_OK is equal to one (i.e., whether the flag is set).
      <br/>
      The condition flag CRC_CHECK_MODE_OK flag, which is advantageously a flag in a decoding mode register (not shown) in the control unit, is advantageously written by the control unit.
      <br/>
      In one embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the previous two iterations resulted in good cyclic redundancy checks (CRC).
      <br/>
      CRC is an error-detection method that is well known in the relevant art.
      <br/>
      In another embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the CRC bits for the previous two iterations were identical.
      <br/>
      In another embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the CRC bits for the previous two iterations were identical and that the previous two iterations resulted in good CRC.
      <br/>
      In another embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the CRC bits for the previous iteration were good and that the entire packet is identical to the decoded packet on the previous iteration.
      <br/>
      In another embodiment a CONVERGE_DETECTED flag may be used in place of the CRC_CHECK_MODE_OK flag.
      <br/>
      The CONVERGE_DETECTED flag having a value of one indicates that the entire packet is identical to the decoded packet on the previous iteration.
      <br/>
      This is beneficial, for example, when the decoder has converged to an erroneous solution, and there is no need to continue trying to decode (i.e., there is no CRC in this mode).
      <br/>
      In other embodiments the CRC_CHECK_MODE_OK flag may having a value of one may indicate whether other known error-detection measures were satisfied for the previous two data packets.
    </p>
    <p num="96">
      If in step 212 the CRC_CHECK_MODE_OK flag is equal to one, the system proceeds to step 208, terminating the iteration process for the data packet.
      <br/>
      If, on the other hand, the CRC_CHECK_MODE_OK flag is not equal to one (i.e., the flag is equal to zero, or cleared), the system proceeds to step 214.
    </p>
    <p num="97">
      In step 214 the system determines whether a hardware control signal denoted FAST_DECODE is equal to one.
      <br/>
      The FAST_DECODE hardware control signal may advantageously be used in a multi-user decoding system, in which a signal is sent by the demodulator (not shown) to speed up the decoding system.
      <br/>
      The FAST_DECODE hardware control signal may advantageously be generated by an external FIFO to tell the decoding system to finish decoding a packet as soon as possible after the minimum number of iterations, MIN_ITER_NUM, has been performed.
      <br/>
      Alternatively, the FAST_DECODE hardware control signal may be driven by the FIFO of the input frame buffer to the decoding system.
      <br/>
      A threshold is set on the FIFO such that if the FIFO is filled with packets to a level that is below the threshold, the decoding system can run the maximum number iterations, MAX_ITER_NUM.
      <br/>
      If the FIFO is close to full (i.e., if the threshold is met or exceeded), the decoding system will run only the minimum number of iterations, MIN_ITER_NUM.
      <br/>
      Thus, if the FIFO is filled to within a predefined percentage of the storage capacity of the FIFO, the FAST_DECODE hardware control signal is driven.
      <br/>
      The threshold level may thus advantageously be set on the FIFO to drive the FAST_DECODE hardware control signal in the event the decoding system realizes that it cannot serve all of the packets waiting in the input frame buffer.
    </p>
    <p num="98">
      If in step 214 the FAST_DECODE hardware control signal is equal to one, the system proceeds to step 208, stopping the iteration process for the data packet.
      <br/>
      If, on the other hand, the FAST_DECODE hardware control signal is not equal to one (i.e., it is equal to zero), the system returns to step 202 to perform another decoding iteration.
    </p>
    <p num="99">
      It would be understood by those skilled in the art that the method steps of FIG. 4 may be performed by any iterative decoder including, e.g., Turbo decoders or Turbo-style decoders.
      <br/>
      It is well known that the Turbo decoding principal can be used for iterating between an equalizer and a decoder, or between a demodulator and a decoder.
      <br/>
      Therefore, it would also be understood by those skilled in the art that the method steps of FIG. 4 may be performed in Turbo equalization (including a decoder).
    </p>
    <p num="100">
      In accordance with another embodiment, the iterative decoding system 100 of FIG. 3, under the supervision of the control unit 116, performs the algorithm steps illustrated in the flow chart of FIG. 5 to stop the process of iteratively decoding a data packet.
      <br/>
      In step 300 a counter (not shown) of the number of decoding iterations performed is set to zero for each new packet that enters the system.
      <br/>
      The current iteration number is denoted ITER_NUM.
      <br/>
      The system then proceeds to step 302 and begins a decoding iteration.
      <br/>
      The system then proceeds to step 304 and increments the current iteration number, ITER_NUM.
      <br/>
      For each outer decoding iteration of the packet, the counter is incremented.
      <br/>
      Until the counter reaches a predefined minimum number of iterations, MIN_ITER_NUM, the packet is automatically passed back from the outer decoder to the inner decoder for another decoding iteration.
      <br/>
      Advantageously, the predefined minimum number of iterations, MIN_ITER_NUM, is set to the minimal number of iterations that may achieve a sufficient decoding quality suitable for output.
      <br/>
      Further advantageously, the predefined minimum number of iterations, MIN_ITER_NUM, is between four and eight.
      <br/>
      In one embodiment the predefined minimum number of iterations, MIN_ITER_NUM, is a four-bit frame parameter.
      <br/>
      After incrementing the current iteration number, ITER_NUM, the system proceeds to step 306.
    </p>
    <p num="101">
      In step 306 the system determines whether the current iteration number, ITER_NUM, is equal to a predefined maximum number of iterations, MAX_ITER_NUM.
      <br/>
      Advantageously, the predefined maximum number of iterations, MAX_ITER_NUM, is between twelve and sixteen.
      <br/>
      In one embodiment the predefined maximum number of iterations, MAX_ITER_NUM, is a four-bit frame parameter.
      <br/>
      If the current iteration number, ITER_NUM, is equal to the predefined maximum number of iterations, MAX_ITER_NUM, the system proceeds to step 308.
      <br/>
      In step 308 the system stops performing decoding iterations on the data packet.
      <br/>
      If, on the other hand, the current iteration number, ITER_NUM, is not equal to the predefined maximum number of iterations, MAX_ITER_NUM, the system proceeds to step 310.
    </p>
    <p num="102">
      In step 310 the system determines whether a condition flag denoted CRC_CHECK_MODE_OK is equal to one (i.e., whether the flag is set).
      <br/>
      The condition flag CRC_CHECK_MODE_OK flag, which is advantageously a flag in a decoding mode register (not shown) in the control unit, is advantageously written by the control unit.
      <br/>
      In one embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the previous two iterations resulted in good CRC.
      <br/>
      In another embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the CRC bits for the previous two iterations were identical.
      <br/>
      In another embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the CRC bits for the previous two iterations were identical and that the previous two iterations resulted in good CRC.
      <br/>
      In another embodiment the CRC_CHECK_MODE_OK flag having a value of one indicates that the CRC bits for the previous iteration were good and that the entire packet is identical to the decoded packet on the previous iteration.
      <br/>
      In another embodiment a CONVERGE_DETECTED flag may be used in place of the CRC_CHECK_MODE_OK flag.
      <br/>
      The CONVERGE_DETECTED flag having a value of one indicates that the entire packet is identical to the decoded packet on the previous iteration.
      <br/>
      This is beneficial, for example, when the decoder has converged to an erroneous solution, and there is no need to continue trying to decode (i.e., there is no CRC in this mode).
      <br/>
      In other embodiments the CRC_CHECK_MODE_OK flag, having a value of one, may indicate whether other known error-detection measures were satisfied for the previous two data packets.
    </p>
    <p num="103">
      If in step 310 the CRC_CHECK_MODE_OK flag is equal to one, the system proceeds to step 308, terminating the iteration process for the data packet.
      <br/>
      If, on the other hand, the CRC_CHECK_MODE_OK flag is not equal to one (i.e., the flag is equal to zero, or cleared), the system proceeds to step 312.
    </p>
    <p num="104">
      In step 312 the system determines whether the current iteration number, ITER_NUM, is equal to the predefined minimum number of iterations, MIN_ITER_NUM.
      <br/>
      If the current iteration number, ITER_NUM, is equal to the predefined minimum number of iterations, MIN_ITER_NUM, the system proceeds to step 314.
      <br/>
      If, on the other hand, the current iteration number, ITER_NUM, is not equal to the predefined minimum number of iterations, MIN_ITER_NUM, the system returns to step 302 to perform another decoding iteration.
    </p>
    <p num="105">
      In step 314 the system determines whether a hardware control signal denoted FAST_DECODE is equal to one.
      <br/>
      The FAST_DECODE hardware control signal may advantageously be used in a multi-user decoding system, in which a signal is sent by the demodulator (not shown) to speed up the decoding system.
      <br/>
      The FAST_DECODE hardware control signal may advantageously be generated by an external FIFO to tell the decoding system to finish decoding a packet as soon as possible after the minimum number of iterations, MIN_ITER_NUM, has been performed.
      <br/>
      Alternatively, the FAST_DECODE hardware control signal may be driven by the FIFO of the input frame buffer to the decoding system.
      <br/>
      A threshold is set on the FIFO such that if the FIFO is filled with packets to a level that is below the threshold, the decoding system can run the maximum number iterations, MAX_ITER_NUM.
      <br/>
      If the FIFO is close to full (i.e., if the threshold is met or exceeded), the decoding system will run only the minimum number of iterations, MIN_ITER_NUM.
      <br/>
      Thus, if the FIFO is filled to within a predefined percentage of the storage capacity of the FIFO, the FAST_DECODE hardware control signal is driven.
      <br/>
      The threshold level may thus advantageously be set on the FIFO to drive the FAST_DECODE hardware control signal in the event the decoding system realizes that it cannot serve all of the packets waiting in the input frame buffer.
    </p>
    <p num="106">
      If in step 314 the FAST_DECODE hardware control signal is equal to one, the system proceeds to step 308, stopping the iteration process for the data packet.
      <br/>
      If, on the other hand, the FAST_DECODE hardware control signal is not equal to one (i.e., it is equal to zero), the system returns to step 302 to perform another decoding iteration.
    </p>
    <p num="107">
      It would be understood by those skilled in the art that the method steps of FIG. 5 may be performed by any iterative decoder including, e.g., Turbo decoders or Turbo-style decoders.
      <br/>
      It is well known that the Turbo decoding principal can be used for iterating between an equalizer and a decoder, or between a demodulator and a decoder.
      <br/>
      Therefore, it would also be understood by those skilled in the art that the method steps of FIG. 5 may be performed in Turbo equalization (including a decoder).
    </p>
    <p num="108">
      Thus, a novel, efficient, iterative decoder has been described.
      <br/>
      Those of skill in the art would understand that the various illustrative logical blocks and algorithm steps described in connection with the embodiments disclosed herein may be implemented or performed with a digital signal processor (DSP), an application specific integrated circuit (ASIC), discrete gate or transistor logic, discrete hardware components such as, e.g., registers and FIFO, a processor executing a set of firmware instructions, or any conventional programmable software module and a processor.
      <br/>
      The processor may advantageously be a microprocessor, but in the alternative, the processor may be any conventional processor, controller, microcontroller, or state machine.
      <br/>
      The software module could reside in RAM memory, flash memory, registers, or any other form of writable storage medium known in the art.
      <br/>
      Those of skill would further appreciate that the data, instructions, commands, information, signals, bits, symbols, and chips that may be referenced throughout the above description are advantageously represented by voltages, currents, electromagnetic waves, magnetic fields or particles, optical fields or particles, or any combination thereof.
    </p>
    <p num="109">It will be appreciated that the preferred embodiments described above are cited by way of example, and the full scope of the invention is limited only by the claims.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13.</claim-text>
      <claim-text>An iterative decoder, comprising: first and second decoders; an interleaver coupled to the first and second decoders and configured to interleave bits within a packet that was decoded by the second decoder and to provide the interleaved packet to the first decoder; a de-interleaver coupled to the first and second decoders and configured to de-interleave bits within a packet that was decoded by the first decoder and to provide the de-interleaved packet to the second decoder; an error-detection module coupled to the second decoder; an input packet buffer coupled to the first decoder;</claim-text>
      <claim-text>and a control unit coupled to the first and second decoders, the interleaver, the de-interleaver, the error-detection module, and the input packet buffer, the control unit being configured to terminate an iterative decoding process being performed on a packet if (1) a number of decoding iterations equals a predefined maximum number of iterations, or (2) the error-detection module generates a satisfactory error-detection measure for two previous packets, or (3) the input packet buffer is filled to within a predefined percentage of the storage capacity of the input packet buffer.</claim-text>
      <claim-text>1. A method of terminating an iterative decoding process being performed on a packet in an iterative decoder, comprising the steps of:</claim-text>
      <claim-text>determining whether a number of decoding iterations equals a predefined maximum number of iterations; determining whether a packet storage element coupled to an input of the iterative decoder is filled to within a predefined percentage of the storage capacity of the packet storage element; determining whether the number of decoding iterations equals a predefined minimum number of iterations; determining whether an error-detection measure has been satisfied for at least one previous packet;</claim-text>
      <claim-text>and terminating the iterative decoding process for the packet if (1) the number of decoding iterations equals the predefined maximum number of iterations, or if (2) the packet storage element is filled to within the predefined percentage of the storage capacity of the packet storage element, or if (3) the number of decoding iterations equals the predefined minimum number of iterations, and the error-detection measure has been satisfied for the at least one previous packet.</claim-text>
      <claim-text>2. The method of claim 1, wherein the error-detection measure comprises a cyclic redundancy check.</claim-text>
      <claim-text>3. The method of claim 1, wherein the at least one previous packet comprises two previous packets.</claim-text>
      <claim-text>4. The method of claim 1, wherein the error-detection measure is satisfied if cyclic redundancy check bits are identical for two previous packets.</claim-text>
      <claim-text>5. The method of claim 1, wherein the error-detection measure is satisfied if a cyclic redundancy check is satisfactory for a previous decoded packet, and if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
      <claim-text>6. The method of claim 1, wherein the error-detection measure is satisfied if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
      <claim-text>7. An iterative decoder, comprising: first and second decoding means for performing an iterative decoding process on a packet; packet storage means coupled to the first and second decoding means; means for determining whether a number of decoding iterations equals a predefined maximum number of iterations; means for determining whether the packet storage means is filled to within a predefined percentage of the storage capacity of the packet storage means; means for determining whether the number of decoding iterations equals a predefined minimum number of iterations; means for determining whether an error-detection measure has been satisfied for at least one previous packet;</claim-text>
      <claim-text>and means for terminating the iterative decoding process for the packet if (1) the number of decoding iterations equals the predefined maximum number of iterations, or if (2) the packet storage means is filled to within the predefined percentage of the storage capacity of the packet storage means, or if (3) the number of decoding iterations equals the predefined minimum number of iterations, and if the error-detection measure has been satisfied for the at least one previous packet.</claim-text>
      <claim-text>8. The iterative decoder of claim 7, wherein the error-detection measure comprises a cyclic redundancy check.</claim-text>
      <claim-text>9. The iterative decoder of claim 7, wherein the at least one previous packet comprises two previous packets.</claim-text>
      <claim-text>10. The iterative decoder of claim 7, wherein the error-detection measure is satisfied if cyclic redundancy check bits are identical for two previous packets.</claim-text>
      <claim-text>11. The iterative decoder of claim 7, wherein the error-detection measure is satisfied if a cyclic redundancy check is satisfactory for a previous decoded packet, and if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
      <claim-text>12. The iterative decoder of claim 7, wherein the error-detection measure is satisfied if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The iterative decoder of claim 13, wherein the error-detection module comprises a cyclic redundancy check unit.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The iterative decoder of claim 13, wherein the first and second decoders comprise maximum a posteriori decoders.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The iterative decoder of claim 13, wherein the first and second decoders comprise Turbo decoders.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The iterative decoder of claim 13, wherein the first decoder is configured to decode an inner code, and wherein the second decoder is configured to decode an outer code.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. A method of terminating an iterative decoding process being performed on a packet in an iterative decoder, comprising the steps of: determining whether a number of decoding iterations equals a predefined maximum number of iterations; determining whether a packet storage element coupled to an input of the iterative decoder is filled to within a predefined percentage of the storage capacity of the packet storage element; determining whether the number of decoding iterations is greater than or equal to a predefined minimum number of iterations; determining whether an error-detection measure has been satisfied for at least one previous packet;</claim-text>
      <claim-text>and terminating the iterative decoding process for the packet if (1) the number of decoding iterations equals the predefined maximum number of iterations, or if (2) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the packet storage element is filled to within the predefined percentage of the storage capacity of the packet storage element, or if (3) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the error-detection measure has been satisfied for the at least one previous packet.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method of claim 18, wherein the error-detection measure comprises a cyclic redundancy check.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The method of claim 18, wherein the at least one previous packet comprises two previous packets.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The method of claim 18, wherein the error-detection measure is satisfied if cyclic redundancy check bits are identical for two previous packets.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The method of claim 18, wherein the error-detection measure is satisfied if a cyclic redundancy check is satisfactory for a previous decoded packet, and if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The method of claim 18, wherein the error-detection measure is satisfied if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. An iterative decoder, comprising: first and second decoding means for performing an iterative decoding process on a packet; packet storage means coupled to the first and second decoding means; means for determining whether a number of decoding iterations equals a predefined maximum number of iterations; means for determining whether the packet storage means is filled to within a predefined percentage of the storage capacity of the packet storage means; means for determining whether the number of decoding iterations is greater than or equal to a predefined minimum number of iterations; means for determining whether an error-detection measure has been satisfied for at least one previous packet;</claim-text>
      <claim-text>and means for terminating the iterative decoding process for the packet if (1) the number of decoding iterations equals the predefined maximum number of iterations, or if (2) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the packet storage means is filled to within the predefined percentage of the storage capacity of the packet storage means, or if (3) the number of decoding iterations is greater than or equal to the predefined minimum number of iterations, and the error-detection measure has been satisfied for the at least one previous packet.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The iterative decoder of claim 24, wherein the error-detection measure comprises a cyclic redundancy check.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The iterative decoder of claim 24, wherein the at least one previous packet comprises two previous packets.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The iterative decoder of claim 24, wherein the error-detection measure is satisfied if cyclic redundancy check bits are identical for two previous packets.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The iterative decoder of claim 24, wherein the error-detection measure is satisfied if a cyclic redundancy check is satisfactory for a previous decoded packet, and if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The iterative decoder of claim 24, wherein the error-detection measure is satisfied if the previous decoded packet is identical to the packet being subjected to the iterative decoding process.</claim-text>
    </claim>
  </claims>
</questel-patent-document>