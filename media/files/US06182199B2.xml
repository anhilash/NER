<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182199B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182199</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182199</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22518391" extended-family-id="42109048">
      <document-id>
        <country>US</country>
        <doc-number>09146659</doc-number>
        <kind>A</kind>
        <date>19980903</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09146659</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165686</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>14665998</doc-number>
        <kind>A</kind>
        <date>19980903</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09146659</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  12/14        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>14</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>711163000</text>
        <class>711</class>
        <subclass>163000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>711152000</text>
        <class>711</class>
        <subclass>152000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>711166000</text>
        <class>711</class>
        <subclass>166000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>711E12098</text>
        <class>711</class>
        <subclass>E12098</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>726021000</text>
        <class>726</class>
        <subclass>021000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-012/14C</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>012</main-group>
        <subgroup>14C</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-012/1416</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>1416</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>12</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>3</number-of-drawing-sheets>
      <number-of-figures>4</number-of-figures>
      <image-key data-format="questel">US6182199</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">System and method for granting permission to modify a memory area</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>FANDRICH MICKEY L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5592641</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5592641</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>KATSUTA HIROSHI</text>
          <document-id>
            <country>US</country>
            <doc-number>5721872</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5721872</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Faust, Robert Allan</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Van Leeuwen, Leslie A.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Nguyen, Hiep T.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A system, method, and computer readable medium allow for granting permission to modify a memory area, such as a data variable stored in memory, without using valuable memory space to store permission variables.
      <br/>
      Rather than using separate permission variables, a portion of a data variable is used to indicate whether or not the data variable may be modified.
      <br/>
      The least significant bit of a variable (i.e. memory area) is used as a permission indicator.
      <br/>
      When the least significant bit is set to one, it is permissible to modify the variable.
      <br/>
      When the least significant bit is set to zero, it is not permissible to modify the variable.
      <br/>
      In one embodiment of the present invention, a counter variable is both checked for permission to increment, and incremented (if permission is granted) in one step.
      <br/>
      Efficiency is increased, which is especially valuable in the case of embedded systems, where memory space is typically in short supply.
      <br/>
      Because valuable memory space is conserved, more data may be stored in memory, and thus more data functions may be implemented in the embedded system.
      <br/>
      Further, because permission to modify a data variable is contained within the data variable itself, a program which desires to modify the data variable does not need to reference a permission, or locking, variable and test for permission to modify the data variable.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates to information handling systems, and, more particularly, to a system and method for granting permission to modify a memory area.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      A microcontroller is usually contained on a single integrated circuit, and is often intended to operate as an embedded system.
      <br/>
      In addition to a processing unit (e.g., a CPU), a microcontroller typically contains a small amount of random access memory (RAM), programmable read only memory (PROM), timers, and I/O ports.
      <br/>
      RAM is often in very short supply in embedded microcontroller applications.
      <br/>
      Often, it is limited to amounts in the 32 to 256 byte range.
    </p>
    <p num="3">
      Microcontrollers are often used to perform complex tasks in an information handling system.
      <br/>
      For example, a microcontroller may be used as a service processor for environmental monitoring within the system, early power off warning, error log analysis, etc.
      <br/>
      Microcontrollers are also used for data acquisition and control of subsystems, motion devices, input devices, display devices, instrumentation devices, etc.
    </p>
    <p num="4">
      Many software programs, including those written as embedded microcontroller applications, require that some type of permission or authority be acquired, before a memory location is modified.
      <br/>
      Usually, some type of permission variable is used to indicate that another variable, such as a data variable, may be updated.
      <br/>
      For example, before updating a counter, the application program checks a permission indicator variable.
      <br/>
      If the permission indicator variable is set to a certain value, the counter may be modified.
      <br/>
      If, however, the permission indicator variable is set to another value, the counter may not be modified.
    </p>
    <p num="5">
      Permission indicator variables can use a great deal of RAM.
      <br/>
      RAM is consumed for every memory area (e.g., the counters described above), and for each permission variable associated with the memory areas.
      <br/>
      In a typical processor, this is usually not a problem.
      <br/>
      However, in a microcontroller, where RAM is typically in short supply, this can be an overwhelming problem.
      <br/>
      Conserving even a small amount of RAM can make a major difference in the functionality of an embedded microcontroller application.
    </p>
    <p num="6">
      Consequently, it would be desirable to have a system and method for conserving RAM in an embedded microcontroller application.
      <br/>
      It would be desirable to have a permission, or locking, system for memory areas (i.e. variables) that does not consume valuable RAM space.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="7">
      Accordingly, the present invention is directed to a system, method, and computer readable medium for granting permission to modify a memory area, such as a data variable stored in memory, without using valuable memory space to store permission variables.
      <br/>
      Rather than using separate permission variables, a portion of a data variable is used to indicate whether or riot the data variable may be modified.
    </p>
    <p num="8">
      The least significant bit of a variable (i.e. memory area) is used as a permission indicator.
      <br/>
      When the least significant bit is set to one, it is permissible to modify the variable.
      <br/>
      When the least significant bit is set to zero, it is not permissible to modify the variable.
      <br/>
      In one embodiment of the present invention, a counter variable is both checked for permission to increment, and incremented (if permission is; granted) in one step.
    </p>
    <p num="9">
      One advantage of the present invention is that it increases the efficiency of embedded systems, where memory space is typically in short supply.
      <br/>
      Because valuable memory space is conserved, more data may be stored in memory, and thus more data functions may be implemented in the embedded system.
      <br/>
      Further, because permission to modify a data variable is contained within the data variable itself, a program which desires to modify the data variable does not need to reference a permission, or locking, variable and test for permission to modify the data variable.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="10">
      The foregoing and other features and advantages of the present invention will become more apparent from the detailed description of the best mode for carrying out the invention as rendered below. In the description to follow, reference will be made to the accompanying drawings, where like reference numerals are used to identify like parts in the various views and in which:
      <br/>
      FIG. 1 is a block diagram of an information handling system in which the present invention may be implemented;
      <br/>
      FIG. 2 is a block diagram of a typical microcontroller in which the present invention may be implemented;
      <br/>
      FIG. 3 is a block diagram of an array of counters; and
      <br/>
      FIG. 4 is a flow chart depicting a method for granting permission to update a memory area, according to the teachings of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT OF THE INVENTION</heading>
    <p num="11">
      The invention may be implemented on a variety of hardware platforms, including personal computers, workstations, mini-computers, servers, and mainframe computers.
      <br/>
      Referring now to FIG. 1, a typical configuration of an information handling system that may be used to practice the novel method of the present invention will be described.
      <br/>
      The information handling system depicted in FIG. 1 is a high end server 10 that includes several physical enclosures.
      <br/>
      A physical enclosure, referred to as the central electronics complex (CEC) 12, contains processor cards, a memory controller, memory cards, power supplies, and cooling units (not shown).
      <br/>
      CEC 10 is connected, via cables 14, to one or more input/output (I/O) racks 16.
      <br/>
      Each I/O rack 16 may contain several I/O drawers 18.
      <br/>
      Each I/O drawer 18 may contain many ports, slots, and bays (not shown) for attaching various I/O devices, such as direct access storage devices (DASD), disk drives, PCI devices, etc.
    </p>
    <p num="12">
      Other information handling systems, e.g., smaller and mid-range servers, or single-user systems, are contained within one physical enclosure.
      <br/>
      An entire system, including processor cards, a memory controller, memory cards, power supplies, cooling units, and I/O devices (including I/O ports and slots to attach additional I/O devices) may be contained within a single system drawer or system unit.
    </p>
    <p num="13">
      A service processor is often included within an I/O drawer, a system drawer, or a system unit.
      <br/>
      A service processor is often implemented on a microcontroller device.
      <br/>
      Service processors are used to perform tasks such as system environmental monitoring/alerting (e.g., AC/DC voltage, fan speed and temperature sensing), early power-off warnings, and error log analysis and alerts.
      <br/>
      Some service processors automatically dial a service center, without operator initiation, when a potential component failure is detected.
    </p>
    <p num="14">
      FIG. 2 is a block diagram of an exemplary service processor 20, implemented on a microcontroller 22, in which the present invention may be implemented.
      <br/>
      Note that while the invention is described with reference to a service processor implemented on a microcontroller, this is not meant to be limiting.
      <br/>
      The present invention may be implemented in many types of information handling systems, including, but not limited to personal computers, workstations, mini-computers, servers, and mainframe computers.
    </p>
    <p num="15">
      Referring now to FIG. 2, service processor 20 will be described.
      <br/>
      Service processor 20 is implemented on microcontroller chip 22, which contains central processing unit (CPU) 24, at least one timer 26, random access memory (RAM) 28, and erasable programmable read only memory (EPROM) 30. Microcontroller 22 also contains several I/O ports 32, which allow it to send and receive data from other devices in the system.
      <br/>
      Various internal buses (not shown) allow the elements of microcontroller 22 to communicate with each other.
    </p>
    <p num="16">
      Typically, EPROM 30 and RAM 28 are small.
      <br/>
      For example, a microcontroller may contain as little as 512 bytes of EPROM and 25 bytes of RAM.
      <br/>
      A program, such as a service processor program, is coded into EPROM 30.
      <br/>
      RAM 28 is used for stack and heap space, and also to hold any variables needed by the program executing in EPROM 30.
      <br/>
      Because the amount of RAM 28 is typically limited in a microcontroller, it is important that the program executing in EPROM 30 use as little RAM space as possible.
    </p>
    <p num="17">
      The present invention is a method, system, and computer readable medium for granting permission to modify a memory area, such as a data variable stored in RAM 28, without using valuable RAM space to store permission variables.
      <br/>
      Rather than using separate permission variables, a portion of a data variable is used to indicate whether or not the data variable may be modified.
      <br/>
      No permission variables are necessary, thus freeing up valuable RAM space, and allowing more functionality to be incorporated into microcontroller 22.
    </p>
    <p num="18">
      The present invention also increases the efficiency of service processor 20.
      <br/>
      First, because RAM space is conserved, more data may be stored in RAM 28, and thus more data functions may be implemented in microcontroller 22, rather than "off-chip" (i.e. another microcontroller or other hardwired logic).
      <br/>
      Second, because permission to modify a data variable is contained within the data variable itself, the program executing in EPROM 30 does not need to reference a permission, or locking, variable array and test for permission to modify a data variable.
    </p>
    <p num="19">
      One embodiment of the present invention is in a service processor, implemented on a microcontroller, in an I/O drawer (e.g., drawer 18 shown in FIG. 1).
      <br/>
      The service processor in the I/O drawer continuously monitors environmental conditions in the drawer.
      <br/>
      When an environmental condition falls outside of a certain predetermined range, a counter associated with that particular environmental condition is incremented.
      <br/>
      When the counter reaches a particular value, an error alert is generated.
    </p>
    <p num="20">
      FIG. 3 depicts an array of counters 40 associated with the fans in an I/O unit.
      <br/>
      Each counter is an eight-bit counter, and there is one counter for each fan.
      <br/>
      In the example shown in FIG. 3, there are eight fans, and thus there are eight counters, numbered from CTR0 42 to CTR7 56.
      <br/>
      The fan speeds are read on a regular basis by microcode in the I/O unit, and the data is sent to the microcontroller via a bus.
      <br/>
      In the described embodiment, it takes one second to read the fan speed of each fan, and thus eight seconds to read the eight fans.
      <br/>
      If a particular fan has a speed that is either too high or too low, the counter associated with that particular fan is incremented.
      <br/>
      If any fan counter reaches a certain maximum number, that particular fan is flagged as being out of specification.
      <br/>
      The main operating system is notified, via an interrupt, that there is a problem with the particular fan.
    </p>
    <p num="21">
      The fan counters should only be incremented after the fan speeds have been read.
      <br/>
      It is possible that the code which compares the actual fan speeds to the desired (i.e. specified) fan speeds may execute more frequently than the fans are read.
      <br/>
      For example, the fan speeds may be read every eight seconds, as discussed above, while the code which compares the actual fan speeds to the desired fan speeds may execute many times per second.
      <br/>
      Thus, it becomes important to know when the fan speeds have been newly read, and when it is permissible to increment (if necessary) the fan counters.
    </p>
    <p num="22">
      This is accomplished by using the least significant bit of each counter as a permission indicator.
      <br/>
      When the least significant bit is set to one, it is permissible to increment the counter.
      <br/>
      When the least significant bit is set to zero, it is not permissible to increment the counter.
      <br/>
      An exemplary code statement, shown in C, for using the least significant bit to indicate permission, is shown below.
      <br/>
      Note that a single C statement both determines if it is permissible to increment counter�i�, and if so, increments counter�i�. counter�i�+=(counter�i� &amp; 1)
    </p>
    <p num="23">
      If the least significant bit of the counter is equal to one, the counter will be incremented.
      <br/>
      However, if the least significant bit of the counter is zero, the counter will not be incremented.
      <br/>
      Suppose, for example, that counter�i� contains the value of ten.
      <br/>
      In binary, the eight bits of counter�i� are 00001010.
      <br/>
      Based on the above C statement, counter�i� will not be incremented.
      <br/>
      This is illustrated as follows:
    </p>
    <p num="24">
      counter�i�+=(counter�i� &amp; 1)
      <br/>
      00001010+=(00001010 &amp; 000000001)
      <br/>
      00001010+=0
      <br/>
      00001010
    </p>
    <p num="25">
      However, suppose that counter�i� contains the value of 11.
      <br/>
      In binary, the eight bits of ccunter�i� are 00001011.
      <br/>
      Now, because the least significant bit of counter�i� is equal to one, it can be incremented by the above C statement.
      <br/>
      This is shown as follows:
      <br/>
      counter�i�+=(counter�i� &amp; 1)
      <br/>
      00001011+=(00001011 &amp; 00000001)
      <br/>
      00001011+=1
      <br/>
      00001100
    </p>
    <p num="26">
      FIG. 4 is a flow chart depicting a method for implementing the present invention.
      <br/>
      First, all sensors that are being monitored are read (step 60).
      <br/>
      Next, it is determined if it is time to read a fan speed (step 62).
      <br/>
      As discussed above, each fan is read once per second.
      <br/>
      Those skilled in the art will appreciate that there are many ways to determine if it is time to read a fan.
      <br/>
      For example, a timer (such as timer 26 in FIG. 2 may be used).
      <br/>
      If it is time to read a fan speed (i.e. the answer to the question in step 62 is "yes"), the fan speed of the fan is read (step 64).
      <br/>
      Typically fans are read in order, from 0 to 7, and those skilled in the art will appreciate that a counter or other such method may be used to keep track of which fan speed to read next.
      <br/>
      Once the fan speed has been read, the least significant bit of the corresponding fan counter is set to one (step 66).
      <br/>
      This may be accomplished by logically ORing the fan counter with one.
      <br/>
      When the least significant bit of a fan counter is equal to one, it indicates that the fan speed has been read, and it is therefore permissible to increment the fan counter if a fan speed is out of specification.
      <br/>
      A read command is then sent to the next fan to be read (step 68).
      <br/>
      Note that the next fan speed will be available in one second.
    </p>
    <p num="27">
      The fan speed of the first fan is then obtained (step 70) and checked to determine if it is out of the specified range (step 72).
      <br/>
      If so (i.e. the answer to the question in step 72 is "yes"), the fan counter associated with the fan is obtained (step 74).
      <br/>
      The fan counter is logically ANDed with one and the result is added to the fan counter (step 76).
      <br/>
      One possible method for implementing step 76 is the C statement discussed above.
      <br/>
      Of course, those skilled in the art will realize that many different programming statements from a variety of programming languages may be used.
      <br/>
      As discussed above, step 76 ensures that a fan counter is only incremented when its least significant bit is equal to one.
      <br/>
      After a fan counter has been incremented, its least significant bit will then be zero, and therefore, it will not be possible to increment the counter again until the least significant bit of the counter is set to one again in step 66.
    </p>
    <p num="28">
      Every time a fan speed is out of specification, its associated fan counter actually gets incremented by two.
      <br/>
      This is because the fan counter is incremented by one in step 66 when its least significant bit is set to one, and then (if the fan speed is out of bounds), the fan counter is incremented by one in step 76.
      <br/>
      This means that each fan counter contains a value which is actually double the number of times that its associated fan counter has been out of specification.
      <br/>
      The actual value of the fan counter (i.e. the number of times the fan speed has actually been out of specification) is half the value of the fan counter.
      <br/>
      Therefore, in step 78, the fan counter is compared to double the maximum count.
      <br/>
      If the fan counter is greater than the maximum count times two (i.e. the answer to the question in step 78 is "yes") the fan is noted as having an individual fan fault (step 80).
      <br/>
      Those skilled in the art will realize that the fan counter could be divided by two in step 78 and then compared to the maximum count.
    </p>
    <p num="29">
      Next, it is determined if there are more fans to check (step 82).
      <br/>
      If so, the next fan speed is obtained (step 84) and the process returns to step 72.
      <br/>
      If all fans, 0 through 7, have been checked (i.e. the answer to the question in step 82 is "no"), the other sensors (read in step 60) are processed for faults (step 86).
      <br/>
      Finally, all faults are sent to the system (step 88) and the process begins again at step 60.
    </p>
    <p num="30">
      The method described in FIG. 4 allows the fan speeds to be checked during every loop of the process.
      <br/>
      However, a particular fan counter will only be incremented if the fan associated with the fan counter has just been read.
      <br/>
      By using the method described in FIG. 4, it is possible to determine when a fan has been read, and thus when it is permissible to increment the fan counter, without implementing a separate permission variable for each fan.
      <br/>
      Thus, scarce RAM space is conserved.
    </p>
    <p num="31">
      Although the invention has been described with a certain degree of particularity, it should be recognized that elements thereof may be altered by persons skilled in the art without departing from the spirit and scope of the invention.
      <br/>
      One of the implementations of the invention is as sets of instructions resident in the random access memory of one or more computer systems configured generally as described in FIGS. 1 and 2.
      <br/>
      Until required by the computer system, the set of instructions may be stored in another computer readable memory, for example in a hard disk drive, or in a removable memory such as an optical disk for eventual use in a CD-ROM drive or a floppy disk for eventual use in a floppy disk drive.
      <br/>
      Further, the set of instructions can be stored in the memory of another computer and transmitted over a local area network or a wide area network, such as the Internet, when desired by the user.
      <br/>
      One skilled in the art will appreciate that the physical storage of the sets of instructions physically changes the medium upon which it is stored electrically, magnetically, or chemically so that the medium carries computer readable information.
      <br/>
      The invention is limited only by the following claims and their equivalents.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for incrementing a variable in an information handling system, comprising the steps of:</claim-text>
      <claim-text>setting a least significant bit of the variable to a permission indicator value; logically ANDing the least significant bit of the variable with one to obtain a first result;</claim-text>
      <claim-text>and adding the first result to the variable; whereby the variable is incremented if the permission indicator value is one.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. A method according to claim 1, wherein said setting step comprises the steps of: determining if it is permissible to increment the variable;</claim-text>
      <claim-text>and in response to said determining, setting the least significant bit equal to one to indicate that it is permissible to increment the variable.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. A method according to claim 2, further comprising the step of initializing the least significant bit to zero.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A method according to claim 1, further comprising the step of determining an actual value of the variable, wherein said determining includes the step of dividing the variable by two.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. An information handling system, comprising: a processor; a memory means; a program executing in said processor; one or more variables, used by said program, and stored in said memory means; means for setting a least significant bit of a selected variable to a permission indicator value; means for logically ANDing the least significant bit of the selected variable with one to obtain a first result;</claim-text>
      <claim-text>and means for adding the first result to the selected variable; whereby the selected variable is incremented if the permission indicator value is one.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. An information handling system according to claim 5, wherein said means for setting comprises: means for determining if it is permissible to increment the selected variable;</claim-text>
      <claim-text>and means for setting the least significant bit equal to one to indicate that it is permissible to increment the selected variable.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. An information handling system according to claim 6, further comprising means for initializing the least significant bit to zero.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. An information handling system according to claim 5, further comprising means for determining an actual value of the selected variable, wherein said means for determining includes means for dividing the selected variable by two.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. A computer readable medium for controlling incrementing of a variable in an information handling system, comprising: means for setting a least significant bit of the variable to a permission indicator value; means for logically ANDing the least significant bit of the variable with one to obtain a first result;</claim-text>
      <claim-text>and means for adding the first result to the variable; whereby the variable is incremented if the permission indicator value is one.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A computer readable medium according to claim 9, wherein said means for setting comprises: means for determining if it is permissible to increment the variable;</claim-text>
      <claim-text>and means for setting the least significant bit equal to one to indicate that it is permissible to increment the variable.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A computer readable medium according to claim 10, further comprising means for initializing the least significant bit to zero.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A computer readable medium according to claim 9, further comprising means for determining an actual value of the variable, wherein said means for determining includes means for dividing the variable by two.</claim-text>
    </claim>
  </claims>
</questel-patent-document>