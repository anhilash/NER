<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182210B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182210</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182210</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="25538268" extended-family-id="1249005">
      <document-id>
        <country>US</country>
        <doc-number>08992375</doc-number>
        <kind>A</kind>
        <date>19971216</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08992375</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>1295720</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>99237597</doc-number>
        <kind>A</kind>
        <date>19971216</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08992375</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <term-of-grant>
      <disclaimer/>
    </term-of-grant>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/38        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>38</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/46        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>46</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>712235000</text>
        <class>712</class>
        <subclass>235000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>712216000</text>
        <class>712</class>
        <subclass>216000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>712242000</text>
        <class>712</class>
        <subclass>242000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>712E09048</text>
        <class>712</class>
        <subclass>E09048</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>712E09050</text>
        <class>712</class>
        <subclass>E09050</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>712E09053</text>
        <class>712</class>
        <subclass>E09053</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>712E09061</text>
        <class>712</class>
        <subclass>E09061</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/38D4</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38D4</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-009/38E1</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38E1</subgroup>
      </classification-ecla>
      <classification-ecla sequence="3">
        <text>G06F-009/38E2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38E2</subgroup>
      </classification-ecla>
      <classification-ecla sequence="4">
        <text>G06F-009/38E4</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38E4</subgroup>
      </classification-ecla>
      <classification-ecla sequence="5">
        <text>G06F-009/38H2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38H2</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3842</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3842</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3013</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3013</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20160304</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3834</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3834</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3838</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3838</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3851</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3851</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="6">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3857</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3857</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140317</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="7">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3863</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3863</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>29</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>25</number-of-drawing-sheets>
      <number-of-figures>38</number-of-figures>
      <image-key data-format="questel">US6182210</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Processor having multiple program counters and trace buffers outside an execution pipeline</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>EICKEMEYER RICHARD JAMES</text>
          <document-id>
            <country>US</country>
            <doc-number>5313634</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5313634</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>DUBEY PRADEEP KUMAR, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5724565</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5724565</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>ITO MOTOHISA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5742782</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5742782</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>DUBEY PRADEEP KUMAR, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5812811</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5812811</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>ARORA JUDGE K, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5832260</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5832260</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>MALLICK SOUMMYA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5961639</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5961639</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>FITE DAVID B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5142634</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5142634</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>ELKIND BOB, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5153848</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5153848</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>OVERHOUSE LEONARD E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5309561</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5309561</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>MCKEEN FRANCIS X, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5420990</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5420990</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>SAINI AVTAR K</text>
          <document-id>
            <country>US</country>
            <doc-number>5421021</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5421021</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>CHESSON GREG, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5524250</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5524250</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="13">
          <text>COLWELL ROBERT P, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5524262</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5524262</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="14">
          <text>KIMURA KOZO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5546593</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5546593</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="15">
          <text>PAPWORTH DAVID B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5586278</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5586278</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="16">
          <text>ABRAMSON JEFFREY M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5588126</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5588126</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="17">
          <text>ABRAMSON JEFFREY M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5606670</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5606670</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="18">
          <text>ABRAMSON JEFFREY M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5664137</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5664137</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="19">
          <text>MOHAMED AHMED HASSAN</text>
          <document-id>
            <country>US</country>
            <doc-number>5754818</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5754818</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="20">
          <text>SITES RICHARD L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5802272</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5802272</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="21">
          <text>GUPTA RAJIV, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5881280</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5881280</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="22">
          <text>MALLICK SOUMMYA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5887166</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5887166</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="23">
          <text>PARADY BODO</text>
          <document-id>
            <country>US</country>
            <doc-number>5933627</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5933627</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>J. Smith et al., "The Microarchitecture of Superscaler Processors," Proceedings of IEEE, vol. 83, No. 12, Dec. 1995, pp. 1609-1624.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>D. Tullsen et al., "Simultaneous Multithreading: Maximizing On-Chip Parallelism," The 22nd International Symposium on Computer Architecture, Jun. 1995, pp. 392-403.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>G. Sohi et al., "Multiscaler Processors." The 22nd Annual International Symposium on Computer Architecture, Jun. 1995, pp. 414-425.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>E. Rotenberg et al., "Trace Processors," The 30th International Symposium on Microarchitecture, Dec. 1997, pp. 138-148.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>M. Franklin et al., "ARB: A Hardware Mechanism for Dynamic Reordering of Memory References. IEEE Transactions on Computers", vol. 45, No. 5, May 1996, pp. 552-571.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="6">
          <text>J. Tsai et al., "The Superthreaded Architecture: Thread Pipelining with Run-Time Data Dependence Checking and Control Speculation," Proceedings of the 1996 Conference on Parallel Architectures and Compilation Techniques, Oct. 1996, pp. 35-46.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="7">
          <text>P. Song, "Multithreading Comes of Age," Microprocessor Report, Jul. 14, 1997, pp. 13-18.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="8">
          <text>Patent Application Ser. No. 08/746,547, field Nov. 13, 1996, pending "Processor Having Replay Architecture," Inventor David Sager.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="9">
          <text>M. Franklin, "The Multiscalar Architecture," Ph.D. Dissertation, Univ. of Wisconsin, 1993, pp. i, ii, v-ix, 109-134.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="10">
          <text>Q. Jacobson et al. "Path-Based Next Trace Prediction," Proceedings of the 30th International Symposium on Microarchitecture, Dec. 1997, pp. 14-23.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="11">
          <text>Q. Jacobson et al. "Control Flow Speculation in Multiscalar Processors," Proceedings of the 3rd International Symposium on High-Performance Computer Architecture, Feb. 1997, pp. 218-229.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="12">
          <text>R. Nair, "Dynamic path-based branch correlation," Proceedings of the 28th International Symposium on Microarchitecture, Dec. 1995, pp. 15-23.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="13">
          <text>S. Palacharla et al., "Complexity-Effective Superscalar Processors," The 24th Annual International Symposium on Computer Architecture, pp. 206-218, Jun. 1997.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="14">
          <text>M. Lipasti et al., "Value Locality and Load Value Prediction," Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems, Oct. 1996, ASPLOS-VII, pp. 138-147.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="15">
          <text>M. Franklin, "The Multiscalar Architecture," Ph.D Dissertation, Univ. of Wisconsin, 1993, pp. i, ii, v-ix, 50-73, 75-81, 86-107 and 153-161.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Intel Corporation</orgname>
            <address>
              <address-1>Santa Clara, CA, US</address-1>
              <city>Santa Clara</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>INTEL</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Akkary, Haitham</name>
            <address>
              <address-1>Portland, OR, US</address-1>
              <city>Portland</city>
              <state>OR</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Chow, Kingsum</name>
            <address>
              <address-1>Hillsboro, OR, US</address-1>
              <city>Hillsboro</city>
              <state>OR</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Aldous, Alan K.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>An, Meng-Ai T.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      In one embodiment of the invention, a processor includes an execution pipeline to concurrently execute at least portions of threads, wherein at least one of the threads is dependent on at least another one of the threads.
      <br/>
      The processor also includes detection circuitry to detect speculation errors in the execution of the threads.
      <br/>
      In another embodiment, the processor includes thread management logic to control dynamic creation of threads from a program.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>RELATED APPLICATIONS</heading>
    <p num="1">
      The present application and Appl.
      <br/>
      Ser. No. 08/991,269 entitled "Out-of-Pipeline Trace Buffer for Instruction Replay Following Misspeculation" and Appl.
      <br/>
      Ser. No. 08/991,734 entitled "Memory System for Ordering Load and Store Instructions in a Processor That Performs Out-Of-Order Multithread Execution", filed concurrently herewith, have essentially common specifications.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Technical Field of the Invention
    </p>
    <p num="3">The present invention relates to processors and, more particularly, to processors that process dependent threads concurrently.</p>
    <p num="4">2. Background Art</p>
    <p num="5">
      Current superscaler processors, such as a microprocessor, perform techniques such as branch prediction and out-of-order execution to enhance performance.
      <br/>
      Processors having out-of-order execution pipelines execute certain instructions in a different order than the order in which the instructions were fetched and decoded.
      <br/>
      Instructions may be executed out of order with respect to instructions for which there are not dependencies.
      <br/>
      Out-of-order execution increases processor performance by preventing execution units from being idle merely because of program instruction order.
      <br/>
      Instruction results are reordered after execution.
    </p>
    <p num="6">
      The task of handling data dependencies is simplified by restricting instruction decode to being in-order.
      <br/>
      The processors may then identify how data flows from one instruction to subsequent instructions through registers.
      <br/>
      To ensure program correctness, registers are renamed and instructions wait in reservation stations until their input operands are generated, at which time they are issued to the appropriate functional units for execution.
      <br/>
      The register renamer, reservation stations, and related mechanisms link instructions having dependencies together so that a dependent instruction is not executed before the instruction on which it depends.
      <br/>
      Accordingly, such processors are limited by in-order fetch and decode.
    </p>
    <p num="7">
      When the instruction from the instruction cache misses or a branch is mispredicted, the processors have either to wait until the instruction block is fetched from the higher level cache or memory, or until the mispredicted branch is resolved, and the execution of the false path is reset.
      <br/>
      The result of such behavior is that independent instructions before and after instruction cache misses and mispredicted branches cannot be executed in parallel, although it may be correct to do so.
    </p>
    <p num="8">
      Multithreading processors such as shared resource multithreading processors and on-chip multiprocessor (MP) processors have the capability to process and execute multiple threads concurrently.
      <br/>
      The threads that these processors process and execute are independent of each other.
      <br/>
      For example, the threads are either from completely independent programs or are from the same program but arc specially compiled to create threads without dependencies between threads.
      <br/>
      However, these processors do not have the ability to concurrently execute different threads from the same program that may have dependencies.
      <br/>
      The usefulness of the multithreading processors is thereby limited.
    </p>
    <p num="9">Accordingly, there is a need for multithreading processors that have the ability to concurrently execute different threads from the same program where there may be dependencies among the threads.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="10">
      In one embodiment of the invention, a processor includes an execution pipeline to concurrently execute at least portions of threads, wherein at least one of the threads is dependent on at least another one of the threads.
      <br/>
      The processor also includes detection circuitry to detect speculation errors in the execution of the threads.
    </p>
    <p num="11">In another embodiment, the processor includes thread management logic to control dynamic creation of threads from a program.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="12">
      The invention will be understood more fully from the detailed description given below and from the accompanying drawings of embodiments of the invention which, however, should not be taken to limit the invention to the specific embodiments described, but are for explanation and understanding only.
      <br/>
      FIG. 1 is a high level block diagram representation of certain components in one embodiment of a processor.
      <br/>
      FIG. 2 is a block diagram of a processor according to one embodiment of the invention.
      <br/>
      FIG. 3 is a block diagram of a processor according to another embodiment of the invention.
      <br/>
      FIG. 4 is a flow diagram of an example of two threads.
      <br/>
      FIG. 5 is a flow diagram of another example of two threads.
      <br/>
      FIG. 6 is a flow diagram of an example of four threads.
      <br/>
      FIG. 7 is a graph showing overlapping execution of the threads of FIG. 6.
      <br/>
      FIG. 8 is a block diagram illustrating individual trace buffers according to one embodiment of the invention.
      <br/>
      FIG. 9 illustrates an array indicating program and retirement orders at two times.
      <br/>
      FIG. 10 is a block diagram representation of certain components in one embodiment of a trace buffer of FIG. 8.
      <br/>
      FIG. 11 is a block diagram representation of certain components in another embodiment of a trace buffer of FIG. 8.
      <br/>
      FIG. 12 is a graphical representation of portions of one embodiment of an instruction queue array of the trace buffer of FIG. 10.
      <br/>
      FIG. 13 is a graphical representation of portions of one embodiment of a data and dependency array of the trace buffer of FIG. 10.
      <br/>
      FIG. 14 illustrates one embodiment of modifier registers and a modified register used in creating the dependency field of the array of FIG. 10.
      <br/>
      FIG. 15 is a logical OR gate used in creating the dependency field of the array of FIG. 13.
      <br/>
      FIG. 16 is a flow chart illustrating one embodiment of operations used to create the dependency field of the array of FIG. 13.
      <br/>
      FIG. 17 is a graphical representation of a particular register and locations in a trace buffer that has dependencies thereon according to one embodiment of the invention.
      <br/>
      FIG. 18 is a graphical representation of portions of one embodiment of an output register file of the trace buffer of FIG. 10.
      <br/>
      FIG. 19 is a graphical representation of portions of one embodiment of an input register file of the trace buffer of FIG. 10.
      <br/>
      FIG. 20 is a block diagram of a comparator and replay triggering logic used in connection with the output register file of FIG. 18 and the input register file of FIG. 19 according to one embodiment of the invention.
      <br/>
      FIG. 21 is a flow diagram illustrating points at which the contents of the output register file may be utilized.
      <br/>
      FIG. 22 is a block diagram illustrating individual memory order buffers (MOBs) within the MOB of FIG. 2 according to one embodiment of the invention.
      <br/>
      FIG. 23 is a graphical representation of portions of one embodiment of a store buffer of one of the MOBs of FIG. 22.
      <br/>
      FIG. 24 is a graphical representation of portions of one embodiment of a load buffer of one of the MOBs of FIG. 22.
      <br/>
      FIG. 25 illustrates a comparator comparing addresses of load and store instructions.
      <br/>
      FIG. 26 illustrates a comparator comparing addresses of store and load instructions.
      <br/>
      FIG. 27 is a block diagram representation of MOB control circuitry and store buffers according to one embodiment of the invention.
      <br/>
      FIG. 28 is a block diagram representation of MOB control circuitry and load buffers according to one embodiment of the invention.
      <br/>
      FIG. 29 is a flow diagram of an example of six threads.
      <br/>
      FIG. 30 is a tree illustrating a relationship in the threads of FIG. 29 at a time t1.
      <br/>
      FIG. 31 is a tree illustrating a relationship in the threads of FIG. 29 at a time t2 assuming thread T4 is reset before thread T1 retires.
      <br/>
      FIG. 32 is a tree illustrating a relationship in the threads of FIG. 29 at a time t2 assuming thread T1 retires before thread T4 is reset.
      <br/>
      FIG. 33 is a tree illustrating a relationship in the threads of FIG. 29 at a time t3.
      <br/>
      FIG. 34 is a flow diagram illustrating an example with five threads.
      <br/>
      FIG. 35 is a tree illustrating a relationship in the threads of FIG. 34 at a time t1.
      <br/>
      FIG. 36 is a tree illustrating a relationship in the threads of FIG. 34 at a time t2.
      <br/>
      FIG. 37 is a block diagram presentation of a processor according to an alternative embodiment to that of FIG. 2.
      <br/>
      FIG. 38 is a computer system including the processor of FIG. 2.
    </p>
    <heading>DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
    <p num="13">
      A.
      <br/>
      Creation of Threads and Overview of Pipeline 108
      <br/>
      B.
      <br/>
      Details Regarding Trace Buffers 114
    </p>
    <p num="14">
      - 1.
      <br/>
      Trace Buffer 114A
    </p>
    <p num="15">
      -  a. Instruction Queue Array 202A
      <br/>
      -  b. DAD Array 206A and Dependency Generation Circuitry 212A
      <br/>
      -  c. Output Register File 210A and Input Register File 208A
      <br/>
      - 2.
      <br/>
      Trace Buffer 114'
      <br/>
      C.
      <br/>
      A Replay Sequence Algorithm
      <br/>
      D.
      <br/>
      Second Level or Final Retirement
      <br/>
      E.
      <br/>
      Memory System
      <br/>
      - 1.
      <br/>
      Store Buffers and Load Buffers
      <br/>
      - 2.
      <br/>
      Comparisons of Load and Store Addresses
      <br/>
      -  a. Execution of Load Instructions
      <br/>
      -  b. Execution of Store Instructions
      <br/>
      -  c. Reset
      <br/>
      - 3.
      <br/>
      Replay of Store Instructions
      <br/>
      - 4.
      <br/>
      Replays of Multiple Load Instructions
      <br/>
      - 5.
      <br/>
      Final Retirement of Load and Store Instructions
      <br/>
      F.
      <br/>
      Additional Information Regarding Thread Management Logic and Final Retirement Logic
      <br/>
      G.
      <br/>
      An Embodiment Without Multithreading
      <br/>
      H.
      <br/>
      Additional Information and Embodiments
    </p>
    <p num="16">
      FIG. 1 illustrates certain components of a processor 10.
      <br/>
      Processor 10 includes an execution pipeline 12 and a trace buffer 14, which is outside execution pipeline 12.
      <br/>
      Execution pipeline 12 may include a memory order buffer.
      <br/>
      Instructions on conductors 18 are provided to execution pipeline 12 for execution.
      <br/>
      The instructions are also provided through conductors 22 to trace buffer 14.
      <br/>
      The instructions may be executed speculatively in execution pipeline 12.
      <br/>
      Examples of the speculation include data speculation and dependency speculation.
      <br/>
      Any of a wide variety of speculations may be involved.
      <br/>
      Processor 10 includes mechanisms, including in trace buffer 14, to detect speculation errors (misspeculations) and to recover from them.
    </p>
    <p num="17">
      When a misspeculation is detected, the misspeculated instruction is provided to execution pipeline 12 from trace buffer 14 through conductors 24 and is replayed in execution pipeline 12.
      <br/>
      If an instruction is "replayed," the instruction and all instructions dependent on the instruction are re-executed, although not necessarily simultaneously.
      <br/>
      If an instruction is "replayed in full," the instruction and all instructions following the instruction in program order are re-executed.
      <br/>
      The program order is the order the instructions would be executed in an in order processor.
      <br/>
      Instructions may pass through conductors 18 entirely in program order or in something other than program order.
      <br/>
      Processor 10 may be an in order or out-of-order processor.
      <br/>
      The re-execution of a dependent instruction may result in instructions which arc dependent on the dependent instruction being replayed.
      <br/>
      The number of re-executions of instructions can be controlled by controlling the events which trigger replays.
      <br/>
      In general, the term execute may include original execution and re-execution.
      <br/>
      Results of at least part of the instructions are provided to trace buffer through conductors 26.
      <br/>
      Final retirement logic 34 finally retires instructions in trace buffer 14 after it is assured that the instructions were correctly executed either originally or in re-execution.
    </p>
    <p num="18">
      Execution pipeline 12 may be any of a wide variety execution pipelines and may be a section of a larger pipeline.
      <br/>
      Execution pipeline 12 may be used in connection with a wide variety of processors.
      <br/>
      Examples are provided in FIG. 2 which illustrates components of a processor 50 having an execution pipeline 108, and in FIG. 3 which illustrates a processor 100 having an execution pipeline 308.
      <br/>
      In the embodiment of the invention in FIG. 2, execution pipeline 108 includes register renaming.
      <br/>
      In other embodiments, the execution pipeline does not include register renaming.
      <br/>
      The processor may concurrently process multiple threads (as in the case of processor 50 in FIG. 2), or not concurrently process multiple threads (as in the case of processor 100 in FIG. 3).
      <br/>
      Processor 50 will be discussed first.
    </p>
    <p num="19">
      Reference in the specification to "one embodiment" or "an embodiment" means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention.
      <br/>
      The appearances of the phrase "in one embodiment" in various places in the specification are not necessarily all referring to the same embodiment.
    </p>
    <p num="20">A. Creation of Threads and Overview of Pipeline 108</p>
    <p num="21">
      Instructions are provided through conductors 102 to an instruction cache (I-cache) 104.
      <br/>
      A decoder 106 is illustrated as receiving instructions from I-cache 104, but alternatively could decode instructions before they reach I-cache 104.
      <br/>
      Depending on the context and implementation chosen, the term "instructions" may include macro-operations (macro-op), micro-operations (uops), or some other form of instructions.
      <br/>
      Any of a variety of instruction sets may be used including, but not limited to, reduced instruction set computing (RISC) or complex instruction set computing (CISC) instructions.
      <br/>
      Further, decoder 106 may decode CISC instructions to RISC instructions.
      <br/>
      Instructions from I-cache 104 are provided to pipeline 108 through MUX 110 and to trace buffers 114 through conductors 118.
    </p>
    <p num="22">
      A trace is a set of instructions.
      <br/>
      A thread includes the trace and related signals such as register values and program counter values.
    </p>
    <p num="23">
      Thread management logic 124 creates different threads from a program or process in I-cache 104 by providing starting counts to program counters 112A, 112B, . . . , 112X, through conductors 130 (where X represents the number of program counters).
      <br/>
      As an example, X may be 4 or more or less.
      <br/>
      Thread management logic 124 also ends threads by stopping the associated program counter.
      <br/>
      Thread management logic 124 may cause the program counter to then begin another thread.
      <br/>
      Portions of different threads are concurrently read from I-cache 104.
    </p>
    <p num="24">
      To determine where in a program or process to create a thread, thread management logic 124 may read instructions from decoder 106 through conductors 128.
      <br/>
      The threads may include instructions inserted by a programmer or compiler that expressly demarcate the beginning and ending of threads.
      <br/>
      Alternatively, thread management logic 124 may analyze instructions of the program or process to break up a program or process supplied to I-cache 104 into different threads.
      <br/>
      For example, branches, loops, backward branches, returns, jumps, procedure calls, and function calls may be good points to separate threads.
      <br/>
      Thread management logic 124 may consider the length of a potential thread, how many variables are involved, the number of variables that are common between successive threads, and other factors in considering where to start a thread.
      <br/>
      Thread management logic 124 may consider the program order in determining the boundaries of threads.
      <br/>
      The program order is the order the threads and the instructions within the threads would be executed on an in order processor.
      <br/>
      The instructions within the threads may be executed out of order (contrary to program order).
      <br/>
      The threads may be treated essentially independently by pipeline 108.
      <br/>
      Thread management logic 124 may include a prediction mechanism including a history table to avoid making less than optimal choices.
      <br/>
      For example, thread management logic 124 may create a thread and then later determine that the thread was not actually part of the program order.
      <br/>
      In that case, if the same code is encountered again, the prediction mechanism could be used to determine whether to create that same thread again.
    </p>
    <p num="25">
      Dynamically creating threads is creating threads from a program that was not especially written or compiled for multithreading, wherein at least one of the threads is dependent on another of the threads.
      <br/>
      The program may originate from off a chip that includes execution pipeline 108 and thread management logic 124.
      <br/>
      Dynamically creating the threads, executing the threads, and detecting and correcting speculation errors in the execution is referred to as dynamic multithreading.
    </p>
    <p num="26">
      FIG. 4 illustrates a thread T1 that includes a conditional backward branch instruction.
      <br/>
      In program order, thread T2 is executed following the conditional branch instruction.
      <br/>
      In time order, thread T2 is executed speculatively beginning at the time thread T1 first reaches the conditional branch instruction.
      <br/>
      Therefore, portions of thread T1 and T2 are executed concurrently.
      <br/>
      If thread T2 involves misspeculations, the effected instructions of thread T2 are replayed.
    </p>
    <p num="27">
      Thread management logic 124 may monitor the count of the program counters through conductors 130.
      <br/>
      A purpose of monitoring the count is to determine when a thread should end.
      <br/>
      For example, when the condition of the conditional branch is not met, if the program counter of thread T1 were allowed to continue, it would advance to the first instruction of thread T2.
      <br/>
      Therefore, thread management logic 124 stops the program counter of thread T1 when the condition is not met.
    </p>
    <p num="28">
      FIG. 5 illustrates a thread T1 that includes a function call instruction.
      <br/>
      In program order, when the call instruction is reached, the program counter jumps to the location of the function and executes until a return instruction, at which time the program counter returns to the instruction after the call.
      <br/>
      In program order, thread T2 begins at the instruction following the return.
      <br/>
      In time order, thread T2 is executed speculatively beginning at the time thread T1 first reaches the call.
      <br/>
      If thread T2 involves misspeculations, the effected instructions of thread T2 are replayed.
      <br/>
      Thread T1 ends when its program counter reaches the first instruction of thread T2.
      <br/>
      The Load MX and Store MX instructions in FIG. 5 will be discussed below.
    </p>
    <p num="29">
      FIG. 6 illustrates threads T1, T2, T3, and T4 which are part of a section of a program.
      <br/>
      Different program counters produce threads T1, T2, T3, and T4.
      <br/>
      Thread T1 includes instructions to point A (function call instruction) and then from point B, to point C (conditional backward branch instruction), to point D and to point C again (the loop may be repeated several times).
      <br/>
      Tread T2 begins at the instruction that in program order is immediately after the return instruction of the function that is called at point A. Thread T3 begins at the instruction that in program order is immediately after the conditional backward branch of point C and continues to point E, to point F, to point G, to point H, and to point I, which is a return instruction to the instruction immediately following point A where thread T2 begins.
      <br/>
      Thread T4 begins at the instruction that in program order is immediately after the conditional backward branch at point E.
    </p>
    <p num="30">
      As illustrated in FIG. 7, portions of threads T1, T2, T3, and T4 are fetched, decoded, and executed concurrently.
      <br/>
      The threads are fetched, decoded, and executed out of order because the program order is not followed.
      <br/>
      In time order, execution of threads T2, T3, and T4 begins immediately following instructions at points A, C, and E, respectively.
      <br/>
      The vertical dashed lines show a parent child relationship.
      <br/>
      Threads T2, T3, and T4 are executed speculatively by relying on data in registers and/or memory locations before it is certain that the data is correct.
      <br/>
      Processor 100 has mechanisms to detect misspeculation and cause misspeculated instructions to be replayed.
      <br/>
      It turns out that thread T4 is not part of the program order.
      <br/>
      Thread T4 may be executed until thread management logic 124 determines that thread T4 is not part of the program order.
      <br/>
      At that time, thread T4 may be reset and the resources that held or process thread T4 in processor 100 may be deallocated and then allocated for another thread.
      <br/>
      In program order, threads T1, T2, and T3 would be executed as follows: first thread T1, then thread T3, and then thread T2.
    </p>
    <p num="31">
      Referring to FIG. 2, instructions from MUX 110 are received by rename/allocate unit 150 which provides a physical register identification (PRID) of the renamed physical register in register file 152.
      <br/>
      The PRID is provided to trace buffer 114 through bypass conductors 126.
      <br/>
      Allocation involves assigning registers to the instructions and assigning entries of the reservation stations of schedule/issue unit 156.
      <br/>
      Once the operands are ready for a particular instruction in the reservation stations, the instruction is issued to one of the execution units (e.g., integer, floating point) of execution units 158 or a memory execution pipeline which includes address generation unit (AGU) 172, memory order buffer (MOB) 178, and data cache 176.
      <br/>
      Depending on the instructions, operands may be provided from register file 152 through conductors 168.
      <br/>
      Under one embodiment of the invention, dependent instructions within a thread may be so linked that they are not executed out-of-order.
      <br/>
      However, dependent instructions from different threads may be concurrently fetched, decoded, and executed out-of-order.
      <br/>
      The execution of certain of the threads may be speculative.
    </p>
    <p num="32">
      For high performance, reservation stations and related mechanisms arc designed to have both low latency and high bandwidth issue of instructions.
      <br/>
      The latency and bandwidth requirements place restrictions on the number of instructions that can be waiting in the reservation stations.
      <br/>
      By positioning trace buffers 114 outside pipeline 108, a large number of instructions can be available for execution/replay without significantly decreasing throughput of pipeline 108.
      <br/>
      The effect of latency between execution pipeline 108 and trace buffers 114 can be reduced through pipelining.
    </p>
    <p num="33">
      The result of an execution and related information are written from writeback unit 162 through conductors 122 (in the case of registers) and through MUX 192 and conductors 196 to trace buffers 114.
      <br/>
      The results and related information may also be written to register file 152 and associated re-order buffer (ROB) 164. Once the result and information of an instruction are written to register file 152 and ROB 164, the instruction is retired in order as far as pipeline 108 is concerned.
      <br/>
      This retirement is called a first level or initial retirement.
      <br/>
      At or before the first level retirement, resources for the retired instruction in schedule/issue unit 156 including the reservation stations, register file 152, and ROB 164 are deallocated.
      <br/>
      However, all needed details regarding the instruction are maintained in trace buffers 114 and MOB 178 until a final retirement, described below.
    </p>
    <p num="34">
      A dependency exists between a later thread and an earlier thread when in program order, data used in the later thread is produced in the earlier thread.
      <br/>
      The data may have been produced in the earlier thread through a memory or non-memory instruction.
      <br/>
      For example, the later thread may be dependent on the earlier thread if a load instruction in the later thread has the same address as a store instruction in the earlier thread.
      <br/>
      The later thread may also be dependent on the earlier thread if an instruction in the later thread involves a register that was modified in the earlier thread.
      <br/>
      Likewise, a later instruction is dependent on an earlier instruction when in program order the later instruction uses data produced by the earlier instruction.
      <br/>
      The word "dependency" is also used in the phrase "dependency speculation." An example of a dependency speculation is speculating that there is no dependency between a load instruction and an earlier store instruction.
      <br/>
      Address matching is an example of a technique for checking for dependency speculation errors.
      <br/>
      An example of data speculation is speculating that the data in a register is the correct data.
      <br/>
      Register matching is an example of a technique for checking for data speculation errors.
    </p>
    <p num="35">B. Details Regarding Trace Buffers 114</p>
    <p num="36">
      Referring to FIG. 8, trace buffers 114 include trace buffers 114A, 114B, 114C, . . . , 114Y, where Y presents the number of trace buffers.
      <br/>
      For example, if Y=4 (i.e., Y=D), there are 4 trace buffers.
      <br/>
      If Y is less than 3, trace buffers 114 does not include all the trace buffers shown in FIG. 8.
      <br/>
      Y may be the same as or different than X (the number of program counters).
      <br/>
      Trace buffers 114 may be a single memory divided into individual trace buffers, or physically separate trace buffers, or some combination of the two.
    </p>
    <p num="37">
      Referring to FIG. 9, in one embodiment, thread management logic 124 includes an array 198 that specifies the program order (which is also the retirement order) of thread IDs.
      <br/>
      In the example, each trace buffer has a unique thread ID or a one-to-one mapping to a thread ID.
      <br/>
      For example, trace buffer 114A is assigned thread ID 1, trace buffer 114B is assigned thread ID 2, etc.
      <br/>
      The thread IDs may be hardwired or programmed.
      <br/>
      In one embodiment, each program counter is associated with a particular thread ID and trace buffer. (Alternatively, there is not such a restricted relationship.)
    </p>
    <p num="38">
      FIG. 9 shows an example of the retirement order of threads at time t1 and time t2.
      <br/>
      In the example, there are only four trace buffers and four thread IDs.
      <br/>
      The associated thread numbers are shown in parenthesis.
      <br/>
      Depending on the implementation, the thread number in parenthesis is not actually included in array 198.
      <br/>
      At time t1, the program and retirement order is thread T1, T3, T2, and T4, as in the example of FIG. 6.
      <br/>
      Between time t1 and time t2, it is determined that thread T4 is not in the program order.
      <br/>
      Therefore, thread T4 is reset, making room for thread T5 (not shown in FIG. 5) in trace buffer 114D.
      <br/>
      Thread T5 is associated with thread ID 4.
      <br/>
      Thread T1 retires, making room for thread T6 in trace buffer 114A.
      <br/>
      Thread T6 is associated with thread ID 1.
      <br/>
      At time t2, the program and retirement order is thread T3, T2, T5, and T6. (If thread T1 retired before thread T4 was reset, then threads T5 and T6 would have had different thread IDs, but program and retirement order would not be changed).
      <br/>
      Depending on the algorithm used, it may have been that thread T2 was initially before thread T3 in array 198, but the program and retirement order would be corrected, as array 198 at time t1.
    </p>
    <p num="39">
      As mentioned, the program order of threads is the order the threads would be executed on an in order processor.
      <br/>
      The program order of instructions is the order the instructions would be executed on an in order processor.
      <br/>
      Thread management logic 124 does not necessarily initially determine the true program order for the threads.
      <br/>
      However, thread management logic 124 does eventually determines the true program order.
    </p>
    <p num="40">
      Referring to FIG. 8, trace buffers 114A, 114B, . . . , 114Y receive instructions through conductors 118A, 118B, . . . 118Y, which are connected to conductors 118.
      <br/>
      There may be demultiplexing circuitry between conductors 118A, 118B, . . . , 118Y and conductors 118.
      <br/>
      Alternatively, enable signals may control which trace buffer is activated.
      <br/>
      Still alternatively, there may be enough parallel conductors to handle parallel transactions.
      <br/>
      Trace buffers 114A, 114B , . . . , 114Y supply instructions and related information for replay to pipeline 108 through conductors 120A, 120B, . . . 120Y, which are connected to conductors 120.
      <br/>
      It is noted that multiple instructions from trace buffers 114 may concurrently pass through conductors 120 and MUX 110 for re-execution.
      <br/>
      At the same time, multiple instructions from decoder 106 may also pass through MUX 110 for the first time.
      <br/>
      A thread ID and instruction ID (instr ID) accompany each instruction through the pipeline.
      <br/>
      A replay count may also accompany the instruction.
      <br/>
      In the case of load and store instructions, a load buffer ID (LBID) and a store buffer ID (SBID) may also accompany the instruction.
      <br/>
      In one embodiment, the LBID and SBID accompany every instruction, although the LBID and SBID values may be meaningless in the case of instructions which arc not loads or stores.
      <br/>
      As described below, a PRID or value may also accompany an instruction being re-executed.
    </p>
    <p num="41">
      Trace buffers 114A, 114B, . . . , 114Y receive PRID, LBID, and SBID values from rename/allocate unit 150 through bypass conductors 126A, 126B, . . . 126Y, which are connected to conductors 126.
      <br/>
      Trace buffers 114A, 114B, . . . , 114Y receive writeback result information and related signals through conductors 122A, 122B, . . . , 122Y, which are connected to conductors 122, and through conductors 196A, 196B, . . . , 196Y, which are connected to conductors 196.
      <br/>
      Replay signals are provided through conductors 194A, 194B, . . . , 194Y, which are connected to conductors 194.
      <br/>
      Multiplexing and/or enable circuitry and/or a substantial number of parallel conductors may be used in conductors 120, 126, 122, 194, and 196.
      <br/>
      The trace buffers may be identical or somewhat different.
    </p>
    <p num="42">
      In FIG. 10, trace buffer 114A illustrates a first embodiment of a trace buffer.
      <br/>
      In FIG. 11, trace buffer 114A' illustrates a second embodiment of a trace buffer.
      <br/>
      Other embodiments of trace buffers could include variations of trace buffer 114A and 114A' or quite different architecture.
    </p>
    <p num="43">1. Trace Buffer 114A</p>
    <p num="44">
      Referring to FIG. 10, trace buffer 114A includes an instruction queue array 202A, a data and dependency (DAD) array 206A, an input register file 208A, an output register file 210A, dependency generation circuitry 212A, and control circuitry 224A.
      <br/>
      The term "array" is intended in a broad sense to include information in multiple directions, without restriction to particular form.
    </p>
    <p num="45">a. Instruction Queue Array 202A</p>
    <p num="46">
      With reference to FIG. 12, the following describes the structure of an instruction queue array 202A and its interaction with other components according to one embodiment of the invention.
      <br/>
      Instruction queue array 202A receives instructions fetched from I-cache 104 that are part of a particular thread.
      <br/>
      The instructions within a thread are fetched and written into instruction queue array 202A in order.
      <br/>
      Instructions that arc part of another thread are written into an instruction queue of a different trace buffer or into instruction queue array 202A at a different time.
      <br/>
      Instruction queue array 202A includes various fields of information for each instruction identifier (instr ID).
      <br/>
      Different embodiments could include somewhat different fields and a different numbers of rows.
      <br/>
      In the embodiment of instruction queue array 202A, the program counter value is not considered, but could be in other embodiments.
      <br/>
      Instruction queue array 202A and all other components illustrated in the drawings may include various fields, signals, and structure that is not illustrated.
      <br/>
      Such fields, signals, and structure are not illustrated because they vary depending on the implementation, are understood by those skilled in the art, and would greatly complicate this specification and tend to obscure the invention.
    </p>
    <p num="47">
      Instructions wait in trace buffer 114A until they are finally retired or discarded (because, for example, it is determined that the thread is not part of an in order execution of the program).
      <br/>
      If instruction queue array 202A fills up while there are still instructions in the trace that have not yet been executed, the instructions are not received by trace buffer 114 or rename/allocate unit 150 until an instruction is finally retired from instruction queue array 202A and a row is deallocated.
      <br/>
      Entries of the various arrays in system 100 may be allocated and deallocated by movement of head and tail pointers.
    </p>
    <p num="48">
      Instruction queue array 202A is described in connection with the following lines of code:
      <br/>
      I0:mul R1, R2 --&gt; R1
      <br/>
      I1:mul R3, R4 --&gt; R2
      <br/>
      I2:add R1, R2 --&gt; R1
      <br/>
      I3:add 10, R1 --&gt; R4
      <br/>
      I4:store R2 --&gt; Mx
      <br/>
      I5:store R1 --&gt; My,
    </p>
    <p num="49">
      which are the first six instructions within a thread.
      <br/>
      It will be apparent that a trace buffer other than trace buffer 114A is earlier in program order than is trace buffer 114A.
    </p>
    <p num="50">
      The "Op Code" field contains the operation code associated with the particular instruction. "Dest," "Source 1," and "Source 2" fields identify the destination, source 1, and source 2 of the instructions.
      <br/>
      The "Index for Source 1" field, identifies instruction entries within the trace buffer 114A that contain the source.
      <br/>
      For example, the destination of instr ID 0 is used for source 1 for instr ID 2.
      <br/>
      Therefore, a 0 is placed in the "Index for Source 1" field of instr ID 2.
      <br/>
      The destination of instr ID 2 is used for source 2 for instr ID 3.
      <br/>
      Therefore, a 2 is placed in the "Index for Source 2" field of instr ID 3.
      <br/>
      An X indicates a don't care.
    </p>
    <p num="51">
      The "Valid 1" and "Valid 2" field are bits that are set to a first value (e.g., a logic 0) when a corresponding source operand of an instr ID has been previously produced by an instruction from outside the thread in trace buffer 114A, and a second value (e.g., a logic 1) when the source operand for an instr ID has been previously produced by an instruction within the thread.
      <br/>
      Source 1 (R1) of instr ID 0 is produced outside the trace in instruction queue array 202A.
      <br/>
      Accordingly, valid 1 of instr ID 0 is a logic 0.
      <br/>
      Source 2 for instr ID 3 is from the destination of instr ID 2.
      <br/>
      Accordingly, valid 2 of instr ID 3 is a logic 1.
    </p>
    <p num="52">
      Instruction I3 involves adding R1 to a constant "10." The constant may be stored with the instruction, in a special register (not shown), in the source 1 field, or through some other mechanism.
      <br/>
      In FIG. 12, an X (don't care) is shown in the Source 1 field for instr ID 3.
      <br/>
      Alternatively, some indicator could be placed in the Source 1 field.
    </p>
    <p num="53">
      A store buffer ID (SBID) field holds an SBID associated with a store instruction in a store buffer, described below.
      <br/>
      A load buffer (LBID) field hold an LBID entry associated with a load instruction in a load buffer, described below.
      <br/>
      The SBID and LBID values are assigned by rename/allocate unit 150 and are written to the instruction queue array through bypass conductors 126.
      <br/>
      A thread ID number field could be included in instruction queue array 202A, but it is not needed because it is implicit.
    </p>
    <p num="54">b. DAD Array 206A and Dependency Generation Circuitry 212A</p>
    <p num="55">
      Referring to FIG. 13, one embodiment of DAD array 206A includes "instr ID" entries (rows) that correspond to the instr ID entries of Instruction Queue Array 202A in a one-to-one fashion.
      <br/>
      Indeed, instruction queue array 202A and DAD array 206A could be different portions of the same array.
      <br/>
      However, in some embodiments, there are different read ports associated with instruction queue array 202A and DAD array 206A.
    </p>
    <p num="56">
      DAD array 206A includes a "Value or PRID" field that contains either the value produced by an instruction or the PRID in register file 152.
      <br/>
      The value is written back from the execution units to trace buffer 114A through write back unit 162 and write back buses 122 and 196.
      <br/>
      A "Status" field, which may be two bits, indicates whether the "Value or PRID" field contains a "Value" or a "PRID." In one embodiment, it is possible that the "Value or PRID" does not hold either a valid "Value" or a valid "PRID." A "Replay Count" field, which uniquely identifies an instruction dispatch, is incremented each time the instruction of the same instr ID is replayed in pipeline 108.
      <br/>
      Under one embodiment, it is possible that an instruction may be concurrently replayed more than one time within pipeline 108.
      <br/>
      In this case, under one embodiment, only the information associated with the highest "replay count" is written back to DAD array 206A.
    </p>
    <p num="57">
      The "Dependency Field" includes a bit for each logical register.
      <br/>
      In FIG. 13, for simplicity, only four logical registers (R1, R2, R3, and R4) arc represented.
      <br/>
      However, the number could be far larger.
      <br/>
      In the example, the dependency field entries are set to 1 to indicate that a data dependency chain exists between an input value to the trace and the instruction entry, and a 0 if there is no dependency.
      <br/>
      The dependency field entries identify which instructions in the trace would need to be executed if an input value is received (such as when value misspeculation is detected).
    </p>
    <p num="58">
      As the instructions are fetched, decoded, and written into trace buffer 114A, the dependency bits are computed sequentially, and are written into the DAD array 206A.
      <br/>
      The dependency bits may be generated before it is determined whether to replay an instruction.
      <br/>
      The dependency bits in FIG. 13 are for the six instructions I0-I5, recited above in section B.1.a.
    </p>
    <p num="59">
      The dependency field can be created through a mechanical approach.
      <br/>
      Before describing one such approach, the creation will be explained on a more intuitive level.
    </p>
    <p num="60">i. Intuitive Level</p>
    <p num="61">
      The result of instruction I0 is dependent on only registers R1 and R2.
      <br/>
      Therefore, a 1 is placed in the R1 and R2 columns and a 0 remains in the R3 and R4 columns of instr ID 0 (which holds information related to instruction I0).
    </p>
    <p num="62">
      The result of instruction I1 is dependent on only registers R3 and R4.
      <br/>
      Therefore, a 0 is placed in the R1 and R2 columns and a 1 in the R3 and R4 columns of instr ID 1.
    </p>
    <p num="63">
      The result of instruction I2 is directly dependent on registers R1 and R2, produced in instructions I0 and I1, respectively.
      <br/>
      In instruction I0, R1 is dependent on the R1 and R2 values at the beginning of the trace.
      <br/>
      In instruction I2, R2 is dependent on the R3 and R4 values at the beginning of the trace.
      <br/>
      Therefore, instruction I2 is indirectly dependent on the R1-R4 values at the beginning of the trace and a 1 is placed in the R1-R4 columns of instr ID 2.
    </p>
    <p num="64">
      The result of instruction I3 is directly dependent on register R1 produced in instruction I2.
      <br/>
      Therefore, instruction I3 indirectly depends on R1-R4 values at the beginning of the trace because instruction I2 depends on these values and a 1 is placed in the R1-R4 columns of instr ID 3.
    </p>
    <p num="65">
      The result of instruction I4 is directly dependent on register R2, which is produced in instruction I1.
      <br/>
      R2 depends on registers R3 and R4 values at the beginning of the trace.
      <br/>
      Therefore, a 0 is placed in the R1 and R2 columns and a 1 is placed in the R3 and R4 columns of instr ID 4.
    </p>
    <p num="66">
      The result of instruction I5 is directly dependent register R1, which is produced in instruction I2, which depends on registers R1-R4 at the beginning of the trace.
      <br/>
      Therefore, a 1 is placed in the R1-R4 columns of instr ID 5.
    </p>
    <p num="67">ii. A Mechanical Approach</p>
    <p num="68">
      The following are registers and an algorithm that may be used to generate the dependency field according to one embodiment of the invention.
      <br/>
      Referring to FIG. 14, dependency generation circuitry 212A contains temporary registers 230, 232, 234, and 236, one for each logical register, plus an additional temporary register 240 .
      <br/>
      Temporary registers 230, 232, 234, and 236 contain modifiers for logical registers R1, R2, R3, and R4 .
      <br/>
      Modified registers 240 contains a set of bits which indicate which logical registers are to be modified by instructions within a trace.
      <br/>
      Registers 230, 232, 234, 236, and 240 are updated every time a new instruction is written into the trace buffer.
      <br/>
      The boundaries between registers is somewhat arbitrary.
      <br/>
      For example, they may all be in one combined register.
    </p>
    <p num="69">
      For each logical register, a trace buffer address register is provided, which points to the last instruction in trace buffer 114A to modify the logical register.
      <br/>
      The modified bits, and the last modifiers addresses are used to compute the dependency bits for the next instruction to be written into trace buffer 114A.
    </p>
    <p num="70">
      Note that as used herein, modifying a register merely means a value is written into the register.
      <br/>
      It does not necessary mean that the contents of the register are different as a result of the instruction.
      <br/>
      For example, if the contents of R1 and R2 are multiplied (as they are in instruction I0) and the result is written into register R1, the contents of R1 is not necessarily different as a result of instruction I0.
      <br/>
      For example, the contents of R1 after the instruction would not be different if the contents of R1 is "0" or R2 is "1" before the instruction.
    </p>
    <p num="71">
      In FIG. 16, a flow chart 250 represents an algorithm which is performed for each source operand of an instruction (e.g., source 1 and source 2) to create the dependency field of DAD array 206A.
      <br/>
      In step 252 it is determined whether the associated bit is set in register 240.
      <br/>
      As described in step 254, if the bit in register 240 is not set, then the bit in the dependency field associated with the register is set to a logical 1.
      <br/>
      As stated in step 258, if the bit in register 240 is set, the source dependency field is read using the index created from the modifier register (230, 232, 234, or 236) for the relevant register.
      <br/>
      Next, as stated in step 262, the source dependency bits are merged with the current instruction dependency bits using a logical OR operation.
      <br/>
      Such a logical OR operation is illustrated by OR-gate 244 in FIG. 15 (in which multiple bits are represented at the inputs).
      <br/>
      In performing the algorithm of FIG. 16, the modified registers and modifiers referred to are those that existed immediately before an instruction is performed.
    </p>
    <p num="72">
      With respect to I0, prior to instruction I0, register 240 has logical 0s for R1, R2, R3, and R4, and the values of registers 230, 232, 234, and 236 are X (don't care).
      <br/>
      Under step 252, the modified bits in register 240 for R1 and R2 are each 0.
      <br/>
      Therefore, under step 254, the dependency field bits for R1 and R2 are each set to 1 in row instr ID 0 of DAD array 206A.
      <br/>
      Registers R3 and R4 are not involved and remain a 0 in the row of instr ID 0.
      <br/>
      Instruction I0 modifies register R1.
      <br/>
      Therefore, a 0 is placed in register 230, indicating that instruction I0 is the most recent instruction to modify register R1.
      <br/>
      The values in registers 232, 234, and 236 remain X (don't care).
      <br/>
      The R1 bit of register 240 is set to a 1 indicating that R1 has been modified by an instruction within the trace.
    </p>
    <p num="73">
      The dependency field for instruction I1 is generated in a similar manner to that of instruction I0.
      <br/>
      The R1 logical register column of modified register 240 remains set to a 1.
      <br/>
      A logical 1 is placed in the R2 column of modified register 240.
      <br/>
      The 1 in register 232 represents instruction I1.
    </p>
    <p num="74">
      With respect to instruction I2, prior to instruction I2, under step 252, the modified bits in register 240 for R1 and R2 are each a logical 1 (i.e., set).
      <br/>
      Under step 258, the modifier registers for R1 (230) and R2 (232), immediately prior to instruction I2, are used as an index.
      <br/>
      Register 230 contains a 0 for instruction I0.
      <br/>
      The dependency field for instruction I0 in instr ID 0 of DAD array 206A is 0011.
      <br/>
      Register 232 contains a 1 for instruction I1.
      <br/>
      The dependency field for instruction I1 in instr ID 1 is 1100.
      <br/>
      Under step 262, the logical OR of 0011 and 1100 is 1111.
      <br/>
      Therefore, 1111 is placed in the dependency field of DAD array 206A for instr ID 2.
      <br/>
      R1 is modified by instruction I2.
      <br/>
      However, a 1 is already in register 240 for register R1.
      <br/>
      A 2 is placed in register 230, indicating that instruction I2 is the most recent instruction to modify instruction R1.
    </p>
    <p num="75">
      The dependency field for instruction I3 is generated in a similar manner to that of instruction I2.
      <br/>
      A logical 1 is added to the R4 column of modified register 240 and a 3 representing instruction I3 is placed in register 236.
      <br/>
      The logical OR produces 1111.
    </p>
    <p num="76">
      With respect to instruction I4, prior to instruction I4, under step 252, the modified bit in register 240 for R2 is set to a 1.
      <br/>
      Under step 258, the modifier register for R2 (232), immediately prior to instruction I4, is used as an index.
      <br/>
      Register 232 contains a 1 for instruction I1.
      <br/>
      The dependency field for instruction I4 in instr ID 1 of DAD array 206A is 1100.
      <br/>
      Under step 262, the logical OR of 1100 (source 1 from instr ID 1) and 0000 (there is no source 2) is 1100.
      <br/>
      Therefore, 1100 is placed in the dependency field of DAD array 206A for row instr ID 4.
    </p>
    <p num="77">
      The dependency field of instruction I5 is generated in a manner similar to that of instruction I4.
      <br/>
      Instructions I5 and I6 modify an external memory location and do not cause a change in registers 230, 232, 234, 236, or 240.
    </p>
    <p num="78">The dependency information may be used by schedule/issue unit 156, or schedule/issue unit 156 may merely derive its own dependency information.</p>
    <p num="79">
      There are different ways in which a sequence or string of instructions can be issued out of trace buffer 114A in replay.
      <br/>
      One way is to sequentially read the trace buffer and extract those instructions that have the dependency bits set and send them for replay.
      <br/>
      However, zeros may have the effect of creating bubbles in the pipeline.
      <br/>
      Another approach is to have bubbles removed by packing logic before sending instructions for execution/replay.
      <br/>
      Referring to FIG. 17, another approach involves some additional hardware including an array 268 for each logical register.
      <br/>
      Array 268 includes instr ID values of instructions that are dependent on register R1.
      <br/>
      The values in array 268 act as pointers to the entire instr ID entries in instruction queue array 202A.
      <br/>
      This allows very fast reading from the instruction buffer.
      <br/>
      A block of instructions (perhaps 2 or 4) are read at a time.
      <br/>
      Trace buffer 114A could be multi-ported and have four decoders and pass each one of these indices that were obtained from the register array into the decoders and instructions I0, I2, I3, and I5 can be read in one cycle.
      <br/>
      The register R1 array could be assembled at the time the dependency field is created, before replay begins.
      <br/>
      The level of indirection facilitates high bandwidth replay.
    </p>
    <p num="80">c. Output Register File 210A. and Input Register File 208A</p>
    <p num="81">
      Trace buffers 114 include detection circuitry to detect certain speculation errors.
      <br/>
      According to one embodiment of the invention, each trace buffer has an output register file that holds the register context of the associated thread and an input register file to receive the register context of the immediately preceding thread in program order.
      <br/>
      The register context is the contents or state of the logical registers.
      <br/>
      The contents of the output register file is updated often, perhaps each time there is a change in a register.
      <br/>
      The contents of the input register file is updated only after a comparison, described below.
    </p>
    <p num="82">
      FIGS. 18 and 19 illustrate embodiments of an output register file 208A (in trace buffer 114A) and an input register file 208B (in trace buffer 114B), although other embodiments could be used.
      <br/>
      Output register file 208A and input register file 210B include a Value or PRID field and a status field.
      <br/>
      The status field indicates whether a valid value or a valid PRID is held in the Value or PRID field.
      <br/>
      In one embodiment, there is either a valid value or a valid PRID.
      <br/>
      In another embodiment, there could be neither, in which case an instruction that depends on an input register file could wait for one.
    </p>
    <p num="83">
      Note that instruction I0 in the example described above involved registers R1 and R2, neither of which were previously the destination of an instruction within the thread that includes instruction I0.
      <br/>
      However, the value or PRID for registers R1 and R2 would be available from input register file 208A to be used in execution of instruction I0.
    </p>
    <p num="84">
      Referring to FIG. 20, a comparator 280B compares the contents of input register file 208B (in trace buffer 114B) for a current thread with the contents of output register file 210A (in trace buffer 114A) for an immediately preceding thread in program order.
      <br/>
      The comparison can be made at the end of the execution of the immediately preceding thread or during the original execution of the preceding thread.
      <br/>
      The comparison is also made at the end of the retirement of the preceding thread.
      <br/>
      In one embodiment, the comparison is only made at the end of the retirement of the preceding thread.
    </p>
    <p num="85">
      Various events could trigger a comparison by comparator 280B.
      <br/>
      The comparison is made to detect speculation errors.
      <br/>
      If there is a difference between the input and output register files, then values of one or more of the output registers of the immediately preceding thread had changed.
      <br/>
      In response, input register file 208B is updated and replay triggering logic 284B causes the effected instructions to be replayed with the changed register values.
      <br/>
      The dependency field may be used by replay triggering logic 284B.
      <br/>
      There is no guarantee that the changed values are the ultimately correct values (i.e., the register values that would have been produced in a purely in order processor).
      <br/>
      The instructions may need to be replayed again, perhaps several times.
    </p>
    <p num="86">
      In one embodiment, the detection circuitry for a thread includes an output register file, an input register file, a comparator and associated control circuitry to detect certain speculation errors in instructions held in the trace buffer that includes the input register file.
      <br/>
      In other embodiments, the detection circuitry could include somewhat different circuitry.
    </p>
    <p num="87">
      As an example, referring to FIG. 21, thread T2 is a current thread and is associated with trace buffer 114B.
      <br/>
      Thread T1 is the immediately preceding thread to thread T2 and is associated with trace buffer 114A.
      <br/>
      Thread T1 includes a function call, the function, and a return from the function call.
      <br/>
      Execution of thread T2 begins immediately after the function call.
      <br/>
      The contents of output register 210A as it existed at the function call are copied into input register file 208B.
      <br/>
      The instructions of thread T2 are executed speculatively based on the register context in input register file 208B.
      <br/>
      At the time of the return instruction, the contents of input register file 208B are compared by comparator 280B with the contents of output register file 210A.
      <br/>
      If there is a difference, input register file 208B is updated and the effected instructions in thread T2 are replayed.
      <br/>
      The comparison may also be made at one or more intermediate times.
      <br/>
      This may help prevent bottlenecks by more evenly distributing replay of instructions, but may cause additional replays if, for example, the output register file contents changes more than once during the function.
      <br/>
      In that the output register file is constantly changing, it may be desirable to have an intermediate buffer that receives the contents of output register file 210A.
      <br/>
      The comparison then may be between the contents of intermediate buffer and input register file 208B.
    </p>
    <p num="88">
      As illustrated in FIG. 8 and 10, register contexts are passed between output register files and input register files over conductors 216.
      <br/>
      Conductors 216 connect each input register file with the output register file of each trace buffer that could hold the trace for the immediately preceding thread.
      <br/>
      If it can be guaranteed that program order will always follow particular trace buffer order, then the layout for conductors 216 could be fairly simple.
      <br/>
      The output and input register files may be controlled by control circuitry 224A shown in FIGS. 10 and 11.
    </p>
    <p num="89">
      Because output and input register files will provide either a value or a PRID, there may be a very small latency between receiving contents in an input register file and being able to execute instructions using a register from the input register file as a source operand.
      <br/>
      If a value is not available, the PRID to register file 152 may be used for execution in pipeline 108.
    </p>
    <p num="90">
      It is expected that many instructions will be replayed several times as correct source operands work their way through the register files of the various threads.
      <br/>
      However, it is also expected that for many programs, a great deal of instructions will need to be replayed either not at all or a relatively small number of times, leading to a substantial increase in instructions correctly executed per unit of time, and a decrease in the total time required to run a program.
    </p>
    <p num="91">2. Trace Buffer 114'</p>
    <p num="92">
      Referring to FIG. 11, trace buffer 114A' is similar to trace buffer 14 (in FIG. 10).
      <br/>
      However, in trace buffer 114A' the dependency field is generated in dependency generation and decoding circuitry 218A after it has been decided that an instruction is to be replayed.
      <br/>
      While this may cause some initial latency in replay, if the issuance of instructions for replay and determining of dependencies is performed in a pipelined fashion, there may be little additional latency once the process has begun.
    </p>
    <p num="93">
      In one embodiment, dependency generation and decoding circuitry 218A holds only one field for dependency information. (In FIG. 13, there are four fields.) That same field could be reused.
      <br/>
      For example, during replay of instructions dependent on register R1, the field could be used to list instructions dependent on register R1.
      <br/>
      During replay of instructions dependent on register R2, the same field could be used to list instructions dependent on register R2, etc.
      <br/>
      Dependency generation and decoding circuitry 218A could include only one modifier field and one modifier register. (In FIG. 14, there are four.) Alternatively, dependency generation and decoding circuitry 218A could include multiple dependency fields and registers.
      <br/>
      Dependency generation and decoding circuitry 218A may determine dependencies for only a few instructions at a time.
    </p>
    <p num="94">
      Data array 214A includes a Value or PRID field, a Status bit field, and replay count field for each instr ID entry (as in DAD array 206A of FIGS. 10 and 13).
      <br/>
      Alternatively, the contents of data array 214A could be put in dependency generation and decoding circuitry 218A making data array 214A unnecessary.
      <br/>
      There are two reasons why it may be advantageous to keep data array 214A and dependency generation and decoding circuitry 218A separate.
      <br/>
      First, they may involve different read ports.
      <br/>
      Second, in one embodiment, dependency generation and decoding circuitry 218A does not have as many rows as do instruction queue array 202A and data array 214A.
      <br/>
      In other words, in one embodiment, dependency generation and decoding circuitry 218A reuses rows, just like it may reuse dependency fields.
      <br/>
      There are, of course, many possibilities.
    </p>
    <p num="95">
      As will be described in greater detail below, MOB 178 signals when load instructions are to be replayed through conductors 194.
      <br/>
      An array having a dependency field (like that for R1 in FIG. 13) may be generated to list the instructions dependent on the load instruction to be replayed.
      <br/>
      However, for a load instruction, the list of dependent instructions begins with the load instruction, rather than with the first instruction in the trace as in the case of registers.
      <br/>
      The dependency field for load instructions may be in dependency generation and decoding circuitry 218A (in FIG. 11). (Of course, load instructions for other traces would be replayed from other trace buffers.) In one embodiment, dependency generation and decoding circuitry 218A is used for dependency fields for both load instructions and registers.
      <br/>
      The same field can be used for both.
      <br/>
      In another embodiment, the dependency fields for registers is in DAD array 206A and the dependency field for loads is in dependency generation and decoding circuitry 218A.
    </p>
    <p num="96">In still another embodiment, the load instruction is replayed in full (i.e., all instructions following the load are re-executed) so that the dependency field is not needed.</p>
    <p num="97">C. A Replay Sequence Algorithm</p>
    <p num="98">
      When replay triggering logic (such as replay triggering logic 284B) determines that a source operand (or other input value) has been mispredicted, it triggers the corresponding trace buffer (such as trace buffer 114B) to dispatch those instructions that are directly or indirectly dependent on the mispredicted source operand to be replayed in pipeline 108.
      <br/>
      The instructions that are directly or indirectly dependent may be identified from the dependency field of the DAD array in the trace buffer or through another array as in FIG. 11.
    </p>
    <p num="99">
      The identified instructions are dispatched from the trace buffer for execution in the order the instructions exist in the trace buffer (which is the program order).
      <br/>
      For example, the instruction in instr ID0 entry is dispatched at prior to or at the same time as an instruction in the instr ID1 entry.
      <br/>
      However, the instructions may be executed out of order under the control of schedule/issue unit 156, as in any out-of-order processor.
      <br/>
      Control bits are appended to the instruction dispatched from the trace buffer to indicate to rename/allocate unit 150 whether to (1) do register renaming, (2) bypass the rename alias table lookup in rename/allocate unit 150 and instead use the PRID from the corresponding trace buffer, or (3) bypass renaming completely and use the value from the DAD array as if it where a constant operand in the instruction.
    </p>
    <p num="100">
      As explained in connection with FIG. 12, the "Valid 1" and "Valid 2" field are bits that arc set to a first value (e.g., a logic 0) when a corresponding source operand of an instr ID has been produced by (e.g., the destination of) an instruction from outside the thread in trace buffer 114A, and a second value (e.g., a logic 1) when the source operand for an instr ID has been produced by an instruction within the thread.
      <br/>
      A replayed instruction dispatched from trace buffer 114A may have its source operands determined as follows:
    </p>
    <p num="101">
      (1) Valid bit 1.
      <br/>
      If the valid bit in instruction queue array 202A is set to a logical 1, the index for the source operand is used to read the corresponding value or PRID in DAD array 206A.
      <br/>
      If neither the value bit nor PRID bit of the DAD array status field is valid, it means the source operand register has not been renamed yet.
      <br/>
      In this case, the instruction is dispatched with the value and PRID status bits having logical zero values through conductor 120 and MUX 110, allowing rename/allocate unit 150 to perform alias table lookup (register renaming) as it normally does.
      <br/>
      If the PRID or value is valid, it is passed along with the instruction through conductor 120 and MUX 110 to rename/allocate unit 150, which in response thereto bypasses the renaming stage.
    </p>
    <p num="102">
      (2) Valid bit 0.
      <br/>
      If the valid bit for a source operand is set to a logical 0, the input operand comes from outside the trace.
      <br/>
      The source register name is used to access input register file 208A.
      <br/>
      The value or PRID from input register file 208A is passed along with the instruction to rename/allocate unit 150, which in response thereto bypasses the renaming stage.
    </p>
    <p num="103">
      Whether the valid bit is 0 or 1, for each dispatched instruction, the value and PRID status field bits in DAD array 206A are reset to or remain at a logical 0.
      <br/>
      This achieves two purposes.
      <br/>
      First, it ensures that a later dependent instruction dispatched before the PRID is copied into the entry from the rename stage would be allowed to be renamed from the rename alias table, avoiding the use of a stale PRID from trace buffer 114A.
      <br/>
      Second, it also ensures that an instruction will not retire until the last execution instance is written back, therefore allowing an instruction to retire only when all data mispredictions have been corrected.
    </p>
    <p num="104">D. Second Level or Final Retirement</p>
    <p num="105">
      An instruction is finally retired from trace buffer 114 when all the instructions for all previous threads have retired and all replay events that belong to the instruction have been serviced.
      <br/>
      Stated another way, an instruction is finally retired when it can be assured that the instruction has been executed with the correct source operand(s).
      <br/>
      Threads are retired in order.
      <br/>
      For example, an instruction in thread X cannot be retired until all the previous threads have been retired (i.e., the instructions of all the previous threads have been retired).
      <br/>
      The instructions within a thread are retired in order, although instructions that are all ready for retirement may be retired simultaneously.
    </p>
    <p num="106">
      Final retirement is controlled by final retirement logic 134.
      <br/>
      In one embodiment of the invention, final retirement includes (1) commitment of results to in order register file, (2) service interrupts, exceptions, and/or branch mispredictions; (3) deallocation of trace buffer and MOB 178 resource entries; and (4) signaling the MOB to mark stores as retired and to issue them to memory.
      <br/>
      Deallocating entries may involve moving a head pointer.
      <br/>
      As described below, store instructions in MOB 178 are not deallocated until alter it is certain that associated data is copied to data cache 176 or other memory.
      <br/>
      Details regarding final retirement of loads and stores instructions in MOB 178 are described below.
    </p>
    <p num="107">E. Memory System</p>
    <p num="108">
      FIG. 22 illustrates that one embodiment of MOB 178 of FIG. 2 includes MOBs 178A, 178B, . . . , 178Y, where Y represents the number of MOBs and matches the number of trace buffers 114.
      <br/>
      MOBs 178A, 178B, . . . , 178Y hold copies of load and store instructions of the traces in trace buffers 114A, 114B, . . . , 114Y, respectively.
      <br/>
      Load instructions are held in load buffers 182A, 182B, . . . , 182Y. Store instructions are held in store buffers 184A, 184B, . . . , 184Y. Conductors 292 represent various conductors that carry signals to and from MOB 178.
      <br/>
      Replay conductors 194 provide signals from MOB 178 to trace buffers 114 alerting trace buffers 114 that a load instruction should be replayed.
      <br/>
      Control circuitry 302 performs a variety of control functions.
    </p>
    <p num="109">1. Store Buffers and Load Buffers</p>
    <p num="110">
      FIG. 23 illustrates one embodiment of a store buffer 184A, which is representative of store buffers 184B, . . . , 184Y. Various other embodiments could be used.
      <br/>
      Store buffer 184A includes various fields for rows of store buffer entries.
      <br/>
      Each entry is identified by a store buffer ID (SBID).
      <br/>
      Rename/allocate unit 150 allocates an SBID entry to each store instruction when it is first fetched and executed, but not on replay.
      <br/>
      The store instruction has the same SBID value until final retirement.
      <br/>
      For example, in FIG. 23, entry SBID 0 is allocated for instruction store 0.
      <br/>
      Entry SBID 1 is allocated for instruction store 1, etc.
      <br/>
      An LBID field holding a "store LBID" value described below, is illustrated in FIG. 23. In one embodiment, when an entry of instruction queue array 202A (in FIG. 12) holds a store instruction, the SBID field of instruction queue array 202A holds the SBID that identifies the entry in store buffer 184A that holds the store instruction, and the LBID field holds the store LBID, if there is one, for that the store instruction.
      <br/>
      The SBID and store LBID accompany the store instruction through pipeline 108.
      <br/>
      In that embodiment, the LBID field might not be also included in store buffer 184A.
    </p>
    <p num="111">
      An instr ID field holds the instruction ID of the store instruction in instruction queue array 202A.
      <br/>
      The thread buffer ID is implicit in both store buffer 184A and the trace buffer 114A.
      <br/>
      An op code field holds the op code of the store instruction.
      <br/>
      A store address field holds the address to which the store instruction is directed.
      <br/>
      In the illustrated embodiment, the address is generated by AGU 172.
      <br/>
      An SB address valid field includes a bit indicating whether the store address is a valid address.
      <br/>
      A data field holds the data to be stored.
      <br/>
      A data valid field includes a bit indicating whether the data is valid.
      <br/>
      Separate address and data valid bits may be used because the valid address may arrive at a different time than the valid data.
      <br/>
      Both the address and data arrive before the store instruction is executed.
      <br/>
      Under one embodiment, the data is included as part of the instruction.
      <br/>
      A retired field includes a bit that is set when final retirement logic 134 indicates the store instruction should retire and is reset when confirmation is received from memory that the store to memory has been complete.
      <br/>
      Retirement of loads and stores is discussed below.
      <br/>
      A replay count field includes a replay count number (and is similar to the replay count field of DAD array 206A in FIG. 13).
      <br/>
      The replay count field is not necessary.
      <br/>
      Under one embodiment, a store instruction can be replayed only once at a time and there is no replay count field.
    </p>
    <p num="112">
      FIG. 24 illustrates one embodiment of a load buffer 182A, which is representative of load buffers 182B, . . . , 182Y. Various other embodiments could be used.
      <br/>
      Load buffer 182A includes various fields for rows of load buffer entries.
      <br/>
      Each entry is identified by a load buffer ID (LBID).
      <br/>
      Rename/allocate unit 150 allocates an LBID entry to each load instruction when it is first fetched and executed, but not on replay.
      <br/>
      The load instruction has the same LBID value until final retirement.
      <br/>
      For example, in FIG. 24, entry LBID 0 is allocated for instruction load 0.
      <br/>
      Entry LBID 1 is allocated for instruction load 1, etc. (The LBID entry number and the SBID field may be called a MOB ID).
      <br/>
      An SBID field holding a "load SBID" value described below, is illustrated in FIG. 24. In one embodiment, when an entry of instruction queue array 202A (in FIG. 12) holds a load instruction, the LBID field of instruction queue array 202A holds the LBID that identifies the entry in load buffer 182A that holds the load instruction, and the SBID field holds the load SBID, if there is one, for that store instruction.
      <br/>
      The LBID and load SBID accompany the load instruction through pipeline 108.
      <br/>
      In that embodiment, the SBID field might not be also included in load buffer 182A.
    </p>
    <p num="113">
      An instr ID field holds the instruction ID of the load instruction in instruction queue array 202A.
      <br/>
      The thread buffer ID is implicit in both load buffer 182A and the trace buffer 114A.
      <br/>
      An op code field holds the op code of the load instruction.
      <br/>
      A load address field holds the address from which the load instruction loads.
      <br/>
      An entry valid field includes a bit indicating the entry is occupied by a valid load instruction.
      <br/>
      In the illustrated embodiment, an address valid field is not included because the address has already been generated by AGU 172.
      <br/>
      A PRID field holds a PRID from rename/allocate unit 152 which indicates the destination of load instructions in the register file 152.
      <br/>
      SB Hit, SBID, Thread ID, and replay count field (if there is one) may be considered part of a status field and are described below in connection with execution of store instructions.
    </p>
    <p num="114">
      At the time store and load instructions are first received by rename/allocate unit 150, entries for store and load instructions are allocated in store buffers 184 and load buffers 182, and entries for registers to receive loaded values are allocated in register file 150 and ROB 164.
      <br/>
      These store and load entries are not subject to a first level retirement, but like entries in trace buffers 114, remain allocated until a final retirement.
      <br/>
      Accordingly, entries are not reallocated on replay.
      <br/>
      If a store or load buffer is full, a store or load instruction, respectively, from I-cache 104 will not pass through rename/allocate unit 150 until an entry is freed up.
      <br/>
      However, a load or store instruction that is being re-executed from a trace buffer will pass through rename/allocate unit 150.
    </p>
    <p num="115">2. Comparisons of Load and Store Addresses</p>
    <p num="116">
      Referring to FIG. 5, in program order, store MX in thread T1 is executed before load MX is executed in thread T2.
      <br/>
      However, because of concurrent execution, in time order, store MX may be executed before or after load MX.
      <br/>
      If store MX is executed before load MX in time order, then the speculative execution of load MX will be in the correct order with respect to store MX.
      <br/>
      If all instructions before store MX in program order have been retired, then it is certain that load MX will load the correct value from memory location MX.
      <br/>
      The correct value is the value that would have been loaded if the threads were run by an in order processor.
      <br/>
      If not all instructions before store MX in program order have been retired, then there is always a chance that the data for store MX is incorrect.
    </p>
    <p num="117">
      By contrast, if store MX is executed after load MX in time order, then the speculative execution of load MX will not be in the correct order with respect to store MX and there is 110 certainty load MX will load the correct value.
      <br/>
      It would only be by coincidence that the correct value happened to be in memory location MX (or the data field of the store buffer entry holding store MX until store MX is finally retired).
      <br/>
      To ensure ultimate correctness of execution, MOB 178 includes various mechanisms to ensure memory data coherency between threads.
    </p>
    <p num="118">a. Execution of Load Instructions</p>
    <p num="119">
      Before a load instruction is executed, its address is compared with the addresses of store instructions to determine which, if any, store instruction is the closest earlier matching store instruction (CEMSI). "Matching" means having the same address as the load instruction. "Earlier" means the CEMSI is earlier in program order than the load instruction. "Closest" means there is no other matching store instruction between the CEMSI and the load instruction to be executed.
      <br/>
      If there is only one earlier matching store instruction, it is the CEMSI.
    </p>
    <p num="120">
      If there is a CEMSI, the load instruction reads its data from the data field of the CEMSI.
      <br/>
      If there is no CEMSI, the load instruction takes its data from memory, such as data cache 176, an L2 cache, or main memory.
      <br/>
      Data from a store buffer 184 or memory is passed through MUX 192 and written to the entry in trace buffers 114 designated by the thread ID and instr ID.
      <br/>
      The data may also be written to the register in register file 152 designated by the PRID.
      <br/>
      The data may also be stored in data cache 176 depending on the caching rules (e.g., write back, write through, etc.).
      <br/>
      MUX 192 is a bypass because it can bypass memory, such as data cache 176, an L2 cache, or main memory.
    </p>
    <p num="121">
      In one embodiment, a different comparator is associated with each entry of each of store buffers 184 to make comparisons between the address of the load to be executed and the address of store instructions.
      <br/>
      Comparator 320 in FIG. 25 is an example and receives the load instruction address and the store address of entry SBID 1 in store buffer 184A.
      <br/>
      Conductor 322 as well as output conductors from other comparators are connected to MOB control circuitry 302.
    </p>
    <p num="122">
      The load SBID points to the SBID of a closest earlier store instruction (CESI) with respect to the load instruction to be executed.
      <br/>
      The CESI is in the store buffer that has the same thread ID as the load instruction.
      <br/>
      If there is a CEMSI, it is either the CESI or earlier than the CESI in program order.
      <br/>
      Rename/allocate unit 150 keeps track of the order of store and load instructions in the program and provides the SBID and the LBID values.
      <br/>
      They may be written through conductors 126 to trace buffers 114.
      <br/>
      Under one embodiment, if there is no CESI with respect to a load instruction, then there is no load SBID associated with that instruction.
      <br/>
      This happens when the first memory instruction in a trace is a load.
      <br/>
      Various techniques may be used to handle this situation including rename/allocate unit 150 sending certain signals to indicate there is no valid load SBID.
      <br/>
      The array wrap around bit, described below, may be used for this purpose.
    </p>
    <p num="123">
      Consider store and load instructions in the following program order:
      <br/>
      store 0
      <br/>
      store 1
      <br/>
      load 0
      <br/>
      store 2
      <br/>
      load 1
      <br/>
      store 3
      <br/>
      store 4
      <br/>
      load 2.
    </p>
    <p num="124">
      The store LBID values in the LBID field are illustrated in store buffer 184A.
      <br/>
      The load SBID values in the SBID field are illustrated in load buffer 182A.
      <br/>
      For example, the 2 in the SBID field of LBID entry 1 indicates that the store instruction at entry SBID 2 in store buffer 184A holds the CESI with respect to the load instruction in LBID entry 1.
      <br/>
      Instructions store 0, store 1, store 2, and load 0 are older or earlier than load 1.
      <br/>
      Instructions store 3, store 4, and load 2 are younger or later than load 1.
    </p>
    <p num="125">
      There are various ways in which control circuitry 302 may determine which if any store instruction is the CEMSI.
      <br/>
      Examples of the ways are discussed in connection with FIG. 27, wherein store buffers 184A, 184B, 184C, and 184D are the only store buffers in MOB 178 and are associated with threads A, B, C, and D, respectively.
      <br/>
      Assume that the program order is thread A, then thread B, then thread C, then thread D. In the example, the load instruction to be executed is in load buffer 182C.
      <br/>
      There is a CESI, which is in store buffer 184C.
    </p>
    <p num="126">
      Conductors 342, 344, 346, and 348 are the output conductors of the various comparators.
      <br/>
      Conductors 362, 364, 366, and 368 provide control signals that enable the comparators to perform the comparisons.
      <br/>
      In different embodiments, control circuitry 302 enables (1) the comparators for all entries in each store buffer, (2) only those comparators that are in a store buffer having a thread ID that is the same as or earlier in program order than the load instruction's thread ID, or (3) only those comparators associated with entries that are earlier in program order than the load instruction.
    </p>
    <p num="127">
      Match determining logic 356 determines which, if any, of the store instructions is the CEMSI.
      <br/>
      In FIG. 27, the store MX instruction in the upper portion of store buffer 184C is the CEMSI.
      <br/>
      If that store MX instruction were not in store buffer 184C, then the CEMSI would be the store MX instruction in store buffer 184B.
      <br/>
      While comparators and match determining logic 356 are determining whether there is a CEMSI, a lookup may be occurring in data cache 176 (and other memory) to be ready if there is no CEMSI.
      <br/>
      Match determining logic 356 includes data path control logic 390, which provides a signal on conductor 370 to control whether MUX 192 passes data from memory or a store buffer.
    </p>
    <p num="128">
      Under one approach, there are two priority determinations made by MOB control circuitry 302.
      <br/>
      One may be to determine the priority of store instructions within store buffers.
      <br/>
      Another may be to determine the priority of the store buffers.
      <br/>
      The determinations may be in either order.
      <br/>
      A carry chain structure may be used in the determination of the priority within the store buffer.
      <br/>
      For example, in one embodiment, for each store buffer other than the one having the same thread ID as the load instruction, it is determined which, if any, matching store instruction is the youngest in program order.
      <br/>
      For the store buffer having the same thread ID as the load instruction, it is determined which, if any, matching instruction is the closest in program order to (including equal to) the CESI.
      <br/>
      Then, it is determined which of those store buffers that have a matching instruction have a thread ID that is closest in program order to the thread ID of the load instruction.
    </p>
    <p num="129">
      Store buffers 184 may be circular arrays each having a head and a tail.
      <br/>
      Initially, store instructions with the greater SBID value are younger.
      <br/>
      However, as store entries are deallocated and allocated, the tail will eventually wrap around so that the head points to a higher SBID entry than does the tail.
      <br/>
      In one embodiment, a wrap around bit is toggled when the tail goes from the highest to the lowest SBID value, and is provided to closest match determining logic 356.
    </p>
    <p num="130">b. Execution of Store Instructions</p>
    <p num="131">
      When a store instruction is executed, its address is compared with the addresses of load instructions to determine which, if any, load instructions that are later in program order (from the same or a younger thread) have the same address as the store instruction.
      <br/>
      A closest later load instruction (CLLI) pointed to by the store SBID designates the earliest load instruction that may be considered.
    </p>
    <p num="132">
      In one embodiment, a different comparator is associated with each entry of each of load buffers 182 to make those comparisons.
      <br/>
      One of the comparators is comparator 324, illustrated in FIG. 26. Merely as an example, comparator 324 is associated with the entry LBID 1 of load buffer 182A.
      <br/>
      Comparator 324 receives the address of a store instruction at one input and the address in the load address field of entry LBID 1 in load buffer 182A at another input.
      <br/>
      A signal on output conductor 326 signifies whether the addresses are the same.
      <br/>
      Conductor 326 as well as output conductors from other comparators are connected to MOB control circuitry 302.
      <br/>
      Comparators (such as comparator 324) may also compare status bits of the store instruction with status bits in the load buffer as described below.
    </p>
    <p num="133">
      FIG. 28 is similar to FIG. 27. However, in FIG. 28 load instruction addresses in load buffers 182A-182D are compared with the address of a store instruction to be executed, and match determining logic 356 determines whether to replay load instructions.
      <br/>
      In one embodiment, match determining logic includes replay triggering logic 394 that provides signals on conductors 194 to indicate to the trace buffers which load instructions are to be replayed.
      <br/>
      In one embodiment, match determining logic 356 considers matches of load instructions with the store instruction beginning with the CLLI.
      <br/>
      Different algorithms may be used.
      <br/>
      Thread management logic 124 indicates those thread IDs that are later in program order than the thread ID of the store instruction being executed.
      <br/>
      In one embodiment, all comparators are enabled.
      <br/>
      In another embodiment, only the conductors in the load buffers having thread IDs equal to or later in program order than the thread ID of the load instruction are enabled.
      <br/>
      In still another embodiment, only the conductors in the load buffers associated with the CLLI and later instructions are enabled.
      <br/>
      The threads to consider can be determined before, after, or during the determination as to which load instructions within the load buffers come later in program order than the store instruction.
    </p>
    <p num="134">
      Under one embodiment, detection circuitry to detect certain speculation errors in execution of load instructions includes the comparators associated with the load buffers, portions of match determining logic 356, and associated control circuitry.
      <br/>
      In other embodiments, the detection circuitry could include somewhat different circuitry.
      <br/>
      It is not required that the detection circuitry to detect speculation errors be in the execution pipeline.
      <br/>
      Different match determining logic could be used in connection with data path control logic and replay triggering logic.
    </p>
    <p num="135">i. Cases in Which There is an Address Match</p>
    <p num="136">
      The status field (SB hit, SBID, Thread ID, Replay Count (if used)) for those younger instructions for which there is an address match is considered in determining whether to replay.
      <br/>
      The status field indicates whether the load instruction got its data from memory (e.g., data cache 176) or the data field of a store buffer.
      <br/>
      The SB hit field has, for example, a 0 if the data came from memory and a 1 if the data came from the store buffer.
      <br/>
      The SBID and thread ID fields hold the SBID and thread ID of the store instruction from which the data came from.
      <br/>
      The thread ID of the store instruction is not necessarily the thread ID of the load instruction for which there is an address match.
      <br/>
      The thread ID of the load instruction is implicit in the load buffer.
      <br/>
      The replay count field (if used) indicates which replay is involved. (If the SB Hit is 0, the data in the SBID, thread ID, and replay count fields is meaningless.)
    </p>
    <p num="137">
      If SB Hit=0 (previous data from memory), a replay event is signaled from the load buffer over conductors 194 to the trace buffer identified by the load instruction thread ID and that load instruction and all dependent instructions are replayed from the trace buffer.
      <br/>
      The instr ID and thread ID are passed over conductors 194 to indicate which instruction is replayed.
    </p>
    <p num="138">
      If SB Hit=1 (previous data from store buffer), the values in the SBID field, thread ID field, and replay count field (if used) control whether a replay is triggered.
      <br/>
      In a first case, the thread ID of the status field for the particular load instruction equals the thread ID of the store instruction, and the SBID in the status field of the particular load instruction matches the SBID of the store instruction.
      <br/>
      In the first case, the load instruction is replayed if the replay count of the store instruction is larger than the replay Count in the status field.
      <br/>
      If there is not a replay count (because a store instruction can only be replayed once at a time), then the load instruction is replayed.
    </p>
    <p num="139">
      In a second case, the thread ID in the status field equals the thread ID of the store instruction, but the SBID in the status field does not match the SBID of the store instruction.
      <br/>
      In the second case, the load instruction is replayed if the SBID in the status field is less then the SBID of the store instruction, but not replayed if the SBID in the status field is greater then the SBID of the store instruction.
    </p>
    <p num="140">
      In a third case, the thread IDs of the status field and store instruction do not match.
      <br/>
      It is expected that this is an infrequent case.
      <br/>
      For simplicity, under one embodiment, the load instruction is replayed (even though it may be contrary to program order).
      <br/>
      It may be a false replay.
      <br/>
      The load instruction when replayed will receive the correct store data.
      <br/>
      Other approaches could be used but they may be far more complex that is justified for such an infrequent case.
    </p>
    <p num="141">ii. Cases in Which There is Not an Address Match</p>
    <p num="142">
      If the addresses do not match, then no replay is triggered except in the following infrequent case.
      <br/>
      If SB Hit=1, the thread ID of the status field matches the thread ID of the store instruction, and the SBID of the status field matches the SBID of the store instruction.
      <br/>
      In this case, there is a replay and the replayed load instruction receives its data from a new entry or memory.
    </p>
    <p num="143">c. Reset</p>
    <p num="144">
      A thread is reset when it is determined that the thread is not in the program order.
      <br/>
      However, loads from other threads could have taken data from the data field associated with store instructions in that thread.
      <br/>
      Thread management logic 124 sends a signal to control circuitry 302.
      <br/>
      In one embodiment, when a thread is reset, the thread ID of the reset thread is compared with every load in every load buffer (except perhaps the load buffer corresponding to the reset thread).
      <br/>
      A replay is triggered for load instructions where the thread ID in the status field matches the thread ID of the reset thread.
      <br/>
      The load instructions are replayed from the appropriate trace buffers.
    </p>
    <p num="145">3. Replay of Store Instructions</p>
    <p num="146">
      As described above, load instructions are replayed in response to execution of store instructions.
      <br/>
      In one embodiment, store instructions arc replayed in response to register comparisons in the trace buffers that indicate a register value has changed.
      <br/>
      For example, referring to FIGS. 12 and 13, instr IDs 4 and 5 in trace buffer 114A, which are store instructions, are shown to be dependent on registers R1-R4.
    </p>
    <p num="147">4. Replays of Multiple Load Instructions</p>
    <p num="148">
      It is possible that more than one load instruction in a load buffer will have status field match with a store instruction.
      <br/>
      In order to avoid complicated logic, one approach is for control circuitry 302 to detect when there are multiple load address matches and cause all instructions after the earliest load in the trace to be re-executed.
    </p>
    <p num="149">5. Final Retirement of Load and Store Instructions</p>
    <p num="150">
      When a load or store instruction is to be finally retired, final retirement logic 134 provides signals to trace buffers 114 and MOB 184 indicating that an instruction is to be finally retired.
      <br/>
      The entry in the trace buffer (identified by the instr ID and thread ID) is deallocated.
      <br/>
      In the case of load instructions, the entry in the load buffer (identified by the thread ID and LBID) is deallocated.
      <br/>
      In the case of load instructions, final retirement is complete.
      <br/>
      In the case of store instructions, prior to deallocation, the data in the data field must be committed to memory.
      <br/>
      Deallocation of the entry in the store buffer and hence final retirement does not occur until confirmation is received that the store is complete.
      <br/>
      Alternatively, the entry may be finally retired before confirmation, but reallocation of the entry cannot occur until confirmation is received.
      <br/>
      Signals on conductors 200 can indicate to thread management logic 124 when the final retirement of stores is complete and the next thread can begin.
    </p>
    <p num="151">
      SB Retired indicates that an instruction has been retired.
      <br/>
      At the time final retirement logic 134 indicates that an instruction should be retired, a bit in the SB Retired field is asserted.
      <br/>
      Once the SB Retired field is asserted, the associated instruction is written to memory in order.
      <br/>
      As soon as MOB 184A learns that the instruction has been written to memory, the SB Retired field is deasserted and the instruction is deallocated.
    </p>
    <p num="152">
      Load buffer 182A and store buffer 184A may be queues with a head and a tail.
      <br/>
      The head is moved when an instruction is deallocated.
      <br/>
      In load buffer 184A, and trace buffers 114, retirement and deallocation may occur simultaneously.
      <br/>
      Final retirement logic 134 provides signals through conductors 136 and 140.
      <br/>
      Demux 188 selects whether one of load buffers 182 or store buffers 184 will receive a retirement signals.
      <br/>
      Demux 188 is optional and could be replaced by enable ports in load buffers 182 and store buffers 184.
    </p>
    <p num="153">F. Additional Information Regarding Thread Management Logic and Final Retirement Logic</p>
    <p num="154">
      In one embodiment, thread management logic 124 uses a tree structure to keep track of thread order.
      <br/>
      Under the tree structure, the program order (which is also the retirement order) flows from top to bottom, and a node on the right is earlier in program order than a node on the left.
      <br/>
      A root is the first in program order.
      <br/>
      A tree is an abstract idea, whereas a tree structure is circuitry that implements the tree.
    </p>
    <p num="155">
      Threads begin at the instruction following a backward branch or a function call.
      <br/>
      That is, threads begin at the next instruction assuming the backward branch were not taken or the function was not called (as illustrated by threads T2 in FIGS. 4 and 5).
      <br/>
      In so doing, from the perspective of a thread (node), the program order of children nodes of the thread are in the reverse of the order in which the threads were started (created).
      <br/>
      For example, in FIG. 6, in time order, execution of thread T2 begins before execution of thread T3, but in program order, thread T3 occurs before thread T2.
    </p>
    <p num="156">
      In one embodiment, three events may cause a thread to be removed from the tree: (1) A thread at the root of the tree is removed when the thread is retired.
      <br/>
      When the thread at the root is retired, the thread (node) that is next in program order becomes the root and nodes are reassigned accordingly. (2) A thread that is last in program order is removed from the tree to make room for a thread higher in program order to be added to the tree.
      <br/>
      In this respect, the tree acts as a last-in-first-out (LIFO) stack. (3) A thread may be reset and thereby removed from the tree when it is discovered that the program counter of its parent thread is outside a range between a start count and an end count.
      <br/>
      In the case where a child thread is created at a backward branch (e.g., thread T4 in FIGS. 6 and 29), the start count is the target of the backward branch and the end count is the program counter value at the backward branch instruction.
      <br/>
      A thread started after a function call can also be reset because there is no return from the function, although it is quite rare for this to happen.
      <br/>
      One approach for dealing with the possibility of there being no return from a function is to ignore the possibility and let the system eventually remove the thread from the tree when it becomes the lowest in program order, as in event (2).
      <br/>
      When a thread is removed from the tree, the resources allocated for that thread (such as a trace buffer, store buffer, and load buffer) are deallocated.
    </p>
    <p num="157">
      Events (1) and (3) are illustrated in FIG. 29, which includes the threads of the example of FIG. 6, with the addition of threads T5 and T6.
      <br/>
      Thread T5 starts following a backward branch instruction at point J and thread T6 starts following a function call at point K. It is assumed that there are only four trace buffers.
      <br/>
      FIG. 30 illustrates the tree structure at time t1.
      <br/>
      Thread T2 is added to the tree before thread T3 is added to the tree.
      <br/>
      Thread T4 is added to the tree after thread T3 is added to the tree.
      <br/>
      Threads T2 and T3 are children of thread T1.
      <br/>
      Thread T4 is a child of thread T3.
      <br/>
      Following the rules of top to bottom and right to left, the program and retirement orders are thread T1, T3, T4, and T2.
      <br/>
      FIG. 31 illustrates the tree structure at time t2 assuming that thread T4 is reset before thread T1 retires.
      <br/>
      The program and retirement orders are thread T1, T3, T2, and T5.
      <br/>
      FIG. 32 illustrates the tree structure at time t2 assuming that thread T1 retires before thread T4 is reset.
      <br/>
      The program and retirement orders are thread T3, T4, T2, and T5.
      <br/>
      FIG. 33 illustrates the tree structure at time t3, which is after the time thread T1 retires and thread T4 is reset.
      <br/>
      The program and retirement orders are T3, T2, T5 and T6.
    </p>
    <p num="158">
      Event (2) is illustrated in FIG. 34, which includes nested functions.
      <br/>
      In time order, the threads are created (started) in the order T1, T2, T3, T4, and T5.
      <br/>
      However, the program order is T1, T5, T4, T3, and T2.
      <br/>
      In the example, there are only four trace buffers.
      <br/>
      Therefore, not all five threads exist at the same time.
      <br/>
      FIG. 35 illustrates the tree structure at time t1, which is before thread T5 has started.
      <br/>
      Program and retirement order are T1, T4, T3, and T2.
      <br/>
      Thread T5 is not yet part of the tree structure.
      <br/>
      FIG. 36 illustrates the tree structure at time t2, which is after thread T5 has started.
      <br/>
      Thread T2, which is lowest is program order, is removed from the tree structure to make room for thread T5.
      <br/>
      A thread that is removed from the tree may be restarted at a later time.
      <br/>
      Alternatively, another thread may execute all or part of the instructions of the thread removed from the tree.
      <br/>
      In one embodiment, in the case of reset, a thread may seek to join the next following thread rather than the reset thread.
      <br/>
      Alternatively, the thread may just continue until otherwise ended.
      <br/>
      The functions of array 198 may be performed in the nodes of the tree.
    </p>
    <p num="159">
      The thread IDs of the children threads are properly positioned according to program order in the tree structure. (Although the program order as determined by thread management logic 124 might change.) A thread is finished when it joins or matches the program count of the next thread in the tree in program order.
      <br/>
      If there is only one child of the thread, then that is the next thread in program order.
      <br/>
      For example, in FIG. 33, thread T2 is the next thread in the tree in program order.
    </p>
    <p num="160">
      Final retirement logic 134 gains information from the tree structure to assemble array 198 or straight from the circuitry of the tree structure.
      <br/>
      There may be decoding circuitry between the tree structure and other logic of thread management logic 124 and logic of final retirement logic 134.
      <br/>
      Array 198 may not be required.
    </p>
    <p num="161">In summary, the tree structure provides information for at least the following purposes: (1) the tree specifies retirement order; (2) the tree specifies program order, which is used by, for example, MOB 178 as described above; (3) the tree specifies an end point of a thread by indicating the starting instruction of another thread; (4) the tree is used in thread resource allocation by indicating which resources are available and which resources get deallocated.</p>
    <p num="162">G. An Embodiment Without Multithreading</p>
    <p num="163">
      FIG. 3 illustrates a processor 100 including a pipeline 308.
      <br/>
      Processor 100 is similar to processor 50.
      <br/>
      However, a trace buffer 300 is the only trace buffer and a MOB 310 is the only MOB.
      <br/>
      Processor 50 is not designed to process multiple threads.
      <br/>
      Therefore, thread management logic is not required for processor 100.
      <br/>
      Trace buffer 300 may be similar to trace buffer 114A, for example, except that multithread specific components are not required.
      <br/>
      For example, conductors 216 and output register file 210 would not be needed.
      <br/>
      Various circuitry may be used to detect speculation errors, including well known circuitry.
      <br/>
      MOB 310 may be similar to MOB 178A, for example, except that multithread specific features are not required.
      <br/>
      For example, a thread ID field would not be needed in the load buffer.
      <br/>
      Other components of processor 100 may be modified somewhat with respect to their configuration in processor 50 to remove multi-threading related features.
      <br/>
      Trace buffer 300 and MOB 310 may be used in connection with various speculations and recovery from errors therein.
      <br/>
      The trace buffer allows a large number of instructions to be held outside the pipeline for possible replay before final retirement.
    </p>
    <p num="164">
      Processor 50 could be used in connection with a non-multithread program.
      <br/>
      In that case, thread management logic 124 could always keep the same thread ID in program order.
      <br/>
      Alternatively, thread management logic 124 could be disabled.
      <br/>
      In the non-multithread case, only one of trace buffers 114 and only one of the MOBs 178 are used.
      <br/>
      Alternatively, trace buffers could be combined to make a larger trace buffer and MOBs could be combined to make a larger MOB.
    </p>
    <p num="165">H. Additional Information and Embodiments</p>
    <p num="166">
      Referring to FIG. 37, a processor 400 is a multi-processor (MP) chip including multi-pipeline unit 402.
      <br/>
      Multi-pipeline unit 400 differs from shared resource pipeline 108 of FIG. 2 in that an entire pipeline (e.g., separate rename/allocate unit for each pipeline) is included with each of pipelines 0, 1, . . . W of multi-pipeline unit 402. (W may equal to or more or less than X.) Otherwise, processor 400 may be essential the same as or very different than processor 50.
      <br/>
      Other processors may include some features of multi-pipeline unit 402 and some features of pipeline 108.
    </p>
    <p num="167">
      Each of the processors mentioned herein, may be included in a part of a variety of computer systems.
      <br/>
      Referring to FIG. 38, merely as an example, processor 50 may be part of a computer system 430.
      <br/>
      System 430 may also include a second processor 434.
      <br/>
      An on-chip second level (L2) cache may be including within processor 50.
      <br/>
      Processor 50 may communicate with a memory controller 440 through a processor bus 442.
      <br/>
      Memory controller 440 may communicate with main memory 446 and peripherals 448 through buses 452 and 454 (which may be a PCI bus).
    </p>
    <p num="168">
      A pipeline similar to pipeline 108 or 308 (in FIGS. 2 and 3) could be used in a processor that does not use register renaming.
      <br/>
      In such a case, the components that are involved in register renaming (e.g., rename/allocate unit 150) could be modified to remove renaming related features.
    </p>
    <p num="169">
      The circuits and details that are described and illustrated are only exemplary.
      <br/>
      Various other circuits and details could be used in their place.
      <br/>
      Further, there may be various design tradeoffs in size, latency, etc.
      <br/>
      For example, the maximum operating clock frequency may have to be reduced if buffers in the execution path (e.g., in the reservation station, register file, ROB) are too large.
      <br/>
      The components illustrated herein may be designed and constructed accordingly to various techniques.
    </p>
    <p num="170">
      There may be intermediate structure (such as a buffer) or signals between two illustrated structures.
      <br/>
      Some conductors may not be continuous as illustrated, but rather be broken up by intermediate structure.
      <br/>
      The borders of the boxes in the figures are for illustrative purposes.
      <br/>
      An actual device would not have to include components with such defined boundaries.
      <br/>
      The relative size of the illustrated components is not to suggest actual relative sizes.
      <br/>
      Arrows shown certain data flow in certain embodiments, but not every signal, such as data requests.
      <br/>
      Where a logical high signal is described above, it could be replaced by a logical low signal and vice versa.
    </p>
    <p num="171">
      The components illustrated in a processor may all be on the same processor chip.
      <br/>
      Alternatively, for example, the trace buffers could be on a different chip than the execution pipeline.
    </p>
    <p num="172">
      The terms "connected," "coupled," and related terms are not limited to a direct connection or a direct coupling, but may include indirect connection or indirect coupling.
      <br/>
      The term "responsive" and related terms mean that one signal or event is influenced to some extent by another signal or event, but not necessarily completely or directly.
      <br/>
      If the specification states a component "may", "could", or is "preferred" to be included, that particular component is not required to be included.
    </p>
    <p num="173">A MOB could use data matching rather than address matching to detect misspeculation.</p>
    <p num="174">
      Those skilled in the art having the benefit of this disclosure will appreciate that many other variations from the foregoing description and drawings may be made within the scope of the present invention.
      <br/>
      Accordingly, it is the following claims including any amendments thereto that define the scope of the invention.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A processor comprising:</claim-text>
      <claim-text>an execution pipeline to concurrently execute at least portions of threads; detection circuitry to detect speculation errors involving thread dependencies in the execution of the threads caused by misspeculated instructions; trace buffers outside the execution pipeline to hold instructions of the threads including the misspeculated instructions;</claim-text>
      <claim-text>and triggering logic to identify at least some of the instructions, if any, as being dependent on at least one of the misspeculated instructions and to trigger re-execution of the misspeculated instructions and at least some of the identified dependent instructions, if any.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The processor of claim 1, wherein the triggering logic triggers replay of the misspeculated instructions.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The processor of claim 1, wherein at least part of the detection circuitry is included within the trace buffers.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The processor of claim 1, wherein each of the trace buffers includes an instruction queue to hold at least some of the instructions of one of the threads and wherein the re-executed dependent instructions for a particular one of the misspeculated instructions may be in more than one of the trace buffers.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The processor of claim 4, further comprising final retirement logic to control final retirement of the instructions in the trace buffers and wherein some of the instructions may be initially retired following execution in the execution pipeline.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The processor of claim 1, further comprising a decoder and wherein the execution pipeline and the trace buffers receive instructions from the decoder concurrently.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The processor of claim 1, wherein the detection circuitry includes: register content comparing circuitry;</claim-text>
      <claim-text>and address comparing circuitry.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The processor of claim 1, further comprising thread management logic and program counters to create the threads under the control of the thread management logic.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The processor of claim 8, further comprising final retirement logic to finally retire the threads according to a retirement order developed by the thread management logic.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The processor of claim 1, wherein the speculation errors involving thread dependencies include dependency speculation errors and data speculation errors.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The processor of claim 1, further comprising a decoder and a cache, and wherein the cache and the execution pipeline receive instructions from the decoder concurrently.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The processor of claim 1, further comprising thread management logic to control creation of the threads, the thread management logic including a structure to specify a program order of the threads and wherein the thread management logic controls creation of the threads out of program order and without regard to thread dependencies.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The processor of claim 12, wherein the structure is a tree structure.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The processor of claim 12, wherein the thread management logic controls dynamic creation of the threads.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The processor of claim 1, further comprising thread management logic to control creation of the threads, the thread management logic including a structure to specify an end point of one of the threads by indicating a starting instruction of another one of the threads.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The processor of claim 1, further comprising thread management logic to control creation of the threads, the thread management logic including a structure to keep track of the threads and to remove a representation of one of the threads from the structure to make room for a representation of a thread higher in program order to join the structure.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The processor of claim 1, further comprising thread management logic to control creation of the threads, the thread management logic including a structure to keep track of the threads and to remove a representation of one of the threads from the tree structure when a program counter of its parent thread is outside a range between a start count and an end count.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The processor of claim 1, further comprising thread management logic to control creation of the threads, the thread management logic including a structure to indicate resources including one of the trace buffers that is available and resources including one of the trace buffers that is to be deallocated.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The processor of claim 1, further comprising thread management logic to control creation of threads and wherein following retirement of a thread, the thread management logic allocates resources including one of the trace buffers used for the retired thread to a thread youngest in program order.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The processor of claim 19, further comprising thread management logic to control creation of threads and wherein the thread management logic controls creation of at least one of the threads based on instructions that expressly demarcate the beginning and ending of the thread.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The processor of claim 1, wherein the trace buffers hold results of at least some of the instructions.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The processor of claim 1, wherein the processor is in a computer system.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The processor of claim 22, wherein the computer system is a multi-processor computer system.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A processor comprising: thread management logic; program counters to create threads under the control of the thread management logic, wherein the threads are created out of program order without regard to thread dependencies; an execution pipeline to concurrently execute at least portions of the threads; detection circuitry to detect a speculation error involving a thread dependency in the execution of the threads caused by a misspeculated instruction; trace buffers outside the execution pipeline to hold instructions of the threads including the misspeculated instruction and results of at least some of the instructions;</claim-text>
      <claim-text>and triggering logic to identify at least some of the instructions, if any, as being dependent on the misspeculated instruction and to trigger re-execution of the misspeculated instruction and at least some of the identified dependent instructions, if any.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The processor of claim 24, wherein the threads are created from instructions of a program originating from off a chip on which the execution pipeline is included.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The processor of claim 24, wherein the triggering logic is replay triggering logic coupled to the detection circuitry to trigger replay of the misspeculated instruction.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The processor of claim 24, further comprising final retirement logic to control final retirement of at least some of the instructions within the trace buffers and wherein some of the instructions may be initially retired following execution in the execution pipeline.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The processor of claim 24, wherein the thread management logic controls dynamic creation of the threads.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. A processor comprising: an execution pipeline to concurrently execute at least portions of threads; detection circuitry to detect speculation errors involving thread dependencies in the execution of the threads caused by misspeculated instructions; trace buffers outside the execution pipeline to hold instructions of the threads including the misspeculated instructions and results of at least some of the instructions;</claim-text>
      <claim-text>and triggering logic to identify at least some of the instructions, if any, as being dependent on at least one of the misspeculated instructions and to trigger re-execution of the misspeculated instructions and at least some of the identified dependent instructions, if any.</claim-text>
    </claim>
  </claims>
</questel-patent-document>