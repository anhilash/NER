<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185556B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185556</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185556</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="23177600" extended-family-id="1237020">
      <document-id>
        <country>US</country>
        <doc-number>09304697</doc-number>
        <kind>A</kind>
        <date>19990504</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09304697</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43171899</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>30469799</doc-number>
        <kind>A</kind>
        <date>19990504</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09304697</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  17/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>707687000</text>
        <class>707</class>
        <subclass>687000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>707718000</text>
        <class>707</class>
        <subclass>718000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>707748000</text>
        <class>707</class>
        <subclass>748000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>707803000</text>
        <class>707</class>
        <subclass>803000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>707812000</text>
        <class>707</class>
        <subclass>812000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>707999002</text>
        <class>707</class>
        <subclass>999002</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>707999003</text>
        <class>707</class>
        <subclass>999003</subclass>
      </further-classification>
      <further-classification sequence="7">
        <text>707999004</text>
        <class>707</class>
        <subclass>999004</subclass>
      </further-classification>
      <further-classification sequence="8">
        <text>707999005</text>
        <class>707</class>
        <subclass>999005</subclass>
      </further-classification>
      <further-classification sequence="9">
        <text>707999009</text>
        <class>707</class>
        <subclass>999009</subclass>
      </further-classification>
      <further-classification sequence="10">
        <text>707999102</text>
        <class>707</class>
        <subclass>999102</subclass>
      </further-classification>
      <further-classification sequence="11">
        <text>707999202</text>
        <class>707</class>
        <subclass>999202</subclass>
      </further-classification>
      <further-classification sequence="12">
        <text>707E17005</text>
        <class>707</class>
        <subclass>E17005</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/30551</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30551</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130816</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/30377</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30377</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130816</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99932</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99932</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99933</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99933</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99934</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99934</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="6">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99935</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99935</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="7">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99939</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99939</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="8">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99943</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99943</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="9">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99953</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99953</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>29</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>5</number-of-drawing-sheets>
      <number-of-figures>5</number-of-figures>
      <image-key data-format="questel">US6185556</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and apparatus for changing temporal database</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>ROBINSON IAN N, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4748439</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4748439</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>BRUNVAND ERIC L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4924435</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4924435</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>SHIBAMIYA AKIRA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4956774</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4956774</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>TURTLE HOWARD R</text>
          <document-id>
            <country>US</country>
            <doc-number>5265065</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5265065</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>TURTLE HOWARD R</text>
          <document-id>
            <country>US</country>
            <doc-number>5418948</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5418948</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>ELMASRI RAMEZ A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5440730</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5440730</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>BORDEN TERRY L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5495606</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5495606</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>HUANG DANIEL T, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5574900</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5574900</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>LEVY ALON Y, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5600831</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5600831</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>CHADHA ATUL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5706495</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5706495</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="11">
          <text>BARBARA DANIEL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5710916</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5710916</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="12">
          <text>BURROWS MICHAEL</text>
          <document-id>
            <country>US</country>
            <doc-number>5745899</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5745899</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="13">
          <text>IBM</text>
          <document-id>
            <country>EP</country>
            <doc-number>0855656</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-855656</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Elmasri, Ramez et al., "Partitioning of Time Index for Optical Disks", Proceedings Eighth International Conference on Data Engineering, 1992., Feb. 2-3, 1992, ISBN: 0-8186-2545-7, pp. 574-583.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Elmasri, Ramez et al., "A Temporal Model And Query Language For ER Databases", Proceedings Sixth International Conference on Data Engineering, 1990, Feb. 5-9, 1990, ISBN: 0-8186-2025-0, pp. 76-83.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Schikuta, Erich et al., "A Knowledge Base for the Optimization of Parallel Query Execution Plans", Proceedings Third International Symposium on Parallel Architectures, Algorithms, and Networks, 1997. (I-SPAN '97), Dec. 18-20, 1997, ISBN: 0-8186-8259-6, pp. 331-337.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>Wu, Chao-Hui et al., "Querying Multimedia Presentations", Proceedings IEEE Conference on Protocols for Multimedia Systems-Multimedia Networking, 1997., Nov. 24-27, 1997, ISBN: 0-8186-7916-6, pp. 64-73.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Amazon.com, Inc.</orgname>
            <address>
              <address-1>Seattle, WA, US</address-1>
              <city>Seattle</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>AMAZON COM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Snodgrass, Richard T</name>
            <address>
              <address-1>Tucson, AZ, US</address-1>
              <city>Tucson</city>
              <state>AZ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Bair, John</name>
            <address>
              <address-1>Superior, CO, US</address-1>
              <city>Superior</city>
              <state>CO</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Gotlieb, Charles E.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Choules, Jack M.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>GRANTED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method and apparatus accepts a query to update or delete rows in a temporal table of a database.
      <br/>
      The query may describe which rows are to be updated, a calculation for the value to be used to update each row of the table, and a period of validity, during which the changes are to take place.
      <br/>
      The method and apparatus creates a sequence of queries and SQL program elements that together can make up an SQL program that will execute the query received.
      <br/>
      The SQL program can split any row of the table to be updated into multiple rows so that each of the multiple rows of the table to be changed have an effective period during which no changes occur in the table to be changed or any other tables referenced in the query received and no effective periods span the beginning or the end of the period of validity.
      <br/>
      The specified change may then be made to the resulting rows, and rows that are adjacent in time with identical values may be collapsed into a single row.
      <br/>
      The result is inserted into the table to be changed and the corresponding original rows in the table to be changed are deleted.
      <br/>
      The method and apparatus operates for queries received to update or delete a table.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>RELATED APPLICATIONS</heading>
    <p num="1">
      The subject matter of this application is related to, and is a continuation-in-part-of, the subject matter of application Ser.
      <br/>
      No. 08/900,181 entitled, "Method and Apparatus for Producing Sequenced Queries" filed on Jul. 25, 1997 by John Bair and Richard Snodgrass having the same assignee as this application and incorporated herein by reference in its entirety.
    </p>
    <heading>FIELD OF THE INVENTION</heading>
    <p num="2">The present invention is related to computer software and more specifically to computer database software.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="3">
      A collection of information is a database.
      <br/>
      Some databases logically organize data in a specific way.
      <br/>
      Data may be stored in tables, with each table containing one or more rows and one or more columns.
      <br/>
      Each column stores a particular type of data and the columns of each row are logically related.
      <br/>
      For example, an employee database may have information in each row related to a particular employee, with each row containing three columns.
      <br/>
      One column may hold social security numbers, another column may hold names and the third column may hold the grade of the employee.
      <br/>
      Thus, each row contains each of the three pieces of information for each employee.
    </p>
    <p num="4">
      In some cases, databases use multiple tables.
      <br/>
      For example, to track personnel records in a company, the table of employee information described above may be used in conjunction with a different table containing information about available positions.
      <br/>
      A third table relates the first two tables, describing the position each employee holds.
      <br/>
      For example, a company may have two managers and five other employees having the position of line employee.
      <br/>
      There are a total of seven employees in the employee table, and two positions in the position table: manager and line employee.
      <br/>
      A third table can relate each of the seven employees to one of the two available positions.
    </p>
    <p num="5">
      As information stored in the database changes, some databases replace the outdated information with the most up-to-date information.
      <br/>
      In such databases, outdated information may be lost forever once replaced.
      <br/>
      For example, if an employee is promoted to manager, the third table that relates employees to positions can be changed to show the employee in the new position, replacing any evidence in the table that the employee was ever a line employee.
    </p>
    <p num="6">
      Other databases are temporal databases, which can retain outdated information along with the up-to-date information.
      <br/>
      The outdated information is stored in a different row from the current information.
      <br/>
      For example, the table that relates employees to positions may have seven rows before the promotion, one for each employee.
      <br/>
      When the promotion occurs, a new eighth row is added relating the employee to the new position while retaining the row that also relates the employee to his or her old position.
    </p>
    <p num="7">
      The information in one or more tables of a temporal database has one or more date columns to identify the period the information in a particular row is or was valid.
      <br/>
      For example, the table relating employees to positions may have two date columns, a start date and an stop date for the row.
      <br/>
      When the employee is promoted to manager, the row relating the employee to a line-employee position has the start date as the hire date of the employee.
      <br/>
      The day he or she is promoted is inserted into the stop date, and a new row is added in the table relating employees to positions which contains an identifier of the employee and an identifier of the manager position.
      <br/>
      In addition, the start date contains the date of the employees first day as a manager.
      <br/>
      Because the table relating employees to positions now has two rows for the promoted employee, the table may be used to retrieve historical information, such as how many line employees the company had before the date of the employee's promotion to manager.
    </p>
    <p num="8">
      Information may be retrieved from a database using a query.
      <br/>
      A query is any command that retrieves information from a database.
      <br/>
      Some commercially available database products such as the Oracle8 database product commercially available from Oracle Corporation of Redwood Shores, California interpret queries that conform to a standard query language called Structured Query Language, or SQL.
      <br/>
      Each database product may also allow certain variations from the SQL standard.
      <br/>
      To retrieve information from a database that implements SQL queries, a user of the database provides a query containing a "select" command and a description of the data the user desires to retrieve.
      <br/>
      The database product retrieves from the tables specified in the query the specified data for the user.
    </p>
    <p num="9">
      Queries may also be used to change information in a database.
      <br/>
      The user can provide a query containing an update command, a criteria for the data to be updated and a description of how the data to be updated is to be changed.
      <br/>
      The database program retrieves the specified data, changes it, and stores it back into the database.
      <br/>
      Other queries can insert or delete data in one or more tables.
    </p>
    <p num="10">
      SQL commands to change a database make data manipulation simpler for the user than it might otherwise be.
      <br/>
      However, SQL commands to change data in a temporal database can be much more complex to structure than queries for non-temporal databases because the data in temporal databases changes over time.
      <br/>
      A conventional SQL update command may not work properly because a conventional SQL update command assumes the data in all tables is static over time.
      <br/>
      However, commands to change a temporal database ordinarily need to take the time-varying nature of the data into account.
    </p>
    <p num="11">
      To update with a new value or values in a set of rows in a table that meet a specified criteria that are applicable during a particular period may not be possible using a conventional SQL command for several reasons.
      <br/>
      A single row may only meet the specified criteria for part of the time the row is applicable.
      <br/>
      The particular period may start or stop between the start date and stop date of one or more rows, causing a portion of any row to be within the particular period and another portion of the same row to be outside of the particular period.
      <br/>
      The new value specified may be undefined over some portion of the time one or more rows are applicable.
    </p>
    <p num="12">
      Although performing an update for a non-temporal database can often be performed using a single SQL update command, updating data in temporal databases is more complex for the reasons described above.
      <br/>
      It is not possible to provide a single SQL update command that appropriately deals with the special cases above.
      <br/>
      The task is sufficiently complex that a typical end user cannot perform it using even a few SQL commands.
      <br/>
      In many cases, a programmer is required to create an SQL program that can handle the complexity required to perform the update properly for the reasons described above.
      <br/>
      What is needed is a method and apparatus that can accept for a temporal database a command similar to an SQL update command for a non-temporal database, and cause the temporal database to be updated as specified in the command.
    </p>
    <heading>SUMMARY OF INVENTION</heading>
    <p num="13">
      A method and apparatus temporally updates one or more tables according to a command that can be similar to a conventional SQL "UPDATE" command, that specifies a period of validity, specifies criteria for the table to be updated and specifies the update values with which to update the table.
      <br/>
      The command is intercepted by the method and apparatus and one or more queries and SQL program elements are substituted in place of the command.
      <br/>
      The queries and SQL program elements will, when submitted to a conventional database product, perform the command.
      <br/>
      The user need only generate a single SQL command, and is therefore freed from dealing with the complexity of converting a temporal command into the series of conventional queries and SQL program elements that would otherwise be required.
      <br/>
      The queries will identify periods of constant data over the period of applicability in either the table to be updated or the tables used to calculate the values that will be used to update the table, or both.
      <br/>
      The SQL program elements will use the result of the queries to potentially split each row in the table to be updated that is within the period of applicability into multiple rows if the row in the table to be updated spans more than one of the constant periods.
      <br/>
      Because during the effective dates of each of the resulting rows of the table to be changed, the values of the table to be changed and the values of any tables used to calculate changed values will be static, conventional SQL program elements may be used to change the values of the table to be changed.
      <br/>
      These program elements are generated, and the queries and all SQL program elements may be submitted to a conventional database product to change the values according to the command received.
      <br/>
      The method and apparatus also intercepts other commands to change a temporal database, such as those similar to conventional SQL "DELETE" and INSERT" commands, and generates conventional SQL commands to perform delete and insert functions using a subset of the techniques used to perform updates described above.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="14">
      FIG. 1 is a block schematic diagram of a conventional computer system.
      <br/>
      FIG. 2 is a block schematic diagram of an apparatus for intercepting a command to change a temporal database and substituting a series of queries and SQL program elements that, when executed by a conventional database product, will perform the command according to one embodiment of the present invention.
      <br/>
      FIG. 3A is a flowchart illustrating a method of intercepting a command to change a temporal database and substituting a series of queries and SQL program elements that, when executed by a conventional database product, will perform the command according to one embodiment of the present invention.
      <br/>
      FIG. 3B is a flowchart illustrating a method of intercepting a command to delete from a temporal database and substituting a series of queries and SQL program elements that, when executed by a conventional database product, will perform the command according to one embodiment of the present invention.
      <br/>
      FIG. 3C is a flowchart illustrating a method of selecting between the methods of FIGS. 3A and 3B according to one embodiment of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT</heading>
    <p num="15">
      The present invention may be implemented as computer software on any number of conventional computer systems in intercommunication, for example using a local area network.
      <br/>
      Referring now to FIG. 1, a conventional computer system 150 for practicing the present invention is shown.
      <br/>
      Processor 160 retrieves and executes software instructions stored in storage 162 such as memory, which may be Random Access Memory (RAM) and may control other components to perform the present invention.
      <br/>
      Storage 162 may be used to store program instructions or data or both.
      <br/>
      Storage 164, such as a computer disk drive or other nonvolatile storage, may provide storage of data or program instructions.
      <br/>
      In one embodiment, storage 164 provides longer term storage of instructions and data, with storage 162 providing storage for data or instructions that may only be required for a shorter time than that of storage 164.
      <br/>
      Input device 166 such as a computer keyboard or mouse or both allows user input to the system 150.
      <br/>
      Output 168, such as a display or printer, allows the system to provide information such as instructions, data or other information to the user of the system 150.
      <br/>
      Storage input device 170 such as a conventional floppy disk drive or CD-ROM drive accepts via input 172 computer program products 174 such as a conventional floppy disk or CD-ROM or other nonvolatile storage media that may be used to transport computer instructions or data to the system 150.
      <br/>
      Computer program product 174 has encoded thereon computer readable program code devices 176, such as magnetic charges in the case of a floppy disk or optical encodings in the case of a CD-ROM which are encoded as program instructions, data or both to configure the computer system 150 to operate as described below.
    </p>
    <p num="16">
      In one embodiment, any number of computer systems 150 may be used to implement the present invention.
      <br/>
      In one embodiment, each computer system 150 is a conventional Sun Microsystems Ultra 1 Creator computer system running the Solaris 2.5.1 operating system commercially available from Sun Microsystems of Mountain View, Calif., although other systems may be used.
    </p>
    <p num="17">
      Referring now to FIG. 2, an apparatus for converting queries that are intended to change data in the database into queries capable of execution by a conventional database product 210 is shown according to one embodiment of the present invention.
      <br/>
      The database product 210 is any conventional database product that can change data in a database such as the conventional Oracle8 product commercially available from Oracle Corporation of Redwood Shores, Calif.
      <br/>
      In one embodiment, the present invention intercepts queries and commands intended for a conventional database product 210 that can execute queries, and provides only the queries and program statements described below in place of the query or command it receives, and in another embodiment, the present invention is integrated with such database product 210.
      <br/>
      Database product 210 stores the data in the database in database storage 208, which is any storage device such as disk or memory.
    </p>
    <p num="18">A. Receipt and Routing of the Query</p>
    <p num="19">
      In one embodiment, a query router 214 receives the query and identifies if it should be processed by the present invention by looking at the type of table on which the query will operate and the command in the query as described below.
      <br/>
      If the type of the table is temporal and the command in the query is an update, insert or delete command, query router 214 sends the query to query storage 212 and sends all other types of queries to database product 210.
      <br/>
      In another embodiment, query router 214 routes certain types of other queries to other apparati.
      <br/>
      For example, queries that select data from temporal tables may be routed by query router 214 to the apparatus described in copending application "METHOD AND APPARATUS FOR PRODUCING SEQUENCED QUERIES", Ser.
      <br/>
      No. 08/900,181.
    </p>
    <p num="20">
      Query storage 212 stores the query received from query router 214.
      <br/>
      The query may take any form.
      <br/>
      One example of a query that will be used for example purposes herein is as follows, however the present invention operates with any type and format of query:
    </p>
    <p num="21">
      --
      <br/>
      --      VALIDTIME PERIOD `�01-JAN-96-01-JAN-97)` UPDATE
      <br/>
      --      Incumbents I
      <br/>
      --      SET PCN = (SELECT PCN FROM Positions P
      <br/>
      --                  WHERE P.JTC = `C` AND P.D = I.D)
      <br/>
      --      WHERE SSN IN (SELECT SSN FROM Employees E
      <br/>
      --      WHERE B = `B` AND E.G = I.G); (Query 1)
    </p>
    <p num="22">
      Query 1 contains four portions.
      <br/>
      The first portion "VALIDTIME PERIOD `�01-JAN-96 - 01-JAN-97)" describes the time period over which the query is to operate, and is referred to as the "period of applicability" of the query received by query router 214 at input 213.
      <br/>
      The square bracket to the left of the first date signifies the period starts at the beginning of Jan. 1, 1996 and the curved bracket or parenthesis to the right of the second date signifies that the period ends at the end of the day before Jan. 1, 1997. Either type of bracket may be used in either position according to the present invention, with the appropriate modifications to the techniques described herein, such as is described in the parent application.
    </p>
    <p num="23">As used herein, dates are used to define periods, although any other indication of time may also be used.</p>
    <p num="24">
      The second portion of Query 1 is the command "UPDATE Incumbents I" which provides instructions to make changes to the table named "Incumbents" and save the changes back into the Incumbents table.
      <br/>
      The Incumbents table is the temporal table described above that relates employees to positions and contains effective dates of those relationships.
    </p>
    <p num="25">
      The third portion of Query 1 is the "SET" clause, "SET PCN = (SELECT PCN FROM Positions P WHERE P.JTC =`C` AND P.D = I.D)", describing how to change the Incumbents table.
      <br/>
      It states that the position category of the Incumbents table is to be changed to the corresponding row of a single column table constructed using the select clause to the right of the equals sign.
    </p>
    <p num="26">
      The fourth portion of Query 1 is the "WHERE" clause, "WHERE SSN IN (SELECT SSN FROM Employees E WHERE B = `B` AND E.G = I.G)", describing which rows of the Incumbents table are to be updated.
      <br/>
      Only those rows of the Incumbents table having a social security number in the set of social security numbers for employees having a name of `B` and a grade equal to the grade of the current row of the Incumbents table are updated.
    </p>
    <p num="27">
      When query router 214 passes the query to query storage 212, query router 214 signals the where table creator 220, where table optimizer 222, where constant set builder 224, set table creator 230, set table optimizer 232, set constant set builder 234, cursor creator 240, set columns before retainer 244, set columns after retainer 246, where predicate false values retainer 248, set false values retainer 250, values setter 252, Tg normalizer 254 and replace/update 256, each described in more detail below.
      <br/>
      The where table creator 220, where table optimizer 222, where constant set builder 224, set table creator 230, set table optimizer 232, set constant set builder 234, cursor creator 240, set columns before retainer 244, set columns after retainer 246, where predicate false values retainer 248, set false values retainer 250, values setter 252, Tg normalizer 254 and replace/update 256, each creates a portion of an SQL program that, when executed by database product 210 using data stored in a database 208, will cause database product 210 to perform the update indicated in the UPDATE statement or other type of command received.
    </p>
    <p num="28">B. Four Basic Components</p>
    <p num="29">
      The apparatus of the present invention includes four basic components.
      <br/>
      The first component 201 builds queries that, when executed by database product 210, will generate temporary tables to allow other components of the apparatus of the present invention to operate efficiently.
      <br/>
      The second component 202 provides code referred to as SQL program elements that, when executed by database product 210, will build a temporary table to hold values of the table that do not correspond to the criteria specified above and are therefore not to be updated.
      <br/>
      The temporary table built has rows corresponding to the rows of the table to be updated that are at least partially within the period of applicability of the temporal update statement.
      <br/>
      However, the SQL program elements executed build the temporary table in such a manner that each row of the table to be updated can correspond to multiple rows in the temporary table.
      <br/>
      The second component 202 of the present invention converts rows of the table to be updated into multiple rows in the temporary table corresponding to: 1) any portion of the effective period of the row that is outside the period of applicability of the update statement, 2) portions of the effective period of the row during which the WHERE clause of the temporal update statement is false and 3) portions of the effective period of the row during which the WHERE clause of the temporal update statement is true but the SET clause has no value.
      <br/>
      In the rows of the temporary tables corresponding to each of these portions, no new values are set by the apparatus of the present invention, and the rows in the temporary table have all the values (except the StartDate and StopDate) they had of the row prior to execution of the temporal update statement.
      <br/>
      A third component 203 of the apparatus of the present invention creates SQL program elements that will create any additional rows in the temporary table corresponding to periods of the original row in the table to be updated not covered by periods 1-3 above, calculate the values to set according to the temporal update statement and set the columns of each of these remaining rows to the values.
      <br/>
      The fourth component 204 of the present invention collapses rows in the temporary table with adjacent rows that have identical values in each column except for the StartDate and StopDate, and inserts the collapsed temporary table into the table to be updated in place of the row corresponding to the row or rows inserted.
    </p>
    <p num="30">C. Building of the Table of Dates from the WHERE Clause</p>
    <p num="31">
      When the where table creator 220 receives the signal from query router 214, the where table creator 220 creates a query that will produce a table containing a list of effective dates for each row in the table to be updated as well as any other table referenced in the fourth portion (the WHERE clause) of the query stored in query storage 212.
      <br/>
      In one embodiment, the where table creator 220 receives, for example in response to a request it provides to query storage 212, the first, second and fourth portions of the query stored in query storage 212.
    </p>
    <p num="32">
      The where table creator 220 builds one or more queries to create the list of dates.
      <br/>
      A temporary table Ta is defined in the query built by the where table creator 220 to store the list described in more detail below.
    </p>
    <p num="33">
      The where table creator 220 builds one or more queries that will cause all StartDates and StopDates within the period of applicability to be placed in a temporary table referred to as Ta.
      <br/>
      In one embodiment, the where table creator 220 builds the one or more queries in stages as described below.
    </p>
    <p num="34">In response to Query 1, the where table creator 220 builds the following query to create the table Ta and populate it with StartDates from the table being updated in the query stored in query storage 212 provided the StartDates are within the period of applicability:</p>
    <p num="35">
      --
      <br/>
      -- CREATE TABLE Ta
      <br/>
      -- UNRECOVERABLE AS SELECT StartDate AS This FROM Incumbents
      <br/>
      -- I
      <br/>
      -- WHERE SSN IN (SELECT SSN FROM Employees E
      <br/>
      --        WHERE B = `B` AND E.G = I.G
      <br/>
      --         AND E.StartDate &lt; I.StopDate
      <br/>
      --         AND I.StartDate &lt; E.StopDate)
      <br/>
      --      AND `01-JAN-96` &lt; I.StartDate AND I.StartDate &lt;
      <br/>
      -- `01-JAN-97`;                   (Query 2a)
    </p>
    <p num="36">
      Query 2a references StartDates and StopDates.
      <br/>
      In one embodiment, it is assumed that every row in every table referenced in the query stored in query storage 212 contains two columns, a StartDate column containing the start date of the row, and a StopDate column, containing the stop date of the row.
      <br/>
      The data in the row is assumed valid between the StartDate and the StopDate of the row as described above.
      <br/>
      This is the effective period for the row.
    </p>
    <p num="37">
      As used herein, a query can include conventional query commands as well as other SQL commands or statements.
      <br/>
      SQL is explained in Harrington, SQL Clearly Explained, (AP Professional 1998), ISBN 0-12-326426-X.
    </p>
    <p num="38">
      The where table creator 220 reads the query in query storage 212 and builds the query such as Query 2a as follows: The first line is provided as shown above in Query 2a.
      <br/>
      The second line is provided as shown in Query 2a, with the name and alias of the table to be updated in the first portion of the query stored in query storage 212 substituted in place of "Incumbents I".
      <br/>
      The word "WHERE" is inserted at the start of line 3, and the criteria of the WHERE clause in lines 3-4 is copied from the fourth portion of the query stored in query storage 212.
      <br/>
      Additional limitations are added to the limitations of the fourth portion of the query stored in query storage 212.
      <br/>
      If the limitation in the query stored in query storage 212 is a set operation such as "IN", the additional limitations added go inside the set operation as shown.
      <br/>
      Those limitations provide that the StartDate of the rows selected from all tables referenced in the fourth portion of the query are before the StopDate of the current row of the table being updated in the query stored in query storage 212, and that the StopDate of the rows selected from the tables referenced in such fourth portion are after the StartDate of the current row of the table being updated in the query stored in query storage 212.
    </p>
    <p num="39">
      Next, the where table creator 220 adds a limitation to the WHERE clause it creates to match the first portion of the query stored in query storage 212.
      <br/>
      If there is no such portion specified, an unlimited period of validity is assumed in the query and the where table creator 220 does not add the limitation to the WHERE clause (and similar limitations described below are also not added).
      <br/>
      In the example query of Query 1, the limitation "AND `01-JAN-96` &lt; I.StartDate AND I.StartDate &lt; `01-JAN-97`" is added to match the first portion of Query 1 to enforce the period of applicability specified in Query 1.
    </p>
    <p num="40">
      In one embodiment, specifying table Ta as UNRECOVERABLE causes the table to be created as a local table, stored on the client rather than the server in a client-server system.
      <br/>
      However, it is not strictly necessary and the keyword `UNRECOVERABLE` may be omitted.
      <br/>
      Other queries described below may also use the UNRECOVERABLE keyword in the same manner to cause tables to be generated locally.
      <br/>
      The where table creator 220 adds the StopDates within the period of applicability from the table to be updated to temporary table Ta by appending to Query 2a an additional query described below.
      <br/>
      For Query 1, the additional query appended is the following query:
    </p>
    <p num="41">
      --
      <br/>
      --      INSERT INTO Ta
      <br/>
      --      SELECT StopDate FROM Incumbents I
      <br/>
      --      WHERE SSN IN (SELECT SSN FROM Employees E
      <br/>
      --           WHERE B = `B` AND E.G = I.G
      <br/>
      --             AND E.StartDate &lt; I.StopDate)
      <br/>
      --             AND I.StartDate &lt; E.StopDate)
      <br/>
      --        AND `01-JAN-96` &lt; I.StopDate AND I.StopDate &lt; `01-JAN-
      <br/>
      --      97`;                      (Query 2b)
    </p>
    <p num="42">
      Query 2b is built by the where table creator 220 in the same manner as Query 2a described above, specifying selection of StopDates instead of StartDates.
      <br/>
      If only StartDates are used in the table to be updated in the query stored in query storage 212, StopDates may be calculated by identifying the day of the next StartDate, if such next StartDate exists.
      <br/>
      If only StopDates are used, the StartDate may be calculated as the day of the preceding StopDate, if such date exists.
    </p>
    <p num="43">
      Next, the where table creator 220 adds a query that causes to be inserted into table Ta the start and stop dates for any other tables referenced in the WHERE clause of the original query stored in table storage 212.
      <br/>
      The where table creator 220 provides this query which selects the StartDate from any referenced table, using only the portions of the WHERE clause in the fourth portion of the query stored in query storage 212 that concern one table that does not involve the table to be changed and adding in the period of applicability limitation to the where clause from the first portion of the query stored in query storage 212 as described above with reference to Query 2b.
      <br/>
      For Query 1, that query is:
    </p>
    <p num="44">
      --
      <br/>
      --        INSERT INTO Ta
      <br/>
      --        SELECT StartDate FROM Employees E
      <br/>
      --        WHERE B = `B`
      <br/>
      --           AND `01-JAN-96` &lt; E.StartDate AND E.StartDate &lt;
      <br/>
      --        `01-JAN-97`;     (Query 2c)
    </p>
    <p num="45">Stop dates are also added to the table Ta by executing the query created by where table creator 220, which uses the same approach as Query 2c described above with the additional date limitation in the last line similar to that of query 2b described above:</p>
    <p num="46">
      --
      <br/>
      --        INSERT INTO Ta
      <br/>
      --        SELECT StopDate FROM Employees E
      <br/>
      --        WHERE B = `B`
      <br/>
      --           AND `01-JAN-96` &lt; E.StopDate AND E.StopDate &lt;
      <br/>
      --        `01-JAN-97`;     (Query 2d)
    </p>
    <p num="47">Had additional tables been referenced in the where clause, the where table creator 220 would build additional queries similar to Queries 2c and 2d using the technique described above or the additional queries can be combined into a smaller number of queries.</p>
    <p num="48">Finally, the where table creator 220 creates additional statements that, when executed by database product 210, will insert into table Ta the endpoints of the period of applicability from the first portion of the original query:</p>
    <p num="49">
      --
      <br/>
      --             INSERT INTO Ta VALUES (`01-JAN-96`) (Query 2e)
      <br/>
      --             INSERT INTO Ta VALUES (`01-JAN-97`) (Query 2f)
    </p>
    <p num="50">
      In another embodiment, to create the queries created by where table creator 220, in place of a SELECT followed by multiple INSERTS, a single query using multiple UNION SELECTS having the WHERE criteria described above are used by where table creator 220.
      <br/>
      Union selects eliminate any duplicate values from the table Ta.
    </p>
    <p num="51">Where table creator 220 provides the queries it builds to assembler 260, described below.</p>
    <p num="52">
      If union selects are not used, a where table optimizer 222 may optionally be employed to eliminate duplicate entries from table Ta.
      <br/>
      The where table optimizer 222 generates the following query in response to the signal from query router 214:
    </p>
    <p num="53">
      --
      <br/>
      --               CREATE TABLE Ta2 (This DATE);
      <br/>
      --               INSERT INTO Ta2
      <br/>
      --                SELECT DISTINCT * FROM Ta;   (Query 3a)
    </p>
    <p num="54">
      In the embodiments in which the where table optimizer 222 is used, the operation of the apparatus of the present invention may be more efficient because the query generated by where table optimizer 222 not only eliminates duplicate entries, but may also sort the entries.
      <br/>
      The where table optimizer 222 provides the query it builds to assembler 260.
      <br/>
      Although the description below assumes that the where table optimizer 222 is employed, if it is not employed, references to Ta2 may be replaced with Ta.
    </p>
    <p num="55">
      A where constant set builder 224 builds the following query that, when executed by database product 210, will create a table of StartDates and StopDates from table Ta2 that define a constant set in response to the signal from query router 214.
      <br/>
      A "constant set" is a table containing rows, with each row containing a StartDate and a StopDate, between which all of the tables referenced in the WHERE clause of the query stored in query storage 212 do not contain changes.
      <br/>
      The where constant set builder 224 builds the following query:
    </p>
    <p num="56">
      --
      <br/>
      --      CREATE TABLE Tb(StartDate DATE, StopDate DATE);
      <br/>
      --      INSERT INTO Tb
      <br/>
      --      SELECT T1.This, T2.This
      <br/>
      --      FROM Ta2 T1, Ta2 T2
      <br/>
      --      WHERE T1.This &lt; T2.This
      <br/>
      --         AND NOT EXISTS (SELECT * FROM Ta2 T3
      <br/>
      --                          WHERE T1.This &lt; T3.This AND
      <br/>
      --      T3.This &lt; T2.This)          (Query 3b)
    </p>
    <p num="57">Where constant set builder 224 passes the Query 3b to assembler 260.</p>
    <p num="58">D. Building the table of Dates from the Set Clause.</p>
    <p num="59">
      When signaled by query router 214, set table creator 230 creates queries that, when executed by database product 210, will generate a table of dates that include certain StartDates and StopDates from the tables referenced in the third portion of the query stored in query storage 212, the SET clause.
      <br/>
      The StartDates in the table that set table creator 230 creates are those corresponding to rows in each table referenced in the set clause of the query stored in query storage 212 that meet the first two of the following criteria and optionally meets the third of the following criteria:
    </p>
    <p num="60">
      1.
      <br/>
      The row meets all of the criteria for the table in the SET clause of the query stored in query storage 212 that are independent of the table being updated;
      <br/>
      2.
      <br/>
      The row has start dates that are within in the period of applicability;
      <br/>
      3.
      <br/>
      At least one row in the table being updated meets the following criteria: of the rows in the other tables referenced in the WHERE clause of the query stored in query storage 212 that meet the criteria of the WHERE clause in the query stored in query storage 212, the StartDate of the row in the referenced table is less than or equal to the StopDate of the row in the table being updated, and the StartDate of the row of the table being updated is less than or equal to the StopDate of the row of the referenced table.
    </p>
    <p num="61">
      The third criteria can sometimes reduce the size of the table built by set table creator 230.
      <br/>
      Therefore, its se is optional to enhance performance of the apparatus shown in FIG. 2.
    </p>
    <p num="62">Using the example of Query 1, set table creator 230 builds the following query:</p>
    <p num="63">
      --
      <br/>
      -- CREATE TABLE Td
      <br/>
      -- UNRECOVERABLE AS SELECT StartDate AS This FROM Positions P
      <br/>
      -- WHERE P.JTC = `C`
      <br/>
      --      AND `01-JAN-96` &lt; StartDate AND StartDate &lt; `01-JAN-97`
      <br/>
      --      AND EXISTS (SELECT * FROM Incumbents I
      <br/>
      --         WHERE SSN IN (SELECT SSN FROM Employees E
      <br/>
      --             WHERE B = `B`
      <br/>
      --             AND E.G = I.G
      <br/>
      --             AND E.StartDate &lt;= I.StopDate
      <br/>
      --             AND I.StartDate &lt;= E.StopDate)
      <br/>
      --             );                                  (Query 4a)
    </p>
    <p num="64">
      In response to the signal from query router 214, set table creator 230 reads the query stored in query storage 212 and creates the query above as follows.
      <br/>
      First, it provides line 1 as shown above in Query 4a, and substitutes the name and alias of a table referenced in the third portion of the query stored in query storage 212.
      <br/>
      Line three contains all conditions of the third portion of the query stored in query storage 212 that are independent of the table to be updated in the query stored in query storage 212.
      <br/>
      Line 4 is provided with the word "AND" and the second portion of the query stored in query storage 212, the period of applicability.
      <br/>
      Optional Line 5 is provided as shown above, with the name and alias of the table to be updated from the query stored in query storage 212 substituted for "Incumbents I".
      <br/>
      Line 5 can reduce the size of table Td, described below.
      <br/>
      Lines 6 through 8 are provided from the fourth portion of the query stored in query storage 212.
      <br/>
      Lines 9 and 10 added before the close parenthesis, ")".
      <br/>
      Lines 9 and 10 are provided as shown with the alias of the table referenced in the fourth portion of the query stored in query storage 212 in place of "E" and the alias or name of the table to be updated in the query stored in query storage 212 substituted in place of "I".
    </p>
    <p num="65">Set table creator 230 generates a query that, when executed by database product 210 will add StopDates to table Td using criteria 1 above and criteria 2 (with the requirement that the StopDate be within the period of applicability instead of the StartDate within the period of applicability) and optionally, criteria 3 above to produce the following Query:</p>
    <p num="66">
      --
      <br/>
      -- INSERT INTO Td
      <br/>
      -- SELECT StopDate FROM Positions P
      <br/>
      -- WHERE P.JTC = `C`
      <br/>
      --        AND `01-JAN-96` &lt; StopDate AND StopDate &lt; `01-JAN-97`
      <br/>
      --      AND EXISTS (SELECT * FROM Incumbents I
      <br/>
      --           WHERE SSN IN (SELECT SSN FROM Employees E
      <br/>
      --             WHERE B = `B`
      <br/>
      --             AND E.G = I.G
      <br/>
      --             AND E.StartDate &lt; I.StopDate
      <br/>
      --             AND I.StartDate &lt; E.StopDate)
      <br/>
      --         );                                    (Query 4b)
    </p>
    <p num="67">Set table creator 230 creates this query as described above with respect to Query 4a, with line 1 provided as shown and the selection of the StopDate in line 2 in place of the StartDate of Query 4a (and the omission of the optional "UNRECOVERABLE" keyword).</p>
    <p num="68">If additional tables are referenced in the SET clause, the third portion of the query stored in query storage 212, one query to add StartDates and another query to add StopDates similar to Queries 4a and 4b for each such referenced table are added by set table creator 230.</p>
    <p num="69">Set table creator 230 generates queries to add to table Td the endpoints of the period of applicability as follows:</p>
    <p num="70">
      --
      <br/>
      --             INSERT INTO Td VALUES (`01-JAN-96`) (Query 4c)
      <br/>
      --             INSERT INTO Td VALUES (`01-JAN-97`) (Query 4d)
    </p>
    <p num="71">Each of queries 4c and 4d are created by providing the queries as shown with the endpoints of the period of applicability of the query stored in query storage 212 substituted in place of "01-Jan-96" and "01-Jan-97".</p>
    <p num="72">Set table creator 230 transmits to assembler 260 queries 4a-4d and the other queries corresponding to StartDates and StopDates of other referenced tables as described above.</p>
    <p num="73">
      As described above with respect to Queries 2a-2d, less than four union selects could have been used in place of the four queries 4a-4d to reduce or eliminate duplicates in table Td.
      <br/>
      Alternatively, an optional set table optimizer 232 may be used to reduce or eliminate duplicates similar to the where table optimizer 222 described above.
    </p>
    <p num="74">
      Set table optimizer 232 is an optional portion of the apparatus and serves to generate a query that, when executed by database product 210, will eliminate duplicate entries in table Td and may also sort the result, and operates similar to where table optimizer 222.
      <br/>
      Set table optimizer 232 creates the following query:
    </p>
    <p num="75">
      --
      <br/>
      --             CREATE TABLE Td2 (This DATE);
      <br/>
      --             INSERT INTO Td2
      <br/>
      --               SELECT DISTINCT * FROM Td      (Query 5a)
    </p>
    <p num="76">Set table optimizer passes this query to assembler 260.</p>
    <p num="77">
      In response to the signal from query router 214, set constant set builder 234 builds a constant set of the tables referenced in the SET clause of the query stored in query storage 212, either using the Td2 table or by creating a new table.
      <br/>
      Using the Td2 table, set constant set builder builds the following query:
    </p>
    <p num="78">
      --
      <br/>
      --      CREATE TABLE Te(StartDate DATE, StopDate DATE);
      <br/>
      --      INSERT INTO Te
      <br/>
      --      SELECT T1.This, T2.This
      <br/>
      --      FROM Td2 T1, Td2 T2
      <br/>
      --      WHERE T1.This &lt; T2.This
      <br/>
      --        AND NOT EXISTS (SELECT * FROM Td2 T3
      <br/>
      --         WHERE T1.This &lt; T3.This AND T3.This &lt; T2.This);
      <br/>
      -- (Query 5b)
    </p>
    <p num="79">Set constant set builder 234 sends Query 5b to assembler 260.</p>
    <p num="80">Because the queries 3a, 3b, 5a, and 5b can be the same for any query stored in query storage 212, these queries may be stored and provided by where table optimizer 222, where constant set builder 224, set table optimizer 232 and set constant set builder 234 instead of being created each time.</p>
    <p num="81">E. Creating the Cursor</p>
    <p num="82">In response to the signal from query router 214, cursor creator 240 retrieves the query stored in query storage 212 and provides a SQL program element that creates a table having the columns listed in the SET clause of the query stored in query storage 212 and a StartDate and a StopDate using the following SQL statement:</p>
    <p num="83">
      --
      <br/>
      -- CREATE TABLE Tg ( PCN NUMBER, StartDate DATE, StopDate
      <br/>
      -- DATE);           (SQL Prog. Element 6)
    </p>
    <p num="84">
      As used herein, a program element is one or more commands containing a query or SQL program code or other similar command.
      <br/>
      Table Tg will be used to hold a single row of the table to be updated in the query stored in query storage 212 as described below.
      <br/>
      A single row of that table may be stored in table Tg as a single row, or prior to storage in table Tg, may be split into several rows and stored in table Tg as several rows as described in more detail below.
    </p>
    <p num="85">
      Cursor creator 240 creates a cursor using the WHERE clause of the query stored in query storage 212 and adding an additional limitation to the IN and an additional limitation to the WHERE clause.
      <br/>
      The limitation to the IN ensures all tables referenced in the WHERE clause of the query stored in query storage 212 have a StartDate that is before the StopDate of the current row of the table being updated and a StopDate after the StartDate of the current row of the table being updated.
      <br/>
      The limitation to the WHERE requires the effective dates of any row added to the cursor to be at least partially within the period of applicability.
      <br/>
      For example, in response to reading Query 1, cursor creator 240 builds the following statement:
    </p>
    <p num="86">
      --
      <br/>
      --      DECLARE
      <br/>
      --      CURSOR IC IS SELECT * FROM Incumbents I
      <br/>
      --      WHERE SSN IN   (SELECT SSN FROM Employees E
      <br/>
      --                     WHERE B = `B` AND E.G = I.G
      <br/>
      --        AND E.StartDate &lt; I.StopDate AND I.StartDate &lt; E.StopDate)
      <br/>
      --        AND I.StartDate &lt; `01-JAN-97` and `01-JAN-96` &lt; I.StopDate
      <br/>
      --      FOR UPDATE OF PCN;
      <br/>
      --      ICrow IC%rowtype:              (SQL Prog. Element 7)
    </p>
    <p num="87">
      Cursor creator creates SQL program element 7 as follows: The first two lines are provided as shown, with "Incumbents I" replaced with the name and alias of the table to be updated in the query stored in query storage 212.
      <br/>
      Lines 3 and 4 are copied from the fourth portion of the query stored in query storage 212.
      <br/>
      Line 5 is provided as shown with "E" replaced with the name of a table other than the table to be updated referenced in the fourth portion of the query stored in query storage 212.
      <br/>
      If multiple tables are so referenced, an additional line is provided within the parenthesis for each additional table so referenced with the name of the referenced table substituted for "E" in that line.
    </p>
    <p num="88">
      Lines 5 and 6 are provided as shown with the exceptions noted herein. "I" in lines 5 (and any additional line or lines similar to line 5 created for additional referenced tables) and 6 are replaced with the name of the table to be updated in the query stored in query storage 212.
      <br/>
      The end of the period of applicability of the query stored in query storage 212 is substituted for "01-Jan-97" and the beginning of the period of applicability of the query stored in query storage 212 is substituted for "01-Jan-96".
    </p>
    <p num="89">
      Line 7 is provided as shown with the name of the column to be updated substituted for "PCN".
      <br/>
      Line 8 is provided as shown.
    </p>
    <p num="90">Cursor creator 240 also creates an SQL program element defining an additional cursor for use as described below using the following program element statements:</p>
    <p num="91">
      --
      <br/>
      --         CURSOR GC IS
      <br/>
      --         SELECT * FROM Tg
      <br/>
      --         ORDER BY StartDate;
      <br/>
      --         GCrow GC%rowtype;
      <br/>
      --         oldPCN NUMBER;     (SQL Prog. Element 8)
    </p>
    <p num="92">
      All lines in SQL Program Element 8 are provided by cursor creator 240 as shown except that the name of the column updated is substituted for "PCN" in the last line.
      <br/>
      If multiple columns are to be set, the last line of SQL Program Element 8 is duplicated once for each such column and added to the end of SQL Program Element 8, with the name of one additional column substituted for "PCN" on that line.
    </p>
    <p num="93">Next cursor creator 240 provides an SQL program element that declares variables for a StartDate, StopDate and an additional variable for each column to be set in the set clause of the query stored in query storage 212, and starts a loop:</p>
    <p num="94">
      --
      <br/>
      --             oldStartDate DATE;
      <br/>
      --             oldStopDate DATE;
      <br/>
      --             multiple NUMBER;
      <br/>
      --             BEGIN
      <br/>
      --             &lt;&lt;ICrowloop&gt;&gt; FOR ICrow IN IC LOOP
      <br/>
      --             (SQL Prog. Element 8)
    </p>
    <p num="95">All lines in SQL Program Element 8 are provided as shown.</p>
    <p num="96">F. Split Rows and Copy values not to be Updated into Tg</p>
    <p num="97">The loop at the last line of SQL Program element 8 will allow all rows of the table being updated in the query stored in query storage 212 that: 1) meet the criteria of the fourth portion of such query, 2) have at least some overlap during the effective period of the row and the effective period of the rows of the table referenced in the fourth portion of the query stored in query storage 212, and 3) have an effective period that is at least partially within the period of applicability to be processed one row at a time.</p>
    <p num="98">
      Processing of each row of the table to be updated in the query stored in query storage 212 and that meet the three criteria described above is performed as follows when the SQL program elements described below are executed by database product 210: table Tg is used to hold one row of the table to be updated in the query stored in query storage 212.
      <br/>
      Rows that have an effective period that is fully within the period of applicability are copied into a single row of table Tg.
      <br/>
      If a portion of the effective period of the row is before the period of applicability of the query stored in query storage 212, that portion is split off and placed into an additional row of table Tg.
      <br/>
      If a portion of the effective period of the row is after the period of applicability of the query stored in query storage 212, that portion is split off and placed into an additional row of table Tg.
      <br/>
      The portion of the row within the period of applicability is set according to the third portion of the query stored in query storage 212.
      <br/>
      If possible, rows split into multiple rows are combined back into a single row equivalent.
      <br/>
      The rows from table Tg are then inserted into the table to be updated in the query stored in query storage 212, replacing the original row from that table, and the apparatus selects the next row of such table to process as described above until no more rows in the table meet the three criteria described above.
    </p>
    <p num="99">
      If the current row held in ICRow has an effective date that begins before the beginning of the period of applicability, the SQL Program Element created by set columns before retainer 244 splits the row into a component before the beginning of the period of applicability.
      <br/>
      Set columns before retainer 244 reads the query stored in query storage 212 and creates a program element that copies from the cursor ICRow the values of the columns that are set in the SET clause of the query stored in query storage 212 if the cursor has a StartDate prior to the period of validity and also retains the StartDate of those rows.
      <br/>
      The columns are stored by set columns before retainer 244 in table Tg created above.
      <br/>
      For example, for Query 1, set columns before retainer 244 would create an SQL Program Element as follows:
    </p>
    <p num="100">
      --
      <br/>
      --      IF ICrow.StartDate &lt; `01-JAN-96`
      <br/>
      --      THEN
      <br/>
      --         INSERT INTO Tg
      <br/>
      --         VALUES (ICrow.PCN, ICrow.StartDate, `01-JAN-96`);
      <br/>
      --      END IF;       (SQL Prog. Element 9a)
    </p>
    <p num="101">In response to the signal from query router 214, set columns before retainer 244 provides SQL Program Element 9a as shown above, substituting the name of the column being changed in the query stored in query storage 212 in place of PCN in line 4 of SQL Program Element 9a, and the beginning of the period of applicability in place of "January 1, 1996" in lines 1 and 4.</p>
    <p num="102">
      If the current row held in ICRow has an effective period that ends after the end of the period of applicability, the SQL Program Element created by set columns after retainer 246 splits the row into a component after the end of the period of applicability.
      <br/>
      In response to the signal from query router 214, set columns after retainer 246 reads the query stored in query storage 212 and creates a program element that, when executed by database product 210, will copy to table Tg from the cursor ICRow the values of the columns that are set in the SET clause of the query stored in query storage 212 if the cursor has a StartDate after the end of the period of validity, and also retains the StopDate of the row.
      <br/>
      For example, for Query 1, set columns after retainer 246 would create an SQL Program Element as follows:
    </p>
    <p num="103">
      --
      <br/>
      --        IF ICrow.StopDate &gt; `01-JAN-97`
      <br/>
      --        THEN
      <br/>
      --        INSERT INTO Tg
      <br/>
      --        VALUES (ICrow.PCN, `01-JAN-97`, ICrow.StopDate);
      <br/>
      --        END IF;       (SQL Prog. Element 9b)
    </p>
    <p num="104">For queries other than Query 1, set columns after retainer 246 provides SQL Program Element 9b as shown above, substituting the name of the column being changed in the query stored in query storage 212 in place of PCN in line 4 of SQL Program Element 9b, and the end of the period of applicability in place of "January 1, 1997" in lines 1 and 4.</p>
    <p num="105">
      In response to the signal from query router 214, a where predicate false values retainer 248 reads the query in query storage 312 and creates a program element that, when executed by database product 210, copies from the table being updated into table Tg the values of the columns that are set in the SET clause of the query stored in query storage 212 for rows that correspond to a false WHERE predicate in the query stored in query storage 212 for the intersection of the effective period of the current row in the table to be updated with table Tb.
      <br/>
      Each row of table Tb contains a StartDate and StopDate that defines a period (referred to as a "where constant period") over which the fourth portion of the query stored in query storage 212 is true, and no changes occur in any of the tables referenced in such portion or the table to be updated, and is limited to the period of applicability.
      <br/>
      Thus, any row in the table to be updated that fully spans a where constant period in which the fourth portion of the query stored in query storage 212 is false is not to be updated for rows of the other tables referenced that have an effective date that falls within the same constant period.
      <br/>
      Because where constant periods were defined to include the table being updated, the effective period of the ICRow object will coincide with a StartDate and a StopDate of at least one row of table Tb.
    </p>
    <p num="106">
      The StartDate and StopDates from the row of Tb are copied into Tg with the field being set from ICRow.
      <br/>
      In one embodiment, where predicate false values retainer 248 provides the following SQL program element in response to Query 1:
    </p>
    <p num="107">
      --
      <br/>
      -- INSERT INTO Tg
      <br/>
      -- SELECT ICrow.PCN, Tb.StartDate, Tb.StopDate
      <br/>
      -- FROM Tb
      <br/>
      -- WHERE ICrow.StartDate &lt;= Tb.StartDate AND Tb.StopDate &lt;=
      <br/>
      -- ICrow.StopDate
      <br/>
      --      AND NOT (ICrow.SSN IN (SELECT SSN FROM Employees E
      <br/>
      --               WHERE B = `B` AND E.G = ICrow.G
      <br/>
      --               AND E.StartDate &lt; Tb.StopDate
      <br/>
      --               AND Tb.StartDate &lt; E. StopDate
      <br/>
      -- );   (SQL Prog. Element 10)
    </p>
    <p num="108">
      Where predicate false values retainer 248 creates this SQL program element by causing lines 1 and 3 of the SQL program element it builds to read "INSERT INTO Tg" and "FROM Tb" respectively.
      <br/>
      Where predicate false values retainer 248 creates line 2 of the SQL program element by creating a line starting with the word "SELECT", adding the name of the columns to be set from the SET clause of the query stored in query storage 212 as objects of ICRow and adding the words, "Tb.StartDate, Tb.StopDate". Where predicate false values retainer 248 builds the where clause at the end of the SQL program element by building the lines "WHERE ICrow.StartDate &lt;= Tb.StartDate AND Tb.StopDate &lt;= ICrow.StopDate AND NOT (ICrow." and adding the remainder of the WHERE clause from the query stored in query storage 212 with the name of the table to be updated replaced with "ICRow".
      <br/>
      Additionally, to any IN predicate is added the last two lines to ensure the StartDate of the current row of the table referenced in the IN predicate is prior to the StopDate of the current row of the Tb table and the StartDate of the current row of the Tb table is prior to the StopDate of the current row of the table referenced in the IN Predicate.
    </p>
    <p num="109">In response to the signal from query router 214, a set false values retainer 250 reads the query stored in query storage 212 and creates a program element that, when executed by database product 210, copies from the table being updated into table Tg the values of the columns for the table being updated intersect Tg intersect Te during which the WHERE clause in the query stored in query storage 212 is true but the SET clause in the query stored in query storage 212 is false.</p>
    <p num="110">For Query 1, set false values retainer 250 creates the following SQL Program Element:</p>
    <p num="111">
      --
      <br/>
      -- INSERT INTO Tg
      <br/>
      -- SELECT ICrow.PCN,
      <br/>
      --      GREATEST(Tb.StartDate, Te.StartDate),
      <br/>
      --      LEAST(Tb.StopDate, Te.StopDate)
      <br/>
      -- FROM Tb, Te
      <br/>
      -- WHERE GREATEST(ICrow.StartDate, Tb.StartDate, Te.StartDate)
      <br/>
      --        &lt; LEAST(ICrow.StopDate, Tb.StopDate, Te.StopDate)
      <br/>
      --      AND ICrow.SSN IN (SELECT SSN FROM Employees E
      <br/>
      --                  WHERE  B = `B` AND E.G = ICrow.G
      <br/>
      --                    AND E.StartDate &lt; Tb.
      <br/>
      StopDate
      <br/>
      --                    AND Tb.StartDate &lt; E.StopDate)
      <br/>
      --      AND NOT EXISTS (SELECT PCN FROM Positions P
      <br/>
      --                  WHERE P.JTC = `C` AND P.D = ICrow.D
      <br/>
      --                    AND P.StartDate &lt; Te.StopDate
      <br/>
      --                    AND Te.StartDate &lt; P.StopDate);
      <br/>
      -- (PL/SQL Program Element 11)
    </p>
    <p num="112">
      In one embodiment, set false values retainer 250 creates SQL Program Element 11 as follows: Line 1 of SQL Program Element 11 is provided as shown, the beginning of line 2 of SQL Program Element 11 is provided as shown above, and to the end of line 2 are appended the names of all columns to be set from the SET clause of the query stored in query storage 212 as objects of ICRow.
      <br/>
      Lines 3-7 in SQL Program Element 11 are provided as shown above.
      <br/>
      Lines 8 and 9 are created by adding the "AND" in line 8 to the WHERE clause of the query stored in query storage 212 with "ICRow" substituted for the name of the table being updated, and adding lines to ensure the current row of any tables referenced in the "IN" predicate of the WHERE clause in the query stored in query storage 212 are such that its StartDate is prior to the StopDate of the current row of table Tb and its StopDate is after the StartDate of the current row of table Tb.
      <br/>
      The next two lines, beginning with "AND NOT EXISTS . . . " are provided with the beginning as shown and completed using the predicate of the SET clause from the query stored in query storage 212 with the name of the table to be changed replaced by "ICRow".
      <br/>
      The last two lines are provided as shown with the name of the table selected from the two lines above the last two lines inserted in place of `P`. If there are multiple SET clauses in the query stored in query storage 212, an open parenthesis, `(`, is added after the `AND` in line 12, and the remainder of the last four lines, beginning with "NOT EXISTS" are duplicated, once for each set clause, with an `OR` inserted between each duplicated set of four lines.
      <br/>
      A close parenthesis, `)` is added to the end of the last line of the last duplicated set of four lines.
      <br/>
      Thus, the syntax is "AND (NOT EXISTS ( . . . ) OR NOT EXISTS ( . . . ) OR . . . ) ".
    </p>
    <p num="113">G. Setting new Values.</p>
    <p num="114">
      In response to the signal from query router 214, a values setter 252 reads the query in query storage 212 and builds an SQL Program Element that, when executed by database product 210, inserts into Tg rows that meet the criteria of the WHERE clause and have a value for the SET clause, for the query stored in query storage 212, along with the values of the column or column to be updated, and the StartDate and StopDates for those rows.
      <br/>
      The criteria are met during ICRow intersect Tb intersect Te.
      <br/>
      For Query 1, values setter 252 generates the following SQL Program Element:
    </p>
    <p num="115">
      --
      <br/>
      -- INSERT INTO Tg
      <br/>
      -- SELECT P.PCN,
      <br/>
      --      GREATEST(Tb.StartDate, Te.StartDate),
      <br/>
      --      LEAST(Tb.StopDate, Te.StopDate)
      <br/>
      -- FROM Tb, Te, Positions P
      <br/>
      -- WHERE GREATEST(ICrow.StartDate, Tb.StartDate, Te.StartDate)
      <br/>
      --        &lt; LEAST(ICrow.StopDate, Tb.StopDate, Te.StopDate)
      <br/>
      --      AND ICrow.SSN IN (SELECT SSN FROM Employees E
      <br/>
      --                  WHERE B = `B` AND E.G = ICrow.G
      <br/>
      --                    AND E.StartDate &lt; Tb.StopDate
      <br/>
      --                    AND Tb.StartDate &lt; E.StopDate)
      <br/>
      --      AND P.StartDate &lt; Te.StopDate
      <br/>
      --      AND Te.StartDate &lt; P.StopDate
      <br/>
      --      AND P.JTC = `C` AND P.D = ICrow.D;
      <br/>
      -- (SQL Program Element 12)
    </p>
    <p num="116">
      Values setter 252 creates SQL program element 12 as follows: values setter 252 provides the first line as shown above.
      <br/>
      The second line is built using a select statement with the alias of the table specified in the select predicate of the SET clause of the query stored in query storage 212 and the name of the column in the SELECT predicate of the SET clause of the query stored in query storage 212 as an object of this table.
      <br/>
      The third and fourth lines of SQL Program Element 12 are provided as shown.
      <br/>
      Line 5 is created by providing "FROM Tb, Te," and inserting the table name and alias for each column selected in the SELECT predicate of the SET clause of the query stored in query storage 212.
      <br/>
      The next two lines are provided as shown.
      <br/>
      The next two lines are formed using the WHERE clause of the query stored in query storage 212, and replacing `WHERE` with `AND` and the name of the table to be updated with `ICRow`. The next pair of lines are provided as shown for each table referenced in the WHERE clause of the query stored in query storage 212 that is not the table being updated, with the name of such table substituted in place of `E` for each pair provided, with the close parenthesis `)` after the end of the last pair.
      <br/>
      The next pair of lines is provided once for each table referenced in the SET clause that is not the table being changed, with the name of such table substituted in place of `P` for each pair of lines so provided.
      <br/>
      The last line is copied from the WHERE predicate of the SET clause of the query stored in query storage 212 with `AND` substituted in lace of `WHERE` and `ICrow` substituted in place of the name of the table being updated.
    </p>
    <p num="117">H. Normalizing Values.</p>
    <p num="118">
      Table Tg will have no rows that overlap in time, and all rows will be contiguous in time.
      <br/>
      It is possible that some of the rows will have the same value of the column or columns to be set in the query stored in query storage 212.
      <br/>
      In such case, such rows may be combined to reduce the number of rows to be inserted into the table being updated.
      <br/>
      Optional Tg normalizer 254 reads the query stored in query storage 212 and creates an SQL program element that combines these rows.
      <br/>
      For Query 1, Tg normalizer 254 builds the following program element:
    </p>
    <p num="119">
      --
      <br/>
      -- multiple := 0;
      <br/>
      -- OPEN GC;-- Tg now available
      <br/>
      -- FETCH GC INTO GCrow;
      <br/>
      -- IF GC%notfound
      <br/>
      --      THEN GOTO endinner;-- this IC need not be updated
      <br/>
      -- END IF;
      <br/>
      -- oldStartDate := GCrow.StartDate;
      <br/>
      -- oldStopDate := GCrow.StopDate;
      <br/>
      --      oldPCN := GCrow.PCN;
      <br/>
      -- LOOP
      <br/>
      -- FETCH GC INTO GCrow;
      <br/>
      -- IF GC%notfound
      <br/>
      -- THEN EXIT;
      <br/>
      -- END IF;
      <br/>
      -- IF oldPCN = GCrow.PCN
      <br/>
      -- THEN
      <br/>
      --        oldStopDate := GCrow.StopDate; -- rows will meet
      <br/>
      -- ELSE
      <br/>
      --        INSERT INTO Incuments
      <br/>
      --        VALUES (ICrow.SSN, oldPCN, ICrow.G, ICrow.D, ICrow.E,
      <br/>
      --        oldStartDate, oldStopDate);
      <br/>
      --        multiple := 1;
      <br/>
      --        oldStartDate := GCrow.StartDate;
      <br/>
      --        oldStopDate := GCrow.StopDate;
      <br/>
      --        oldPCN := GCrow.PCN;
      <br/>
      -- END IF;
      <br/>
      -- END LOOP;-- GCrow
      <br/>
      -- (SQL Program Element 13)
    </p>
    <p num="120">
      When executed by database product 210, SQL Program Element 13 consolidates consecutive rows of table Tg that have the same value of all of the columns to be set in the query stored in query storage 212.
      <br/>
      Because table Tg was built to ensure that consecutive rows do not have overlapping times or gaps between the StopDate of one row and the StartDate of the next row, after verifying that any rows at all exist in table Tg, consolidation is reduced to checking whether the value of each column being set in the SET clause of the query stored in query storage 212 in a row of table Tg is the same as that of the prior row, the rows having been placed in date order in SQL Program Element 8.
      <br/>
      All consolidated rows of table Tg except for the last row are inserted into the table being updated by SQL Query 13.
      <br/>
      The last row is handled as described below.
    </p>
    <p num="121">
      Tg Normalizer 254 creates SQL Program Element 13 as follows: Lines 1-8 are provided as shown.
      <br/>
      These lines open the cursor, initialize a variable, "multiple", and fetch the first row of table Tg, skipping the process if Table Tg is empty.
      <br/>
      The StartDate and StopDates of the row are stored into variables, "oldStartDate" and "oldStopDate".
      <br/>
      Line 9 is provided using the name of the column to be set from the query stored in query storage 212 in place of "PCN".
      <br/>
      If multiple columns are to be set in the query stored in query storage 212, duplicate copies of line 9 are provided underneath line 9, with each copy using the name of a different column to be set.
    </p>
    <p num="122">
      Lines 10-14 are provided as shown, which start a loop which fetches subsequent rows of table Tg, one row at a time, testing to see if a subsequent row is fetched, and exiting the loop if no such subsequent row exists.
      <br/>
      Line 15 is provided as shown with "PCN" replaced by the name of the column to be set from the query stored in query storage 212.
      <br/>
      If multiple columns are to be set in such query, an equality condition for each such column is "ANDed" to line 15. (e.g. "If ((oldPCN = GCRow.PCN) AND (oldSECONDROWNAME = GCRow.SECONDROWNAME))").
      <br/>
      Lines 16-18 are provided as shown, with lines 16 and 17 advancing the oldStopDate variable to the StopDate of the current row of Tg if all fields to be set in the query stored in query storage 212 in the current row of Tg match the same fields in the prior row of Tg.
      <br/>
      Line 18 starts the "Else" condition to be performed if no such match occurs.
    </p>
    <p num="123">
      Line 19 specifies insertion, with the name of the table being updated in the query stored in query storage 212 inserted in place of "Incumbents".
      <br/>
      Lines 20-21 are built by providing the names of all columns to be set in the query stored in query storage 212 using the "oldX" variables, where X is the column names (e.g. "oldPCN"), providing oldStartDate and oldStopDate, and providing the remaining column names of Tg as objects of ICRow.
    </p>
    <p num="124">
      Lines 22-24 are provided as shown, which identify using the "multiple" variable that Tg rows have been combined as described above (i.e. "normalized") and sets the oldStartDate and oldStopDate equal to the StartDate and StopDate, respectively, of the current row of Tg.
      <br/>
      Line 25 stores the columns to be set in the query stored in query storage 212 of the current row of Tg into "oldX" variables as described above.
      <br/>
      If multiple columns are to be set in the query stored in query storage 212, duplicates of line 25 are placed underneath line 25 with the name of a different column to be set in each copy substituted in place of "PCN" on both sides of the equation as shown in line 25.
      <br/>
      Lines 26 and 27 are provided as shown.
    </p>
    <p num="125">I. Replacing Values Into Table to Be Changed.</p>
    <p num="126">
      In response to the signal from query router 214, replace/update 256 reads the query stored in query storage 212 and builds an SQL program element that, when executed by database product 210, inserts into the table being updated in the query stored in query storage 212 the last row of Table Tg, consolidated as described above, into the table being updated in the query stored in query storage 212, and deletes the original row corresponding to the row inserted.
      <br/>
      If only one row exists in table Tg after normalizing as described above, any updated values of the columns being set in the query stored in query storage 212 are inserted using an update in place of the prior values for the row instead of the insert and delete described above.
      <br/>
      Additionally, the SQL program element built by replace/update 256 performs clean up operations such as closing cursors, deleting rows from table Tg for any processing of subsequent rows of the table being updated as described above, and committing the transactions performed by the SQL Program Elements described above.
    </p>
    <p num="127">In response to Query 1, replace/update 256 builds the following program element:</p>
    <p num="128">
      --
      <br/>
      -- IF multiple = 1
      <br/>
      -- THEN
      <br/>
      --      DELETE Incumbents WHERE CURRENT OF IC;
      <br/>
      --      INSERT INTO Incubents
      <br/>
      --      VALUES (ICrow.SSN, oldPCN, ICrow.G, ICrow.D, ICrow.E,
      <br/>
      --      oldStartDate, oldStopDate);
      <br/>
      -- ELSIF oldPCN &lt; &gt; ICrow.PCN
      <br/>
      -- THEN
      <br/>
      --      UPDATE Incumbents
      <br/>
      --      SET PCN = oldPCN
      <br/>
      --      WHERE CURRENT OF IC;
      <br/>
      -- END IF;
      <br/>
      -- DELETE FROM Tg;
      <br/>
      -- &lt;&lt;endinner&gt;&gt;
      <br/>
      -- CLOSE GC;
      <br/>
      -- END LOOP ICrowloop;
      <br/>
      -- &lt;&lt;endloop&gt;&gt;
      <br/>
      -- COMMIT;
      <br/>
      -- END;
      <br/>
      -- (SQL Program Element 14)
    </p>
    <p num="129">
      Replace/update 256 reads the query stored in query storage 212 and builds SQL program element 14 by providing it as shown above with the following exceptions: In line 4, "Incumbents" is replaced with the name of the table to be changed.
      <br/>
      In lines 5 and 6, a name corresponding to each column in the table being changed is inserted between the parentheses.
      <br/>
      The name inserted in between the parentheses for columns in the table being changed that are being updated in the SET clause of the query stored in query storage 212 use the "old" version of the name (e.g. because the PCN column is being set in Query 1, OldPCN is used in place of PCN).
      <br/>
      The name inserted between the parentheses for other columns except for the StartDate and StopDate columns use the "ICRow" object version (e.g. if the other column names in the Incumbents table are SSN, G, D, E, StartDate and StopDate, the corresponding names are ICRow.SSN, ICRow.G, ICRow.D and ICRow.E as shown in SQL Program Element 14).
      <br/>
      The oldStartDate and OldStopDate names are used in place of the StartDate and Stopdate of the table being updated as shown in SQL Program Element 14.
      <br/>
      These names are placed in the order corresponding to the names of the columns in the table being changed.
      <br/>
      In Line 7, the name of the column being changed in the SET clause of the query stored in query storage 212 is substituted for "PCN" on both sides of the inequality operator.
      <br/>
      If multiple columns are being set, the "oldPCN &lt;&gt; ICRow.PCN" is "or-ed" with a similar condition using the name of the other column or columns.
      <br/>
      For example, if PCN, PCN1 and PCN2 were in the set clause of query 1, line 7 would read "ELSIF oldPCN &lt;&gt; ICRow.PCN OR oldPCN1 &lt;&gt; ICRow.PCN1 OR oldPCN2 &lt;&gt; ICRow.PCN2" The name of the table to be changed is substituted in place of "Incumbents" in line 9, and the name of the column to be changed that is listed in the SET clause of the query stored in query storage 212 is substituted in place of "PCN" in both placed of line 10.
      <br/>
      If additional columns are changed in the query stored in query storage 212, a copy of line 9 is placed under line 9 for each such column with a different one of the other column names being changed substituted in place of "PCN" in each of the copies of line 9.
    </p>
    <p num="130">I. Assembling the SQL Program.</p>
    <p num="131">
      When signaled by query router 214, each of the where table creator 220, where table optimizer 222, where constant set builder 224, set table creator 230, set table optimizer 232, set constant set builder 234, cursor creator 240, set columns before retainer 244, set columns after retainer 246, where predicate false values retainer 248, set false values retainer 250, values setter 252, Tg normalizer 254 and replace/update 256 produces the query or SQL Program Element described above and passes the result to assembler 260.
      <br/>
      Assembler 260 assembles the queries and SQL Program elements into a single SQL Program to be executed by database product 210, and then passes it to database product 210 for execution.
      <br/>
      In one embodiment, the Queries and SQL Program Elements described above are assembled into the program in the order in which they are described above, although other orders may be used as long as tables created are created before they are used.
      <br/>
      Assembler 260 can submit to database product 210 the program in multiple pieces.
      <br/>
      In another embodiment, assembler 260 is not used, and query router 214 signals each of the where table creator 220, where table optimizer 222, where constant set builder 224, set table creator 230, set table optimizer 232, set constant set builder 234, cursor creator 240, set columns before retainer 244, set columns after retainer 246, where predicate false values retainer 248, set false values retainer 250, values setter 252, Tg normalizer 254 and replace/update 256 in the sequence described above.
      <br/>
      Each of these inserts the Query or Program Element it builds into a program object and passes the object to the next of these in the sequence, with the last of these submitting the program object to database product 210.
    </p>
    <p num="132">
      In one embodiment, assembler 260 includes into the SQL program it provides to database product 210 prior to the queries and SQL program elements it receives an SQL program element to drop all of the tables created in the queries and SQL program elements described above.
      <br/>
      Dropping tables created will make sure that old values inserted from prior queries are not part of the tables created to process the present query.
    </p>
    <p num="133">J. Method.</p>
    <p num="134">
      Referring now to FIG. 3A, a method of intercepting a command to change a temporal database and substituting a series of queries and SQL program elements that, when executed by a conventional database product, will perform the command is shown according to one embodiment of the present invention.
      <br/>
      A query as described above to change a temporal database is received 310.
      <br/>
      One or more queries are built 312 that, when executed by a database product, will produce a table of StartDates and StopDates within the period of applicability for: i) the table to be changed, ii) all other tables in the where clause of the query received in step 310, and iii) the boundary dates of the period of applicability as described above with reference to the where table creator 220 of FIG. 2.
    </p>
    <p num="135">One or more queries are built 314 that, when executed by a database product optionally eliminate duplicates from the table resulting from the execution of the query built in step 312 as described above with reference to the where table optimizer 222 of FIG. 2 and/or build a constant set from the table resulting from step 312 or 314 as described above with reference to the where constant set builder 224 of FIG. 2.</p>
    <p num="136">
      One or more queries are built 316 that, when executed by a database product, create a table containing the StartDates and StopDates of the tables referenced in the set clause of the query received in step 310 meeting all of the first two, and optionally third criteria described above with reference to set table creator 230 of FIG. 2 as described above.
      <br/>
      One or more queries are optionally built 318 that, when executed by a database product, eliminates duplicates from the table that results from the table resulting from the execution of the query built in step 316, as described above with reference to the set table optimizer 232 of FIG. 2.
      <br/>
      One or more queries are built 318 that, when executed by a database product, create a constant set as described above with respect to set constant set builder 234 of FIG. 2.
      <br/>
      Steps 312 through 318 may be performed in any order, sequentially or in parallel.
    </p>
    <p num="137">
      One or more SQL program elements is built 320 that, when executed by a database product, create a cursor as described above with respect to cursor creator 240.
      <br/>
      One or more SQL program elements is built 322 that, when executed by a database product, retain values before the period of applicability as described above with respect to set column before retainer 244 of FIG. 2.
      <br/>
      One or more SQL program elements is built 324 that, when executed by a database product, retain the values in the table to be changed after the period of applicability as described above with respect to set columns after retainer 246 of FIG. 2.
      <br/>
      One or more SQL program elements is built 326 that, when executed by a database product, retain values in the table to be changed during the dates the where predicate is false as described above with respect to where predicate false values retainer 248 of FIG. 2.
      <br/>
      One or more SQL program elements is built 328 that, when executed by a database product, retain values in the table to be changed during periods in which the where predicate is true but the set predicate is false as described above with reference to set false values retainer 250.
      <br/>
      One or more SQL program elements are built 330 that, when executed by a database product, set new values of the table to be changed according to the set clause of the query received in step 310 as described above with respect to values setter 252.
      <br/>
      One or more SQL program elements are built 332 that, when executed by a database product, normalize the rows that will result from the queries and SQL program elements built in steps 312 through 330 into a smaller number of rows and insert all but the last row if the smaller number of rows is greater than one as described above with respect to TG normalizer 254 of FIG. 2.
      <br/>
      One or more SQL program elements are built 334 that, when executed by a database product, insert the last row from the result of step 332 into the table to be changed and delete the rows being changed if execution of the SQL Program Element created in step 332 results in more than one row, or replace the column or columns being changed for the rows being changed with the corresponding column or columns in the result of step 332 if execution of the SQL Program Element created in step 332 resulted in only one row as described above with respect to replace/update 256 of FIG. 2.
      <br/>
      Steps 312-334 are built in response to the query received in step 310 as described above.
    </p>
    <p num="138">
      The queries and program elements built in steps 312334 are assembled 336 as described above with respect to assembler 260 of FIG. 2 and provided to a database product for execution.
      <br/>
      Step 336 may include inserting commands to drop tables corresponding to tables built as a result of execution of the queries and SQL program elements built in steps 312-334.
      <br/>
      The drop commands are inserted before the commands that create the tables.
      <br/>
      It isn't necessary for the queries and SQL program elements to be provided all at the same time or in the order built, as described above.
      <br/>
      The user can receive the result of the execution without knowledge of the steps 312 through 336.
    </p>
    <p num="139">K. Deletions--Apparatus.</p>
    <p num="140">
      If the query received by query router 214 is a delete query, there will be no set clause in the query.
      <br/>
      However, the VALIDTIME statement will notify query router 214 that the deletion is a sequenced deletion.
      <br/>
      In such event, query router 214 passes the query to query storage 212 and the apparatus of the present invention operates as described above with the following exceptions:
    </p>
    <p num="141">
      First, in response to receipt of the query, query router 214 does not signal set table creator 230, set table optimizer 232, set constant set builder 234, where predicate false values retainer 248, set false values retainer 250 and values setter 252.
      <br/>
      This means that queries 4a through 5b and SQL Program Elements 10 and 11 will not be built and will not be executed by database product 210 in order to perform the query received by query router 214.
    </p>
    <p num="142">
      Second, Tg normalizer 254 does not build lines corresponding to lines 9, 15-18 and 25-26 of SQL Program Element 13.
      <br/>
      Because no columns are to be set, no "OldX" variables (e.g. "OldPCN") are included in line 20 of SQL Program Element 13.
    </p>
    <p num="143">Third, replace/update 256 does not build lines corresponding to lines 7-12 of SQL Program Element 14.</p>
    <p num="144">To implement these changes, in one embodiment, two versions of where predicate false values retainer 248, Tg Normalizer 254 and replace/update 256 exist in the apparatus of the present invention, with query router 214 signaling one version 248, 254, 256 in response to receipt of an update statement and signaling another version (not shown) of each that operate as modified in this paragraph in response to receipt of a delete query.</p>
    <p num="145">
      In another embodiment, where predicate false values retainer 248, Tg normalizer 254 and replace/update 256 can respond as described above to either update or delete queries.
      <br/>
      Query router examines the query and notifies where predicate false values retainer 248, Tg normalizer 254 and replace/update 256 of the type of the query.
    </p>
    <p num="146">L. Deletions--Method.</p>
    <p num="147">
      Referring now to FIG. 3B, a method of intercepting a command to delete from a temporal database and substituting a series of queries and SQL program elements that, when executed by a conventional database product, will perform the command is shown according to one embodiment of the present invention.
      <br/>
      FIG. 3B is similar to FIG. 3A, except that steps 316, 318, 328, and 330 are not performed as described above with reference to delete queries, and steps 326, 332 and 334 are replaced with steps 327, 333 and 335, respectively.
      <br/>
      Steps 327, 333 and 335 operate similar to steps 326, 332 and 334, respectively, modified as described above with respect to delete queries.
    </p>
    <p num="148">
      FIGS. 3A and 3B can be used individually, or together in conjunction with the additional steps of FIG. 3C. Referring now to FIG. 3C additional steps 311A and 311B are shown to determine whether the steps 312-336 described in FIG. 3A or 3B are to be used.
      <br/>
      Following step 310 of either FIG. 3A or 3B, the query received in step 310 may be examined 311A by looking for the word "update" or "delete" to determine whether the query is a sequenced update or a sequenced delete query.
      <br/>
      If the query is a sequenced update statement, the remaining steps 312-336 shown in FIG. 3A are performed as described above with reference to FIG. 3A, and if the query is a sequenced delete query, the steps 312-336 shown in FIG. 3B are performed as described above with reference to FIG. 3B.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method of updating a database table comprising a first plurality of rows, each row having a start identifier, an end identifier and a first value, the method comprising:</claim-text>
      <claim-text>receiving a command to update a database, the command comprising a criteria and a period of validity, the period of validity having a beginning and an end; generating at least two rows for each of a second plurality of the first plurality of rows of the table meeting the criteria and having at least one selected from a start date not after the end of the period of validity and a stop date not prior to the beginning of the period of validity;</claim-text>
      <claim-text>and changing the value of at least one row corresponding to at least one of the rows in the second plurality, responsive to the command received.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein the criteria comprises a first criteria and a second criteria and the generating step comprises: identifying a third plurality of rows meeting the second criteria and not the first criteria and having at least one selected from:</claim-text>
      <claim-text>- a start identifier after the beginning of the period of validity and before the end of the period of validity;</claim-text>
      <claim-text>and - an end identifier after the beginning of the period of validity and before the end of the period of validity;</claim-text>
      <claim-text>and providing for each row in the third plurality a first row and a second row: - the first row having the first value and having a start identifier and an end identifier, said start identifier and end identifier of the first row responsive to a period when the first criteria is false;</claim-text>
      <claim-text>and - the second row having a second value responsive to the command and having a start identifier and an end identifier responsive to a period when the first criteria and the second criteria are true.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 1, wherein the generating step comprises: identifying a third plurality of rows meeting the criteria and having a start identifier prior to the beginning of the period of validity and an end identifier after the beginning of the period of validity;</claim-text>
      <claim-text>and providing for each row in the third plurality a first row and a second row, the first row having a start identifier comprising the start identifier of the respective row in the third plurality and an end identifier corresponding to the beginning of the period of validity and the second row having a start identifier corresponding to the beginning of the period of validity.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 3 wherein the changing step comprises assigning a second value to the second row and the first value to the first row.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 3 wherein the changing step comprises assigning a second value to the second row and the first value to the first row.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 3 wherein the changing step comprises assigning a second value to the second row, a third value to the third row and the first value to the first row.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 1, wherein the generating step comprises: identifying a third plurality of rows meeting the criteria and having a end identifier after the end of the period of validity and an start identifier before the end of the period of validity;</claim-text>
      <claim-text>and providing for each row in the third plurality a first row and a second row, the first row having an end identifier comprising the end identifier of the respective row in the third plurality and a start identifier corresponding to the end of the period of validity and the second row having an end identifier corresponding to the end of the period of validity.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 1, wherein the generating step comprises: identifying a third plurality of rows meeting the criteria and having a end identifier after the end of the period of validity and an start identifier before the beginning of the period of validity;</claim-text>
      <claim-text>and providing for each row in the third plurality a first row, a second row and a third row, the first row having an end identifier comprising the end identifier of the respective row in the third plurality and a start identifier corresponding to the end of the period of validity, the second row having an end identifier corresponding to the end of the period of validity and a start identifier corresponding to the beginning of the period of validity, the third row having a start identifier comprising the start identifier of the respective row in the third plurality and an end identifier corresponding to the beginning of the period of validity.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 1 comprising the additional step of storing at least some of the first rows and the second rows into the table.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of claim 1 comprising the additional step of identifying at least one constant set of startdates and stopdates from at least one selected from the table and a table described in the command, and wherein the changing step is responsive to at least one of the at least one constant set.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 10 wherein the constant sets are responsive to the period of validity.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 1 wherein the changing step comprises setting up a database cursor.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 1 comprising the additional step of combining at least two rows having a same value.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 1 wherein the changing step comprises inserting at least one row into the table.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A computer program product comprising a computer useable medium having computer readable program code embodied therein for updating a database table comprising a first plurality of rows, each row having a start identifier, an end identifier and a first value, the computer program product comprising: computer readable program code devices configured to cause a computer to receive a command to update a database, the command comprising a criteria and a period of validity, the period of validity having a beginning and an end; computer readable program code devices configured to cause a computer to generate at least two rows for each of a second plurality of the first plurality of rows of the table meeting the criteria and having at least one selected from a start date not after the end of the period of validity and a stop date not prior to the beginning of the period of validity;</claim-text>
      <claim-text>and computer readable program code devices configured to cause a computer to change the value of at least one row corresponding to at least one of the rows in the second plurality, responsive to the command received.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The computer program product of claim 15, wherein the criteria comprises a first criteria and a second criteria and the computer readable program code devices configured to cause a computer to generate comprise: computer readable program code devices configured to cause a computer to identify a third plurality of rows meeting the second criteria and not the first criteria and having at least one selected from: - a start identifier after the beginning of the period of validity and before the end of the period of validity;</claim-text>
      <claim-text>and - an end identifier after the beginning of the period of validity and before the end of the period of validity;</claim-text>
      <claim-text>and computer readable program code devices configured to cause a computer to provide for each row in the third plurality a first row and a second row: - the first row having the first value and having a start identifier and an end identifier, said start identifier and end identifier of the first row responsive to a period when the first criteria is false;</claim-text>
      <claim-text>and - the second row having a second value responsive to the command and having a start identifier and an end identifier responsive to a period when the first criteria and the second criteria are true.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The computer program product of claim 15, wherein the computer readable program code devices configured to cause a computer to generate comprise: computer readable program code devices configured to cause a computer to identify a third plurality of rows meeting the criteria and having a start identifier prior to the beginning of the period of validity and an end identifier after the beginning of the period of validity;</claim-text>
      <claim-text>and computer readable program code devices configured to cause a computer to provide for each row in the third plurality a first row and a second row, the first row having a start identifier comprising the start identifier of the respective row in the third plurality and an end identifier corresponding to the beginning of the period of validity and the second row having a start identifier corresponding to the beginning of the period of validity.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The computer program product of claim 17 wherein the computer readable program code devices configured to cause a computer to change comprise computer readable program code devices configured to cause a computer to assign a second value to the second row and the first value to the first row.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The computer program product of claim 17 wherein the computer readable program code devices configured to cause a computer to change comprise assigning a second value to the second row and the first value to the first row.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The computer program product of claim 17 wherein the computer readable program code devices configured to cause a computer to change comprise computer readable program code devices configured to cause a computer to assign a second value to the second row, a third value to the third row and the first value to the first row.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The computer program product of claim 15, wherein the computer readable program code devices configured to cause a computer to generate comprise: computer readable program code devices configured to cause a computer to identify a third plurality of rows meeting the criteria and having a end identifier after the end of the period of validity and an start identifier before the end of the period of validity;</claim-text>
      <claim-text>and computer readable program code devices configured to cause a computer to provide for each row in the third plurality a first row and a second row, the first row having an end identifier comprising the end identifier of the respective row in the third plurality and a start identifier corresponding to the end of the period of validity and the second row having an end identifier corresponding to the end of the period of validity.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The computer program product of claim 15, wherein the computer readable program code devices configured to cause a computer to generate comprise: computer readable program code devices configured to cause a computer to identify a third plurality of rows meeting the criteria and having a end identifier after the end of the period of validity and an start identifier before the beginning of the period of validity;</claim-text>
      <claim-text>and computer readable program code devices configured to cause a computer to provide for each row in the third plurality a first row, a second row and a third row, the first row having an end identifier comprising the end identifier of the respective row in the third plurality and a start identifier corresponding to the end of the period of validity, the second row having an end identifier corresponding to the end of the period of validity and a start identifier corresponding to the beginning of the period of validity, the third row having a start identifier comprising the start identifier of the respective row in the third plurality and an end identifier corresponding to the beginning of the period of validity.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The computer program product of claim 15 additionally comprising computer readable program code devices configured to cause a computer to store at least some of the first rows and the second rows into the table.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The computer program product of claim 15 additionally comprising computer readable program code devices configured to cause a computer to identify at least one constant set of startdates and stopdates from at least one selected from the table and a table described in the command, and wherein the computer readable program code devices configured to cause a computer to change are responsive to at least one of the at least one constant set.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The computer program product of claim 24 wherein the constant sets are responsive to the period of validity.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The computer program product of claim 15 wherein the computer readable program code devices configured to cause a computer to change comprise computer readable program code devices configured to cause a computer to set up a database cursor.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The computer program product of claim 15 additionally comprising computer readable program code devices configured to cause a computer to combine at least two rows having a same value.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The computer program product of claim 15 wherein the computer readable program code devices configured to cause a computer to change comprise computer readable program code devices configured to cause a computer to insert at least one row into the table.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. A system for updating a database table comprising a plurality of rows, each row having a start identifier, and end identifier and a first value, the system comprising: a query router having an input operatively coupled for receiving a command to update a database, the command comprising a criteria and a period of validity, the period of validity having a beginning and an end, the query router for providing at an output an indicator of at least a portion of the query received at the input; at least one values retainer having an input coupled to the query router output for generating at least one row comprising the first value for each of a second plurality of the first plurality of rows of the table meeting the criteria and having at least one selected from a start date not after the end of the period of validity and a stop date not prior to the beginning of the period of validity;</claim-text>
      <claim-text>and a values setter for generating at least one row comprising a second value responsive to the command for each of a second plurality of the first plurality of rows of the table meeting the criteria and having at least one selected from a start date not after the end of the period of validity and a stop date not prior to the beginning of the period of validity.</claim-text>
    </claim>
  </claims>
</questel-patent-document>