<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182108B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182108</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182108</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="23505799" extended-family-id="42108929">
      <document-id>
        <country>US</country>
        <doc-number>08381635</doc-number>
        <kind>A</kind>
        <date>19950131</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1995US-08381635</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165522</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>38163595</doc-number>
        <kind>A</kind>
        <date>19950131</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1995US-08381635</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/48        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>48</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>718102000</text>
        <class>718</class>
        <subclass>102000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>719315000</text>
        <class>719</class>
        <subclass>315000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>719330000</text>
        <class>719</class>
        <subclass>330000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/48C2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>48C2</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-009/48C4</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>48C4</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/4812</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>4812</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/4843</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>4843</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>27</number-of-claims>
    <exemplary-claim>11</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>15</number-of-drawing-sheets>
      <number-of-figures>16</number-of-figures>
      <image-key data-format="questel">US6182108</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and system for multi-threaded processing</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>PAPADOPOULOS GREGORY M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5560029</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5560029</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>HODGES CLARK DOUGLAS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5675796</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5675796</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>WILLMAN BRYAN</text>
          <document-id>
            <country>US</country>
            <doc-number>5684993</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5684993</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>JAGANNATHAN SURESH, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5692193</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5692193</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>SCHREIBER BENN LEE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5787281</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5787281</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <text>TRUFYN NICHOLAS</text>
          <document-id>
            <country>US</country>
            <doc-number>4553202</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4553202</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>HENNESSY JAMES P, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4809168</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4809168</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>NAKADE TOSHIMITSU, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4847751</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4847751</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>FREUND THOMAS J</text>
          <document-id>
            <country>US</country>
            <doc-number>5095421</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5095421</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>JOHNSON DONAVON W, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5175852</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5175852</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>VAN DYKE DON A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5179702</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5179702</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>KARGER PAUL A</text>
          <document-id>
            <country>US</country>
            <doc-number>5210874</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5210874</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="13">
          <text>BRANDLE RICHARD T, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5218699</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5218699</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="14">
          <text>IWASAKI MASAAKI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5274809</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5274809</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="15">
          <text>ANSCHUETZ BRIGITTE D L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5305455</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5305455</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="16">
          <text>GOLDBERG STEVEN H, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5319782</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5319782</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="17">
          <text>STROUT II ROBERT E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5339415</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5339415</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="18">
          <text>SMITH CURTIS A</text>
          <document-id>
            <country>US</country>
            <doc-number>5421013</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5421013</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="19">
          <text>YASREBI MEHRAD</text>
          <document-id>
            <country>US</country>
            <doc-number>5463625</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5463625</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="20">
          <text>LI JIANZHONG, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5515492</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5515492</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="21">
          <text>GILLES ROBERT A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5561797</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5561797</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>Abadi, M. et al., "A Calculus for Access Control in Distributed Systems," Feb. 1991, revised Aug. 1991, pp. iii-viii and 1-44 pages.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>Abadi, Martin, "Baby Modula-3 and a Theory of Objects," SRC Research Report, Feb. 1993; revised Dec. 1992, iii-iv and 1-36.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>Birrell, A. D. et al., "Synchronization Primitives for a Multiprocessor: A Formal Specification," SRC Research Report, Aug. 1987, pp. i-iii and 1-20.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>Birrell, Andrew D., "An Introduction to Programming with Threads," SRC Research Report, Jan. 1989, pp. 1-33.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>Broy, Manfred et al., "Can Fair Choice be Added to Dijkstra's Calculus?", SRC Research Report, Feb. 1989, pp. 1-17.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="6">
          <text>Burstall, R. et al., "A Kernel Language for Modules and Abstract Data Types," SRC Research Report, Sep. 1984, pp. 2-51.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="7">
          <text>Cardelli, Luca, "A Polymorphic lambda-calculus with Type: Type," SRC Research Report, May 1986, pp. 1-27.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="8">
          <text>Cardelli, Luca et al., "Modula-3 Report (revised)," SRC Research Report, Nov. 1989, pp. 1-71.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="9">
          <text>DeTreville, John, "Experience with Concurrent Garbage Collectors for Modula-2+," SRC Research Report, Nov. 1990, pp. 1-54.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="10">
          <text>Ellis, John R. et al., "Real-time Concurrent Collection on Stock Multiprocessors," SRC Research Report, Feb. 1988, pp. 1-24.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="11">
          <text>Horning, Jim et al., "Some Useful Modula-3 Interfaces," SRC Research Report, Dec. 1993, pp. iii-vii and 1-103.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="12">
          <text>Lamport, Leslie, "A Fast Mutual Exclusion Algorithm," SRC Research Report, Nov. 1985, revised Oct. 1986, pp. iii and 1-12.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="13">
          <text>Lamport, Leslie, "A Simple Approach to Specifiying Concurrent Systems," SRC Research Report, Dec. 1986, revised Jan. 1988, corrected Aug. 1988, pp. iii-viii and 1-39.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="14">
          <text>Lamport, Leslie, "Concurrent Reading and Writing of Clocks," SRC Research Report, Apr. 1988, revised Nov. 1990, pp. iii-vi and 1-7.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="15">
          <text>Lamport, Leslie, "How to Make a Correct Multiprocess Program Execute Correctly on a Multiprocessor," SRC Research Report, Feb. 1993, pp. iii-vii and 1-10.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="16">
          <text>Lamport, Leslie, "On Interprocess Communication," SRC Research Report, Dec. 1985, pp. iii-viii and 1-50.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="17">
          <text>Lamport, Leslie, "win and sin: Predicated Transformers for Currency," SRC Research Report, May 1987, revised Dec. 1989, pp. iii-ix and 1-43.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="18">
          <text>McJones, Paul R. et al. "Evolving the UNIX System Interface to Support Multithreaded Programs," SRC Research Report, Sep. 1987 (reformatted for electronic distribution Aug. 1997), pp. 1-80.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="19">
          <text>Nelson, Greg, "A Generalization of Dijkstra's Calculus," SRC Research Report, Apr. 1987, pp. 1-56.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="20">
          <text>Owicki, Susan, "Experience with the Firefly Multiprocessor Workstation," SRC Research Report, Sep. 1989, pp. 1-17.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="21">
          <text>Roberts, Eric S. et al., "WorkCrews: An Abstraction for Controlling Parallelism," SRC Research Report, Apr. 1989, pp. 1-17.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="22">
          <text>Rovner, Paul et al., "On Extending Modula-2 For Building Large, Integrated Systems," SRC Research Report, Jan. 1985, pp. 1-45.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="23">
          <text>Schroeder, Michael D. et al., "Performance of Firefly RPC," Apr. 1989, pp. 1-15.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="24">
          <text>Thacker, Charles P. et al. "Firefly: A Multiprocessor Workstation," SRC Research Report, Dec. 1987, pp. 1-17.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="25">
          <text>Microsoft OLE 2.0 Design Team, Object Linking &amp; Embedding: OLE 2.0 Design Specification, Microsoft Corporation, 1992-1993, pp. 2-4 and Chapter 11.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="26">
          <text>Brookes, Stephen D., On the Relationship of CCS and CSP, Department of Computer Science, Carnegie-Mellon University, Mar. 1983, 20 pages.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="27">
          <text>van Glabbeek, R.J., Notes on the Methodology of CCS and CSP, Stanford Technical Report, 21 pages, 1983.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="28">
          <text>Kimura, Shigetomo and Shoichi Noguchi, Synthesis of Algebraic Processes Based on Process Enumeration, Systems and Computers in Japan, vol. 24, No. 13, 1993, pp. 1-15.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="29">
          <text>Aczel, Peter, "Final Universes of Processes," Mathematical Foundations of Programming Semantics, 9th Int'l. Conference, New Orleans, LA, Apr. 7-10, 1993, Springer-Verlag, Berlin, Germany, 28 pages.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="30">
          <text>Meyer, Albert R., "Observing Truly Concurrent Processes," Proceedings of the Int'l. Symposium TACS '94, Sendai, Japan, Apr. 19-22, 1994, Springer-Verlag, Berlin, Germany, abstract.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="31">
          <text>Baeten, J.C.M. and C. Verhoef, A Congruence Theorem for Structured Operational Semantics with Predicates, Eindhoven University of Technology (Netherlands), Dept. of Mathematics and Computing Science, 1993, pp. 477-492.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="32">
          <text>Bloom, Bard et al., Bisimulation Can't be Traced: Preliminary Report, Laboratory for Computer Science, Massachusetts Institute of Technology, 1987, pp. 1-21.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="33">
          <text>Hoare, C.A.R., Communicating Sequential Processes, Prentice/Hall International, May 1985, Chapters 1, 2, 5, 6, and 7.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="34">
          <text>Taubner, Dirk, Finite Representations of CCS and TCSP Programs by Automata and Petri Nets, Lecture Notes in Computer Science, vol. 369, Springer Verlag, Berlin, 1989, 158 pages.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="35">
          <text>Milner, Robin, A Calculus of Communicating Systems, Lecture Notes in Computer Science, vol. 92, Springer-Verlag, Oct. 1980, Chapters 1-7.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="36">
          <text>Peterson, James L., "The Mach Kernel," Proceedings, Share Europe Spring Meeting: Managing Communications in a Global Marketplace, Cannes, France, Share Europe, Geneva, Switzerland, Mar. 30-Apr. 3, 1992, pp. 571-578.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="37">
          <text>Nakajima, Tatsuo et al., "Integrated Management of Priority Inversion in Real-Time Mach," Proceedings, Real-Time Systems Symposium 1993, IEEE, Piscataway, NJ 1993, pp. 120-130.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="38">
          <text>Black, David L., Scheduling Support for Concurrency and Parallelism in the Mach Operating System, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, Apr. 1990, 16 pages.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="39">
          <text>Cheriton, David R., The Thoth System: Multi-Process Structuring and Portability, Elsevier Science Publishing Co., Inc., New York, 1982, Chapters 1-5.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="40">
          <text>Cheriton, David R., Multi-Process Structuring and the Thoth Operating System, Computer Science Department, University of Waterloo, May 1979, 90 pages.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="41">
          <text>Fuggetta, Alfonso et al., Some Consideration on Real-Time Behavior of Concurrent Programs, IEEE Transactions on Software Engineering, vol. 15, No. 3, Mar. 1989, pp. 356-359.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="42">
          <text>Jones, Michael B and Richard F. Rashid, "Mach and Matchmaker: Kernel and Language Support for Object-Oriented Distributed Systems," in OOPSLA '86 Proceedings, Assoc. for Computing Machinery, Portland, Oregon, Sep. 29-Oct. 2, 1986, pp. 67-77.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="43">
          <text>Accetta, Mike et al., "Mach: A New Kernel Foundation for Unix Development," in Summer Conference Proceedings, USENIX Assoc., Jun. 9-13, 1986, Atlanta, Georgia, pp. 93-112.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="44">
          <text>Rashid, Richard F., "From RIG to Accent to Mach: The Evolution of a Network Operating System," in 1986 Proceedings of the Fall Joint Computer Conference, ACM and Computer Society of the IEEE, Nov. 2-6, 1986, pp. 1128-1137.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="45">
          <text>Sansom, Robert D. et al, "Extending a Capability Based System into a Network Environment" in Communications Architecture &amp; Protocols '86 Symposium, ACM SIGCOMM, Aug. 5, 6, and 7, 1986, pp. 265-274.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Microsoft Corporation</orgname>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>MICROSOFT</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Williams, Antonty S.</name>
            <address>
              <address-1>Mercer Island, WA, US</address-1>
              <city>Mercer Island</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Mitchell, Alexander A.</name>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Atkinson, Robert G.</name>
            <address>
              <address-1>Woodinville, WA, US</address-1>
              <city>Woodinville</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Hodges, C. Douglas</name>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="5">
          <addressbook lang="en">
            <name>Posch, Johann</name>
            <address>
              <address-1>Mercer Island, WA, US</address-1>
              <city>Mercer Island</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="6">
          <addressbook lang="en">
            <name>Wittenberg, Craig H.</name>
            <address>
              <address-1>Mercer Island, WA, US</address-1>
              <city>Mercer Island</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Klarquist Sparkman Campbell Leigh &amp; Whinston, LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Grant, William</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      The present invention provides a method and system for multi-threaded processing that is an improvement over conventional systems.
      <br/>
      The system of the present invention comprises multiple threads of execution, multiple apartments, shared data, and a concurrency management component.
      <br/>
      The threads of execution run independently and each occupy one apartment.
      <br/>
      The apartments contain objects that have methods to perform operations.
      <br/>
      The shared data contains data that is accessible by all threads within the process.
      <br/>
      The concurrency management mechanism performs processing so that the multiple threads can execute concurrently in a reliable and robust manner.
      <br/>
      In an alternative system of the present invention, the threads are separate from the apartments and the threads execute within the apartments to perform processing.
      <br/>
      After performing the processing, the thread exits the apartment so that the apartment may be occupied by another thread.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>TECHNICAL FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates generally to data processing systems and, more particularly, to multi-threaded processing within a data processing system.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      A computer program that has been loaded into memory and prepared for execution is called a "process." A process comprises the code, data, and other resources, such as files, that belong to the computer program.
      <br/>
      Each process in a data processing system has at least one thread which is known as the main thread.
      <br/>
      A thread comprises a pointer to a set of instructions, related central processing unit (CPU) register values, and a stack.
      <br/>
      A process can have more than one thread with each thread executing independently and keeping its own stack and register values.
      <br/>
      When a process has more than one thread, the process is said to be multi-threaded.
    </p>
    <p num="3">
      When a process performs multi-threaded processing, the threads can each perform a discrete unit of functionality.
      <br/>
      One advantage to multi-threaded processing is that threads can transfer information back and forth without having to cross process boundaries, which is expensive in terms of CPU processing time.
      <br/>
      Another advantage of multi-threaded processing is that when transferring data between threads of a single process, a reference to the data can be transferred instead of a copy of the data.
      <br/>
      Otherwise, if each discrete unit of functionality were implemented as a process, the data would typically have to be copied before being transferred to the destination process and this requires a significant amount of CPU processing time.
    </p>
    <p num="4">Two models used for performing multi-threaded processing by conventional systems are the free threading model and the lightweight process model.</p>
    <p num="5">
      As shown in FIG. 1, the free threading model comprises a process 100 containing a number of objects 104, 108, 112, 116 and shared data 102.
      <br/>
      The term "object" refers to a combination of code ("Methods") and data.
      <br/>
      The code of the object typically acts upon the data of the object.
      <br/>
      The shared data 102 is data that can be accessed by any object within the process 100.
      <br/>
      Each object in the free threading model has a lock 106, 110, 114, 118.
      <br/>
      The locks 106, 110, 114, 118 on the objects 104, 108, 112, 116 serialize access to each object so as to prevent contention problems.
      <br/>
      The shared data 102 has a semaphore 103 that serializes access to the shared data.
      <br/>
      In the free threading model, there are multiple threads and each thread can access any object 104, 108, 112, 116.
      <br/>
      Thus, the locks 106, 110, 114, 118 are necessary to prevent contention problems that may arise when more than one thread attempts to access an object.
    </p>
    <p num="6">
      One problem with the free threading model is that it is difficult to provide concurrency management within the free threading model.
      <br/>
      The term "concurrency management" in this context refers to managing the objects so that each object may concurrently execute in a reliable and robust manner.
      <br/>
      Providing concurrency management is difficult since a lock must be implemented for each object.
      <br/>
      In addition, the implementation of each lock is further complicated since each lock must play a part in preventing process-wide deadlock. "Deadlock," in this context, refers to when two or more objects are blocked while waiting on each other to perform an operation.
      <br/>
      For example, if a first object is blocked while waiting to invoke a method on a second object and the second object, in turn, is blocked while waiting to invoke a method on a first object, each object is waiting on the other and therefore deadlock has occurred.
      <br/>
      Since each object must have a lock, additional code is necessary for each object and this code must be developed and tested.
      <br/>
      Further, if an object is created and inadvertently a lock is not put on the object, the object and the process can behave in an undesirable manner.
      <br/>
      A second problem with the free threading model occurs when more than one object within a process is performing user interface operations.
      <br/>
      This problem arises because when an object is performing an operation on a portion of the user interface such as a window, the window is usually locked.
      <br/>
      Consequently, if a second object then tries to perform an operation on the window while the window is locked, the second object will receive an error and will not be able to perform the operation.
      <br/>
      Thus, it is difficult to perform user interface operations with the free threading model.
    </p>
    <p num="7">
      FIG. 2 depicts a diagram of the lightweight process ("LWP") model for performing multi-threaded processing.
      <br/>
      In the LWP model, a process 200 contains a number of lightweight processes 202, 204, 206.
      <br/>
      Each lightweight process executes independently and contains procedures, data and variables.
      <br/>
      Therefore, a lightweight process is very similar to a thread.
      <br/>
      In the LWP model, each lightweight process can perform a discrete unit of functionality and can thus take advantage of the benefits of multi-threaded processing.
      <br/>
      However, the LWP model does not provide shared data and therefore when one lightweight process wants to communicate to another lightweight process, the data is typically copied before it can be sent.
      <br/>
      Performing a copy of the data before sending the data requires a significant amount of CPU processing time.
      <br/>
      In addition, since there is no shared data, data that all lightweight processes would like to access has to be maintained by a lightweight process.
      <br/>
      Such information includes location information for the procedures in the lightweight processes.
      <br/>
      Therefore, for example, whenever a lightweight process wants to determine the location of a procedure so that it may invoke the procedure, the lightweight process must communicate to the lightweight process that maintains the location information.
      <br/>
      This communication is costly in terms of CPU processing time.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="8">
      In accordance with a first aspect of the present invention, a method is executed in a computer system having a process with address space and a plurality of threads within the address space.
      <br/>
      In accordance with this method of the first aspect of the present invention, each thread is a path of execution and has a communication mechanism.
      <br/>
      In addition, the communication mechanism has a concurrency management component.
      <br/>
      This method of the first aspect of the present invention provides for sending a communication from a source thread to a destination thread, where the communication requests a reply from the destination thread to the source thread.
      <br/>
      While the source thread is waiting for the reply to the communication, this method provides for processing events by the concurrency management component to manage concurrency on behalf of the source thread so that concurrency problems do not arise while the source thread is waiting.
      <br/>
      Further, this method provides for receiving the reply to the communication from the destination thread.
    </p>
    <p num="9">
      In accordance with a second aspect of the present invention, a method is executed in a computer system having a process with a plurality of threads of execution and a plurality of apartments.
      <br/>
      In accordance with this method of the first aspect of the present invention the threads are for executing within the apartments and the apartments contain objects.
      <br/>
      This method provides for receiving a communication by a first thread to perform processing within an apartment, determining if a second thread is executing within the apartment, when it is determined that the second thread is not executing within the apartment, executing within the apartment by the first thread to process the communication, and when it is determined that the second thread is executing within the apartment, sending the communication to the second thread for processing.
    </p>
    <p num="10">
      In accordance with a third aspect of the present invention, a data processing system having a process is provided.
      <br/>
      The process of the data processing system of the third aspect of the present invention comprises a plurality of objects, a shared data component, and a communication mechanism.
      <br/>
      The plurality of objects comprises a source object for generating a first communication and for outputting instructions and a destination object for receiving the first communication from the source object.
      <br/>
      The shared data component is for maintaining data accessible by the objects, wherein the first communication refers to data within the shared data component.
      <br/>
      The communication mechanism is for sending the first communication from the source object to the destination object and for receiving the instructions from the source object.
      <br/>
      The communication mechanism further comprises a concurrency management component for executing the instructions received from the source object when a second communication is received by the source object while the communication mechanism is sending the first communication to the destination object but the sending of the first communication has not yet completed, wherein the instructions are for managing concurrency on behalf of the source object so that concurrency problems do not arise while the communication mechanism is sending the first communication.
    </p>
    <p num="11">
      In accordance with a fourth aspect of the present invention, a data processing system having a process is provided.
      <br/>
      The process of the data processing system of the fourth aspect of the present invention comprises a plurality of apartments, a remote procedure call component, a plurality of threads of execution, and a shared data component.
      <br/>
      The plurality of apartments contain procedures for performing operations.
      <br/>
      The remote procedure call component is for sending a message containing a remote procedure call for invoking a procedure of a destination apartment.
      <br/>
      The plurality of threads of execution are for receiving the message containing the remote procedure call, for executing the procedure of the destination apartment to process the remote procedure call when the apartment is unoccupied, and for sending the message to a thread occupying the apartment when the apartment is occupied.
      <br/>
      The shared data component is for maintaining data accessible by the threads of execution, wherein a thread of execution accesses the shared data as part of invoking the procedure.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="12">
      FIG. 1 depicts the components utilized in the conventional free threading mode for multi-threaded processing.
      <br/>
      FIG. 2 depicts the components utilized in the conventional lightweight process model for multi-threaded processing.
      <br/>
      FIG. 3 depicts a data processing system suitable for practicing the preferred embodiment of the present invention.
      <br/>
      FIG. 4 depicts the components of the apartment model of the preferred embodiment of the present invention.
      <br/>
      FIG. 5 depicts a more detailed diagram of the components of the apartment model of the preferred embodiment of the present invention.
      <br/>
      FIG. 6 depicts a flow chart of the steps performed in creating a thread in the apartment model of the preferred embodiment of the present invention.
      <br/>
      FIG. 7 depicts an example of a process utilizing the apartment model of the preferred embodiment of the present invention.
      <br/>
      FIG. 8 depicts a flow chart of the steps performed by an RPC mechanism of a thread of the apartment model of the preferred embodiment of the present invention when sending a message.
      <br/>
      FIG. 9 depicts a flow chart of the steps performed by the message loop of a thread of the apartment model of the preferred embodiment of the present invention that does not perform user interface operations.
      <br/>
      FIG. 10 depicts a flow chart of the steps performed by the message loop of a thread of the apartment model of the preferred embodiment of the present invention that performs user interface operations.
      <br/>
      FIG. 11A depicts a flow chart of the steps performed by an RPC window procedure of a thread of the apartment model of the preferred embodiment of the present invention that performs user interface operations.
      <br/>
      FIG. 11B depicts a flow chart of the steps performed by a UI window procedure of a thread of the apartment model of the preferred embodiment of the present invention that performs user interface operations.
      <br/>
      FIG. 12 depicts a flow chart of the steps performed by the RPC inbound thread of the apartment model of the preferred embodiment of the present invention.
      <br/>
      FIG. 13 depicts a flow chart of the steps performed by the RPC outbound thread of the apartment model of the preferred embodiment of the present invention.
      <br/>
      FIG. 14 depicts the components of the rental model of an alternative embodiment of the present invention.
      <br/>
      FIG. 15 depicts a flow chart of the steps performed by a thread of the rental model of the alternative embodiment of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE INVENTION</heading>
    <p num="13">
      The preferred embodiment of the present invention provides an improved method and system for performing multi-threaded processing.
      <br/>
      The preferred embodiment of the present invention is known as the "Apartment Model" for multi-threaded processing.
      <br/>
      The apartment model is an improvement over conventional systems by having multiple threads, shared data, and concurrency management on a per-thread basis.
      <br/>
      Each thread has one apartment in which it executes and each apartment contains objects.
      <br/>
      The shared data is data that is accessible by all threads within the process.
      <br/>
      The concurrency management of the preferred embodiment is implemented on a per-thread basis and manages the multiple threads so that each thread may concurrently execute in a reliable and robust manner.
    </p>
    <p num="14">
      The apartment model has a number of significant advantages over conventional systems.
      <br/>
      First, the apartment model performs concurrency management on a per-thread basis and therefore is an improvement over the free threading model where concurrency management is implemented on an object-by-object basis.
      <br/>
      This reduces the number of locks that must be implemented, thereby facilitating the implementation of objects and threads.
      <br/>
      Second, the apartment model is well suited for use with user interface operations.
      <br/>
      This improvement over conventional systems is realized from having one window on the user interface managed by no more than one thread.
      <br/>
      Third, the apartment model utilizes shared data which reduces the CPU processing time for transferring data between threads and reduces the CPU processing time for accessing data that needs to be accessible by all threads.
      <br/>
      CPU processing time is reduced when transferring data since a reference to the data can be transferred instead of a copy of the data.
      <br/>
      Also, since data that needs to be accessible by all threads is stored in the shared data, a direct memory reference can occur when accessing the data.
      <br/>
      This is an improvement over the LWP model where a communication to a thread maintaining the data would have to occur.
    </p>
    <p num="15">
      In an alternative embodiment of the present invention, known as the "rental model," the threads within the process are separate from the apartments within the process and, thus, there is no one-to-one correspondence between apartments and threads.
      <br/>
      That is, practically any thread can execute in any apartment, but only one at a time.
      <br/>
      In the rental model, the apartments are merely data structures containing objects and the threads execute within the apartments to perform processing.
      <br/>
      After performing processing within an apartment, a thread releases the apartment so that the apartment can be used by another thread.
      <br/>
      Typically in the rental model, the number of threads is less than the number of apartments and each thread is utilized on an as-needed basis.
      <br/>
      Thus, the number of threads for a process is reduced and the overhead (e.g., register, stack, etc.) associated with each thread is also reduced.
      <br/>
      In addition, by separating the threads from the apartments, the rental model reduces the amount of processing associated with concurrency management.
      <br/>
      This is done by a thread determining whether an apartment is in use by another thread ("occupied") or not in use ("unoccupied") before attempting to execute within the apartment.
      <br/>
      If the apartment is unoccupied, the thread can avoid the processing associated with concurrency management and execute within the apartment without fear of encountering any concurrency problems.
      <br/>
      It is only when the apartment is occupied that the thread performs processing associated with concurrency management to prevent concurrency problems.
    </p>
    <p num="16">
      FIG. 3 depicts a data processing system 300 suitable for practicing the preferred embodiment of the present invention.
      <br/>
      The data processing system 300 has a CPU 302, a memory 304 and a secondary storage device 306 such as a hard disk drive.
      <br/>
      The memory 304 holds a copy of an operating system 310, such as the "MICROSOFT WINDOWS NT" operating system sold by Microsoft Corporation of Redmond, Wash., and a copy of an application program 308.
    </p>
    <p num="17">
      FIG. 4 depicts the components of a process 308 utilizing the apartment model of the present invention.
      <br/>
      The process 308 contains shared memory 400, a user interface (UI) thread 402 and a non-UI thread 404.
      <br/>
      The shared memory 400 is accessible by all threads within the process 308 and access to the shared memory is protected by semaphores 401.
      <br/>
      The UI thread 402 performs UI operations and contains objects 414, 416, a remote procedure call (RPC) mechanism 406 and a concurrency management (CM) mechanism 410.
      <br/>
      The RPC mechanism 406 is responsible for sending and receiving messages.
      <br/>
      The RPC mechanism 406 can both send messages to other threads within the process 308 as well as messages to other processes.
      <br/>
      The messages sent by the RPC mechanism 406 can be used to invoke the methods on objects in other threads or other processes.
      <br/>
      The CM mechanism 410 is responsible for handling concurrency problems so that the threads within the process 308 can execute concurrently in a reliable and robust manner.
      <br/>
      A suitable CM mechanism for use in the apartment model is more fully described in U.S. patent application Ser.
      <br/>
      No. 08/224,859, entitled "Concurrency Management in a Communication Mechanism," now U.S. Pat. No. 5,675,796, entitled "Concurrency Management Component for Use by a Computer Program During the Transfer of a Message," which is hereby incorporated by reference.
      <br/>
      The non-UI thread 404 performs operations not associated with a user interface and contains objects 418, 420, 422, the RPC mechanism 408, and the CM mechanism 412.
      <br/>
      Although only two threads are depicted, one skilled in the art will appreciate that additional or fewer threads can be used by the present invention.
    </p>
    <p num="18">
      A developer of an application program can conform to the apartment model for multi-threaded processing and thus take advantage of the benefits of the apartment model by utilizing apartments, shared memory, an RPC mechanism, and a CM mechanism.
      <br/>
      The developer utilizes apartments for their application program by dividing the application program into discrete units of functionality.
      <br/>
      Each discrete unit of functionality is then implemented as an apartment containing objects where each object performs functionality related to the discrete unit of functionality of the apartment.
      <br/>
      The developer utilizes shared memory by allocating a portion of memory within the address space of the application program to be accessible by all apartments.
      <br/>
      The developer then defines which data within the application program should be placed into shared memory and develops semaphores to serialize access to the shared data.
      <br/>
      However, the semaphores may be provided to the developer as an operating system facility.
      <br/>
      The developer utilizes an RPC mechanism by either developing an RPC mechanism or by incorporating any of a number of well-known RPC mechanisms into the application program.
      <br/>
      The developer utilizes a CM mechanism in the application program by utilizing any acceptable CM mechanism such as the CM mechanism described in U.S. patent application Ser.
      <br/>
      No. 08/224,859, entitled "Concurrency Management in a Communication Mechanism," now U.S. Pat. No. 5,675,796, entitled "Concurrency Management Component for Use by a Computer Program During the Transfer of a Message." After utilizing the apartments, the shared memory, the RPC mechanism and the CM mechanism in the application program, the application program can then take advantage of the apartment model for multi-threaded processing.
    </p>
    <p num="19">
      The shared memory of the apartment model contains a data structure that is accessible by all threads within the process.
      <br/>
      This data structure contains an entry for each object in the process.
      <br/>
      Each entry in the data structure contains a field for the object ID, the apartment ID in which the object is located, a handle ("window handle") to one or more windows associated with the thread, and a pointer to the object.
      <br/>
      In accessing the data structure, since the data structure is protected by semaphores, a thread must go through a specific procedure.
      <br/>
      This procedure is as follows: the thread wishing to access the data structure first executes a "wait" command, which identifies that the thread will wait until the data structure is available; when the data structure is available, the thread accesses the data structure to retrieve or store whichever entries are needed; and when the thread has completed accessing the data structure, the thread performs a "signal" command, which indicates that the data structure is available for use by another thread.
    </p>
    <p num="20">
      As previously stated, the CM mechanism performs concurrency management for the threads in a process.
      <br/>
      In order to use the CM mechanism, a thread must first register with the CM mechanism by invoking the CoRegisterMessageFilter routine, which is described in more detail in U.S. patent application Ser.
      <br/>
      No. 08/224,859, entitled "Concurrency Management in a Communication Mechanism," now U.S. Pat. No. 5,675,796, entitled "Concurrency Management Component for Use by a Computer Program During the Transfer of a Message." After registering with the CM mechanism, the CM mechanism can be utilized to perform concurrency management processing.
      <br/>
      A thread, in utilizing the CM mechanism, will typically send a message to an object in another thread or another process.
      <br/>
      While the thread is waiting for a successful reply to the message sent, the CM mechanism enters a loop and handles all events that occur.
      <br/>
      Such events include incoming messages, unsuccessful replies and window messages.
      <br/>
      Incoming messages are handled by the CM mechanism by determining if the thread is in a state where it can handle the message.
      <br/>
      If the thread is in such a state, the thread processes the message.
      <br/>
      Otherwise, the incoming message is rejected.
      <br/>
      The term "window messages" refers to messages destined for the window associated with the thread.
      <br/>
      The processing of the CM mechanism is more fully described in U.S. patent application Ser.
      <br/>
      No. 08/224,859, entitled "Concurrency Management in a Communication Mechanism," now U.S. Pat. No. 5,675,796, entitled "Concurrency Management Component for Use by a Computer Program During the Transfer of a Message," which has previously been incorporated by reference.
    </p>
    <p num="21">
      The "WINDOWS NT" operating system can be used to transfer messages between processes and threads within a data processing system.
      <br/>
      This transfer of messages is performed by the operating system maintaining a message queue for each thread that has a window.
      <br/>
      When the operating system receives a message, it puts the message onto the message queue of the thread for which the message is destined and the thread can then retrieve the message from the message queue.
      <br/>
      In retrieving messages from the message queue, a thread typically uses a "message loop." In the message loop, the thread continually retrieves messages and processes the messages for the lifetime of the thread.
      <br/>
      This message loop performs functionality dependent upon whether the thread performs user interface operations (i.e., has a window) or does not perform user interface operations.
      <br/>
      This will be described in more detail below.
      <br/>
      In order to interact with the message queue, "WINDOWS NT" provides various routines: GetMessage, PostMessage, and DispatchMessage.
      <br/>
      The GetMessage routine retrieves the next message from the message queue maintained by the operating system for a particular thread.
      <br/>
      The PostMessage routine is used by a thread to pass a message to the operating system and the operating system will then place the message onto the message queue for the thread for which the message is destined.
      <br/>
      The DispatchMessage routine is invoked by a thread to pass a message to the operating system and, in turn, the operating system will invoke the appropriate window procedure for handling the message.
      <br/>
      Another mechanism used by "WINDOWS NT" to transfer messages is the window procedure ("WinProc").
      <br/>
      Every window has an associated WinProc and a thread can have more than one window.
      <br/>
      This WinProc is defined by the thread and invoked by the operating system when the operating system receives an event for the thread.
      <br/>
      Such an event may include timer expiration, the button of a mouse being depressed, or movement of the mouse.
      <br/>
      WinProcs will be discussed in more detail below.
      <br/>
      Although the apartment model of the preferred embodiment of the present invention is described as using the "WINDOWS NT" operating system, one skilled in the art will appreciate that other operating systems can be used.
    </p>
    <p num="22">
      FIG. 5 depicts a more detailed diagram of a process 308 utilizing the apartment model and interacting with the operating system (OS) 310 and a network 510.
      <br/>
      The process 308 has shared memory 400, a UI thread 402, a non-UI thread 404, an RPC inbound thread 502 and an RPC outbound thread 503.
      <br/>
      The RPC inbound thread 502 is responsible for receiving messages from the network 510 or an RPC outbound thread from another process, and passing the messages to the OS 310 for delivery to the threads 402, 404.
      <br/>
      The RPC outbound thread 503 receives messages from the threads 402, 404 indirectly through a message queue 505 and sends the messages to the network 510 or to the OS 310 where the messages are delivered to an RPC inbound thread in another process.
      <br/>
      The network 510 used by the present invention can be any of a number of networks including, but not limited to, a local area network or a wide area network.
      <br/>
      The operating system 310 contains a message queue 504 that contains messages for the UI thread 402, a message queue 505 that contains messages for the RPC outbound thread 503 and a message queue 506 that contains messages for the non-UI thread 404.
      <br/>
      The non-UI thread 404 and the RPC outbound thread 503 of the present invention display an invisible window so that the OS 310 will maintain a message queue 506 for the non-UI thread and the RPC outbound thread.
    </p>
    <p num="23">
      FIG. 6 depicts a flowchart of the steps performed in creating a thread.
      <br/>
      The steps described herein can be performed statically or dynamically.
      <br/>
      That is, the creation of a thread within the apartment model can be performed as part of initialization, before normal processing begins, or as part of normal processing.
      <br/>
      The steps described are typically performed by the main thread of a process or, alternatively, the steps can be performed by another thread.
      <br/>
      The first step performed in creating a thread is to invoke the CoInitializeEx routine (step 602).
      <br/>
      The CoInitializeEx routine is a call to the RPC inbound thread that makes an entry in the data structure in the shared memory for the new thread and creates a window handle for the new thread.
      <br/>
      After invoking the CoInitializeEx routine, the thread invokes the CreateThread routine (step 604).
      <br/>
      The CreateThread routine is a call to the operating system that creates a new thread for a process.
      <br/>
      The arguments to the CreateThread routine include the starting address of the code that the thread is to execute.
      <br/>
      After creating the thread, the thread then creates objects within the newly created thread (step 606).
      <br/>
      The creation of the objects and the functions performed by the objects depend on the functionality of the process in which the objects and thread are created and are therefore said to be "application specific." For example, if the process were a spreadsheet program, one object may be implemented for each cell in a spreadsheet with the methods of the object being used to manipulate the data within the cell.
      <br/>
      After creating the objects, the thread registers the created objects with the data structure in the shared memory (step 608).
      <br/>
      In this step, the main thread adds entries to the data structure for each object that is created in the newly created thread.
      <br/>
      After registering the objects, all of the processing necessary for creating a thread in the apartment model is completed.
    </p>
    <p num="24">
      To more clearly describe the creation and use of threads within an application program, consider FIG. 7 which depicts an example of the creation and utilization of a thread in the apartment model.
      <br/>
      This example describes a thread created as part of the processing of a spreadsheet program.
      <br/>
      In this example, the main thread of the spreadsheet program is responsible for creating a spreadsheet object and the main thread subsequently creates a second thread, "thread 2," that performs "auto save" functionality.
      <br/>
      Auto save functionality refers to automatically saving the spreadsheet every ten minutes while the spreadsheet is open for user manipulation.
      <br/>
      The example described below is designed to operate in an object oriented environment, such as an environment that supports the Microsoft OLE 2.0 protocol established by Microsoft Corporation of Redmond, Wash.
      <br/>
      One skilled in the art will recognize that the present invention can be practiced in a non-object oriented environment as well as other object oriented environments.
    </p>
    <p num="25">
      The first step performed in the spreadsheet example is that the main thread invokes the CoInitializeEx routine (step 702).
      <br/>
      The processing of this step is similar to that as described relative to step 602 of FIG. 6.
      <br/>
      After invoking the CoInitializeEx routine, the main thread creates a spreadsheet object.
      <br/>
      In this step, the main thread creates an object representative of a spreadsheet with methods to manipulate the spreadsheet.
      <br/>
      After creating the spreadsheet object, the main thread registers the object with the data structure in the shared memory (step 706).
      <br/>
      The processing of this step is similar to that as described relative to step 608 of FIG. 6.
      <br/>
      After registering the object, the main thread invokes the CoMarshalInterface routine to prepare an interface to the spreadsheet object to be marshaled to thread 2 (step 708).
      <br/>
      The term "interface" refers to a collection of methods on an object and the term "marshalling" refers to transferring a pointer of an interface to an entity, so that the entity can invoke the methods on the interface.
      <br/>
      The CoMarshalInterface routine is more clearly described in U.S. patent application Ser.
      <br/>
      No. 08/158,627, entitled "Method and System for Network Marshalling of Interface Pointers for Remote Procedure Calls," now U.S. Pat. No. 5,511,197, which is hereby incorporated by reference.
      <br/>
      After invoking the CoMarshalInterface routine, the main thread invokes the create thread routine to create thread 2 (step 710).
    </p>
    <p num="26">
      After invoking the create thread routine, thread 2 is created and the code for thread 2 is executed on the path of execution for thread 2.
      <br/>
      The first step performed by thread 2 is to invoke the ColnitializeEx function (step 712).
      <br/>
      After invoking the ColnitializeEx function, thread 2 invokes the CoUnmarshalInterface routine (step 714).
      <br/>
      The CoUnmarshalInterface routine returns a pointer to an interface on the spreadsheet object so that thread 2 can invoke the methods on the spreadsheet object.
      <br/>
      After invoking the CoUnmarshalInterface routine, thread 2 determines if the spreadsheet object is still in existence (step 716).
      <br/>
      While the spreadsheet object is in existence, thread 2 waits 10 minutes and invokes Pobj.Save (step 718).
      <br/>
      In this step, "Pobj" refers to a pointer to the interface and the "Save" method refers to a method that saves the spreadsheet object.
      <br/>
      Thus, this step automatically saves the spreadsheet object every 10 minutes while the object is in existence.
      <br/>
      If, however, the spreadsheet object were ever deleted, thread 2 terminates the thread (step 720).
      <br/>
      In this step, thread 2 is terminated and all of the overhead (e.g., CPU registers, stack, etc.) is released.
      <br/>
      After terminating the thread, the processing for thread 2 ends.
    </p>
    <p num="27">
      With reference to the main thread, after the main thread has invoked the create thread routine and the create thread routine has returned, the main thread goes into a message loop for the lifetime of the main thread (step 722).
      <br/>
      During the processing of the message loop, the main thread can receive events from a number of sources including the keyboard, the operating system or thread 2.
      <br/>
      All messages and events are interleaved and received one at a time via the message loop.
    </p>
    <p num="28">
      Although the spreadsheet example has been described using the CoMarshalInterface and CoUnmarshalInterface routines, one skilled in the art will appreciate that other routines can be used to pass interface pointers or references to objects.
      <br/>
      One example of such an alternative is utilizing the BindToObject routine.
      <br/>
      The BindToObject routine is more clearly described in U.S. patent application Ser.
      <br/>
      No. 08/088,724, entitled "Method and System for Naming and Binding Objects," now abandoned which is hereby incorporated by reference.
      <br/>
      In addition, one skilled in the art will appreciate that other OLE routines can be used as well as other functions of other object models.
      <br/>
      Although the creation of objects has been described relative to a newly created thread, one skilled in the art will recognize that in the present invention a thread (or apartment) can be created without objects or that objects can be created and deleted dynamically during the lifetime of the thread.
    </p>
    <p num="29">
      FIG. 8 depicts the steps performed by the RPC mechanism of a thread in the apartment model when sending a message.
      <br/>
      The processing described is applicable to both UI threads and non-UI threads.
      <br/>
      In describing the processing, it is assumed that the thread has previously invoked the CoRegisterMessageFilter routine, which registers the thread with the CM mechanism.
      <br/>
      After registering with the CM mechanism, the thread can utilize the CM mechanism to perform concurrency management.
      <br/>
      The first step performed by the RPC mechanism is to allocate a buffer and package the parameters for the message into the buffer (step 802).
      <br/>
      The parameters of the message include the object ID of the object for which the message is destined, the method ID of the method for invocation, parameters for the method and the communication port ID.
      <br/>
      One skilled in the art will appreciate that additional or different parameters may be used by the present invention.
      <br/>
      The communication port ID is discussed in more detail below.
      <br/>
      After packaging the parameters, the RPC mechanism determines whether the destination for the message is intraprocess (step 804).
      <br/>
      In this step, the RPC mechanism examines the communication port ID within the message.
      <br/>
      Each message has a communication port ID that is an identifier of the destination of the message and can therefore identify that the message is destined for an intraprocess thread.
      <br/>
      In addition, the communication port ID can refer to the communication port of the network or the communication port of an RPC inbound thread that is in another process.
      <br/>
      A "communication port" is a portion of the destination that is used for receiving and storing messages.
      <br/>
      Alternatively, a communication port can refer to a mechanism for transferring data to the destination's memory.
      <br/>
      If the destination is an object of a thread within the process, the RPC mechanism retrieves the window handle from the data structure for the destination thread (step 806).
      <br/>
      After retrieving the window handle for the destination thread, the RPC mechanism invokes the PostMessage routine (step 808).
      <br/>
      In this step, the RPC mechanism passes the message to the operating system and the operating system places the message onto the appropriate message queue for the destination thread.
      <br/>
      If the message is destined for outside of the process, the RPC mechanism sends the message to the RPC outbound thread (step 812).
      <br/>
      The RPC mechanism sends the message to the RPC outbound thread via the operating system where it is placed on the message queue of the RPC outbound thread.
      <br/>
      After receiving the message, the RPC outbound thread will then send the message to another process either locally or over the network.
      <br/>
      After either sending the message to the RPC outbound thread or posting the message, the RPC mechanism waits for a response to the outstanding message and performs concurrency management while waiting for the response (step 810).
      <br/>
      One benefit to using an RPC outbound thread in step 812 is that step 810 can be performed for all messages (both intra-process and RRC messages) and therefore centralizes concurrency management processing.
      <br/>
      That is, there is one step that is invoked for receiving responses to all types of messages.
      <br/>
      The CM mechanism performs concurrency management by processing all incoming messages, window messages, and unsuccessful responses to the message until a successful response to the message is received.
      <br/>
      After receiving a successful response to the message, processing ends.
      <br/>
      Although the RPC mechanism has been described as centralizing concurrency management processing, one skilled in the art will appreciate that instead of utilizing an RPC outbound thread in step 812, the present invention can send an RPC message directly over a network or other transport and then in step 810 wait for responses over multiple receive channels.
    </p>
    <p num="30">
      FIG. 9 depicts a flowchart of the steps performed by the message loop for a non-UI thread.
      <br/>
      The first step performed by the message loop is to determine whether the thread has any objects in the apartment (step 901).
      <br/>
      If during the lifetime of the thread all of the objects in the apartment were deleted, processing ends.
      <br/>
      Otherwise, the non-UI thread invokes the GetMessage routine (step 902).
      <br/>
      In this step, the GetMessage routine retrieves the next message from the message queue for the non-UI thread.
      <br/>
      After retrieving the message, the non-UI thread determines whether the message retrieved is an RPC message (step 904).
      <br/>
      This is done by examining the parameters of the message.
      <br/>
      If the message retrieved is an RPC message, the non-UI thread extracts the object ID and the method ID from the message (step 906).
      <br/>
      After extracting the object ID and the method ID, the non-UI thread unpacks the parameters from the message and invokes the particular method on the object (step 908).
      <br/>
      In this step, the parameters for the particular method are unpacked and the method is invoked with the parameters.
      <br/>
      If, however, the non-UI thread receives a message other than an RPC message, the non-UI thread processes the message (step 912).
      <br/>
      In this step, the non-UI thread may have received another type of message either from the operating system or from another thread or process and the non-UI thread will process the message accordingly.
      <br/>
      This processing is application specific.
      <br/>
      After either processing a non-RPC message or invoking the method on the object, processing continues to step 901.
      <br/>
      Although only one mechanism, step 901, has been described for terminating the message loop, one skilled in the art will appreciate that other mechanisms can be used.
    </p>
    <p num="31">
      FIG. 10 depicts the steps performed by the message loop for a UI thread.
      <br/>
      The first step performed by the message loop is to determine whether the thread has any objects in the apartment (step 1002).
      <br/>
      If during the lifetime of the thread all of the objects were deleted from the apartment, processing ends.
      <br/>
      However, while there are objects in the apartment, the message loop invokes the GetMessage routine (step 1004) and the DispatchMessage routine (step 1006).
      <br/>
      The GetMessage routine retrieves the next message from the message queue for the thread.
      <br/>
      The DispatchMessage routine sends the retrieved message to the operating system so that the operating system can invoke the window procedure for this thread to handle the message.
      <br/>
      Although only one mechanism, step 1002, has been described for terminating the message loop, one skilled in the art will appreciate that other mechanisms can be used.
    </p>
    <p num="32">
      A UI thread has two window procedures: an RPC window procedure for handling RPC messages and a UI window procedure for handling events from the operating system.
      <br/>
      FIG. 11A depicts the steps performed by the RPC window procedure for a UI thread.
      <br/>
      The RPC WinProc for a UI thread receives messages from other threads.
      <br/>
      The first step performed by the RPC WinProc of a UI thread is to extract the object ID and the method ID from the message (step 1104).
      <br/>
      After extracting the object ID and the method ID, the RPC WinProc unpacks the parameters for the method from the message and invokes the appropriate method (step 1106).
      <br/>
      As part of invoking the method, when the method invocation completes, the appropriate parameters are returned.
      <br/>
      The processing of this step is similar to that described relative to step 908 of FIG. 9.
      <br/>
      After invoking the appropriate method, the processing ends.
    </p>
    <p num="33">
      FIG. 11B depicts the steps performed by the UI window procedure for a UI thread.
      <br/>
      The UI WinProc receives events from the operating system.
      <br/>
      The term "events" is generally used to refer to everything received via the operating system, including messages.
      <br/>
      The first step performed by the UI WinProc is to process the event (step 1108).
      <br/>
      In this step, the UI WinProc has received an event such as a MOUSE_DOWN event.
      <br/>
      In response to receiving the event, the WinProc will perform application specific processing.
      <br/>
      After processing the event, processing ends.
    </p>
    <p num="34">
      Although the processing of FIGS. 10, 11A and 11B has been described relative to a UI thread, one skilled in the art will appreciate that the non-UI threads of the present invention can also perform this processing.
      <br/>
      That is, since the non-UI threads of the present invention utilize an invisible window, the non-UI threads can be implemented using the WinProcs described in FIGS. 11A and 11B.
    </p>
    <p num="35">
      FIG. 12 depicts a flowchart of the steps performed by the RPC inbound thread of the preferred embodiment.
      <br/>
      The first step performed by the RPC inbound thread is to invoke the RPC_GetMessage routine (step 1202).
      <br/>
      The RPC_GetMessage routine retrieves a message from its communication port that is destined for a thread within the process.
      <br/>
      As previously stated, each RPC inbound thread has a communication port that stores messages received from the network or from an RPC outbound thread from another process.
      <br/>
      After invoking the RPC_GetMessage routine, the RPC inbound thread extracts the object ID from the message (step 1204).
      <br/>
      After extracting the object ID, the RPC inbound thread obtains the window handle to the thread for which the message is destined (step 1206).
      <br/>
      In this step, the RPC inbound thread accesses the data structure in the shared memory with the object ID so as to obtain the window handle.
      <br/>
      After obtaining the window handle, the RPC inbound thread invokes the PostMessage routine (step 1208).
      <br/>
      In this step, the PostMessage routine passes the message to the operating system and the operating system, in turn, places the message onto the appropriate message queue for the thread for which the message is destined.
      <br/>
      One of the parameters to the PostMessage routine is the window handle of the destination thread.
      <br/>
      After invoking the PostMessage routine, processing continues to step 1202.
    </p>
    <p num="36">
      FIG. 13 depicts a flowchart of the steps performed by the RPC outbound thread.
      <br/>
      The first step performed by the RPC outbound thread is to invoke the GetMessage routine (step 1302).
      <br/>
      In this step, the RPC outbound thread retrieves a message from its message queue.
      <br/>
      Although the preferred embodiment is described as retrieving a message from the message queue, one skilled in the art will appreciate that the present invention can receive messages via other mechanisms.
      <br/>
      After invoking the GetMessage routine, the RPC outbound thread examines the communication port ID contained within the message (step 1304).
      <br/>
      In this step, the RPC outbound thread retrieves the communication port ID, which may be a reference to the communication port of the network or the communication port of an RPC inbound thread of another process.
      <br/>
      After examining the communication port ID, the RPC outbound thread sends the message to the referenced communication port (step 1306).
      <br/>
      After sending the message to the referenced communication port, the RPC outbound thread continues to step 1302 and invokes the GetMessage routine.
      <br/>
      The RPC outbound thread continues processing steps 1302-1306 until the RPC outbound thread is terminated.
    </p>
    <p num="37">
      The rental model is an alternative embodiment of the present invention where the threads are separate from the apartments in which the threads execute.
      <br/>
      Using the rental model, there are typically less threads than apartments.
      <br/>
      This has the advantage of reducing the overhead associated with having multiple threads.
      <br/>
      Another advantage to having threads separate from the apartments in which they execute is that concurrency management processing is reduced.
      <br/>
      That is, when a thread needs to execute within an apartment, if the apartment is unoccupied, there is no need to perform concurrency management when accessing the apartment.
      <br/>
      This saves the processing time associated with performing concurrency management.
      <br/>
      As shown in FIG. 14, a process 1400 utilizing to the rental model interacts with the operating system 310.
      <br/>
      The process 1400 has a number of threads 1402, 1404, 1406, including an RPC inbound thread 502, and a number of apartments 1408, 1410, 1412, and 1414.
      <br/>
      The apartments 1408, 1410, 1412, 1414 have objects 1416, 1418, 1420, 1422, 1424, 1426, 1428.
      <br/>
      The threads 1402, 1404, 1406 are independent paths of execution that receive messages from either another thread or the RPC inbound thread 502 via the operating system 310.
      <br/>
      The RPC inbound thread 502 receives messages (RPC messages) from another process via the operating system 310.
      <br/>
      Regardless of whether the thread is an RPC inbound thread or not, the processing performed by each thread is similar.
      <br/>
      Upon receiving a message, a thread will examine the message and determine the apartment in which the thread must execute in order to process the message.
      <br/>
      The thread then determines whether the apartment is occupied or unoccupied, and if the apartment is unoccupied, the thread occupies the apartment and processes the message.
      <br/>
      Otherwise, if the apartment is occupied, the thread sends a message to the thread occupying the apartment by posting a message to the operating system.
      <br/>
      This message will then be retrieved by the thread executing within the apartment and handled by the CM mechanism.
      <br/>
      That is, the message will be interleaved in the message queue and processed if the thread occupying the apartment is in a state capable of handling the message.
    </p>
    <p num="38">
      FIG. 15 depicts a flowchart of the steps performed by a thread utilizing the rental model.
      <br/>
      The processing described herein is applicable to threads and RPC inbound threads.
      <br/>
      That is, this processing is independent of the source of the message.
      <br/>
      The first step performed by the thread is to invoke the GetMessage routine (step 1502).
      <br/>
      After invoking the GetMessage routine, the thread unpacks the parameters and determines the destination apartment (step 1504).
      <br/>
      This step is performed by obtaining the object ID within the message and accessing the data structure within the shared memory.
      <br/>
      After determining the destination apartment, the thread determines if the destination apartment is occupied (step 1506).
      <br/>
      That is, in this step, the thread determines whether another thread is executing within the destination apartment.
      <br/>
      If the destination apartment is occupied, the thread posts the message to the occupying thread in the destination apartment (step 1516).
      <br/>
      The thread posts the message in this step so that the occupying thread receives the message when the occupying thread checks for incoming messages before exiting the apartment and then processes the message utilizing the CM mechanism.
      <br/>
      After posting the message, the thread waits for a reply from the occupying thread and returns the reply (step 1517).
      <br/>
      After returning the reply, the processing continues to step 1502 where the thread again invokes the GetMessage routine.
      <br/>
      If the destination apartment is unoccupied, the thread executes within the destination apartment (step 1508).
      <br/>
      In this step, the thread accesses the desired object invokes the appropriate methods on the object, and returns the results.
      <br/>
      After executing within the destination apartment, the thread determines whether it has received any incoming messages (step 1510).
      <br/>
      In this step, the thread examines the message queue to determine if it has received any messages.
      <br/>
      If the thread has received an incoming message, the thread invokes the CM mechanism (step 1512).
      <br/>
      In this step, the CM mechanism is invoked to determine whether the thread can process the incoming message.
      <br/>
      If it is determined that the thread can process the incoming message, the thread processes the incoming message.
      <br/>
      Otherwise, if the CM mechanism determines that the thread is unable to process the incoming message, the incoming message is rejected.
      <br/>
      If no incoming messages have been detected, or after invoking the CM mechanism, the thread exits the apartment (step 1514).
      <br/>
      At this point, the apartment is available for another thread to execute within it.
      <br/>
      After exiting the apartment, processing continues to step 1502 and the thread invokes the GetMessage routine.
    </p>
    <p num="39">While the present invention has been described with reference to a preferred embodiment thereof, those skilled in the art will know of various changes in form that may be made without departing from the spirit and scope of the claimed invention as defined in the appended claims.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11.</claim-text>
      <claim-text>A method in a computer system for synchronizing access to data among multiple threads of a process, the method comprising: designating one of the multiple threads as an apartment thread, the apartment thread for allocating data; sending a message to the apartment thread from a thread other than the apartment thread, the message requesting that the apartment thread access the data on behalf of the other thread;</claim-text>
      <claim-text>and in response to receiving the sent message at the apartment thread, accessing by the apartment thread of the data wherein all accessing of the data is through the apartment thread.</claim-text>
      <claim-text>1. In a computer system having a process with a plurality of threads, the process having an address space and shared data accessible by the threads within the address space of the process, at least two of the threads having a concurrency management component, each thread being a path of execution, one thread being a source thread and one thread being a destination thread, a method comprising:</claim-text>
      <claim-text>providing a communication mechanism for each thread that has a concurrency management component; sending a first communication containing a reference to data within the shared data from the source thread to the destination thread via the communication mechanism, said first communication requesting a reply from the destination thread to the source thread, wherein the sending includes providing semaphores to the shared data to serialize access to the shared data; while the source thread is waiting for the reply to the first communication, receiving a second communication by the source thread;</claim-text>
      <claim-text>and processing the second communication by the concurrency management component to manage concurrency on behalf of the source thread so that concurrency problems do not arise while the source thread is waiting;</claim-text>
      <claim-text>and receiving the reply to the first communication from the destination thread.</claim-text>
      <claim-text>2. In a computer system having a process including a plurality of objects, and shared data accessible by the objects, one object being a source object, a method comprising: providing one or more apartments for partitioning the plurality of objects of the process, wherein a first apartment includes the source object; providing a communication mechanism that has a concurrency management component for the first apartment; sending a first communication from the source object to a destination object, said first communication requesting a reply from the destination object to the source object; while the source object is waiting for the reply to the first communication, receiving a second communication by the source object;</claim-text>
      <claim-text>and processing the second communication by the concurrency management component to manage concurrency on behalf of the first apartment so that concurrency problems do not arise while the source object is waiting;</claim-text>
      <claim-text>and receiving the reply to the first communication from the destination object.</claim-text>
      <claim-text>3. The method of claim 2 wherein the sending a first communication includes sending a first communication from the source object in the first apartment to the destination object in a second apartment.</claim-text>
      <claim-text>4. The method of claim 2 wherein the plurality of objects of the process includes the destination object, wherein the first communication contains a reference to data within the shared data, and wherein the sending a first communication includes providing semaphores to the shared data to serialize access to the shared data.</claim-text>
      <claim-text>5. The method of claim 2 wherein a second process includes the destination object, wherein the destination object has methods for performing operations, and wherein the sending a first communication includes sending a first communication containing a remote procedure call from the source object to the destination object, wherein the remote procedure call invokes a method of the destination object.</claim-text>
      <claim-text>6. A data processing system comprising: a process having a plurality of threads and a plurality of data organized into one or more sets; a source thread in the process for operating upon data in a first set and for creating a first message involving data in the first set; a destination thread for operating upon data in a second set and for receiving the first message from the source thread; a transfer mechanism for transferring the first message from the source thread to the destination thread;</claim-text>
      <claim-text>and a first set-specific concurrency management component for processing a second message received by the source thread while the source thread waits for a reply to the first message from the destination thread; wherein for each thread one or more objects encapsulate the data operated upon by the thread and wherein the transfer mechanism transfers a message from a source object accessible by the source thread to a destination object accessible by the destination thread.</claim-text>
      <claim-text>7. The data processing system of claim 6 wherein the data processing system has a plurality of processes, wherein the source thread is in a first process and wherein the destination thread is in a second process.</claim-text>
      <claim-text>8. The data processing system of claim 6 wherein the process further comprises shared data for maintaining data that is accessible by the threads and wherein the source thread accesses the shared data to determine a location of the destination thread.</claim-text>
      <claim-text>9. The data processing system of claim 6 wherein the destination thread executes one or more procedures and wherein the first message contains a remote procedure call for invoking a procedure executable by the destination thread.</claim-text>
      <claim-text>10. A data processing system having a process comprising: a plurality of objects in one or more sets, wherein a source object in a first set is for generating a first communication and wherein a destination object is for receiving the first communication from the source object; a shared data component for maintaining data accessible by the objects, wherein the first communication refers to data within the shared data component;</claim-text>
      <claim-text>and a communication mechanism for sending the first communication from the source object to the destination object, the communication mechanism further comprising:</claim-text>
      <claim-text>- a concurrency management component for executing when a second communication is received by the source object to manage concurrency on behalf of the first set so that concurrency problems do not arise while the source object awaits a reply to the first communication.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 11 including notifying the other thread when the apartment threads accesses the data.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 11 wherein the other thread has a concurrency management component to manage concurrency on its behalf while it is waiting for a response to the sent message.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A method in a computer system for synchronizing access to an object among multiple threads of a process, the method comprising: creating a plurality of threads; under control of one of the created threads, instantiating the object by one of the threads;</claim-text>
      <claim-text>and accessing the object by requesting the thread that instantiated the object to access of the object on behalf of a requesting thread, and by, in response to the request, accessing the instantiated object by the thread that instantiated the object wherein all accessing of the object is through the thread that instantiated the object.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method of claim 14 including notifying the requesting thread when the thread that instantiated the object accesses the object.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 14 wherein the requesting thread has a concurrency management component to manage concurrency on its behalf while it is waiting for access to the object.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. A computer system with partitioning of a plurality of objects in a process for multi-threaded processing, the computer system comprising: a process comprising an address space and a plurality of objects, wherein an object comprises data and methods to operate upon the data; a plurality of threads in the process;</claim-text>
      <claim-text>and one or more apartments for partitioning the plurality of objects, wherein each of the one or more apartments has an associated dedicated thread for executing to operate upon the data of objects in that apartment.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The computer system of claim 17 wherein an apartment handle identifies each of the one or more apartments, the computer system further comprising: a data structure that for each of the plurality of objects maps an object identifier to an apartment handle in order to form an object to apartment association.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The computer system of claim 17 further comprising: a communication mechanism for routing an object call to an appropriate apartment and thread for performing the object call.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The computer system of claim 17 wherein each of the plurality of threads is capable of accessing shared data in the process, wherein semaphores serialize access to the shared data, and wherein a communication between a first thread and a second thread includes a reference to data within the shared data.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The computer system of claim 17 wherein each of the one or more apartments has a concurrency management component that prevents deadlocks between the plurality of threads in the process.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. In a computer system having a process that includes a plurality of objects, a method for serializing access to objects in the process based upon membership of the objects in an object set, the method comprising: providing one or more object sets for partitioning a plurality of objects in a process, wherein a first object set includes one or more objects, and wherein an object comprises data and methods to operate upon the data; providing a unit of execution associated with the first object set for executing the methods of the one or more objects of the first object set; receiving plural operation requests directed to the one or more objects of the first object set;</claim-text>
      <claim-text>and based upon membership of the one or more objects in the first object set, serializing execution of the requested operations by the unit of execution.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. A data processing system comprising: a process having a plurality of threads, a plurality of data organized into one or more sets, and shared data for maintaining data that is accessible by the threads, the shared data having semaphores for regulating access to the shared data; a source thread in the process for operating upon data in a first set and for creating a first message involving data in the first set; a destination thread for operating upon data in a second set and for receiving the first message from the source thread, the source thread accessing the shared data to determine a location of the destination thread; a transfer mechanism for transferring the first message from the source thread to the destination thread;</claim-text>
      <claim-text>and a first set-specific concurrency management component for processing a second message received by the source thread while the source thread waits for a reply to the first message from the destination thread.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A method in a computer system for synchronizing access to data among multiple threads of a process, wherein the data is an object, the method comprising: designating one of the multiple threads as an apartment thread, the apartment thread for instantiating the object; sending a message to the apartment thread from a thread other than the apartment thread, the message requesting that the apartment thread access the data on behalf of the other thread;</claim-text>
      <claim-text>and in response to receiving the sent message at the apartment thread, accessing by the apartment thread of the data wherein all accessing of the data is through the apartment thread.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. A computer system with organization of data in a process to segregate processing of the data between units of execution, the computer system comprising: a process having a shared address space, shared data, and segregated data split into one or more segregated data sets; for a first segregated data set, a first unit of execution for executing within the process to operate upon the data of the first segregated data set; for a second segregated data set, a second unit of execution for executing within the process to operate upon the data of the second segregated data set; a data structure that stores shared data in the shared address space, said shared data including a mapping of segregated data to a segregated data set that includes the segregated data; for the first segregated data set, a first segregated data set concurrency management component for regulating access to the data of the first segregated data set;</claim-text>
      <claim-text>and for the second segregated data set, a second segregated data set concurrency management component for regulating access to the data of the second segregated data set.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. A computer system with organization of data in a process to segregate processing of the data between units of execution, the computer system comprising: a process having a shared address space, shared data, and segregated data split into one or more segregated data sets; for a first segregated data set, a first unit of execution for executing within the process to operate upon the data of the first segregated data set; for a second segregated data set, a second unit of execution for executing within the process to operate upon the data of the second segregated data set;</claim-text>
      <claim-text>and a data structure that stores shared data in the shared address space, said shared data including a mapping of segregated data to a segregated data set that includes the segregated data; wherein for each segregated data set one or more objects encapsulate the data of the segregated data set, each of the one or more objects exposing methods for a unit of execution to operate upon the encapsulated data.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. A computer system with organization of data in a process to segregate processing of the data between units of execution, the computer system comprising: a process having a shared address space, shared data, and segregated data split into one or more segregated data sets; for a first segregated data set, a first unit of execution for executing within the process to operate upon the data of the first segregated data set; for a second segregated data set, a second unit of execution for executing within the process to operate upon the data of the second segregated data set;</claim-text>
      <claim-text>and a data structure that stores first data of the shared data in the shared address space, said first data including a mapping of segregated data to a segregated data set that includes the segregated data; wherein each unit of execution is capable of accessing the shared data, and wherein a communication between units of execution includes a reference to second data within the shared data.</claim-text>
    </claim>
  </claims>
</questel-patent-document>