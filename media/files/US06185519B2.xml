<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185519B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185519</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185519</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="26755415" extended-family-id="42113568">
      <document-id>
        <country>US</country>
        <doc-number>09204019</doc-number>
        <kind>A</kind>
        <date>19981201</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09204019</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43171826</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>20401998</doc-number>
        <kind>A</kind>
        <date>19981201</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09204019</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>7424598</doc-number>
        <kind>P</kind>
        <date>19980210</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1998US-60074245</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H04Q   3/00        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>Q</subclass>
        <main-group>3</main-group>
        <subgroup>00</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>703021000</text>
        <class>703</class>
        <subclass>021000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>370242000</text>
        <class>370</class>
        <subclass>242000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>703017000</text>
        <class>703</class>
        <subclass>017000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>703022000</text>
        <class>703</class>
        <subclass>022000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>H04Q-003/00D3F</text>
        <section>H</section>
        <class>04</class>
        <subclass>Q</subclass>
        <main-group>003</main-group>
        <subgroup>00D3F</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04Q-003/0041</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>Q</subclass>
        <main-group>3</main-group>
        <subgroup>0041</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>12</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>8</number-of-drawing-sheets>
      <number-of-figures>8</number-of-figures>
      <image-key data-format="questel">US6185519</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and system for feature interaction detection in a telecommunication network</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>MANABE HISASHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5337351</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5337351</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>LARSSON G HAKAN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5388258</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5388258</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>CAIN MICHAEL E</text>
          <document-id>
            <country>US</country>
            <doc-number>5448631</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5448631</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>SIPS JOHAN WILLEM, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5796950</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5796950</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>SKOGBY STAFFAN</text>
          <document-id>
            <country>US</country>
            <doc-number>5946474</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5946474</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Evers, K. et al., "An Algorithmic Approach for Feature Interaction Detection," IEEE Intelligent Network Workshop, vol. 2, May 1997, pp. 1-14.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Nakamura, M. et al., "Analyzing Non-Deteminism in Telecommunication Services Using P-Invariant of Petri-Net Model," 16th Annual Joint Conf. of IEEE Computer and Communications Societies, INFOCOM '97, vol. 3, Apr. 1997, pp. 1253-1260.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Cheung, T. et al., "Detecting and Resolving the Interaction Between Telephone Features: Terminating Call Screening and Call Forwarding by Colored Petri-Nets," IEEE Int'l Conf. on Systems, Man and Cybernetics, vol. 3, Oct. 1995, pp. 2245-2250.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>Nakamura, M. et al., "A Method for Detecting and Eliminating Feature Interactions Using a Frame Model," IEEE Int'l Conf. on Communications, ICC '95, vol. 1, Jun. 1995, pp. 99-103.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>Kelly, B. et al., "Feature Interaction Detection Using SDL Models," IEEE Global Telecommunications Conference, Globecom '94, vol. 3, Dec. 1994, pp. 1857-1861.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="6">
          <text>Brothers, L.R. et al., "Feature Interaction Detection," IEEE Int'l Conf. on Communications, ICC '93. vol. 3, May 1993, pp. 1553-1557.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="7">
          <text>Kang, M. et al., "The Design and Verification of Service Feature Interaction Manager on AIN Using Z Schema," Proc. of 20th Int'l Computer Software and Applications Conf., Compsac '96, Aug. 1996, pp. 477-482.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="8">
          <text>Cameron, E. J. et al., "Feature Interactions in Telecommunications Systems," IEE Communications Magazine, vol. 31, No. 8, Aug. 1993, pp. 18-23.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="9">
          <text>McConnell, V. K. et al., "Feature Interaction Analysis in the Advanced Intelligent Network: A Telephone Company Perspective," IEEE Int'l Conf. on Communications, ICC '93, vol. 3, May 1993, pp. 1548-1552.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="10">
          <text>Dworak, F.S., "Approaches to Detecting and Resolving Feature Interactions," Global Telecommunications Conf., Globecom '91, vol. 2, Dec. 1991, pp. 1371-1377.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="11">
          <text>Liljegren, S. et al., "Fine-a Feature Design Environment," 7th Int'l Conf. on Software Engineering for Telecommunication Switching Systems, SETSS '89, 1989, pp. 122-126.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="12">
          <text>Aiken, D.J. "Experiences of Implementation Using Advanced Intelligent Network Release 1 Architecture," 8th Int'l Conf. on Software Engineering for Telecommunication System and Services. 1992, pp. 19-26.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="13">
          <text>Aiken, D.J. "An Approach to Resolving Feature Interaction in Advanced Intelligent Network Services," 4th IEE Conf. on Telecommunications. 1993, pp. 221-228.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="14">
          <text>Blumenthal, R. et al. "A Practical Approach to a Usable IN Feature Interaction Tool," IEEE Intelligent Network Workshop (IN '96). 1996, Apr. 1996, pp. 1-12.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="15">
          <text>The Feature Interaction Problem in Telecommunication Systems, by Bowen, T.F. et al., published in the Proceedings of the 7th International Conference on Software Engineering for Telecommunication Switching Systems, pp. 59-62, Jul. 1989.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <related-publication>
        <document-id>
          <country>US</country>
          <doc-number>60/074,245</doc-number>
          <date>19980210</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/074245</doc-number>
          <date>19980210</date>
        </document-id>
      </related-publication>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Telcordia Technologies, Inc.</orgname>
            <address>
              <address-1>Morristown, NJ, US</address-1>
              <city>Morristown</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>TELCORDIA TECHNOLOGIES</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Lin, Fuchun Joseph</name>
            <address>
              <address-1>Morris Plains, NJ, US</address-1>
              <city>Morris Plains</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Ghosh, Abhrajit</name>
            <address>
              <address-1>Scotch Plains, NJ, US</address-1>
              <city>Scotch Plains</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Liu, Hong</name>
            <address>
              <address-1>Parsippany, NJ, US</address-1>
              <city>Parsippany</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Giordano, Joseph</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Teska, Kevin J.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Methods and systems disclosed efficiently detect potential interactions between features in a telecommunications network.
      <br/>
      The methods and systems specify AIN (Advanced Intelligent Network) and switch-based features and detect their interactions when present within a feature package provided to a single subscriber.
      <br/>
      The methodology supports the assumption that each feature is created without the knowledge of other features, and that each feature is specified as a "black box," i.e., nothing is known about its internal logic except its input/output behaviors.
      <br/>
      The invention models a call environment, models two or more features, and combines the call variable usage for each feature.
      <br/>
      Methods then compare the combined call variable usages to detect potential feature interactions.
      <br/>
      The invention assists a service mediator in the tasks of detecting potential interactions among AIN features provided by different third party service providers, and detecting potential interactions between a third party service provider's AIN features and switch-based features.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
    <p num="1">
      This application claims the benefit of U.S. Provisional Application Ser.
      <br/>
      No. 60/074,245, filed Feb. 10, 1998, the contents of which are hereby incorporated by reference.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">The present invention generally relates to telecommunications and, more particularly, to feature interaction in the AIN (Advanced Intelligent Network) Framework.</p>
    <p num="3">
      Telecommunications software continues to evolve and add features.
      <br/>
      For example, in a telephone network, a feature is an add-on functionality to standard telephone service (e.g., call forwarding).
      <br/>
      The correct operation of a feature depends on a number of assumptions about its execution environment and available resources.
      <br/>
      Individual features are usually developed in isolation from each other and/or over a long period of time.
      <br/>
      When a set of features is put together, they might compete for limited system resources, and some of the underlying assumptions of a feature might be invalidated because of the execution of other features.
      <br/>
      As a result, a set of features might interfere with one another and exhibit unexpected and/or undesirable behaviors.
      <br/>
      This is the well-known "feature interaction" problem in telecommunications software engineering, which is further described in "The Feature Interaction Problem in Telecommunication Systems" by Bowen, T. F. et al., In Proceedings of the 7th International Conference on Software Engineering for Telecommunication Switching Systems, pp. 59-62, July 1989.
    </p>
    <p num="4">
      It is important to detect and resolve interactions among features before they are packaged for commercial offerings.
      <br/>
      Revenues are at stake if customers are baffled by the unexpected behavior of the set of features they subscribe to from a service provider.
      <br/>
      However, detecting and resolving interactions among features is a very difficult task.
      <br/>
      First, the logic of some of the features can be very complicated: it is not unusual for the documentation of a complex feature to run close to a hundred pages.
      <br/>
      Extracting the right amount of information from a document for interaction analysis requires a keen insight into feature design.
      <br/>
      Second, it is not unusual for a switching system to have hundreds of features.
      <br/>
      In addition, pairwise feature interaction analysis is not sufficient to uncover all the interactions among a set of features.
      <br/>
      As a result, even if one has access to all the information on the features developed for one's own products, one has to deal potentially with an exponential number of cases in the analysis.
    </p>
    <p num="5">
      The feature interaction problem has become even more complicated with the advent of the Advanced Intelligent Network (AIN) and the government deregulation in the telecommunications industry.
      <br/>
      In the AIN architecture, service logic can be stored at a Service Control Point (SCP), while the switching functions are provided in the Service Switching Point (SSP).
      <br/>
      The SSP is further described in TR-NWT001284: "Advanced Intelligent Network (AIN) Switching Systems Generic Requiremeits (Release 0.1)" by Bellcore, August 1992.
      <br/>
      Similarly, the SCP is a computing system containing processing logic and is further described in TR-NWT001285: "Advanced Intelligent Network (AIN) 0.1 Switch-Service Control Point (SCP) Application Protocol Interface Generic Requirements" by Bellcore, August 1992.
      <br/>
      In addition, AIN provides a set of well-defined interfaces between the SSP and the SCP to allow service logic programs in the SCP to be invoked by the SSP and to influence call processing in the SSP.
      <br/>
      The separation of service logic fiom switching functions allows service providers to develop features independent of switch vendors.
    </p>
    <p num="6">
      The passing of the Telecommunications Act of 1996 requires Incumbent Local Exchange Carriers (ILECs) to unbundle "dial tones" to third party service providers (i.e. other Competing LECs or CLECs).
      <br/>
      The unbundling of ILECs' networks can create the scenario in which ILECs may have to provide mediated access to features developed by third party service providers due to future FCC or state mandates.
      <br/>
      In this context, features can be classified into two categories: (1) "switch-based features," which usually come from the switch vendors and reside on the switches; and (2) "AIN features," which are usually developed by operating phone companies and third party service providers.
      <br/>
      Due to competition among third party service providers and between third party service providers and operating phone companies, only limited input/output behaviors are publicly available for each feature.
      <br/>
      Consequently, the operating phone companies face the challenge of providing mediated access for third party features without knowing the internal logic of these features.
    </p>
    <p num="7">Feature Interaction Problem in AIN Release 0.1</p>
    <p num="8">
      FIG. 1 shows two service SSPs 102 in an AIN 0.1 environment.
      <br/>
      The SSPs 102 are connected across a network 106 that may contain other SSPs switching points and various nodes between the end points.
      <br/>
      The SSPs 102 shown in the figure are also each connected to a SCP 104.
    </p>
    <p num="9">
      At the heart of AIN is the "basic call model" (BCM), which is a finite state machine residing on an SSP 102 that models the progress of a call.
      <br/>
      For a typical call, there is an "originating" basic call model (OBCM) 108 at the SSP 102 of the caller side 112 and a "terminating" basic call model (TBCM) at the SSP 102 of the callee side 114.
    </p>
    <p num="10">
      FIGS. 2a and 2b show graphical representations of the OBCM 108 and TBCM 110, respectively.
      <br/>
      The BCMs shown in the FIGS. 2a and 2b are standard for AIN Release 0.1. Each basic call model defines a set of "points in call" (PICs) which correspond to the important states in a call.
      <br/>
      Associated with each PIC is a set of "detection points" (DPs) which are used to detect an event during a call.
      <br/>
      A DP is associated with a set of "triggers" each of which specifies the conditions under which an AIN feature can be invoked.
    </p>
    <p num="11">
      AIN features are implemented by service logic programs residing on the SCP 104.
      <br/>
      Each AIN feature is associated with a set of triggers that specify at which PICs in the basic call model and under what conditions the feature can be invoked by the SSP 102 during a call.
      <br/>
      Typically, an AIN feature is invoked during a call if the following four conditions are satisfied: (1) the user has subscribed to this feature; (2) the user has activated this feature; (3) the call is at a PIC that the trigger of this feature is associated with; (4) the trigger condition is true.
      <br/>
      Note that even though an AIN feature, in general, can have more than one trigger, it can only be activated by one trigger at any instance during a call.
      <br/>
      In the following description, AIN features associated with a single trigger are considered, but the analysis extends to multiple triggers as well.
    </p>
    <p num="12">
      FIG. 3 shows a conceptual model of feature interaction in AIN Release 0.1. AIN is based on the SS7 Signaling Network Architecture, which is further described in Beninger, Toni, "SS7 Basics," Telephony Div.
      <br/>
      Intertec Publishing Corp.
      <br/>
      ISBN:0-917845-16-1.
      <br/>
      The SSP 102 communicates with the SCP 104 via TCAP messages 302.
      <br/>
      TCAP (Transaction Capabilities Application Part) is an SS7 application protocol which provides non-circuit related information transfer capabilities and generic services to applications, yet remains independent of the application.
      <br/>
      For feature interaction detection, the focus is on call-related TCAP messages 302, i.e., those that affect the processing of a call.
      <br/>
      Each TCAP message 302 carries a set of call variables (as TCAP parameters), which are used to exchange call-related information between an SSP 102 and an SCP 104.
      <br/>
      When an AIN feature 304 is invoked, the SSP 102 sends a query message with a set of call variable values to the SCP 104 to start the execution of the feature on the SCP 104.
      <br/>
      Upon the receipt of the query message, the SCP 104 executes the service logic program according to the type of message and the call variable values in the message.
      <br/>
      The SCP 104 then informs the SSP 102 of the next action to take by sending a response message back the SSP with a set of call variables whose values may have been generated or modified by the SCP.
      <br/>
      The SSP 102 uses these call variable values received in the response message to influence the call processing.
      <br/>
      There might be several rounds of message exchanges between the SSP 102 and the SCP 104 before the feature 304 is done.
      <br/>
      In summary, an invocation of an AIN feature 304 can be regarded as a transaction between an SSP 102 and an SCP 104, which starts with a query message from the SSP and involves a finite sequence of message exchanges between the SSP and the SCP.
      <br/>
      Switch-based features 306 are described below.
    </p>
    <p num="13">
      The execution of an AIN feature is atomic with respect to other AIN features, i.e., once an AIN feature is invoked, it cannot be interrupted by another AIN feature until it is finished.
      <br/>
      In AIN Release 0.1, the same holds true for AIN and switch-based features, an AIN feature cannot be interrupted by a switch-based feature and vice-versa.
    </p>
    <p num="14">
      It is possible for an AIN 0.1 feature to cause a modification in the control flow of the call model within which it is activated.
      <br/>
      Thus, it is possible that the AIN feature may start out at one PIC and terminate at another.
      <br/>
      In one embodiment consistent with the present invention, those features that terminate at the same PIC as the one at which they triggered are considered.
    </p>
    <p num="15">
      There are two major reasons why features interact with each other: "control sharing" and "data sharing".
      <br/>
      For control sharing, a set of features share the state information of the same basic call model, and consequently, the order of invocation among the features is very important.
      <br/>
      If one feature disconnects the call, then all the remaining features will not be able to execute.
      <br/>
      This is called "disabling."
    </p>
    <p num="16">
      For data sharing, features share the same set of call variables on a SSP 102 for call processing (see FIG. 3).
      <br/>
      Since the set of call variables carried in the TCAP messages 302 between the SSP 102 and the SCP 104 is essential to allow a feature 304 to influence call processing in the SSP, call variable values set or changed by one feature 304 might affect other features invoked later in the same basic call model that read and use these call variables.
      <br/>
      This is called a "side-effect."
    </p>
    <p num="17">Accordingly, it would be desirable to have a system that quickly and efficiently recognizes these problems and determines whether a feature package has potential interactions.</p>
    <heading>DESCRIPTION OF THE INVENTION</heading>
    <p num="18">Methods and systems consistent with the present invention satisfy this and other desires by presenting an integrated methodology for specifying AIN and switch-based features and detecting their interactions when present within a feature package provided to a single subscriber, which can be used to support access to third party service providers' features for AIN Release 0.1.</p>
    <p num="19">
      Consistent with the present invention, a method is provided that models a call environment, models two or more features, and combines the call variable usage for each feature.
      <br/>
      The method then compares the combined call variable usages to detect potential feature interactions.
    </p>
    <p num="20">
      Methods and systems consistent with the present invention assist a service mediator in the tasks of detecting potential interactions among AIN features provided by different third party service providers, and detecting potential interactions between a third party service provider's AIN features and switch-based features.
      <br/>
      The service mediator performs these detections based on the minimum necessary feature information obtained from service providers.
      <br/>
      Once the providers make individual feature specifications available, each specification can be validated for consistency in terms of data and control, and interaction analysis can be conducted to reveal potential interactions.
      <br/>
      Two types of interactions are identified: (1) side-effects, where a call variable modified by one feature is used by another feature and (2) disabling, where one feature disconnects a call, preventing another feature from execution.
      <br/>
      The combining of the various call variable usages of each feature dramatically reduces the number of cases considered during the analysis.
    </p>
    <p num="21">
      The methodology has the advantage that each feature may be created without the knowledge of other features, and that each feature can be specified as a "black box," i.e., nothing is known about its internal logic except its input/output behaviors.
      <br/>
      Consequently, a service provider can create features within some pre-notified, well-defined constraints without being aware of other service providers' AIN features or a switch vendor's switch-based features.
      <br/>
      This advantage allows third-party service providers to reveal only non-intrusive, minimal amounts of information about their features to a service mediator.
      <br/>
      A by-product of the analysis is a set of interaction scenarios represented via message sequences for each interacting AIN feature.
      <br/>
      These scenarios give additional feedback to the user that aids in the process of resolving the detected interactions.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="22">
      FIG. 1 is a block diagram representing an exemplary prior art call processing network with service switching points and service control points consistent with the present invention;
      <br/>
      FIG. 2a is a block diagram representing a prior art originating basic call model used in AIN Release 0.1 consistent with the present invention;
      <br/>
      FIG. 2b is a block diagram representing a prior art terminating basic call model used in AIN Release 0.1 consistent with the present invention;
      <br/>
      FIG. 3 is a block diagram depicting prior art feature interaction in AIN Release 0.1 consistent with the present invention;
      <br/>
      FIG. 4 is a block diagram illustrating an overview of feature interaction analysis consistent with the present invention;
      <br/>
      FIG. 5 is a block diagram illustrating a computer system suitable for execution of methods consistent with the present invention;
      <br/>
      FIG. 6 is a flowchart illustrating steps used in a method for processing an AIN feature in accordance with one embodiment of the present invention; and
      <br/>
      FIG. 7 is a flowchart illustrating steps used in a method for detecting interactions within feature packages in accordance with one embodiment of the present invention.
    </p>
    <heading>BEST MODE FOR CARRYING OUT THE INVENTION</heading>
    <p num="23">
      Methods and systems consistent with the present invention generally concern two types of interactions among features operating whiting the same basic call model. disabling and side effects.
      <br/>
      The methods and systems can be applied to detect both types of feature interactions, and the detection is centered on usage analysis of the common set of call variables on the SSP 102 that are shared among the features.
      <br/>
      Since no knowledge of a feature's internal logic but its input/output behavior is assumed, the information from the TCAP messages 302 plays a central role in methods and systems consistent with the present invention for detecting both types of feature interactions.
    </p>
    <p num="24">
      FIG. 4 depicts a block diagram of a feature interaction methodology consistent with the present invention.
      <br/>
      It defines an input, a process, and an output.
      <br/>
      There are two sources of inputs: those from "information modeling" 402 and those from "feature specifications" 404.
    </p>
    <p num="25">Information modeling 402 means encoding and organizing the feature execution environment in a machine manipulable form, which includes the basic call models (108 and 110), the call-related TCAP messages 302, the set of call variables exchanged between an SSP 102 and an SCP 104, and the interrelations among them.</p>
    <p num="26">
      Feature specifications 404 are the minimum required feature information from the service providers.
      <br/>
      They are described in both data specification and control specification.
      <br/>
      The former defines how a feature manipulates the data within the scope of its control.
      <br/>
      The latter defines the TCAP message control sequences between the SCP 104 and the SSP 102 for a feature.
    </p>
    <p num="27">The "feature interaction analysis" process 406 takes the inputs defined above and carries out the reasoning required to detect any potential interactions among input features.</p>
    <p num="28">
      The output is any "anomalies" 408 (i.e., potential interactions) discovered by the feature interaction analysis process 406.
      <br/>
      This information is decoded and presented to users in an easily readable format.
    </p>
    <p num="29">
      Information modeling 402, feature specification 404 and feature interaction analysis 406 are described in detail below in sections 1, 2 and 3.
      <br/>
      Section 1 discusses information modeling in detail.
      <br/>
      Section 2 elaborates on feature specifications needed to make use of methods and systems consistent with the present invention.
      <br/>
      Section 3 addresses feature interaction detection and optimizations used for the analysis.
    </p>
    <p num="30">System Description</p>
    <p num="31">
      FIG. 5 is a block diagram of a data processing system 500 suitable for executing methods consistent with the present invention.
      <br/>
      The data processing system 500 comprises a computer system 501, which may for example, be connected to a network 503, such as the Internet.
      <br/>
      The computer system 501 includes a central processing unit (CPU) 504, a main memory 506, and a secondary storage device 510 interconnected via bus 502.
      <br/>
      This secondary storage device may be a hard drive, for example.
      <br/>
      Additionally, the computer system 500 includes a display 512 and an input device 514.
      <br/>
      Main memory 506 contains software code for implementing methods consistent with the present invention.
      <br/>
      The data processing system 500 also comprises a database 516.
      <br/>
      This database 516 may be external to the computer system 501, or may be contained on the computer system 501, for example, in the main memory 506.
      <br/>
      The relational database tables 530 described herein may be stored in the main memory 506 or the database 516, and manipulations of these tables may be performed by CPU 504.
    </p>
    <p num="32">
      As described in detail below, this main memory 506 contains a parser and sequence generator 520, a partitioner 524, and an interaction detector 522.
      <br/>
      Also described below, the database 516 is used to store persistent data and may contain data including a basic call model 526, a library of feature specifications 528 and library of packages comprised of some combinations of these features.
    </p>
    <p num="33">
      Those skilled in the art will appreciate that aspects of methods and systems consistent with the present invention may be stored on or read from any other computer readable media besides memory like secondary storage devices, such as hard disks, floppy disks, and CD-ROM, or a carrier wave from a network 503, such as the Internet.
      <br/>
      Additionally, those skilled in the art will appreciate that data processing system 500 may contain additional or different components, and that processes implemented by software may also be implemented by hardware components.
    </p>
    <p num="34">1. Information Modeling</p>
    <p num="35">
      As shown in FIG. 5, information modeling is realized by a relational database 516 consisting of a collection of tables.
      <br/>
      Each row in a table is a data record comprising several attributes.
      <br/>
      Such a database 516 is built to serve several purposes.
      <br/>
      It ties the AIN basic call models (108 and 110) with the TCAP messages 302.
      <br/>
      It also defines the properties of the call variables (i.e., parameters) carried by each TCAP message 302 and defines the properties of each TCAP message.
      <br/>
      Furthermore, the database 516 is used for defining the allowable TCAP message sequences between an SSP 102 and an SCP 104, and defining the precedence relations between DPs occurring at the various PICs in each of the BCMs.
      <br/>
      The rest of the section will address each of these issues in detail.
      <br/>
      Note that not all the information about AIN is modeled.
      <br/>
      Only abstract information needed for the purpose of feature interaction analysis is modeled.
    </p>
    <p num="36">1.1. Tying AIN Basic Call Models with TCAP Messages</p>
    <p num="37">
      Three tables 1(a), (b) and (c), (PIC, DP, and TRIGGER) are created to encode the information that ties the AIN basic call models with the TCAP messages 302.
      <br/>
      The PIC table associates each PIC with all of its DP's.
      <br/>
      The DP table associates each DP with all of its triggers.
      <br/>
      The TRIGGER table then associates each trigger with a TCAP query message sent to SCP.
      <br/>
      In each table, information about the OBCM 108 and the TBCM 110 are separated by a bold horizontal line.
    </p>
    <p num="38">
      -- TABLE 1(a)
      <br/>
      -- PIC
      <br/>
      --        PIC                          DP
      <br/>
      --        O_NULL                       Origination_Attempt
      <br/>
      --        COLLECT_INFORMATION          Info_Collected
      <br/>
      --        ANALYZE_INFORMATION          Info_Analyzed
      <br/>
      --        SELECT_ROUTE                 Network_Busy
      <br/>
      --        T_NULL                       Termination_Attempt
    </p>
    <p num="39">
      -- TABLE 1(b)
      <br/>
      -- DP
      <br/>
      --      DP                    TRIGGERS
      <br/>
      --      Origination_Attempt   Off-Hook Immediate
      <br/>
      --      Info_Collected        Off-Hook Delay
      <br/>
      --                            Channel Setup PRI
      <br/>
      --                            Shared Interoffice Trunk
      <br/>
      --      Info_Analyzed         BRI Feature Activation Indicator
      <br/>
      --                            Public Office Dialing Plan Feature
      <br/>
      --                            Code
      <br/>
      --                            Customized Dialing Plan
      <br/>
      --                            3/6/10 Digit Public Office Dialing
      <br/>
      --                            Plan
      <br/>
      --                            N11
      <br/>
      --      Network_Busy          AFR
      <br/>
      --      Termination_Attempt   Termination Attempt
    </p>
    <p num="40">
      -- TABLE 1(c)
      <br/>
      -- TRIGGER
      <br/>
      --      TRIGGER                          MESSAGE
      <br/>
      --      Off-Hook Immediate               Origination_Attempt
      <br/>
      --      Off-Hood Delay                   Info_Collected
      <br/>
      --      Channel Setup PRI                Info_Collected
      <br/>
      --      Shared Interoffice Trunk         Info_Collected
      <br/>
      --      BRI Feature Activation Indicator Info_Analyzed
      <br/>
      --      Public Office Dialing Plan Feature Code Info_Analyzed
      <br/>
      --      Customized Dialing Plan          Info_Analyzed
      <br/>
      --      3/6/10 Digit Public Office Dialing Plan Info_Analyzed
      <br/>
      --      N11                              Info_Analyzed
      <br/>
      --      AFR                              Network_Busy
      <br/>
      --      Termination Attempt              Termination_Attempt
    </p>
    <p num="41">
      Implicit in Table 1(a) is the "precedence" relation among PIC's in a BCM.
      <br/>
      For OBCM 108, the linear ordering is from O_NULL to SELECT_ROUTE.
      <br/>
      For example PIC ANALYZE_INFORMATION occurs after PIC O_NULL but before PIC SELECT_ROUTE.
      <br/>
      Similarly, the linear ordering from top to bottom in the "trigger" column of Table 1(b) also implies the precedence relation among triggers in a BCM.
      <br/>
      So trigger Customized_Dialing_Plan has higher priority over trigger N11, even though they are associated with the same DP, Info_Analyzed.
    </p>
    <p num="42">1.2. Defining the Properties and Call Variables of Each TCAP Message</p>
    <p num="43">
      A table message is created to encode the important data of TCAP messages 302.
      <br/>
      The attributes of this table include, (1) the name of a message, (2) the sender of a message (SSP 102 or SCP 104 or both), (3) the TCAP package type of a message, (4) the TCAP component type of a message, (5) the call variables carried by a message, (6) which BCM sends/receives this message (OBCM, TBCM, or both), and (7) the type of a message (call-related, non-call-related, or abnormal message).
    </p>
    <p num="44">Table 2 lists a sample record of a message table. (Note that the attributes in Table 2 are listed by row rather than by column.)</p>
    <p num="45">
      -- TABLE 2
      <br/>
      -- A Sample Record in table message
      <br/>
      -- Message Name          Analyze_Route
      <br/>
      -- Sender                SCP
      <br/>
      -- Package Type          RES
      <br/>
      -- Component Type        INV
      <br/>
      -- Message Call variables ChargeNumber, CallingPartyID,
      <br/>
      --                       ChargePartyStationType, CalledPartyID,
      <br/>
      --                       OutpulseNumber, Tcm, PrimaryTrunk
      <br/>
      --                       Group,
      <br/>
      --                       AlternateTrunkGroup,
      <br/>
      --                       SecondAlternateTrunkGroup,
      <br/>
      --                       PrimaryCarrier, AlternateCarrier,
      <br/>
      --                       SecondAlternateCarrier,
      <br/>
      --                       PassiveLegTreatment, RedirectingPartyID
      <br/>
      --                       PrimaryBillingIndicator,
      <br/>
      --                       AlternateBillingIndicator,
      <br/>
      --                       SecondAlternateBillingIndicator,
      <br/>
      --                       OverflowBillingIndicator,
      <br/>
      --                       AMAAlternateBillingNumber,
      <br/>
      --                       AMABusinessCustomerID, AMALine
      <br/>
      --                       Number,
      <br/>
      --                       AMADigitsDialedWC, Amp
      <br/>
      -- BCM                   O
      <br/>
      -- Type                  CL
    </p>
    <p num="46">
      Each TCAP message 302 deals with only a subset of call variables.
      <br/>
      Each call variable in a message is either mandatory, meaning that the message must carry a value for this call variable, or optional, in which case the message may or may not carry a value for the call variable.
      <br/>
      This information is further specified in the parameter table in the following subsection.
    </p>
    <p num="47">
      For the purpose of feature interaction detection, call-related messages are primarily analyzed.
      <br/>
      However, one or more non-call-related message components can be packaged with a response message and sent back from the SCP 104 to the SSP 102.
      <br/>
      So the set of messages modeled are all call-related messages and a subset of non-call-related messages that can be sent back from the SCP 104 with the call-related messages.
    </p>
    <p num="48">1.3. Defining the Properties of Each TCAP Message Call Variable</p>
    <p num="49">
      A table parameter is created to encode the important data of TCAP message call variables.
      <br/>
      This table is so named because the call variables are carried as TCAP parameters from the SSP 102 to the SCP 104 and back.
      <br/>
      The attributes of this table include: (1) the PIC from which the data of a call variable becomes available, (2) the data transfer direction of a call variable (from SSP 102 to SCP 104 or from SCP to SSP), (3) in which message and in what format a call variable is presented.
    </p>
    <p num="50">Table 3 lists two sample records of a parameter table, which concern call variables BearerCapability and CalledPartyID, respectively.</p>
    <p num="51">
      -- TABLE 3
      <br/>
      -- Sample Records in Table parameter
      <br/>
      --                       Bearer-
      <br/>
      -- Call variable         Capability CalledPartyID
      <br/>
      -- Obcm_pic              O_NULL    ANALYZE_INFORMATION
      <br/>
      -- Tbcm_pic              T_NULL    T_NULL
      <br/>
      -- Ssp                   X         X
      <br/>
      -- SCP                   X         X
      <br/>
      -- Termination_Notification-
      <br/>
      -- Info_Analyzed�   M         O
      <br/>
      -- Info_Collected�  M
      <br/>
      -- Network_Busy�    M         O
      <br/>
      -- Origination_Attempt� M
      <br/>
      -- Termination_Attempt� M         O
      <br/>
      -- Analyze_Route-              O
      <br/>
      -- Authorize_Termination -
      <br/>
      -- Continue -
      <br/>
      -- Disconnect -
      <br/>
      -- Forward_Call -              O
      <br/>
      -- Send_To_Resource -
      <br/>
      -- ACG-
      <br/>
      -- Send_Notification
      <br/>
      -- Resource_Clear
      <br/>
      -- Update_Data
      <br/>
      -- Send_To_Resource
      <br/>
      -- Update_Request        O
      <br/>
      -- ACG
      <br/>
      -- Cancel_Resource_Event
      <br/>
      -- Update_Data-
      <br/>
      -- Resource_Clear -
    </p>
    <p num="52">The second column in table 3 specifies the characteristics of parameter BearerCapability: (1) the data becomes available from PIC O_NULL in the OBCM 108 and from PIC T_NULL in the TBCM 110; (2) it can be sent from SSP 102 SCP 104 or vice versa; (3) in messages Info_Analyzed and Info_Collected, BearerCapability is a mandatory call variable (marked as "M"), but in message Update_Request it is an optional call variable (marked as "O").</p>
    <p num="53">1.4. Define the Allowable TCAP Message Sequences between the SSP and the SCP</p>
    <p num="54">
      A rule-based specification (also in table format) is used to encode all the able TCAP message sequences between the SSP 102 and the SCP 104 (see Table 4).
      <br/>
      This table contains the message exchange rules when an OBCM 108 or a TBCM 110 on the SSP 102 interacts with the service logic of a feature on the SCP 104.
    </p>
    <p num="55">
      -- TABLE 4
      <br/>
      -- Rule-Based Specification of SSP-SCP TCAP Message Sequences
      <br/>
      --               Last_Message--
      <br/>
      -- Rule   BCM    Exchanged            Next_Message_Exchanged
      <br/>
      -- 1      O      Origination_Attempt� Analyze_Route- �Send_Noti-
      <br/>
      --                                    fication�ACG*�, Disconnect-
      <br/>
      --                                    �Send_Notification .vertline.ACG*�,
      <br/>
      --                                    &lt;suspend&gt;Send_To_Resource*
      <br/>
      --                                    �ACG*.vertline.Update_Request�
      <br/>
      -- 2      O      Info_Collected� Analyze_Route- �Send--
      <br/>
      --                                    Notification.vertline.ACG*�,
      <br/>
      --                                    Disconnect- �Send--
      <br/>
      --                                    Notification.vertline.ACG*�, &lt;suspend&gt;
      <br/>
      --                                    Send_To_Resource*
      <br/>
      --                                    �ACG*.vertline.Update_Request�
      <br/>
      -- 3      O      Info_Analyzed�  Analyze_Route- �Send--
      <br/>
      --                                    Notification.vertline.ACG*�, Continue-
      <br/>
      --                                    �Send_Notification.vertline.ACG*�,
      <br/>
      --                                    Disconnect- �Send--
      <br/>
      --                                    Notification.vertline.ACG*�,
      <br/>
      --                                    &lt;suspend&gt;Send_To_Resource*
      <br/>
      --                                    �ACG*.vertline.Update_Request�
      <br/>
      -- 4      O      Network_Busy�   Analyze_Route-
      <br/>
      --                                    �Send_Notification.vertline.ACG*�,
      <br/>
      --                                    Disconnected- �Send--
      <br/>
      --                                    Notification.vertline.ACG*�,
      <br/>
      --                                    &lt;suspend&gt;Send_To_Resource*
      <br/>
      --                                    �ACG*.vertline.Update Request�
      <br/>
      -- 5      T      Termination_Attempt� Authorize_Termination-
      <br/>
      --                                    �Send_Notification.vertline.ACG*�,
      <br/>
      --                                    Forward_Call- �Send--
      <br/>
      --                                    Notification.vertline.ACG*�,
      <br/>
      --                                    Disconnect- �Send--
      <br/>
      --                                    Notification.vertline.ACG*�,
      <br/>
      --                                    &lt;suspend&gt;Send_To_Resource*
      <br/>
      --                                    �ACG*.vertline.Update_Request�
      <br/>
      -- 6      O,T    Send_Notification    Termination_Notification-
      <br/>
      -- 7      O,T    ACG                  GapDuration_Timeout
      <br/>
      -- 8      O,T    Update_Request       Update_Data*, Honored_RR-
      <br/>
      -- 9      O,T    Send_To_Resource     Resource_Clear*,Cancel--
      <br/>
      --                                    Resource_Event
      <br/>
      -- 10     O,T    Cancel_Resource_Event Resource_Clear*
      <br/>
      -- 11     O,T    Resource_Clear       &lt;resume&gt;
      <br/>
      -- 12     O,T    Update_Data          -
      <br/>
      -- 13     O,T    GapDuration_Timeout  -
    </p>
    <p num="56">
      There are two attributes in a rule: Last_Message_Exchanged and Next_Message_Exchanged.
      <br/>
      Their syntactic constructs and semantic meanings are described below.
    </p>
    <p num="57">
      Each message uses a single symbol suffix to indicate its package type in the following way: (1) The query messages are suffixed with an exclamation mark ("?"). (2).
      <br/>
      The response and unidirectional messages are suffixed with a pound sign ("-"), except for Send_Notification.
      <br/>
      Send_Notification is treated as if it were a conversation message because it requires a unidirectional message, Termination_Notification, as its response. (3) The conversation messages have no suffix.
    </p>
    <p num="58">
      Last_Message_Exchanged specifies a single message that is last exchanged between an SSP 102 and an SCP 104.
      <br/>
      This attribute is used to enable a rule.
      <br/>
      The message specified follows the preceding suffixing rules with one exception: the suffix "-" (i.e., response and unidirectional message) is prohibited.
      <br/>
      Next_Message_Exchanged is a list of messages separated by comma (",").
      <br/>
      It specifies all the possible next messages that can be exchanged between an SSP 102 an SCP 104.
      <br/>
      The messages specified also follow the preceding suffixing rules with two exceptions: (1) The suffix "?" (i.e., a query message) is prohibited. (2) A with suffix "*" (asterisk) is allowed.
      <br/>
      This suffix is a shorthand notation for pressing a message that can be exchanged either as a conversion message or as a response/unidirectional message.
      <br/>
      For instance, the Next_Message_Exchanged in Rule 9 is Resource_Clear*, which is a shorthand notation for Resource_Clear-, Resource_Clear.
    </p>
    <p num="59">
      A message specified in Next_Message_Exchanged can be a multiple-component TCAP message.
      <br/>
      In this case, it will be expressed as a call-related component followed by one or two non-call-related components enclosed within a pair of square brackets.
      <br/>
      Those noncall-related messages are separated by a vertical bar ".vertline." to indicate the possibility of any arbitrary combination of those components.
      <br/>
      For instance, one of the messages in the Next_Message_Exchanged of Rule 1 is Analyze_Route-�Send_Notification.vertline.ACG*�, which represents any one of the following six possible formats:
    </p>
    <p num="60">1. a three-component message</p>
    <p num="61">
      - Analyze_Route-�Send_Notification.vertline.ACG�, or
      <br/>
      2. a three-component message
      <br/>
      - Analyze_Route-�Send_Notification.vertline.ACG-�, or
      <br/>
      3. a two-component message Analyze_Route-�SendNotification�, or
      <br/>
      4. a two-component message Analyze_Route-�ACG�, or
      <br/>
      5. a two-component message Analyze_Route-�ACG-�, or
      <br/>
      6. a single-component message Analyze_Route-.
    </p>
    <p num="62">
      Two special operators &lt;suspend&gt; and &lt;resume&gt; can also appear in the Next_Message_Exchanged. &lt;suspend&gt; is prefixed to the conversation message Send_To_Resource, &lt;resume&gt; follows Resource_Clear.
      <br/>
      The &lt;suspend&gt; is used to set a backtracking point for executing rules.
      <br/>
      The &lt;resume&gt; is used to resume the rule execution from the backtracking point.
      <br/>
      A single pound sign ("-") implies the end of the message exchange.
    </p>
    <p num="63">1.5. Defining Precedence Relations Between DPs</p>
    <p num="64">
      The OBCM 108 and TBCM 110 as shown in FIGS. 2a and 2b can be used to define a precedence relationship between DPs at the various PICs in each of the call models.
      <br/>
      Two tables listed as Table 5 (tbcm 110) and Table 6 (obcm 108) are created to define partial orderings of the DPs at the TBCM and OBCM, respectively.
      <br/>
      Each entry in each column of these tables is a DP-PIC pair representing a DP and the PIC at which it occurs.
      <br/>
      The first and second columns in these tables represent preceding and succeeding DP-PIC pairs respectively, within the associated BCM.
      <br/>
      Thus, Feature_Requested(O_NULL) precedes Origination_Attempt(O_NULL) in the OBCM 108.
      <br/>
      The relations obtained by computing the transitive closures of each of these tables define precedence relations on DP-PIC pairs in each of the BCMs.
      <br/>
      These precedence relations are useful for detecting feature interactions between AIN and switch-based features (as will be seen in section 3.4.1).
      <br/>
      Note that the precedence relation between triggers as described in section 1.1 is not sufficient because switch-based features are not associated with AIN triggers.
    </p>
    <p num="65">
      -- TABLE 5
      <br/>
      -- tbcm
      <br/>
      -- Preceding DP-PIC pair                   Succeeding DP-PIC pair
      <br/>
      -- Termination_Attempt (T_NULL)            Call_Presented
      <br/>
      --  (AUTHORIZE_TERMINATION)
      <br/>
      --                                         Termination_Denied
      <br/>
      --  (AUTHORIZE_TERMINATION)
      <br/>
      --                                         Cleared (AUTHORIZE_TERMINATION)
      <br/>
      -- Call_Presented (AUTHORIZE_TERMINATION)  Term_Resource_Available
      <br/>
      --  (SELECT_FACILITY)
      <br/>
      --                                         T_Busy (SELECT_FACILITY)
      <br/>
      --                                         Cleared (SELECT_FACILITY)
      <br/>
      -- Team_Resource_Available (SELECT_FACILITY) Call_Accepted (PRESENT_CALL)
      <br/>
      --                                         Call_Rejected (PRESENT_CALL)
      <br/>
      --                                         T_No_Answer (PRESENT_CALL)
      <br/>
      --                                         Cleared (PRESENT_CALL)
      <br/>
      -- Call_Accepted (PRESENT_CALL)            T_Answer (T_ALERTING)
      <br/>
      --                                         Call_Rejected (T_ALERTING)
      <br/>
      --                                         Mid_Call (T_ALERTING)
      <br/>
      --                                         T_No_Answer (T_ALERTING)
      <br/>
      --                                         Cleared (T_ALERTING)
      <br/>
      -- Mid_Call (T_ALERTING)                   T_Answer (T_ALERTING)
      <br/>
      --                                         Call_Rejected (T_ALERTING)
      <br/>
      --                                         T_No_Answer (T_ALERTING)
      <br/>
      --                                         Cleared (T_ALERTING)
      <br/>
      -- T_Answer (T_ALERTING)                   Disconnected (ACTIVE)
      <br/>
      --                                         Mid_Call (ACTIVE)
      <br/>
      --                                         Cleared (ACTIVE)
      <br/>
      -- Mid_Call (ACTIVE)                       Disconnected (ACTIVE)
      <br/>
      --                                         Cleared (ACTIVE)
      <br/>
      -- Disconnected (ACTIVE)                   Release_Timeout (RELEASE_PENDING)
      <br/>
      --                                         Cleared (RELEASE_PENDING)
    </p>
    <p num="66">
      -- TABLE 6
      <br/>
      -- obcm
      <br/>
      -- Preceding DP-PIC pair        Succeeding DP-PIC pair
      <br/>
      -- Feature_Requested (O_NULL)   Origination_Attempt (O_NULL)
      <br/>
      -- Origination_Attempt (O_NULL) Origination_Attempt_Authorized
      <br/>
      --  (AUTHORIZE_ORIG_ATTEMPT)
      <br/>
      --                              Origination_Denied (AUTHORIZE_ORIG_ATTEMPT)
      <br/>
      --                              Disconnected (AUTHORIZE_ORIG_ATTEMPT)
      <br/>
      -- Origination_Attempt_Authorized Info_Collected (COLLECT_INFORMATION)
      <br/>
      -- (AUTHORIZE_ORIG_ATTEMPT)     Collect_Timeout (COLLECT_INFORMATION)
      <br/>
      --                              Disconnected (COLLECT_INFORMATION)
      <br/>
      --                              Feature_Requested (COLLECT_INFORMATION)
      <br/>
      -- Feature_Requested            Info_Collected (COLLECT_INFORMATION)
      <br/>
      -- (COLLECT_INFORMATION)        Collect_Timeout (COLLECT_INFORMATION)
      <br/>
      --                              Disconnected (COLLECT_INFORMATION)
      <br/>
      -- Info_Collected               Info_Analyzed (ANALYZE_INFORMATION)
      <br/>
      -- (COLLECT_INFORMATION)        Invalid_Information (ANALYZE_INFORMATION)
      <br/>
      --                              Disconnected (ANALYZE_INFORMATION)
      <br/>
      --                              Feature_Requested (ANALYZE_INFORMATION)
      <br/>
      -- Feature_Requested            Info_Analyzed (ANALYZE_INFORMATION)
      <br/>
      -- (ANALYZE_INFORMATION)        Invalid_Information (ANALYZE_INFORMATION)
      <br/>
      --                              Disconnected (ANALYZE_INFORMATION)
      <br/>
      -- Info_Analyzed                Route_Selected (SELECT_ROUTE)
      <br/>
      -- (ANALYZE_INFORMATION)        Network_Busy (SELECT_ROUTE)
      <br/>
      --                              Disconnected (SELECT_ROUTE)
      <br/>
      --                              Feature_Requested (SELECT_ROUTE)
      <br/>
      -- Feature_Requested            Route_Selected (SELECT_ROUTE)
      <br/>
      -- (SELECTED_ROUTE)             Network_Busy (SELECT_ROUTE)
      <br/>
      --                              Disconnected (SELECT_ROUTE)
      <br/>
      -- Route_Selected (SELECT_ROUTE) Call_Setup_Authorized (AUTHORIZE_CALL_SETUP)
      <br/>
      --                              Authorization_Failure (AUTHORIZE_CALL_SETUP)
      <br/>
      --                              Disconnected (AUTHORIZE_CALL_SETUP)
      <br/>
      --                              Feature_Requested (AUTHORIZE_CALL_SETUP)
      <br/>
      -- Feature_Requested            Call_Setup_Authorized (AUTHORIZE_CALL_SETUP)
      <br/>
      -- (AUTHORIZE_CALL_SETUP        Authorization_Failure (AUTHORIZE_CALL_SETUP)
      <br/>
      --                              Disconnected (AUTHORIZE_CALL_SETUP)
      <br/>
      -- Call_Setup_Authorized        O_Term_Seized (SEND_CALL)
      <br/>
      -- (AUTHORIZED_CALL_SETUP)      Mid_Call (SEND_CALL)
      <br/>
      --                              Disconnected (SEND_CALL)
      <br/>
      --                              O_Called_Party_Busy (SEND_CALL)
      <br/>
      --                              O_No_Answer (SEND_CALL)
      <br/>
      -- Mid_Call (SEND_CALL)         O_Term_Seized (SEND_CALL)
      <br/>
      --                              Disconnected (SEND_CALL)
      <br/>
      --                              O_Called_Party_Busy (SEND_CALL)
      <br/>
      --                              O_No_Answer (SEND_CALL)
      <br/>
      -- O_Term_Seized (SEND_CALL)    O_Answer (O_ALERTING)
      <br/>
      --                              Mid_Call (O_ALERTING)
      <br/>
      --                              Disconnected (O_ALERTING)
      <br/>
      --                              O_Called_Party_Busy (O_ALERTING)
      <br/>
      --                              O_No_Answer (O_ALERTING)
      <br/>
      -- Mid_Call (O_ALERTING)        O_Answering (O_ALERTING)
      <br/>
      --                              O_Called_Party_Busy (O_ALERTING)
      <br/>
      --                              O_No_Answer (O_ALERTING)
      <br/>
      --                              Disconnected (O_ALERTING)
      <br/>
      -- O_Answer (O_ALERTING)        Cleared (ACTIVE)
      <br/>
      --                              Mid_Call (ACTIVE)
      <br/>
      --                              Disconnected (ACTIVE)
      <br/>
      -- Mid_Call (ACTIVE)            Cleared (ACTIVE)
      <br/>
      --                              Disconnected (ACTIVE)
      <br/>
      -- Cleared (ACTIVE)             Release_Timeout (RELEASE_PENDING)
      <br/>
      --                              Mid_Call (RELEASE_PENDING)
      <br/>
      --                              Disconnected (RELEASE_PENDING)
      <br/>
      -- Mid_Call (RELEASE_PENDING)   Release_Timeout (RELEASE_PENDING)
      <br/>
      --                              Disconnected (RELEASE_PENDING)
    </p>
    <p num="67">
      2.
      <br/>
      Feature Modeling and Specification
    </p>
    <p num="68">
      This section discusses the feature information used by methods and systems consistent with the present invention to run the feature interaction analysis.
      <br/>
      Referring back to FIG. 4, an exemplary business scenario may be that specifications of AIN features 404 are submitted to the service mediator by third-party service providers, and the specifications of switch-based features are made available directly by the service mediators for the feature interaction analysis 406.
    </p>
    <p num="69">2.1. AIN Feature Specification</p>
    <p num="70">
      Each AIN feature is modeled via two pieces of information: control specification and data specification.
      <br/>
      The control specification is a rule-based specification that specifies how the feature interacts with the SSP 102 via TCAP messages 302.
      <br/>
      The data specification is a data usage description that specifies how the call variables in each TCAP message 302 are manipulated by the feature.
      <br/>
      Details of these specifications are provided in sections 2.1.2 and 2.1.3.
    </p>
    <p num="71">2.1.1. An Illustrative AIN 0.1 Feature</p>
    <p num="72">
      Throughout this section, an AIN 0.1 feature, called NPA-NXX screening, is used as an example to illustrate the process of AIN feature specification.
      <br/>
      NPA-NXX screening is a feature that allows subscribers to screen outgoing calls from their lines.
      <br/>
      With this feature, screening can be applied to local calls or long distance calls.
      <br/>
      The subscribers can define screening lists to prevent calls to certain classes of numbers (fort example to a certain calling area, toll based service lines like 900 numbers or 976 numbers or even to a specific number).
    </p>
    <p num="73">2.1.2. Control Specification (AIN feature)</p>
    <p num="74">
      The control specification of a feature is a set of rules that describes all the possible TCAP message sequences between an SSP 109 and an SCP 104 for a feature.
      <br/>
      This specification turns out to be a subset of the rule-based specification defined in Section 1.4 (Table 4).
    </p>
    <p num="75">
      In fact, given the AIN trigger for a feature, one can find the corresponding SSP query message that starts the feature via one or more lookups in the tables defined in the previous section.
      <br/>
      Using this SSP query message as a starting point, one can select the set of all the message exchange rules from Table 4.
      <br/>
      The resulting set of rules forms the control specification for that feature.
    </p>
    <p num="76">
      Table 7 lists the control specification for NPA-NXX screening.
      <br/>
      Each rule in the control specification lists a message and its possible successor in a sequence of message exchanges between an SSP 102 and an SCP 104 as a result of this feature being triggered.
      <br/>
      Thus, when the feature is triggered (at trigger Customized Dialing Plan), an Info_Analyzed� query message from the SSP 102 could result in either of Analyze_Route-, Disconnect-, Continue- or Send_To_Resource being sent in response, by the SCP 104.
    </p>
    <p num="77">
      -- TABLE 7
      <br/>
      -- Control Specification for NPA-NXX Screening
      <br/>
      -- Rule   Last_Message_Exchanged Next_Message_Exchanged
      <br/>
      -- 1      Info_Analyzed�   Analyze_Route- �Send--
      <br/>
      --                              Notification.vertline.ACG*�,
      <br/>
      --                              Disconnect- �Send--
      <br/>
      --                              Notification.vertline.ACG*�,
      <br/>
      --                              Continue- �Send--
      <br/>
      --                              Notification.vertline.ACG*�,
      <br/>
      --                              &lt;suspend&gt;Send_To--
      <br/>
      --                              Resource* �ACG*.vertline.Update_Request�
      <br/>
      -- 2      Send_Notification     Termination_Notification-
      <br/>
      -- 3      ACG                   GapDuration_Timeout
      <br/>
      -- 4      Update_Request        Update_Data*, Honored_RR-
      <br/>
      -- 5      Send_To_Resource      Resource_Clear*, Cancel--
      <br/>
      --                              Resource_Event
      <br/>
      -- 6      Cancel_Resource_Event Resource_Clear*
      <br/>
      -- 7      Resource_Clear        &lt;resume&gt;
      <br/>
      -- 8      Update_Data           -
      <br/>
      -- 9      GapDuration_Timeout   -
    </p>
    <p num="78">2.1.3. Data Specification (AIN feature)</p>
    <p num="79">
      The data specification of a feature specifies the usage of each call variable in every TCAP message 302 used by this feature.
      <br/>
      This specification process is called "population" of the call variables in a message.
      <br/>
      Currently, the following notations have been defined to mark the usage of each call variable.
    </p>
    <p num="80">
      Call variables that come into the SCP 104, are marked as:
      <br/>
      "R" if they are call variables sent by SSP 102 to be Read and used by the feature:
      <br/>
      "N" if they are call variables sent by SSP 102 but Not to be read and used;
      <br/>
      "X" if they are optional call variables that won't get populated for this feature.
    </p>
    <p num="81">
      Call variables that leave from SCP 104, are marked as:
      <br/>
      "G" if they are not call variables from SSP 102 but Generated by SCP 104;
      <br/>
      "U" if they are call variables received from SSP 102 and now sent back by SCP 104 to Update the call processing variables in SSP;
      <br/>
      "H" if they are call variables received from SSP 102 and now sent back to SSP 102 unchanged;
      <br/>
      "X" if they are optional call variables that won't get populated for this feature.
    </p>
    <p num="82">
      Note that only mandatory and optional call variables (as described in section 1.3) need to be populated in a data specification.
      <br/>
      In particular, population of all mandatory call variables of a message is required, i.e., they cannot be marked as "X" in a data specification.
      <br/>
      Table 8 shows a part of the data specification for the message sequences initiated by the Info_Analyzed message of the NPA-NXX screening feature.
      <br/>
      For the sake of space, only the populated call variables are shown in the table 8.
    </p>
    <p num="83">
      -- TABLE 8
      <br/>
      -- Partial Data Specification for NPA-NXX
      <br/>
      --                                       Analyze Cancel              Discon-
      <br/>
      --                    Resource  Send    Send      Send        Termination Up-
      <br/>
      --    Update
      <br/>
      --                                ACG    Route   Resource  Continue  nect
      <br/>
      --  Info      Resource  Clear     Notifi- To        To          Notifi-
      <br/>
      --  date   Data    Update
      <br/>
      -- Call Variable           ACG    -  -   Event     -     -   Analyzed� Clear
      <br/>
      --    -     cation  Resource  Resource - cation      Data   -   Request
      <br/>
      -- ACGEncountered                                                            N
      <br/>
      -- AMAAlternateBillingNumber               G                 G         G
      <br/>
      --                                        X         G
      <br/>
      -- AMABusinessCustomerID                 G       G         G
      <br/>
      --                              X       G
      <br/>
      -- AMADigitsDialedWC                     G       G         G
      <br/>
      --                              X       G
      <br/>
      -- AMALineNumber                         G       G         G
      <br/>
      --                              X       G
      <br/>
      -- AMAsIpID                              G       G         G
      <br/>
      --                              X       G
      <br/>
      -- AccessCode                                                                N
    </p>
    <p num="84">
      -- AlternateBillingIndicator               G
      <br/>
      -- AnswerIndicator
      <br/>
      --                                      G         G
      <br/>
      -- ApplicationErrorstring
      <br/>
      -- BearerCapability                                                          N
      <br/>
      --
      <br/>
      --            X
      <br/>
      -- BusyCause
      <br/>
      --                                                            R
      <br/>
      -- CalledPartyID                         H                                   R
      <br/>
      -- CalledPartyBGID                                                           R
      <br/>
      -- CallingPartyID                        H       H                           R
      <br/>
      -- ChargeNumber                          X                                   N
      <br/>
      -- ChargePartyStationType                X                                   N
      <br/>
      -- ClearCause
      <br/>
      --          R         R
      <br/>
      -- CollectedAddressInfo                                                      X
      <br/>
      --          R         X
      <br/>
      -- CollectedDigits                                                           X
      <br/>
      --          R         X
      <br/>
      -- ConnectTime
      <br/>
      --                                                            R
      <br/>
      -- ControlCauseIndicator   G      G
      <br/>
      -- DestinationAddress
      <br/>
      --                                                X
      <br/>
      -- DisconnectFlag
      <br/>
      --                                      G         G
      <br/>
      -- EchoData
      <br/>
      --                              G                             R
      <br/>
      -- FailureCause
      <br/>
      --          R         R                                                   R
      <br/>
      --    R
      <br/>
      -- GapDuration             G      G
      <br/>
      -- GapInterval             G      G
      <br/>
      -- GlobalTitleValue        G      G
      <br/>
      -- Lata                                                                      R
      <br/>
      -- OriginalCalledPartyID                                                     N
      <br/>
      -- PrimaryBillingIndicator               G                 G         G
      <br/>
      --                                      X         G
      <br/>
      -- ResourceType
      <br/>
      --                                      G         G
      <br/>
      -- StrParameterBlock
      <br/>
      --                                      G         G
      <br/>
      -- TerminationIndicator
      <br/>
      --                                                            R
      <br/>
      -- TranslationType         G      G
      <br/>
      -- TriggerCriteriaType                                                       R
      <br/>
      -- UserID                                                                    R
      <br/>
      --
      <br/>
      --            H
    </p>
    <p num="85">2.2. Switch-based Feature Specification</p>
    <p num="86">
      Referring back to FIG. 3, a switch-based feature 306 is also modeled by data and control specifications.
      <br/>
      The control specification of a switch-based feature 306 specifies in what BCMs and at which DPs of each BCM the feature can influence call processing.
      <br/>
      The data specification then details the data (call variable) manipulation of the switch-based feature 306 at each "control" point.
      <br/>
      A switch-based feature 306 modifying data that could affect the values of TCAP call variables that are sent to the SCP 104 when an AIN feature 302 is triggered after the switch-based feature 306 terminates.
      <br/>
      A switch-based feature 306 can also be affected by values transferred to the SSP 102 from the SCP 104 via TCAP messages 302 as a result of a preceding AIN feature's execution.
      <br/>
      As stated, AIN 0.1 features 304 and switch-based features 306 are mutually atomic: an AIN feature may not execute while a switch-based feature is executing and vice versa.
      <br/>
      In addition, a switch-based feature 306 can be triggered at multiple detection points, and the effect that a switch based feature 306 can have on call variables (and vice versa) can differ at each of these points.
      <br/>
      This is reflected in the data specification as described below.
    </p>
    <p num="87">2.2.1. An Illustrative Switch-based Feature</p>
    <p num="88">
      Call Forwarding Variable (CFV) is a calling feature that allows a user to redirect calls from one line to another.
      <br/>
      CFV is described in further detail in Bellcore, "Call Forwarding Variable", Technical Reference TR-TSY-000580, Issue 1, October 1989.
      <br/>
      CFV is controlled via an activation and deactivation procedure.
      <br/>
      The activation procedure has the capability to let the customer specify a Directory Number for the remote line to which calls should be forwarded.
      <br/>
      When a subscriber of the call forwarding feature receives a call, a special ring is used at the subscriber's line (if the line is idle) to indicate that a call has been received and forwarded.
      <br/>
      Calls cannot be answered at the subscriber's line while CFV is active, but calls can be originated from there.
      <br/>
      CFV is a feature that can occur at multiple DPs and can influence multiple legs of a call in the AIN 0.1 call model.
    </p>
    <p num="89">2.2.2. Data and Control Specification of a Switch-based Feature</p>
    <p num="90">
      Although data manipulation and control flow are distinct aspects of a switched-based feature, they are specified in one integrated table.
      <br/>
      Table 9 shows a part of the combined data and control specification for CFV.
      <br/>
      A switch-based feature can operate on different BCM (Terminating 110 or Originating 108) instances for different legs of the same call.
      <br/>
      In the case of CFV, it is possible for the feature to be active on a TBCM 110 instance for one leg of a call and on an OBCM 108 instance for another leg of the same call.
      <br/>
      The feature could be active at a number of DPs in each of the BCM instances, and a given DP can be available at more than one PIC.
      <br/>
      Thus, the switch-based feature's specification has an entry for the call variable usage for each DP at each PIC present within each BCM instance on which the feature operates.
      <br/>
      In Table 9, the first column lists the instance number for the BCM instance in question, the second lists the BCM type (Originating 108 or Terminating 110) for this BCM instance, the third is the name of the DP at which this feature can operate along with a list of PICs (in parentheses) at which this DP may be encountered for this BCM instance.
      <br/>
      The rest of the columns give the call variable usage of this feature at this DP for three call variables: ACGEncountered, AMAAlternateBillingNumber and AMABusinessCustomerID.
      <br/>
      The rest of the call variables are not shown due to space constraints.
    </p>
    <p num="91">
      -- TABLE 9
      <br/>
      -- Part of Data and Control Specification for CFV.
      <br/>
      --                                                                 AMA-
      <br/>
      --                 Detection Points (DPs) and the Points in ACG-
      <br/>
      --  Alternate-    AMABusiness-
      <br/>
      -- Instance BC M    Call (PICs) at which they occur.    Encountered
      <br/>
      --  BillingNumber CustomerID
      <br/>
      -- 1       T       Termination_Attempt                 N           W
      <br/>
      --    W
      <br/>
      -- 1       T       T-Cleared (AUTHORIZE_TERMINATION/   N           N
      <br/>
      --    N
      <br/>
      --                 SELECT_FACILITY/PRESENT_CALL/
      <br/>
      --                 T_ALERTING/T_ACTIVE/T_RELEASE_
      <br/>
      --                 PENDING)
      <br/>
      -- 2       O       Origination_Attempt_Authorized      N           W
      <br/>
      --    W
      <br/>
      -- 2       O       Origination_Denied                  N           N
      <br/>
      --    N
      <br/>
      -- 2       O       Invalid_Information                 N           N
      <br/>
      --    N
      <br/>
      -- 2       O       Network_Busy                        N           N
      <br/>
      --    N
      <br/>
      -- 2       O       Authorization_Failure               N           N
      <br/>
      --    N
      <br/>
      -- 2       O       O_Called_Party_Busy (O_ALERTING)    N           N
      <br/>
      --    N
      <br/>
      -- 2       O       O_No_Answer (O_ALERTING)            N           N
      <br/>
      --    N
      <br/>
      -- 2       O       O_Release_Timeout                   N           N
      <br/>
      --    N
    </p>
    <p num="92">
      The call variable usage columns can contain one of four possibilities.
      <br/>
      A "READ" ("R") implies that the switch-based feature reads the call variable value, a "WRITE" ("W") specifies that the call variable value is written to by the feature, a "READ/WRITE" ("R/W") indicates that the call variable value can be processed in both ways.
      <br/>
      A value of "READ/WRITE" implies that the switch-based feature could perform both operations on the associated call variable.
      <br/>
      Since a switch-based feature is a black box, the ordering of the operations is not necessarily available, and it is assumed that either order is possible.
      <br/>
      The fourth alternative is that the call variable value is "NOT USED" ("N") at this DP.
    </p>
    <p num="93">
      For analysis of the features, a "signature" of a switch-based feature is defined.
      <br/>
      A switch-based feature is a set of tuples of the kind (D, P,  MU , PHI ), where "ID" and "P" are the DP and the PIC respectively at which the usage pattern "u" occurs for this switch-based feature for BCM instance " PHI ". Each such tuple is called a signature of the instance " PHI 's" detection point "D" at PIC "P" for this switch-based feature.
    </p>
    <p num="94">3. Analysis Methods and Optimizations</p>
    <p num="95">
      This section discusses the analysis methods used to deal with feature interactions consistent with the present invention.
      <br/>
      Optimizations that can be used to speed up the detection process are described.
    </p>
    <p num="96">
      Methods and systems of detection consistent with the present invention generally run in two phases.
      <br/>
      In the first phase, message sequences (see section 3.1) are generated for each AIN feature, and the feature specifications are validated, as illustrated in FIG. 6.
      <br/>
      In the second phase, a package of features is checked for interactions, as illustrated in FIG. 7.
    </p>
    <p num="97">
      FIG. 6 depicts a flowchart illustrating the processing and validation of an AIN feature.
      <br/>
      First, the data specification is entered into memory 506 (see FIG. 5) and the control specification is entered into the parser and sequence generator 520 (step 602) in memory 506.
      <br/>
      Additional steps in this process are detailed below.
    </p>
    <p num="98">3.1. Generating Feature Execution Sequences for AIN features</p>
    <p num="99">
      An AIN feature execution constitutes a finite sequence of message exchanges between the SSP 102 and the SCP 104.
      <br/>
      The finite sequence of messages exchanged between the SSP 102 and the SCP 104 during a feature execution is called an "execution sequence" for the feature.
      <br/>
      The feature's behavior is characterized by its set of execution sequences.
    </p>
    <p num="100">
      Given a trigger for a feature, one can identify the corresponding query message for that trigger.
      <br/>
      Based on the control specification for a feature, starting with the query message, the system can then construct the set of execution sequences that could occur as a result of the trigger (step 604).
      <br/>
      To save computing time, the system may generate "maximal" sequences, described below in Section 3.4.2.
    </p>
    <p num="101">3.2. Computing Cumulative Call Variable Usage for AIN Features</p>
    <p num="102">
      Using the data specification of a feature, the cumulative call variable usage for an execution sequence can be computed as follows (step 606).
      <br/>
      The result will be used for feature interaction analysis as shown in the following section.
    </p>
    <p num="103">
      Given an execution sequence s, a vector .nu. is used to store the cumulative call variable usage.
      <br/>
      Each element in .nu. corresponds to a specific call variable.
      <br/>
      Initially, all elements in .nu. are set to NOOP.
      <br/>
      Then each element in .nu. is updated by going through each message in s according to the rules specified in Table 10 below.
      <br/>
      Suppose .nu.i corresponds to call variable p. Then "Current .nu.i " refers to the cumulative usage of p computed so far; "Operation" refers to the operation performed by the current message on p, and "New .nu.i " is the updated value of the cumulative usage of p. Note that the bold face values in the "New .nu.i " column refer to errors in a feature specification, which will be discussed below in section 3.3.
    </p>
    <p num="104">
      -- TABLE 10
      <br/>
      -- Cumulative Call Variable Usage Updating Rules
      <br/>
      --      Current vi     Operation            New vi
      <br/>
      --      NOOP           R                    READ
      <br/>
      --                     G                    WRITE
      <br/>
      --                     H                    NRBH
      <br/>
      --                     U                    NRBU
      <br/>
      --      READ           R                    READ
      <br/>
      --                     G                    RBG
      <br/>
      --                     H                    READ
      <br/>
      --                     U                    READ-WRITE
      <br/>
      --      WRITE          R                    WRITE-READ
      <br/>
      --                     G                    WRITE
      <br/>
      --                     H                    NRBH
      <br/>
      --                     U                    NRBU
      <br/>
      --      READ-WRITE or  R                    No Change
      <br/>
      --      WRITE-READ     G                    RBG
      <br/>
      --                     H                    No Change
      <br/>
      --                     U                    No Change
    </p>
    <p num="105">If the feature is correctly specified, then after the last message is processed, .nu. holds the final cumulative call variable usage for s. There are four possible values for each .nu.i : (1) "READ", which means p is only read by the SCP 104 during the execution of s; (2) "WRITE", which means p is only written by the SCP 104 during the execution of s; (3) "READ-WRITE", which means p is both read and written by the SCP 104 during the execution of s, but the first operation by the SCP 104 on p is a read; and (4) "WRITE-READ", which means p is both read and written by SCP 104 during the execution of s, but the first operation by the SCP 104 on p is a write.</p>
    <p num="106">The "signature" of an execution sequence is defined as follows: given a sequence s with cumulative call variable usage .nu., the tuple &lt;s, .nu.&gt; is called the signature of s. The signature &lt;s, .nu.&gt; contains the complete description of s in terms of control and data</p>
    <p num="107">3.3. Validation of Individual AIN Features</p>
    <p num="108">
      The purpose of feature validation is to check errors in a feature specification in terms of control and data.
      <br/>
      If there are any errors (step 608), the system generates a validation error report for the user (step 610).
      <br/>
      Control errors appear in two forms: syntax and semantics.
      <br/>
      Syntax errors refer to violations of the rules of Table 4 in a control specification, which can be detected by encoding the rules of Table 4 in a parser.
      <br/>
      Semantic errors refer to choosing the wrong message and/or component, or missing a message in a control specification.
      <br/>
      Semantic errors that are feature specific can generally only be detected by design experts.
      <br/>
      However, some semantic errors can be detected automatically.
      <br/>
      For example, if a control specification has a response message that carries a Send_Notification component, the parser gives a warning if Rule 6 of Table 4 is not included in the specification.
    </p>
    <p num="109">
      Data errors, on the other hand, refer to errors in populating call variable usage for messages in data specifications.
      <br/>
      These errors are caught during the computation of cumulative call variable usage, and they are listed in bold face in Table 10.
      <br/>
      NRBH (No Read Before "H") and NRBU (No Read before "U") both identify cases when the SCP 104 tries to read or update a call variable value that has not been sent to the SCP 104 for reading in any previous message from the SSP 102.
      <br/>
      RBG (Read Before "G") indicates another type of error: when the SCP 104 tries to generate a call variable value that has already been sent to the SCP 104 for reading, by the SSP.
      <br/>
      In this case, a "U" should be used instead if the SCP 104 writes on the call variable.
      <br/>
      Checking for data errors ensures that the data specification of a feature is consistent with the corresponding control specification.
    </p>
    <p num="110">3.4. Reducing Complexity</p>
    <p num="111">
      Even though the control specification of an AIN feature ensures that the set of execution sequences of the feature is finite, the number of execution sequences of the feature can be very large.
      <br/>
      There are a number of problems: first, the generation of a complete set of execution sequences is very time-consuming and storing all the sequences requires a lot of disk space; second, the complexity of computing cumulative call variable usage grows linearly with the number of sequences; third, when analyzing interactions among features, the computation of the combined behavior of a set of features may become unmanageable.
      <br/>
      Collectively, these problems are generally referred to as the "state explosion" problem in analyzing distributed systems.
    </p>
    <p num="112">
      Methods consistent with the present invention generally use a two-step relief strategy for this problem.
      <br/>
      First, they reduce the number of execution sequences considered for each individual feature, and second, they reduce the complexity in interaction analysis.
    </p>
    <p num="113">3.4.1. Formalizing the Notion of Interaction</p>
    <p num="114">
      Section 3.1 above explained that an AIN feature's control specification could be used to generate message exchange sequences between the SSP 102 and the SCP 104 for the feature.
      <br/>
      Thus, an AIN feature is representable as a detection point along with a collection of sequence signatures that are determined via the control and data specifications for that feature.
      <br/>
      Given the trigger for an AIN feature, it is obvious how the DP and the PIC at which it will occur can be determined (via tables 1(a) and (b)).
      <br/>
      Also, section 2.2.2 explained how a switch-based feature could be considered to be a collection of DP signatures.
      <br/>
      These ideas are formalized using the following definitions.
    </p>
    <p num="115">
      "Interaction" between AIN features is defiled as follows: two AIN features F1 and F2 can "interact" if F1 's trigger precedes (as discussed in section 1.1) that of F2, and there exist sequences s1 and s2, for F1 and F2 respectively, with signatures &lt;s1, u1&gt; and &lt;s2, u2&gt; respectively and
      <br/>
      (i) a call variable whose index is i (in the cumulative call variable usage for each sequence) such that u1i =WRITE, READ-WRITE or WRITE-READ and u2i =READ or READ-WRITE, or
      <br/>
      (ii) u1d =WRITE, READ-WRITE or WRITE-READ, where d is the index of the DisconnectFlag call variable.
    </p>
    <p num="116">
      "Interaction" between AIN and switch-based features is defined as follows: An AIN feature F1 with DP D1 occurring at PIC P1 and a switch-based feature F2 can "interact" if there exists a sequence "s" with signature &lt;s, u1&gt; for F1 and a DP-signature (D2, P2, u2,  PHI 2) for F2 such that
      <br/>
      either D1 -P1 precedes D2 -P2 and
      <br/>
      - (i) there exists a call variable whose index is "i" (in the cumulative usage for each sequence) such that u1i =WRITE, READ-WRITE or WRITE-READ and u2i =READ, READ/WRITE, or
      <br/>
      - (ii) u1d =WRITE, READ-WRITE or WRITE-READ
      <br/>
      - or D2 -P2 precedes D1 -P1 (as discussed in section 1.5 and defined in tables 5 and 6) and
      <br/>
      - (i) there exists a call variable whose index is "i" (in the cumulative usage for each sequence) such that u2i =WRITE or READ/WRITE and u1i =READ or READ-WRITE, or
      <br/>
      - (ii) u2d =WRITE or READ/WRITE.
    </p>
    <p num="117">In either case, d is the index of the DisconnectFlag call variable.</p>
    <p num="118">
      These definitions characterize the class of interactions that are the subject of methods and systems consistent with the present invention.
      <br/>
      Side-effect interactions, as formalized above, occur when a feature writes a value to a call variable that is read in some way by another feature.
      <br/>
      A "write" could happen via either WRITE, READ-WRITE, WRITE-READ or READ/WRITE.
      <br/>
      A "read" could happen via either READ, READ-WRITE or READ/WRITE.
      <br/>
      Disabling interactions occur when a feature writes a value to the DisconnectFlag call variable.
      <br/>
      It should be noted that if an AIN feature's DP-PIC pair and a switch-based feature's DP-PIC pair are identical, then their cumulative call variable usages need to be checked in either order. since either can be executed before the other.
    </p>
    <p num="119">3.4.2. Maximal Sequences</p>
    <p num="120">
      An execution sequence is considered to be "maximal" if and only if it is not a prefix or subset of another execution sequence.
      <br/>
      One only need generate the set of maximal execution sequences for a feature to cover all cumulative call variable usages of a feature.
    </p>
    <p num="121">
      The maximal sequences for a feature can be generated using all of the TCAP components in a control specification for the generation of message sequences instead of using a subset of these components for some sequences.
      <br/>
      Using subsets of TCAP components in rules for message sequence generation results in the creation of prefixes of maximal sequences.
      <br/>
      TCAP component specifications in a control specification are discussed above in section 1.4.
    </p>
    <p num="122">
      If any interactions exist between features using non-maximal sequences, they can be detected using maximal sequences.
      <br/>
      A method for generating message sequences for an AIN feature consistent with the present invention as described in section 3.5.1 makes use of this fact and preferably generates the set of maximal sequences.
    </p>
    <p num="123">3.4.3. Equivalence Classes and Combined Representations</p>
    <p num="124">
      For the set of maximal execution sequences generated, the number of sequences considered can be further reduced by introducing an equivalence relation: given two maximal execution sequences s and t, let &lt;s, u&gt; and &lt;t, .nu.&gt; be their respective signatures, s and t are "equivalent," denoted as s_t, if and only if, for every i, ui =.nu.i. The relation "_" partitions the set of maximal execution sequences into equivalence classes.
      <br/>
      By definition, two execution sequences in the same equivalence class are indistinguishable in terms of data and control. �s� denotes an equivalence class for maximal sequence s and &lt;�s�, u&gt; denotes the signature of �s�.
    </p>
    <p num="125">Furthermore, if an AIN feature interacts with another due to a particular sequence s, then this interaction can be captured by simply performing the interaction analysis on the equivalence class �s'� for the maximal sequence s' of s. The interaction analysis can be performed by using the cumulative call variable usage of �s'� instead of that of s. Additionally, if an equivalence class shows an interaction involving an AIN feature, then there must exist a sequence for this feature which causes the interaction.</p>
    <p num="126">
      The equivalence classes can be generated by simply grouping generated (maximal) sequences for an AIN feature based on their cumulative call variable usages as has been described in section 3.2 (step 612).
      <br/>
      They can be used instead of individual sequences for interaction detection between features as mentioned above.
    </p>
    <p num="127">
      The amount of analysis performed between a pair of features can be further reduced by considering a combined representation for all the equivalence classes for the AIN feature(s).
      <br/>
      A combined representation maybe generated by stepping though all the generated equivalence classes for the feature to create a "combined call variable usage vector." each of whose components gives the combined usage of a call variable by all the equivalence classes of the feature (step 614).
      <br/>
      The creation of this combined usage vector starts off by generating a vector .nu., each of whose components is set to a value of NOOP.
      <br/>
      At each step in the process, an equivalence class's cumulative call variable usage vector is used to update the value of this vector .nu.. The rules for doing this are described in Table 11.
      <br/>
      Note the use of the "/" operator as opposed to the "-" operator.
      <br/>
      This is similar to the "/" operator used in the context of switch-based features' call variable usage in section 2.2.2. The "-" operator has the same semantics as were described in section 3.2 (Table 10) while the "/" operator is an alternation operator.
    </p>
    <p num="128">
      -- TABLE 11
      <br/>
      -- Rules for Computing the Combined Cumulative Call Variable
      <br/>
      -- Usage Vector
      <br/>
      --                                             Updated
      <br/>
      -- Current combined vi   Next Equiv.
      <br/>
      Class' ui combined vi
      <br/>
      -- NOOP                  Anything              ui
      <br/>
      -- READ, READ-WRITE      WRITE, WRITE-READ     READ/WRITE
      <br/>
      -- WRITE, WRITE-READ     READ, READ-WRITE      READ/WRITE
      <br/>
      -- READ, READ-WRITE      READ-WRITE            READ/WRITE
      <br/>
      -- WRITE, WRITE-READ     WRITE-READ            WRITE/READ
      <br/>
      -- READ                  READ                  READ
      <br/>
      -- WRITE                 WRITE                 WRITE
      <br/>
      -- READ-WRITE            READ                  READ-WRITE
      <br/>
      -- WRITE-READ            WRITE                 WRITE-READ
      <br/>
      -- READ/WRITE            Anything              READ/WRITE
      <br/>
      -- Anything              NOOP                  No Change
    </p>
    <p num="129">
      The significance of the cumulative call variable usage vector can be summarized in the following: if the combined call variable usage for a call variable i is set to (i) X, this means that there exists an equivalence class whose cumulative call variable usage for i is X, (ii)X-Y, there exists an equivalence class whose cumulative call variable usage is X-Y, (iii))X/Y, there exists an equivalence class whose use could be X or X-Y and an equivalence class whose use could be Y or Y-X.
      <br/>
      Conversely, if there exists an equivalence class whose cumulative call variable usage for i is set to (i) X, the combined call variable usage for i can be either X, X-Y or X/Y, (ii) X-Y, the combined call variable usage for i can be either X-Y or X/Y. (Note that X-Y stands for X preceding Y, X/Y stands for X or Y, and X,Y=READ, WRITE).
    </p>
    <p num="130">
      The following represents an AIN feature.
      <br/>
      If an AIN feature has D as its DP, P as the PIC at which this DP occurs, T as its trigger and C as its combined call variable usage vector, the AIN feature can be represented as (D, P. T. c).
      <br/>
      This is called the "combined representation" of the AIN feature.
      <br/>
      The combined usage vector, c, can be used in the same manner as outlined in section 3.4.1 for detecting the interactions involving an AIN feature.
      <br/>
      The only addition is that "READ/WRITE" for a call variable in c, can be considered as a "read" as well as a "write" for the AIN feature.
      <br/>
      Thus, interactions involving AIN features can be redefined based on their combined representations.
      <br/>
      In this case, c would be used in almost the same manner as the cumulative call variable usage for a message sequence to check for side effect interactions.
      <br/>
      D and P would be used when checking for the precedence relation between this AIN feature and a switch-based feature.
      <br/>
      T would be used to check the precedence relation between this feature and another AIN feature.
    </p>
    <p num="131">
      Given an AIN feature F1, it will interact with another feature F2 if and only if the combined representation of F1, (D, P, T, c), interacts with F2.
      <br/>
      This considerably reduces the amount of checking that needs to be done between a pair of features for detecting interactions.
      <br/>
      Once an interaction is detected involving an AIN feature, the manner of computation of the usage of a call variable in the combined representation of the feature makes it possible to locate an equivalence class that causes the interaction and thus obtain a representative sequence for this class.
      <br/>
      Using equivalence classes makes the retrieval of representative sequences much easier since one does not need to step through all of the sequences of the AIN feature.
    </p>
    <p num="132">3.4.4. Reducing the Amount of Analysis for a Feature Package</p>
    <p num="133">
      A package of features provided to a subscriber can be composed of multiple AIN and switch-based features.
      <br/>
      The class of interactions described so far deals with interactions between pairs of features.
      <br/>
      For the type of interactions involved here, it is sufficient to verify the lack of interactions in an arbitrary feature package by verifying the lack of interactions between every pair of features in the package.
    </p>
    <p num="134">
      In methods and systems consistent with the present invention, given a package of features, there are no interactions in the package if there are no pairwise interactions between individual features in the package.
      <br/>
      There is no need to check different subsets of a feature package for interactions if only dealing with AIN 0.1 features that return control to the same PlC as the one at which they triggered.
      <br/>
      This would be a combinatorially explosive (O(2n)) procedure.
      <br/>
      Instead, one needs to check individual feature pairs (O(n2)).
    </p>
    <p num="135">3.5. Analysis Algorithms</p>
    <p num="136">
      The data obtained via information modeling (as discussed in section 1) and feature specification (obtained from the user of the system as discussed in section 2) is used as input to two stages of analysis.
      <br/>
      The first stage of analysis occurs right after an individual AIN feature has been described via its control and data specifications.
      <br/>
      The end result of this stage is the generation of equivalence classes for this AIN feature (as discussed in section 3.4.3).
      <br/>
      The second stage of analysis begins when the user wants to check a particular feature package for interactions.
      <br/>
      It is in this stage that the feature interaction methods consistent with the present invention as outlined with regard to FIG. 4 are used; any interactions in the input package will be detected at the end of this stage.
      <br/>
      This subsection discusses methods used in these two stages of analysis.
    </p>
    <p num="137">3.5.1. Equivalence Class Generation for an AIN Feature</p>
    <p num="138">Generally, the equivalence class generation process has two parts: (1) generation of all possible sequences of TCAP messages 302 exchanged between the SCP 104 and the SSP 102 for a given feature and (2) computing the cumulative call variable usage for each of these sequences (as discussed in section 3.2) and grouping the sequences based on these cumulative call variable usages into equivalence classes.</p>
    <p num="139">
      All possible sequences of TCAP messages 302 exchanged between the SCP 104 and SSP 102 for a given feature are generated from the control specification of the feature (see section 2.1.2.) The sequences of possible TCAP messages 302 exchanged may be determined by starting with a message 302 in the Last_Message_Exchanged column (see Table 7) and determining the corresponding next possible messages, which are listed in Next_Message_Exchanged column.
      <br/>
      Then, for each next possible message, it can be determined which are the next possible messages from that message that can be exchanged.
      <br/>
      This may be repeated for each message sequence until there is no next message to be exchanged (i.e., Next_Message_Exchanged is -.) It should be noted, however, that it is most efficient to generate the maximal sequences (see section 3.4.2) for an AIN feature.
    </p>
    <p num="140">
      Once the complete set of sequences for each feature has been generated, one generates the equivalence classes based on cumulative call variable usage of these sequences.
      <br/>
      Recall from section 3.4.3 that an equivalence class for a feature is basically a set of maximal sequences for that feature each of which has the same cumulative call variable usage.
      <br/>
      Initially, the set of equivalence classes is empty.
      <br/>
      The cumulative call variable usage for each sequence is computed by stepping through every message of the sequence and updating a cumulative call variable usage vector as discussed in section 3.2. After the cumulative call variable usage vector has been computed for a sequence, the former is compared with all the cumulative call variable usage vectors computed for currently generated equivalence classes.
      <br/>
      In case the Current cumulative call variable usage vector has already been computed in some previous equivalence class, this sequence becomes a part of that class; otherwise a new equivalence class, with this sequence as the sole current member, is created.
      <br/>
      Once the cumulative call variable usages for each of these sequences are computed, the equivalence classes for this feature have also been generated.
    </p>
    <p num="141">3.5.2. Detecting Interactions in a Package of Features</p>
    <p num="142">
      Given a package of features comprised of both AIN and switch-based features, interactions between features can be detected using the specifications of these features as input by the user along with the information generated as described in the previous section.
      <br/>
      Also, because of the way these features have been modeled, it is possible to detect these interactions by processing one pair of features at a time.
    </p>
    <p num="143">
      FIG. 7 depicts a flowchart illustrating a method for detecting interactions in a package of features consistent with the present invention.
      <br/>
      First, a feature package is created by a user using the features stored in the library 528 (step 702).
      <br/>
      The entered features are partitioned between AIN features and switch-based features by the partitioner 524 (step 704) residing in memory 506.
      <br/>
      These features are entered into the interaction detector 522 (step 706) along with the information model including the BCM 526 of the AIN network in which the features will operate (step 708).
      <br/>
      Then, the interaction detector 522 uses this information to detect interactions between the features (step 710).
    </p>
    <p num="144">
      To simplify the detection, all the equivalence classes of a feature are combined into a single representation.
      <br/>
      This single representation is basically a single cumulative call variable usage vector for that feature.
      <br/>
      It is computed from the individual cumulative call variable usages of each equivalence class as discussed in section 3.4.3.
    </p>
    <p num="145">
      The interaction between an AIN feature and another AIN feature is detected via the following procedure:
      <br/>
      i) Determine the order in which the features would fire based on the triggers for these features.
      <br/>
      ii) Based on this ordering check the combined representation vector of each feature to see if the preceding feature writes a value to a call variable that the succeeding feature reads, or if the preceding feature writes to the DisconnectFlag call variable.
    </p>
    <p num="146">
      The same steps are followed for interaction detection between AIN and switch-based features.
      <br/>
      The slight difference here is that since a switch-based feature can have multiple detection points, the system needs to check the interaction between the call variable usage for a switch-based feature at each detection point for this feature (as described in section 2.2) and the combined representation vector for the AIN feature.
    </p>
    <p num="147">
      In case any interactions are detected in the steps outlined above, the system extracts (for AIN features) all the equivalence classes that are causing this interaction, along with a few representative sequences from each class, for display to the user (step 712).
      <br/>
      This error report helps the user of the system to get a more detailed idea of how the interaction is happening.
    </p>
    <p num="148">3.5.3. Feature Interaction Example</p>
    <p num="149">
      The following example illustrates the interaction detection discussed in section 3.5.2 above.
      <br/>
      Although a package composed of only two features is considered here, this interaction, as shown above, would be caught even if features other than these were present in the package.
    </p>
    <p num="150">
      This example illustrates the detection of a side-effect interaction.
      <br/>
      It considers a package composed of the features Call Forwarding Variable and NPA-NXX screening which were described in section 2.
      <br/>
      Interaction analysis of this package reveals that when Call Forwarding Variable is activated at the Origination_Attempt DP and NPA-NXX screening is triggered at the Info_Analyzed DP during a call, the former is seen to write a value to the call variable CalledPartyID, and the latter is seen to read this variable.
      <br/>
      It is possible for the subscriber of this package to see unexpected results because of this interaction.
      <br/>
      Let the subscriber's telephone number be M. If the subscriber decides to have all calls to M forwarded to another number N, without considering the fact that N is on the screening list of the NPA-NXX feature, the net result would be that the subscriber would not receive any forwarded calls from M at N, which is clearly not expected by the subscriber.
      <br/>
      Thus, in this case, a potential interaction detected by methods and systems consistent with the present invention could result in a feature interaction in a practical situation.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for detecting feature interaction between a first Service Control Point (SCP) based feature and a second SCP-based feature in a call processing network, said method comprising the steps of:</claim-text>
      <claim-text>using relational database models to model originating and terminating basic call models and to tie Transaction Capabilities Application Part (TCAP) messages to the originating and terminating basic call models; modeling the first feature and the second feature based on TCAP messages and TCAP call variables wherein the resultant first and second feature models are distinct from said relational database models representing the basic call models; determining from said first feature model a set of TCAP message sequences that can occur when executing the first feature and from said second feature model a set of TCAP message sequences that can occur when executing the second feature; determining from said first feature model a call variable usage vector for each TCAP message sequence within the set of TCAP message sequences for the first feature and from said second feature model a call variable usage vector for each TCAP message sequence within the set of TCAP message sequences for the second feature, wherein the call variable usage vectors indicate how the corresponding TCAP message sequence uses call variables;</claim-text>
      <claim-text>and detecting feature interaction by comparing, through use of the relational database models representing the basic call models, the call variable usage vectors of the first feature against the call variable usage vectors of the second feature.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein the step of modeling the first and second features further includes the step of: modeling the first and second features using a relational database.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 1, wherein the call processing network is an AIN Release 0.1 network, and wherein the originating and terminating basic call models are AIN Release 0.1 originating and terminating basic call models.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 1, wherein the step of determining the set of TCAP message sequences for the first and second features further includes the step of: reducing the number of TCAP message sequences by grouping the message sequences for each feature into equivalence classes based on an equivalence relation; wherein the step of determining the call variable usage vectors for the first and second features further includes the steps of:</claim-text>
      <claim-text>- reducing the number of call variable usage vectors by determining one call variable usage vector for each of the equivalence classes of a given feature;</claim-text>
      <claim-text>and - combining the call variable usage vectors among each of the equivalence classes of a given feature into a single call variable usage vector;</claim-text>
      <claim-text>and wherein the step of detecting feature interaction only requires: - detecting feature interaction by comparing, through use of the relational database models representing the basic call models, the single combined call variable usage vector of the first feature against the single combined call variable usage vector of the second feature.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 4 wherein the first feature is a switch-based feature, wherein the step of modeling the first and second features requires modeling the first switch-based feature based only on TCAP call variables; wherein the step of determining call variable usage vectors requires determining from said first switch-based feature model, call variable usage patterns for the first switch-based feature, wherein the call variable usage patterns indicate how the first switch-based feature uses TCAP variables and wherein the call variable usage patterns are independent of TCAP message sequences;</claim-text>
      <claim-text>and wherein the step of detecting feature interaction requires detecting feature interaction by comparing, through use of the relational database models representing the basic call models, the call variable usage patterns of the first switch-based feature against the single combined call variable usage vector of the second SCP-based feature.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 5, wherein the step of modeling the first and second features includes modeling a set of features wherein said set of features includes said first and second features.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 6, wherein the step of detecting feature interaction requires: comparing the combined call variable usage vectors and/or call variable usage patterns in a pairwise manner.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A method for feature interaction detection in a call processing network, comprising the steps of: modeling originating and terminating basic call models; modeling a plurality of features based on TCAP messages wherein the resultant feature models are distinct from the models representing the basic call models; generating call variable usage vectors for each of the plurality of features from the model of each feature wherein the call variable usage vectors for a given feature represent how that feature affects call variables; reducing the number of call variable usage vectors for each of the plurality of features by eliminating redundant call data usage information through the use of equivalence classes;</claim-text>
      <claim-text>and detecting feature interaction among the plurality of features by comparing, through use of the models representing the basic call models, the reduced number of call variable usage vectors of the plurality of features in a pairwise manner.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. Computer-readable memory containing instructions for controlling a data processing system to perform a method for detecting feature interaction in call processing network, the method comprising the steps of: modeling originating and terminating basic call models; modeling a first feature and a second feature based on TCAP messages wherein the resultant feature models are distinct from the models representing the basic call models; generating call variable usage vectors for the first feature from the first feature model wherein the call variable usage vectors represent how the feature affects call variables; reducing the number of call variable usage vectors of the first feature by eliminating redundant call data usage information through the use of equivalence classes; generating call variable usage vectors for the second feature from the second feature model wherein the call variable usage vectors represent how the feature affects call variables; reducing the number of call variable usage vectors of the second feature by eliminating redundant call data usage information through the use of equivalence classes;</claim-text>
      <claim-text>and comparing, through use of the models representing the basic call models, the reduced call variable usage vectors of the first feature to the reduced call variable usage vectors of the second feature to detect a feature interaction.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A system for detecting feature interaction between a first Service Control Point (SCP) based feature and a second SCP-based feature in a call processing network, said system comprising: means for using relational database models to model originating and terminating basic call models and to tie Transaction Capabilities Application Part (TCAP) messages to the originating and terminating basic call models; means for modeling the first feature and the second feature based on TCAP messages and TCAP call variables wherein the resultant first and second feature models are distinct from said relational database models representing the basic call models; means for determining from said first feature model a set of TCAP message sequences that can occur when executing the first feature and from said second feature model a set of TCAP message sequences that can occur when executing the second feature; means for determining from said first feature model a call variable usage vector for each TCAP message sequence within the set of TCAP message sequences for the first feature and from said second feature model a call variable usage vector for each TCAP message sequence within the set of TCAP message sequences for the second feature, wherein the call variable usage vectors indicate how the corresponding TCAP message sequence uses call variables;</claim-text>
      <claim-text>and means for detecting feature interaction by comparing, through use of the relational database models representing the basic call models, the call variable usage vectors of the first feature against the call variable usage vectors of the second feature.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The system of claim 10, wherein the means for determining the set of message sequences for the first and second features further includes: means for reducing the number of TCAP message sequences by grouping the message sequences for each feature into equivalence classes based on an equivalence relation; wherein the means for determining the call variable usage vectors for the first and second features farther includes; - means for reducing the number of call variable usage vectors by determining one call variable usage vector for each of the equivalence classes of a given feature;</claim-text>
      <claim-text>and - means for combining the call variable usage vectors among each of the equivalence classes of a given feature into a single call variable usage vector;</claim-text>
      <claim-text>and wherein the means for detecting feature interaction only requires: - means for detecting feature interaction by comparing, through use of the relational database models representing the basic call models, the single combined call variable usage vector of the first feature against the single combined call variable usage vector of the second feature.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The system of claim 11 wherein the first feature is a switch-based feature, wherein the means for modeling the first and second features requires means for modeling the first switch-based feature based only on TCAP call variables; wherein the means for determining call variable usage vectors requires means for determining from said first switch-based feature model, call variable usage patterns for the first switch-based feature, wherein the call variable usage patterns indicate how the first switch-based feature uses TCAP variables and wherein the call variable usage patterns are independent of TCAP message sequences;</claim-text>
      <claim-text>and wherein the means for detecting feature interaction requires means for detecting feature interaction by comparing, through use of the relational database models representing the basic call models, the call variable usage patterns of the first switch-based feature against the single combined call variable usage vector of the second SCP-based feature.</claim-text>
    </claim>
  </claims>
</questel-patent-document>