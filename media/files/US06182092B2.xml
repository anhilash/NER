<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182092B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182092</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182092</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="25400166" extended-family-id="42108930">
      <document-id>
        <country>US</country>
        <doc-number>08892579</doc-number>
        <kind>A</kind>
        <date>19970714</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08892579</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165527</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>89257997</doc-number>
        <kind>A</kind>
        <date>19970714</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08892579</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  17/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F  17/22        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>22</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>715227000</text>
        <class>715</class>
        <subclass>227000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>707E17006</text>
        <class>707</class>
        <subclass>E17006</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>715234000</text>
        <class>715</class>
        <subclass>234000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-017/30S5V</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>017</main-group>
        <subgroup>30S5V</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-017/22M</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>017</main-group>
        <subgroup>22M</subgroup>
      </classification-ecla>
      <classification-ecla sequence="3">
        <text>G06F-017/22T</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>017</main-group>
        <subgroup>22T</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/30569</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30569</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/2247</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>2247</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/2264</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>2264</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>17</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>19</number-of-drawing-sheets>
      <number-of-figures>20</number-of-figures>
      <image-key data-format="questel">US6182092</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and system for converting between structured language elements and objects embeddable in a document</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>PUTZ STEVEN B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5210824</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5210824</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>MOTOYAMA TETSURO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5506985</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5506985</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>YOSHIOKA MAKOTO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5553216</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5553216</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>KREMEN GARY, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5706434</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5706434</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>NAKATSUYAMA HISASHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5802529</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5802529</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>GUCK RANDAL LEE</text>
          <document-id>
            <country>US</country>
            <doc-number>5848415</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5848415</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>BLUMER THOMAS P, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5890171</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5890171</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>KYOJIMA MASAKI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5920879</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5920879</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>MIYAGAWA JUNICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5991782</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5991782</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>Chappell, David, Understanding ActiveX and OLE, Microsoft Press, Jun. 1996, pp. 107-128.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>Microsoft Internet Assistant for Word 6.0 for Windows, Microsoft, 1995.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Microsoft Corporation</orgname>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>MICROSOFT</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Francis, James Lee</name>
            <address>
              <address-1>Carnation, WA, US</address-1>
              <city>Carnation</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Mantek, Frank</name>
            <address>
              <address-1>Issaquah, WA, US</address-1>
              <city>Issaquah</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Layman, Andrew</name>
            <address>
              <address-1>Bellevue, WA, US</address-1>
              <city>Bellevue</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Little, Robert A.</name>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="5">
          <addressbook lang="en">
            <name>Apfel, Darren Alexander</name>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Klarquist Sparkman Campbell Leigh &amp; Whinston, LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Feild, Joseph H.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A converter converts between structured language elements and objects embeddable in the native format of a document editor.
      <br/>
      A data structure representing the embeddable object is created without instantiating an instance of the object and includes the associated structured language element.
      <br/>
      Subsequently, the structured language element is used to instantiate an object and set its properties.
      <br/>
      Any portion of the structured language element not recognized during the conversion process is retained by the embeddable object.
      <br/>
      If conversion back to a structured language element is subsequently required, the conversion process is facilitated by the presence of the original structured language element within the embeddable object as well as the retained portion of the structured language element not recognized.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>COPYRIGHT AUTHORIZATION</heading>
    <p num="1">
      A portion of the disclosure of this patent document contains material which is subject to copyright protection.
      <br/>
      The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.
    </p>
    <heading>FIELD OF THE INVENTION</heading>
    <p num="2">
      This invention relates to document format conversion.
      <br/>
      More particularly, the invention relates to converting between a structured language element and an object embeddable in the native format of a document editor.
    </p>
    <heading>BACKGROUND AND SUMMARY OF THE INVENTION</heading>
    <p num="3">
      Electronic documents may be composed according to a variety of document formats which differ in the way they represent a document.
      <br/>
      For example, two documents in two different formats may appear similar when displayed to the user.
      <br/>
      However, the internal representations of the documents may be very different.
      <br/>
      Since a document editor is typically able to load and save only those documents of a particular format (i.e., the document editor's "native" format), a common problem related to document formats is converting documents from one document format to another.
    </p>
    <p num="4">
      A particular type of document format is referred to herein as a structured language.
      <br/>
      Structured languages use plain text to denote how a document should be formatted and to indicate items within the document.
      <br/>
      Particular structured languages such as the Hypertext Markup Language (HTML) and the Virtual Reality Modeling Language (VRML) are widely used on the Internet, a world-wide network of cooperating computer networks.
      <br/>
      However, structured languages can also be used for non Internet purposes.
    </p>
    <p num="5">
      HTML comprises plain text and HTML tags, the latter of which are comprised of HTML tag components (e.g., an HTML tag name, HTML attribute keyword or HTML attribute value).
      <br/>
      One function of the HTML tags is to format and organize the text of an HTML document.
      <br/>
      Another function of the HTML tags is to denote items within the HTML document.
      <br/>
      For example, a particular item called a hyperlink provides a link to another document and is denoted by a particular HTML tag.
      <br/>
      Hyperlinks can be thought of as cross references connecting HTML documents to facilitate traversal from one HTML document to another.
      <br/>
      As a result, a certain collection of interconnected HTML documents available on the Internet is often referred to as the World Wide Web (WWW).
      <br/>
      Although widely used on the Internet, HTML can also be used on non-networked machines or on intranets (networks separate from the Internet using Internet standards).
    </p>
    <p num="6">
      The text in an unrendered HTML document is sometimes referred to as "source" or "raw" HTML.
      <br/>
      Ordinarily, such source HTML is not viewed without the aid of an HTML document viewer (commonly called a web browser).
      <br/>
      The HTML document viewer interprets the unrendered HTML text to provide the user with a rendered HTML document.
      <br/>
      For example the "&lt;B&gt;" HTML tag causes text associated with it to appear in boldface type, and the "&lt;HR&gt;" HTML tag results in a horizontal rule.
      <br/>
      HTML includes numerous other tags to represent headings, numbered lists, and other items.
      <br/>
      Commercially available HTML document viewers include the Internet Explorer by Microsoft Corporation of Redmond, Washington, Netscape Navigator by Netscape Communications Corporation of Mountain View, Calif., and Mosaic by the National Center for Supercomputer Applications (NCSA) of Champaign-Urbana, Ill.
    </p>
    <p num="7">
      Originally, HTML consisted of only text and text-related tags.
      <br/>
      The limitations of a text only system were recognized, and new HTML tags were added to define images, forms, tables, and other items.
      <br/>
      As other limitations in existing tags are recognized, HTML is extended and enhanced.
      <br/>
      For example, new HTML tags are added, or existing tags are redefined.
      <br/>
      As a result, the definitions of HTML tags may change over time, and the rendering process evolves to accommodate the changes.
    </p>
    <p num="8">
      One or more HTML tags can be used to construct an HTML element.
      <br/>
      Certain HTML elements relating to forms are particularly useful because they can be used to collect information from users.
      <br/>
      For example, when the HTML document is rendered, an HTML element may appear as a text box or a graphical push button.
      <br/>
      A user can place identifying or search information in the text box and click on the push button (i.e., activate a user input device such as a mouse while pointing at the graphical push button) to send the information to a vendor.
      <br/>
      Such an arrangement has numerous uses, including conducting business over the Internet (e.g., using an HTML order form document), performing operations on non-networked computers (e.g., using an HTML form to search a database of personal contact information), or gathering information over an intranet (e.g., using an HTML form to collect information from a new employee).
    </p>
    <p num="9">
      A recurring problem associated with HTML is finding a convenient way to create and edit HTML documents.
      <br/>
      Many of the more powerful document editors (e.g., word processor, spreadsheet, or presentation programs) include a large set of useful features for editing and publishing a variety of documents, such as WYSIWYG (What-You-See-Is-What-You-Get) editing, spell checking, and extensive on-line help.
      <br/>
      Document editors such as Microsoft Word 95 and Microsoft Excel 95 by Microsoft Corporation of Redmond, Wash., offer these and many other useful features.
    </p>
    <p num="10">
      In addition, many document editors allow certain items to be embedded into documents.
      <br/>
      For instance, a word processor may permit an image or a video to be inserted into a text document.
      <br/>
      A certain item called an object may be embedded in a document if it is of a format recognized by the document editor as embeddable.
      <br/>
      Examples of embeddable objects are text boxes, pick lists, and graphical push buttons.
      <br/>
      A class identifier is used to identify like objects of a particular class.
    </p>
    <p num="11">
      Once embedded in the document, some document editors allow the user to manipulate the object within the document.
      <br/>
      For example, text boxes, pick lists, and graphical push buttons may be placed within a document to create a form.
      <br/>
      A user may define the appearance and behavior of the embedded objects by setting their properties.
      <br/>
      For example, Microsoft Forms3 by Microsoft Corporation provides the user with classes of objects relating to text boxes, push buttons, and other items that can be embedded in Microsoft Word 95 documents.
      <br/>
      Thus, the user may employ these document editors with embeddable object capability to create and edit forms.
    </p>
    <p num="12">
      However, using these editors to edit HTML documents presents two basic problems.
      <br/>
      First, the format these editors use to load or save documents (hereafter their "native" format) is typically not HTML, so the editors do not offer a way to create or edit rendered HTML documents.
      <br/>
      In other words, a document saved in the native format of one of these editors is typically not saved according to the HTML specification.
    </p>
    <p num="13">
      The second problem relates to embedding HTML into a document.
      <br/>
      Although some document editors allow items of various formats to be embedded into documents, HTML is generally not recognized as an embeddable format.
      <br/>
      In other words, document editors generally do not permit HTML elements to be embedded into a document.
    </p>
    <p num="14">
      Some document editors address the first problem by offering a mechanism for converting between the editor's native format and HTML, called a converter.
      <br/>
      However, these converters typically convert only a subset of the possible HTML tags and elements, such as simple ones relating to formatting and hyperlinks.
      <br/>
      In this way, the user can take advantage of the features within the document editor to edit some HTML documents and need not use a separate application to edit HTML documents.
      <br/>
      However, more complex HTML elements, such as those relating to forms cannot be converted to simple formatting or a hyperlink.
      <br/>
      Further, the second problem relating to the non-embeddable nature of HTML prevents such a simple converter from simply placing these HTML elements into a document.
    </p>
    <p num="15">
      To solve the conversion problem, a comprehensive program could be constructed to convert between an HTML document and a document in a particular native document format.
      <br/>
      For example, the Internet Assistant by Microsoft Corporation provides users with an HTML conversion software routine for Microsoft Word 95.
      <br/>
      A problem facing these programs is that the HTML-to-native document format converter must be able to convert a wide variety of HTML elements into the native document format.
      <br/>
      In addition, each of the HTML tag components may affect the conversion process.
      <br/>
      Further, the native document format may not include features that fully represent the HTML elements.
      <br/>
      Therefore, additional data must be associated with the native document features and additional logic must be included in the document editor to handle the additional data.
      <br/>
      The logic required to implement such a process can be relatively complex.
      <br/>
      Finally, if the HTML elements cannot be fully represented by native document features, the document editor may not provide WYSIWYG editing of the converted document.
    </p>
    <p num="16">
      The native document format-to-HTML converter faces similar problems because it requires logic to convert the native document format into a wide variety of HTML elements.
      <br/>
      Thus, a comprehensive converter becomes quite large and complex.
      <br/>
      In addition, when HTML is converted into a native document format and subsequently converted back into HTML, the resulting HTML may not be identical to the original HTML, due to idiosyncrasies of the conversion process.
      <br/>
      Finally, as HTML evolves, such a converter falls quickly into obsolescence, and the additional logic included in the document editor must be changed.
    </p>
    <p num="17">
      Several document editors bypass the problems associated with conversion and use HTML as their native format, allowing users to directly edit rendered HTML.
      <br/>
      Examples of these HTML editors include FrontPage by Microsoft Corporation, Netscape Navigator Gold by Netscape Communications Corporation, and HoTMetaL by SoftQuad Incorporated of Toronto, Canada.
      <br/>
      However, these specialized programs have their own drawbacks.
      <br/>
      They contain a reduced set of features compared to other document editors, and a new version of the editor must be provided when new HTML extensions or enhancements are added.
    </p>
    <p num="18">
      Another way to address the problems associated with conversion is to edit the source HTML without rendering it.
      <br/>
      A document editor may offer a way to manipulate plain text.
      <br/>
      If so, the editor may be used to open, save, edit, or create source HTML without rendering it.
      <br/>
      However, such an approach is problematic because the user cannot see how the HTML viewer will ultimately render the HTML.
      <br/>
      For example, the user may see the unrendered HTML element for a graphical push button (e.g., &lt;INPUT TYPE="reset"&gt;) but cannot see where the push button will be placed or how it will appear when rendered.
      <br/>
      As a result, the user cannot perform WYSIWYG editing, and the editing process is often slowed by repeated switching between editing the source HTML with a document editor and viewing the rendered HTML with an HTML viewer.
      <br/>
      Forms are challenging to edit in any environment, and the inability to easily see the form compounds the difficulty.
    </p>
    <p num="19">Thus, users who wish to create or edit HTML documents containing certain HTML elements, such as those relating to forms, have been forced to choose among three undesirable situations: writing a comprehensive converter program with its associated problems, using a specialized HTML editor with limited features, or editing source HTML by switching back and forth between programs.</p>
    <p num="20">
      The present invention provides methods and systems for converting between a structured language document and a document of a native format while avoiding these problems.
      <br/>
      Conversion between structured language elements and objects embeddable in the native format of a document editor is provided.
      <br/>
      Thus the user is not required to use a separate, specialized program and can take advantage of the features in a document editor that does not use the structured language as its native format (e.g., a non-HTML document editor) and does not recognize the structured language as an embeddable format.
    </p>
    <p num="21">
      In one implementation, a method is provided for converting a structured language element to an object of an embeddable format recognized by the document editor.
      <br/>
      A converter first converts a structured language document to a stream in a format called Rich Text Format (hereinafter "RTF").
      <br/>
      When a structured language element is encountered in the structured language document, a class identifier identifying an object of a format embeddable in the document editor is selected according to a selected tag component (e.g., an HTML tag name) of the structured language element with reference to a Structured Language Element-to-Embeddable Object Class Association Table.
      <br/>
      Then, the class identifier and the structured language element are placed into a storage.
      <br/>
      The storage is converted into a stream, and the stream is placed into the RTF stream.
      <br/>
      The converter does not instantiate an embeddable object during the conversion process or set the embeddable object's properties.
      <br/>
      In this way, the converter logic is kept small and need not be repeatedly updated with each change in the structured language.
      <br/>
      If new structured elements are created, a new Structured Language Element-to-Embeddable Object Class Association Table can be provided instead of providing a new converter.
      <br/>
      Another advantage to this arrangement is that some document editors already have a facility for converting RTF to their native format.
    </p>
    <p num="22">
      In another aspect of the invention, the streams relating to embeddable objects in the RTF stream described above are converted into storages, each storage containing a class identifier and a structured language stream.
      <br/>
      When the embeddable object relating to the storage is to be displayed, the storage is used to instantiate an embeddable object of the class identified by the class identifier in the storage.
      <br/>
      The structured language stream is passed to the embeddable object using an interface to the object, and the structured language stream is stored within the embeddable object.
      <br/>
      An advantage to this arrangement is that a document editor may already have a facility for determining when an item is to be displayed and can already instantiate an object if provided an appropriate storage.
      <br/>
      Thus, this aspect of the invention has the advantage of providing an appropriate storage for instantiating the embeddable object without instantiating an object to produce the storage.
    </p>
    <p num="23">
      In another aspect of the invention, the structured language stream within the embeddable object is used to set the properties of the embeddable object.
      <br/>
      A property setting software routine is included in the document editor.
      <br/>
      The embeddable object provides the structured language stream and a Structured Language Attribute-to-Embeddable Object Property Association Table to the property setting software routine, which parses the structured language and sets the appropriate embeddable object properties according to the structured language stream.
      <br/>
      In this way, the embeddable object avoids containing certain logic for parsing the structured language because the property setting software routine handles the details of parsing the structured language with reference to the Structured Language Attribute-to-Embeddable Object Property Association Table.
      <br/>
      In this way, the size of the embedded object is reduced, and structured language extensions or enhancements can be processed by providing a new Table.
    </p>
    <p num="24">
      In another aspect of the invention, the property setting software routine stores a "found" value within the embeddable object indicating which of the properties were set with reference to the Structured Language Attribute-to-Embeddable Object Property Association Table.
      <br/>
      If the property setting software routine encounters a portion of the structured language stream that it is unable to process, it stores the portion separately within the embeddable object.
      <br/>
      The information relating to which of the properties were set and which portions of the structured language could not be processed is used if the embeddable object is later converted back into the structured language.
      <br/>
      In this way, idiosyncrasies of the conversion process are avoided, and the resulting structured language more closely resembles the original structured language, even if not recognized during the property setting process.
    </p>
    <p num="25">
      In the case of an HTML document, since the HTML elements (e.g., such as those relating to forms) in the HTML document are converted to objects embeddable by a non-HTML document editor, the user can use the numerous features available within the non-HTML document editor.
      <br/>
      Since the embeddable object handles some of the details of the HTML to embeddable object conversion, the same conversion logic may be used to process HTML streams containing new extensions or enhancements.
      <br/>
      If the details of the conversion process change due to new HTML extensions or enhancements, changes to the conversion process can be effected by providing a new embeddable object class (which may contain a new Structured Language Attribute-to-Embeddable Object Property Association Table).
      <br/>
      A mechanism for providing a new embeddable object class already exists, so the invention facilitates converting new HTML extensions or enhancements.
    </p>
    <p num="26">
      Other aspects of the invention relate to converting an embeddable object into a related structured language element.
      <br/>
      The embeddable object provides a stream of the structured language through an interface.
      <br/>
      If no changes have been made to the embeddable object since the structured language stream was stored in it, the embeddable object uses the stored structured language stream.
      <br/>
      Using the stored stream facilitates the conversion process and results in a structured language stream closely resembling (or identical to) the original.
    </p>
    <p num="27">
      If there have been changes to the embeddable object, or if no structured language stream is present within the embeddable object, a property saving software routine is provided by the document editor to assist the embeddable object in producing a structured language stream.
      <br/>
      The property saving software routine uses the Structured Language Attribute-to-Embeddable Object Property Association Table and the "found" value described above to generate a stream of the structured language relating to the embeddable object.
      <br/>
      The property saving software routine also retrieves any portion of structured language not recognized that was stored within the embeddable object.
      <br/>
      Thus, the embeddable object can use the property saving software routine to assist it in generating a stream of the structured language.
      <br/>
      In this way, the embeddable object avoids containing certain logic for generating a stream of the structured language.
      <br/>
      As a result, the size of the embeddable object is reduced.
    </p>
    <p num="28">In addition, using the "found" value and the portion of structured language not recognized results in a structured language element more closely resembling (or identical to) the original one.</p>
    <p num="29">Additional features and advantages of the invention will be made apparent from the following detailed description of an illustrated embodiment which proceeds with reference to the accompanying drawings.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="30">
      FIG. 1 is a block diagram of a computer system that may be used to implement a method and apparatus for embodying the invention.
      <br/>
      FIG. 2 is a block diagram of a typical arrangement for using a web browser on a computer system, such as that of FIG. 1, to view an HTML document.
      <br/>
      FIG. 3A is a view of an unrendered HTML document, such as that of FIG. 2.
      <br/>
      FIG. 3B is a view of the HTML document of FIG. 3A in rendered form.
      <br/>
      FIG. 4 is a diagram illustrating the terminology used to describe various portions of HTML text in the HTML document of FIG. 3A.
      <br/>
      FIG. 5 is a block diagram of an object conforming to the Common Object Model (COM) specification.
      <br/>
      FIG. 6 is a flowchart showing an overview of the HTML to Microsoft Word 97 native format conversion process shown in FIGS. 7-14.
      <br/>
      FIG. 7 is a block diagram of an HTML to RTF converter used to convert an HTML document such as that shown in FIG. 3A.
      <br/>
      FIG. 8 is a flowchart of a method for converting an HTML document, such as that shown in FIG. 3A, to an RTF stream.
      <br/>
      FIG. 9 is a block diagram of a document editor for processing an RTF stream, such as the RTF stream shown in FIG. 8 to produce storages relating to HTML elements.
      <br/>
      FIG. 10 is a flowchart of a method for processing an RTF stream, such as that shown in FIG. 9, to produce storages relating to HTML elements.
      <br/>
      FIG. 11 is a block diagram of a document editor for providing an embeddable object relating to a storage, such as the storages shown in FIG. 9.
      <br/>
      FIG. 12 is a flowchart of a method for providing an embeddable object relating to a storage, such as the storages shown in FIG. 9.
      <br/>
      FIG. 13 is a block diagram of an embeddable object such as that shown in FIG. 11, a Structured Language Attribute-to-Embeddable Object Property Association Table and a property setting software routine.
      <br/>
      FIG. 14 is a flowchart of a method for setting the properties of the embeddable object shown in FIG. 13 using the Structured Language Attribute-to-Embeddable Object Property Association Table shown in FIG. 13.
      <br/>
      FIG. 15 is a block diagram of document to HTML converter for converting embeddable objects such as the one shown in FIG. 13.
      <br/>
      FIG. 16 is a flowchart of a method for converting a document such as that shown in FIG. 15 to an HTML document.
      <br/>
      FIG. 17 is a flowchart of a method for converting an embeddable object such as that shown in FIG. 15 to an HTML stream.
      <br/>
      FIG. 18 is a block diagram of an embeddable object such as that shown in FIG. 15, a Structured Language Attribute-to-Embeddable Object Property Association Table and a property saving software routine.
      <br/>
      FIG. 19 is a flowchart of a method for producing an HTML stream from the properties of an embeddable object, such as that shown in FIG. 15.
    </p>
    <heading>DETAILED DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS</heading>
    <p num="31">
      The present invention is directed toward methods and systems for converting between a structured language element (e.g., an HTML element) and an embeddable object.
      <br/>
      In one embodiment, the invention is incorporated into a word processing application program entitled "Microsoft Word 97," marketed by Microsoft Corporation of Redmond, Wash.
      <br/>
      Microsoft Word 97 provides a means for creating, editing, and saving documents in a word processing environment and includes a rich set of features such as WYSIWYG editing, spell checking, and an extensive on-line help facility.
    </p>
    <p num="32">Exemplary Operating Environment</p>
    <p num="33">
      FIG. 1 and the following discussion are intended to provide a brief, general description of a suitable computing environment in which the invention may be implemented.
      <br/>
      While the invention will be described in the general context of computer-executable instructions of a computer program that runs on a personal computer, those skilled in the art will recognize that the invention also may be implemented in combination with other program modules.
      <br/>
      Generally, program modules include routines, programs, components, data structures, etc. that perform particular tasks or implement particular abstract data types.
      <br/>
      Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.
      <br/>
      The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network.
      <br/>
      In a distributed computing environment, program modules may be located in both local and remote memory storage devices.
    </p>
    <p num="34">
      With reference to FIG. 1, an exemplary system for implementing the invention includes a conventional personal computer 20, including a processing unit 21, a system memory 22, and a system bus 23 that couples various system components including the system memory to the processing unit 21.
      <br/>
      The system bus may be any of several types of bus structure including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, Microchannel, ISA and EISA, to name a few.
      <br/>
      The system memory includes read only memory (ROM) 24 and random access memory (RAM) 25. A basic input/output system 26 (BIOS), containing the basic routines that help to transfer information between elements within the personal computer 20, such as during start-up, is stored in ROM 24.
      <br/>
      The personal computer 20 further includes a hard disk drive 27, a magnetic disk drive 28, e.g., to read from or write to a removable disk 29, and an optical disk drive 30, e.g., for reading a CD-ROM disk 31 or to read from or write to other optical media.
      <br/>
      The hard disk drive 27, magnetic disk drive 28, and optical disk drive 30 are connected to the system bus 23 by a hard disk drive interface 32, a magnetic disk drive interface 33, and an optical drive interface 34, respectively.
      <br/>
      The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the personal computer 20.
      <br/>
      Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in the exemplary operating environment.
    </p>
    <p num="35">
      A number of program modules may be stored in the drives and RAM 25, including an operating system 35, one or more application programs 36, other program modules 37, and program data 38.
      <br/>
      A user may enter commands and information into the personal computer 20 through a keyboard 40 and pointing device, such as a mouse 42.
      <br/>
      Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like.
      <br/>
      These and other input devices are often connected to the processing unit 21 through a serial port interface 46 that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB).
      <br/>
      A monitor 47 or other type of display device is also connected to the system bus 23 via an interface, such as a video adapter 48.
      <br/>
      In addition to the monitor, personal computers typically include other peripheral output devices (not shown), such as speakers and printers.
    </p>
    <p num="36">
      The personal computer 20 may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer 49.
      <br/>
      The remote computer 49 may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the personal computer 20, although only a memory storage device 50 has been illustrated in FIG. 1.
      <br/>
      The logical connections depicted in FIG. 1 include a local area network (LAN) 51 and a wide area network (WAN) 52. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.
    </p>
    <p num="37">
      When used in a LAN networking environment, the personal computer 20 is connected to the local network 51 through a network interface or adapter 53.
      <br/>
      When used in a WAN networking environment, the personal computer 20 typically includes a modem 54 or other means for establishing communications over the wide area network 52, such as the Internet.
      <br/>
      The modem 54, which may be internal or external, is connected to the system bus 23 via the serial port interface 46.
      <br/>
      In a networked environment, program modules depicted relative to the personal computer 20, or portions thereof, may be stored in the remote memory storage device.
      <br/>
      It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.
    </p>
    <p num="38">HTML Overview</p>
    <p num="39">
      HTML is a prevalent language of a portion of the Internet known as the World Wide Web.
      <br/>
      HTML documents are text documents that are used to produce a rendered version of the document in a display area.
      <br/>
      The unrendered HTML document is sometimes called HTML "source." A typical HTML viewer (also known as a "web browser") arrangement is illustrated at FIG. 2.
      <br/>
      An HTML document 60 is rendered in a document display area 72 for viewing by a user.
    </p>
    <p num="40">
      HTML documents can reside as files of a file system stored in a hard drive 27 (FIG. 1) or other secondary storage of a personal computer 20 (FIG. 1), or reside as resources at a remote computer 58 (FIG. 2) connected to the computer network 57, such as a world-wide web site on the Internet or an intranet.
      <br/>
      The illustrated document 60 residing at the site 58 conforms with HTML standards, and may include extensions and enhancements of HTML standards.
      <br/>
      For a detailed discussion of HTML, see HTML 3: Electronic Publishing on the World Wide Web by Dave Raggett et al., Addison-Wesley Longman Ltd., Essex, England, 1996.
    </p>
    <p num="41">
      In conformance with HTML, the illustrated document 60 can incorporate other additional information content 62, such as images, audio, video, executable programs, etc. (hereafter simply "images" 62), which also reside at the remote computer 58.
      <br/>
      The document 60 and images 62 preferably are stored as files in a file system of the remote computer 58.
      <br/>
      The document 60 incorporates the images 62 using HTML tags that specify the location of files or other Internet resources containing the images on the Internet 57.
    </p>
    <p num="42">
      When used for browsing documents, the illustrated browser displays the document in a window 68 or rectangular area of the computer's display 65 allocated to the browser by the operating system.
      <br/>
      The illustrated window 68 comprises a frame 70, a document display area 72, and user interface controls 74.
      <br/>
      The browser provides the document display area 72 for displaying the document.
    </p>
    <p num="43">
      An example of the correspondence between an HTML source document and a resulting rendered display is illustrated at FIGS. 3A and 3B. FIG. 3A illustrates an example of an HTML document 130 in source (unrendered) form.
      <br/>
      When the HTML document 130 at FIG. 3A is rendered it appears as shown in the window 131 at FIG. 3B. It will be appreciated that web browsers may display rendered versions differing slightly from that shown in FIG. 3B. For example, graphical boxes may have rounded edges or appear as three dimensional objects.
      <br/>
      Also, the typeface used to display text may differ.
    </p>
    <p num="44">
      An exemplary portion 140 of an the HTML source document 130 is illustrated at FIG. 4.
      <br/>
      The portion 140 comprises HTML tags 141, 143, 144, 150, 152, 155, and 156.
      <br/>
      An HTML tag is denoted by the presence of HTML tag delimiters (The characters "&lt;" and "&gt;").
      <br/>
      The first word of an HTML tag 143 is its HTML tag name 142.
      <br/>
      Some HTML tags, such as the HTML tag 144, start with the character "/" and are also known as HTML end tags.
      <br/>
      The HTML tag 150 comprises HTML tag components 145, 146, 147, 148, and 149.
      <br/>
      Certain HTML tag components such as the HTML tag component 148 serve to denote an HTML attribute keyword and others, such as the HTML tag component 149 serve as an optionally related HTML attribute value.
      <br/>
      Each HTML tag may have zero, one, or more attributes.
      <br/>
      Some HTML attribute keywords (e.g., "CHECKED") may have no related HTML attribute value.
    </p>
    <p num="45">
      The HTML element 151 comprises an HTML tag 152, and the HTML element 153 comprises an HTML start tag 155 and an HTML end tag 156.
      <br/>
      The first word of the HTML element 153 is its HTML element name 154.
    </p>
    <p num="46">
      A web browser renders the HTML document according to a well-known process, and ordinarily does not display the HTML tags.
      <br/>
      For example, the HTML tag "&lt;B&gt;" denotes the beginning of boldface text.
      <br/>
      When a web browser encounters the "&lt;B&gt;" tag, it does not display it, but rather displays any text following it in boldface type until it encounters the "&lt;/B&gt;" end tag.
    </p>
    <p num="47">
      One particular HTML element has the HTML element name "FORM".
      <br/>
      An HTML document may have zero, one, or more such HTML elements.
      <br/>
      Inside the HTML element with the name "FORM" are additional HTML elements, known as HTML form elements.
      <br/>
      An exemplary HTML form element with form elements inside it follows:
    </p>
    <p num="48">
      &lt;FORM ACTION="http://a.b.c/xyz.cgi" METHOD="post"&gt;
      <br/>
      &lt;P&gt;
      <br/>
      Please enter a choice:
      <br/>
      &lt;INPUT TYPE="TEXT" MAXLENGTH="25" NAME="CHOICE"&gt;
      <br/>
      &lt;/P&gt;
      <br/>
      &lt;P&gt;
      <br/>
      &lt;INPUT TYPE="submit" NAME="OK"&gt;
      <br/>
      &lt;INPUT TYPE="reset"&gt;
      <br/>
      &lt;/P&gt;
      <br/>
      &lt;/FORM&gt;
    </p>
    <p num="49">
      Some of the form elements have an HTML element name of "INPUT" and an optional "TYPE" attribute keyword.
      <br/>
      If the "TYPE" attribute keyword is omitted, the form element defaults to a text box.
      <br/>
      If the "TYPE" attribute keyword specifies an attribute value of "radio," "checkbox," "submit," or "reset," the form element will appear as a graphical radio button, a check box, a submit push button, or a reset push button, respectively, when rendered.
      <br/>
      Some form elements, such as the "TEXTAREA" form element do not use the "TYPE" attribute keyword.
      <br/>
      The HTML language specification includes other form elements, and new ones may be added as HTML is extended or enhanced.
    </p>
    <p num="50">
      Each of the form elements may have additional attributes which are indicated by an HTML attribute keyword and an HTML attribute value.
      <br/>
      For example, a text box may have the attribute of MAXLENGTH with an attribute value of "25".
      <br/>
      HTML elements with the name "FORM" ordinarily contain the HTML form elements known as the "reset" and "submit" elements which are HTML elements with the element name of "INPUT" and a TYPE of either "reset" or "submit." When rendered, these elements typically appear as graphical push buttons and may be used to clear the form or send its contents according to a predetermined protocol (e.g. "submit" or "post"), which is indicated in the "FORM" element with the keyword "METHOD." These elements need not be rendered as push buttons, and can be, for example, an image or some other item.
    </p>
    <p num="51">
      When the HTML document is rendered for presentation to the user, the user can place information in the text boxes, select a radio button, or click on the "submit" graphical push button to submit the information placed the form.
      <br/>
      The "submit" button can also be an image map.
      <br/>
      An image map is essentially a "submit" button in the form of an image.
      <br/>
      When the image map is clicked (i.e., the user clicks a mouse button or some other device while a pointer is positioned over the image map), the associated form is submitted along with additional information concerning where (i.e., the x-y coordinates) within the image map the click occurred.
    </p>
    <p num="52">
      Numerous other HTML elements exist, such as the "MARQUEE" HTML element, which provides scrolling text, and the "VIDEO" HTML element which provides video.
      <br/>
      Some HTML elements may not require presentation in the document display area.
      <br/>
      For example, the "BGSOUND" HTML element provides a background sound (e.g., music that plays while the document is viewed) but need not be shown in the document display area.
      <br/>
      As discussed above, the number of HTML elements and their features continually grow as HTML is extended and enhanced.
    </p>
    <p num="53">Storage and Stream Overview</p>
    <p num="54">
      Data on a personal computer 20 may be arranged in many ways.
      <br/>
      One way of arranging data is by using a storage or stream.
      <br/>
      A storage is a data location that may itself contain data or refer to streams and/or other storages.
      <br/>
      Streams comprise data of any type and are not required to have a particular internal structure.
      <br/>
      Storages and streams are well known and may be arranged according to the OLE structured storage model.
      <br/>
      For a detailed description of storages and streams, see Inside OLE 2 by Kraig Brockschmidt, Microsoft Press, Redmond, Wash. 1994.
    </p>
    <p num="55">ActiveX Controls Overview</p>
    <p num="56">
      With reference to FIGS. 5, 11, 13, 15, and 18, the illustrated embodiment of the invention utilizes embeddable objects conforming to the ActiveX Controls specification of Microsoft Corporation.
      <br/>
      ActiveX controls conform with the component object model (COM) of Microsoft Corporation and are related to Microsoft's OLE standards.
      <br/>
      For a detailed discussion of COM, ActiveX and OLE, see Understanding ActiveX and OLE by David Chappell, Microsoft Press, Redmond, Wash. 1996. A brief overview of ActiveX controls and associated terminology is provided below before discussing the details of the illustrated embodiment.
      <br/>
      It will be appreciated that embeddable objects may follow other specifications such as the CORBA (Common Object Request Broker Architecture) specification of Object Management Group or be of other formats embeddable in a document editor's native document format.
    </p>
    <p num="57">
      ActiveX controls are programming objects conforming to Microsoft's COM specification.
      <br/>
      An object is an instance of a programmer-defined type referred to as a class, which exhibits the characteristics of data encapsulation, polymorphism and inheritance.
      <br/>
      Data encapsulation refers to the combining of data (also referred to as properties of an object) with methods that operate on the data (also referred to as member functions of an object) into a unitary software component (i.e., the object), such that the object hides its internal composition, structure and operation and exposes its functionality to client programs that utilize the object only through one or more interfaces.
      <br/>
      An interface of the object is a group of semantically related member functions of the object.
      <br/>
      In other words, the client programs do not access the object's data directly, but must instead call functions on the object's interfaces to operate on the data.
    </p>
    <p num="58">
      Polymorphism refers to the ability to view (i.e., interact with) two similar objects through a common interface, thereby eliminating the need to differentiate between two objects.
      <br/>
      Inheritance refers to the derivation of different classes of objects from a base class, where the derived classes inherit the properties and characteristics of the base class (such as the interfaces of the base class).
    </p>
    <p num="59">
      The COM specification defines binary standards for objects and their interfaces which facilitate the integration of software components.
      <br/>
      At FIG. 5, a typical object 170 is represented in the computer system 20 (FIG. 1) by an instance data structure 172, a virtual function table 174, and member functions 176-78.
      <br/>
      The instance data structure 172 contains a pointer 180 to the virtual function table 174 and the data 182.
      <br/>
      A pointer is a data value that holds the address of an item in memory.
      <br/>
      The data 182 can include the properties (or data members) 183 and 184.
      <br/>
      The virtual function table 174 contains the entries 186-88 for the member functions 176-78.
      <br/>
      Each of the entries 186-88 contains a reference to the code 176-78 that implements the corresponding member function.
    </p>
    <p num="60">
      The pointer 180, the virtual function table 174, and the member functions 176-78 implement an interface of the object 170.
      <br/>
      Client programs interact with the object 170 by obtaining a pointer (referred to as an interface pointer) to the pointer 180 of the virtual function table 174.
      <br/>
      The following code (in the C++ programming language) implements a call to member functions of an interface pointed to by pointer pInterface:
      <br/>
      pInterface-&gt;MemberFunction( . . . )
    </p>
    <p num="61">
      By convention, the interfaces of an object are illustrated graphically as a plug-in jack as shown for the IPersistHTML interface 406 at FIG. 11. Also, interfaces conventionally are given names beginning with a capital "I." Objects can include multiple interfaces which are implemented with one or more virtual function tables.
      <br/>
      The member function of an interface is denoted as "IInterfaceName::FunctionName."
    </p>
    <p num="62">
      The object 170 conforming to the COM specification exhibits data encapsulation by exposing its interfaces (semantic groupings of its member functions) to client programs.
      <br/>
      The client programs interact with the object 170 by calling the member functions 176-78 on a particular interface of the object, but do not directly manipulate the object's data.
      <br/>
      The object 170 also exhibits polymorphism and inheritance in that the object 170 can provide interfaces in common with a base class and other similar objects, so that client programs can interact with each of the objects in the same manner by calling member functions of the interface that the objects have in common.
    </p>
    <p num="63">
      ActiveX controls conform to the COM standard described above.
      <br/>
      The class of an ActiveX control is uniquely identified by a class identifier (CLSID).
      <br/>
      Certain interfaces to an ActiveX control, such as IPersistStreamInit are well known in the art and are described in more detail below.
      <br/>
      For a detailed discussion of various interfaces provided by various ActiveX controls, see Understanding ActiveX and OLE by David Chappell, Microsoft Press, Redmond, Wash. 1996.
    </p>
    <p num="64">
      Part of the ActiveX Controls specification requires that the ActiveX control be able to associate a particular one of its properties with a dispatch identifier (DISPID).
      <br/>
      Thus, the DISPID can serve as a property identifier.
      <br/>
      The dispatch identifier is an integer value and can be used in conjunction with a particular interface called IDispatch to set or read the properties of an ActiveX control.
      <br/>
      One of the methods (or member functions) provided by IDispatch is called Invoke.
      <br/>
      The IDispatch::Invoke method itself includes methods arranged in a dispinterface.
      <br/>
      Given an integer value, the dispinterface invokes one of the methods of the dispinterface, and passes any provided parameters to the method.
      <br/>
      Commonly, these methods of the dispinterface are operable to set or read the properties of ActiveX control.
      <br/>
      Thus, the Invoke method can be used to set or read a property of an ActiveX control if provided with the following: the DISPID that identifies the particular property to be set or read (which is used to determine the associated property-setting or property-reading method), whether the property is to be set or read, and a value for setting or a location for reading the property.
      <br/>
      In this way, properties of an ActiveX control can be set or read with reference to the DISPID associated with a particular property.
    </p>
    <p num="65">
      The IPersistStreamInit interface provides a means for an object to persist itself.
      <br/>
      An object may be in any number of possible states at a given time.
      <br/>
      For instance, the properties may be set to particular values (e.g., a graphical push button may have its "name" property set to "OK").
      <br/>
      Persisting an object means producing and storing whatever state data is required for the object to restore its present state at some subsequent time.
      <br/>
      Later, the object "depersists" (e.g. acquires its state data) by accessing the state data to restore the previous state.
      <br/>
      The state data is typically of some format not compatible with HTML.
    </p>
    <p num="66">
      Accordingly, the IPersistStreamInit interface provides two methods, IPersistStreamInit::Save and IPersistStreamInit::Load.
      <br/>
      IPersistStreamInit::Save generates a stream (the persisted state of the object).
      <br/>
      If this stream is provided to IPersistStreamInit::Load, the object is restored to its present state.
      <br/>
      Another interface, IPersistStorage, operates in a similar manner but uses a storage instead of a stream.
    </p>
    <p num="67">
      Part of the ActiveX specification provides for embedding an ActiveX control within another object.
      <br/>
      The object in which the ActiveX control is embedded is called a control container.
      <br/>
      The application that can manipulate the ActiveX control embedded in a control container is sometimes called an ActiveX control host.
      <br/>
      Example ActiveX control hosts are Microsoft Visual Basic, the Internet Explorer, and Microsoft Word 97 of Microsoft Corporation.
      <br/>
      Applications typically implement their documents as objects, so in an arrangement in which an ActiveX control is embedded in a document editor's document involves an object (the ActiveX control) contained by another object (the control container or document), both of which can be manipulated by the host (the document editor).
    </p>
    <p num="68">
      Embedding is achieved through a particular set of interfaces of the control container and the embedded object.
      <br/>
      These interfaces provide a way for the control container and the embedded object to communicate about such details as when the embedded object should display itself or be redrawn.
      <br/>
      For further details concerning embedding, see Understanding ActiveX and OLE by David Chappell, Microsoft Press, Redmond, Wash. 1996.
    </p>
    <p num="69">It will be appreciated that a wide variety of embeddable ActiveX controls such as text boxes, graphical push buttons, background sounds and scrolling texts exist, and additional ones can be created.</p>
    <p num="70">Microsoft Word 97 Overview</p>
    <p num="71">
      Microsoft Word 97 is a document editor offering a word processing environment with a rich set of features including WYSIWYG editing, spell checking, and an extensive on-line help facility.
      <br/>
      Microsoft Word 97 can create, edit, and save documents as well as copy, cut, and paste items into and out of Microsoft Word 97.
      <br/>
      Microsoft Word 97 can host an ActiveX control and its native documents can serve as ActiveX control containers that support embedding of ActiveX controls.
      <br/>
      Further, an embedded ActiveX control and its properties can be manipulated within Microsoft Word 97.
    </p>
    <p num="72">RTF Overview</p>
    <p num="73">
      Rich Text Format (RTF) is one of the document formats Microsoft Word 97 can convert into its native format.
      <br/>
      RTF is a well-known format used to represent formatted text and includes mechanisms for marking text as bold and italic.
      <br/>
      RTF supports many features such as color tables, style sheets, hidden text, storage of document statistics, and others.
      <br/>
      RTF also has provisions for placing objects such as ActiveX controls into an RTF stream.
      <br/>
      RTF is a plain text format that is ordinarily presented to a user in rendered form.
    </p>
    <p num="74">
      Certain HTML tags are readily translated into RTF.
      <br/>
      For example, the HTML tag "&lt;B&gt;" is associated with bold text, and the HTML tag "&lt;BR&gt;" indicates a line break.
      <br/>
      Each of these have a corresponding RTF translation.
    </p>
    <p num="75">Since Word can convert RTF into its own internal format, Microsoft Word 97 can be used to convert an RTF document, view the document, and edit it in Microsoft Word 97's feature-rich environment, including WYSIWYG editing, spell checking, and an extensive on-line help facility.</p>
    <p num="76">Overview of HTML Document to Microsoft Word 97 Native Format Document Conversion Process</p>
    <p num="77">
      A flowchart illustrating an overview of the HTML document to Microsoft Word 97 native format conversion process is shown at FIG. 6.
      <br/>
      At step 192, the HTML document is converted to an RTF stream.
      <br/>
      Then, at step 194, the RTF stream is converted to a document (e.g., a document in Microsoft Word 97 native format).
      <br/>
      Finally, at step 196, the document is displayed.
      <br/>
      One of the features of the invention is that the logic pertaining to step 192 does not have to include logic to instantiate and set the properties of objects.
      <br/>
      In this way, the HTML to RTF converter logic can be smaller, and the same converter logic can be used to process HTML documents containing new extensions or enhancements.
      <br/>
      Although the illustrated embodiment first converts the document to RTF, conversion to some other intermediate format, directly to Microsoft Word 97's native format, or directly to any number of other formats could be achieved.
    </p>
    <p num="78">
      An HTML to RTF converter is illustrated at FIG. 7.
      <br/>
      Converter controller 212 controls the conversion process.
      <br/>
      The HTML document 210 is a file comprising HTML tags.
      <br/>
      The HTML document 210 may reside as a file of a file system stored in the hard drive 27 (FIG. 1) or other secondary storage of a personal computer 20, or reside as resources at a remote computer 58 (FIG. 2) connected to the computer network 57, such as a world-wide web site on the Internet or an intranet.
      <br/>
      The flags 216, a CLSID 220, and an HTML stream 218 are shown as inside a storage 214; however, it will be appreciated that in FIG. 7 and the other figures, a storage may be internally represented as pointers to the items.
      <br/>
      The RTF stream 222 is a location into which text in Rich Text Format corresponding to the HTML document 210 is written.
    </p>
    <p num="79">
      The Structured Language Element-to-Embeddable Object Class Association Table 224 associates an HTML tag component 226 with a particular class identifier 234.
      <br/>
      The Table 224 is described in more detail below.
      <br/>
      A temporary location 202 is used to temporarily store portions of the HTML document 210.
    </p>
    <p num="80">
      One way to start the conversion process is to open the HTML Document 210 with the Microsoft Word 97 application.
      <br/>
      Microsoft Word 97 provides a familiar means of opening a document with the "File, Open . . . " command available from the Microsoft Word 97 menu bar.
      <br/>
      The user selects the HTML document 210, and Microsoft Word 97 proceeds according to the HTML to RTF conversion method illustrated at FIG. 8.
    </p>
    <p num="81">
      At step 252, the HTML document 210 is examined to determine if it contains HTML.
      <br/>
      A common method for making such a determination is examining the HTML document 210 for the HTML indicator "&lt;HTML&gt;".
      <br/>
      If "&lt;HTML&gt;" is present, the conversion process continues by opening the Rich Text Format (RTF) stream 222.
      <br/>
      If there is no "&lt;HTML&gt;", the HTML document 210 is opened according to some non-HTML procedure.
      <br/>
      It will be recognized that other methods for determining if the HTML document 210 contains HTML may be used, such as detecting any HTML tag within the document or detecting a particular filename extension (e.g., ".html" or ".htm").
    </p>
    <p num="82">
      At step 254, the HTML document 210 is parsed according to familiar parsing procedures so that a next portion of the document is contained in the temporary location 202.
      <br/>
      For instance, if the next portion of the HTML document 210 contains an HTML tag, the tag is placed in the temporary location 202.
      <br/>
      If, instead, the next portion of the HTML document 210 contains plain text that is not an HTML tag, the plain text is placed into the temporary location 202.
      <br/>
      In special cases an entire HTML element is required for conversion.
      <br/>
      In such a case, if a particular HTML begin tag is detected, the HTML begin tag, the text following the tag (if any), and the HTML end tag are placed into the temporary location 202.
      <br/>
      For example, the HTML tag name "TEXTAREA" indicates the begin tag of an HTML "TEXTAREA" form element.
      <br/>
      If such an HTML tag is encountered, additional information is read from the HTML document 210 into the temporary location 202 until an HTML "&lt;/TEXTAREA&gt;" end tag is encountered.
      <br/>
      The special cases are indicated within the parsing logic.
      <br/>
      It will be appreciated that the parsing process may take many forms, such as using index pointers to the document denoting the begin and end locations of the respective portion of the document instead of copying the next portion to a separate location.
    </p>
    <p num="83">
      Next, the contents of the temporary location 202 are examined.
      <br/>
      First, at step 256, the temporary location 202 is examined to determine if it contains an HTML "FORM" tag (i.e., an HTML tag with a tag name of "FORM").
      <br/>
      If so, the beginning of a form is indicated.
      <br/>
      At step 258, a top of form break is inserted into the RTF stream 222 as the text phrase "Top of FormF" (where F is the number of the current form in the document, starting with 1) formatted with a special paragraph style "z-Top of Form".
      <br/>
      Special allowance is made for storing information contained in the "FORM" tag relating to the submission of the form so that it can be retrieved later when creating an associated "INPUT" HTML element for submitting the form, as described below.
      <br/>
      Certain error checking is included at this point to detect if a Microsoft Word 97 form is begun while another Microsoft Word 97 form has already begun and not ended.
    </p>
    <p num="84">
      Second, at step 260, the temporary location 202 is examined to determine if it contains an HTML "&lt;/FORM&gt;" tag, which denotes the end of an HTML form.
      <br/>
      If the "&lt;/FORM&gt;" tag is present, a bottom of form break is written into the RTF stream 222 at step 262.
      <br/>
      The bottom of form break is inserted into the RTF stream 222 as the text phrase "Bottom of FormF" (where F is the number of the current form in the document) formatted with a special paragraph style "z-Bottom of Form".
      <br/>
      Certain error checking is included at this point to detect if there is no Microsoft Word 97 form that has been begun and not ended.
      <br/>
      It will be appreciated that the top and bottom of form breaks could be denoted in any number of ways, such as by placing a set of special characters into the RTF stream 222.
    </p>
    <p num="85">
      Third, at step 264, the method uses the Structured Language Element-Embeddable Object Class Association Table 224, described below, to determine an appropriate CLSID 220.
      <br/>
      If Table 224 indicates an appropriate class identifier 234 or 236, the temporary location 202 relates to an object (e.g., an ActiveX control for representing a text box, a graphical push button, or scrolling text).
      <br/>
      Then, a persisted state of an object is created in the storage 214 at step 266.
      <br/>
      The persisted state is created by creating a storage 214, placing the class identifier 234 or 236 indicated by the Table 224 into the CLSID 220, placing the text contained in the temporary location 202 in the HTML stream 218, and marking the storage as HTML by setting the flags 216.
      <br/>
      It will be appreciated that the determination of whether to convert the temporary location 202 to an object could alternatively be made by examining some other data structure such as a list of structured language tag components.
      <br/>
      Then, at step 270, the storage 214 is converted to a stream using the well known OleConvertIStorageToOLESTREAM function and passed to the RTF stream 222.
      <br/>
      Preferably, a special RTF tag is used to denote that the stream relates to HTML when it is passed to the RTF stream 222.
    </p>
    <p num="86">
      If no class identifier 234 or 236 is determined at step 264, the temporary location 202 is converted to Rich Text Format (RTF) at step 268 according to familiar methods and placed into the RTF stream 222.
      <br/>
      If any additional information from the HTML document 210 is required to complete the conversion to RTF, it is read from the HTML document 210.
      <br/>
      If the conversion to RTF cannot be made, the HTML is ignored.
    </p>
    <p num="87">
      At step 272, the method checks for an EOF condition to determine if the end of the HTML document 210 has been reached.
      <br/>
      If so, the HTML document 210 is closed, the RTF stream 222 is ended, and the method ends.
      <br/>
      Otherwise, the next portion of the HTML document 210 is parsed in a further iteration of steps 252-270.
      <br/>
      The conversion process also handles certain additional details of parsing HTML, such as the well known specialized "&lt;HEAD&gt;" and "&lt;BODY&gt;" tags.
      <br/>
      Additional details of the conversion process are described below.
    </p>
    <p num="88">Structured Language Element-to-Embeddable Object Class Association Table</p>
    <p num="89">
      In order to facilitate the HTML element to embeddable object conversion process, the converter uses a Structured Language Element-to-Embeddable Object Class Association Table 224 illustrated at FIG. 7.
      <br/>
      An entry 226 in the Table 224 associates an HTML tag component 226 with an object class identifier (CLSID) 234. For example, if the temporary location 202 comprises the tag component "MARQUEE", the Table 224 is consulted for the tag component "MARQUEE" and an entry 226 is found indicating a class identifier 234 of CLSID_ScrollingText.
      <br/>
      The class identifier 234 of an object providing marquee functionality (an ActiveX control providing scrolling text) is stored in the CLSID 220.
      <br/>
      The Structured Language Element-to-Embeddable Object Class Association Table 224 is implemented as two parallel arrays, one comprising HTML tag components, the other comprising class identifier information.
      <br/>
      When an index to the one array indicates a certain tag component, the same index to the other array indicates the associated class identifier.
    </p>
    <p num="90">
      With respect to step 264, above, one of the HTML tag components 204, 206, or 208 is selected, then the Table 224 is searched for the selected tag component.
      <br/>
      In some cases, an HTML tag component 204, 206, or 208 may indicate a default value (e.g., the HTML tag component "INPUT" defaults to a TYPE of "TEXT."), in which case the table is searched for the default if no HTML tag component indicates otherwise.
      <br/>
      The Table 224 is searched by matching the selected tag component 204, 206, or 208 with the HTML tag components 230 or 232.
      <br/>
      If an entry 228 with a match 230 is found, the associated class identifier 236 indicates the class identifier to be stored in the CLSID 220.
    </p>
    <p num="91">Converting an RTF Stream to a Microsoft Word 97 Document</p>
    <p num="92">
      After the HTML document 210 has been converted to the RTF stream 222, the RTF stream 222 is converted to a document (e.g. a Microsoft Word 97 native format document).
      <br/>
      FIG. 9 is a block diagram showing a document editor controller 306 (e.g. Microsoft Word 97), an RTF stream 304, and a document 318.
      <br/>
      The document 318 may reside as a file of a file system stored in the hard drive 27 (FIG. 1) or other secondary storage of a personal computer 20, or it may be located in the RAM 25 of the system memory 22.
      <br/>
      A method for converting the RTF stream 304 to the document 318 is illustrated at FIG. 10.
    </p>
    <p num="93">
      At step 352, the next portion of the RTF stream 304 is parsed according to familiar methods into the temporary location 302.
      <br/>
      At step 354, it is determined if the temporary location 302 is to be converted to a storage by detecting a special RTF tag in the temporary location 302.
      <br/>
      At step 356, a storage 308 is created, and the contents of the temporary location 302 are used to determine the flags 310, the CLSID 312, and the HTML stream 314.
      <br/>
      The CLSID 312 and the HTML stream 314 are related to the CLSID 220 and the HTML stream 218 of FIG. 7.
      <br/>
      A link 316 between the document 318 and the storage 308 is kept so that it can be determined where within the document 318 the storage 308 resides.
    </p>
    <p num="94">If at step 354, it is determined that the temporary location 302 is not to be converted to a storage, at step 358, the temporary location 302 is converted to the format of document 318 (e.g. Microsoft Word 97 native format) according to familiar methods and passed to the document 318.</p>
    <p num="95">
      At step 360, it is determined if the end of the RTF stream 304 has been reached.
      <br/>
      If so, the method ends, otherwise the RTF stream 304 is parsed in a further iteration of steps 352-358.
      <br/>
      After the RTF stream 304 is converted to the document 318, the document 318 is displayed as described below.
    </p>
    <p num="96">Preparing the Document for Display</p>
    <p num="97">
      At FIG. 11, a document 402 (e.g. a Microsoft Word 97 document) is displayed by a document editor controller 404 (e.g. Microsoft Word 97).
      <br/>
      The process for displaying the document 402 is well known.
      <br/>
      Commonly, the entire document 402 is not displayed at once.
      <br/>
      Instead, a certain portion of it is rendered for presentation to the user.
      <br/>
      As part of the display process, a facility is implemented to indicate when a particular item is to be presented to the user.
      <br/>
      When the facility indicates that an item relating to a storage 412 or 416 has come into view for presentation to the user, the following method for presenting the storage to the user is used if the flags 418 indicate that the storage 416 relates to HTML.
      <br/>
      The method is shown at FIG. 12.
    </p>
    <p num="98">
      At step 454, an object 408 is instantiated using the CLSID 422.
      <br/>
      At step 456, a link 424 to the object 408 is placed in the document 402 to indicate where within the document 402 the object 408 resides.
      <br/>
      Then, at step 458, the HTML stream 420 is passed to the object 408 using the LoadHTML member function of the IPersistHTML interface 406 (IPersistHTML::LoadHTML) which stores the HTML stream 420 in the HTML stream 414.
      <br/>
      The details of IPersistHTML::LoadHTML are described below.
    </p>
    <p num="99">Using the HTML Stream with IPersistHTML::LoadHTML</p>
    <p num="100">With reference to FIG. 13, after the HTML stream 520 has been passed to the object 504 using the LoadHTML member function of the IPersistHTML interface 502, a property 506 of the object 504 may need to be set to a value such as 512.</p>
    <p num="101">
      Although not required, preferably, the object 504 uses a software routine that can assist during the property setting process.
      <br/>
      The object 504 passes the HTML stream 520 and a Structured Language Attribute-to-Embeddable Object Association Table 530 to a property setting software routine 516 called LoadPropertiesFromHTMLStream.
      <br/>
      Preferably, the Structured Language Attribute-to-Embeddable Object Association Table is defined as part of the class of objects identified by the CLSID 422 (FIG. 11) used to instantiate the object 504.
    </p>
    <p num="102">
      LoadPropertiesFromHTMLStream parses the HTML stream 520 and uses the Structured Language Attribute-to-Embeddable Object Property Association Table 530 to set the properties 508 and 506 of the object 504.
      <br/>
      The Structured Language Attribute-to-Embeddable Object Property Association Table 530 contains entries for use during the property setting process.
      <br/>
      Each entry 532 or 534 in Table 530 contains an HTML attribute keyword 536 and a corresponding object property identifier (e.g. an ActiveX control dispatch identifier or DISPID) 538.
    </p>
    <p num="103">
      The Structured Language Attribute-to-Embeddable Object Property Association Table 530 is implemented as an array of HTML_ATTR_DESC structs.
      <br/>
      HTML_ATTR_DESC is defined as follows:
    </p>
    <p num="104">
      --
      <br/>
      -- struct HTML_ATTR_DESC
      <br/>
      -- +
      <br/>
      --        DISPID      dispid;            // dispid of corresponding property.
      <br/>
      --        LPTSTR      pszName;           // Name of Attribute.
      <br/>
      --        VARTYPE     vt;                // variant type of the property.
      <br/>
      --        long        lValueImplied;
      <br/>
      --                    // If not null, the implied value if name but no
      <br/>
      --                    // value.
      <br/>
      So, if an attribute is present, but does not
      <br/>
      --                    // contain a declared value, this will be used.
      <br/>
      --        BOOL        fImpliedBool;
      <br/>
      --                    // Presence of this attribute implies True
      <br/>
      --                    // but the property does not have a value,
      <br/>
      --                    // e.g., the MULTIPLE property of the
      <br/>
      --                    // SELECT tag.
      <br/>
      Absence implies False.
      <br/>
      -- };
    </p>
    <p num="105">
      The members of the struct can be used to track special cases, such as the "CHECKED" attribute which defaults to a value of "TRUE." Arrays and structs are well known data structures available in the C and C++ languages.
      <br/>
      An example table 530 for a text box (i.e., an HTML "INPUT" element with a type of "TEXT") follows:
    </p>
    <p num="106">
      --
      <br/>
      -- //   This is an example
      <br/>
      -- //   for a text box.
      <br/>
      It also works for a "password" HTML element.
      <br/>
      -- HTML_ATTR_DESC s_TextHTMLProps =
      <br/>
      -- +
      <br/>
      --      + DISPID_WHTMLType,         TEXT("TYPE"), VT_BSTR,    0,   FALSE   },
      <br/>
      --      + DISPID_WHTMLMaxLength,    TEXT("MAXLENGTH"), VT_I4,      0,   FALSE
      <br/>
      --   },
      <br/>
      --      + DISPID_WHTMLWidth,        TEXT("WIDTH"), VT_I4,      0,   FALSE   },
      <br/>
      --      + DISPID_GROUPNAME,         TEXT("NAME"), VT_BSTR,    0,   FALSE   },
      <br/>
      --      + DISPID_VALUE,             TEXT("VALUE"), VT_BSTR,    0,   FALSE   }
      <br/>
      -- };
    </p>
    <p num="107">
      It is contemplated that as new objects are written by software developers, the new objects may use LoadPropertiesFromHTMLStream during the property setting process by providing a Structured Language Attribute-to-Embeddable Object Property Association Table 530 to facilitate conversion between HTML and a new object developed by the developer.
      <br/>
      In this way, the new object avoids having to duplicate the functionality of LoadPropertiesFromHTMLStream, and the logic in the control can be smaller.
      <br/>
      The object is not required to use LoadPropertiesFromHTMLStream.
      <br/>
      Also, it will be appreciated that the properties 506 and 508 of the object 504 may be set in any number of other ways such as by another program or another object.
    </p>
    <p num="108">LoadPropertiesFromHTMLStream is defined as follows:</p>
    <p num="109">
      --
      <br/>
      -- // Parse a string containing HTML attributes and set
      <br/>
      -- //            corresponding properties of punkObject.
      <br/>
      -- // Attributes that are not recognized are returned, unmodified,
      <br/>
      -- //            in bstrNotRecognized.
      <br/>
      -- HRESULT LoadPropertiesFromHTMLStream (
      <br/>
      --               IUnknown * punkObject,
      <br/>
      --               IStream * pStream,
      <br/>
      --               LONG    cAttributes,
      <br/>
      --               HTML_ATTR_DESC * ahtmlattrAttribute,
      <br/>
      --               BSTR * bstrNotRecognized );
    </p>
    <p num="110">
      LoadPropertiesFromHTMLStream operates according to the following method illustrated at FIG. 14 with reference to FIG. 13. The HTML stream 520 is the stream of HTML associated with the object 504 and is used to set the properties 506 and 508.
      <br/>
      Typically, only a certain portion of the HTML stream 520 is provided to LoadPropertiesFromHTMLStream.
      <br/>
      The HTML element name or other HTML tag components may be omitted.
      <br/>
      At 552, parsing is performed on the certain portion of the HTML stream 520 which results in an HTML attribute keyword 526 and HTML attribute value 528 stored in the temporary location 524.
      <br/>
      At step 554, the Table 530 is searched for the HTML attribute keyword 526.
      <br/>
      If there is an entry 534 in the Table 530 with an HTML attribute keyword 536 that matches the HTML attribute keyword 526, the table indicates how to process the temporary location 524.
      <br/>
      At step 560, the associated DISPID 538 of the entry 534 is used to set a property 506 of the object 504 to a value 512 by using the value 528.
      <br/>
      Preferably, the value 512 of the property 506 is set using a call to the Invoke member function of the interface IDispatch 514 (IDispatch::Invoke).
      <br/>
      The call to IDispatch::Invoke specifies the DISPID 538 relating to the property 506, the value 528, and that the value 512 is to be set.
      <br/>
      At step 562, a bit of the found bitmap 518 is set, indicating that the property 506 was set.
      <br/>
      If the Table 530 fails to indicate how to process the temporary location 524, the keyword 526 and the value 528 are preserved at step 558 in the HTML not recognized 522, which the object 504 preferably retains for later retrieval.
    </p>
    <p num="111">
      LoadPropertiesFromHTMLStream operates to properly manipulate any necessary tag delimiters and associations between HTML attributes keywords and their corresponding HTML attribute values.
      <br/>
      For example, the HTML "INPUT" element of type "RADIO" relating to a radio button presents a special case because the HTML attribute keyword ("CHECKED") does not have a related HTML attribute value (it implicitly has an attribute value of "TRUE").
      <br/>
      Also, an HTML "INPUT" element defaults to a type of "TEXT."
    </p>
    <p num="112">
      Special provisions are made for setting the properties of an ActiveX control relating to an HTML "INPUT" element of type submit or image.
      <br/>
      Certain information related to the submission of the form is gathered from a location where it was stored previously during the processing of an HTML "FORM" element, as described above.
    </p>
    <p num="113">
      At step 564, it is determined if the end of the HTML stream 520 has been reached.
      <br/>
      If so, the method ends.
      <br/>
      Otherwise, the next portion of the HTML stream 520 is parsed in a further iteration of steps 552-562.
    </p>
    <p num="114">
      After the properties have been set, the flags 510 are set to indicate that the object 504 relates to HTML and that no changes have been made to it.
      <br/>
      Various other properties of the object 504 may be set as needed by the document editor.
      <br/>
      For example, the object may have a name assigned to it by the document editor.
      <br/>
      This name is assigned in addition to the HTML name as determined during the property setting process described above.
      <br/>
      The object 504 then has the information it needs to present itself to the user.
    </p>
    <p num="115">Editing the Document</p>
    <p num="116">
      When the document editor controller 404 (FIG. 11) displays the document 402, the user is presented with the option of toggling between a form edit mode and a run mode.
      <br/>
      During form edit mode, the user may make examine or alter the properties of objects embedded in the document.
      <br/>
      A change to an object may result in storing a value in its associated flags 510 and the found bitmap 518 to indicate that it has been changed.
      <br/>
      Similarly, a newly created object may have its flags 510 and found bitmap 518 set accordingly.
      <br/>
      During run mode, the objects may be operated by the user to perform their functions.
    </p>
    <p num="117">
      For example, during form edit mode, the user may change the appearance or position of the reset push button.
      <br/>
      During run mode, the user may click on the reset push button to clear the values in the form associated with it.
    </p>
    <p num="118">
      An object in a form may need to determine what other objects are located within the same form.
      <br/>
      For instance, when the user selects one of a set of related radio buttons or clicks on the submit or reset button, information relating to other objects in the form must be retrieved or altered.
      <br/>
      For example, when the user clicks on a "reset" button, the values in the objects associated within the same form breaks are cleared.
      <br/>
      Preferably, a function within the document editor searches the document to determine what other objects are located within the same form as a particular object.
    </p>
    <p num="119">
      Finally, after the HTML document has been converted to the format of the document, the user may save the document (e.g., by using the "File, Save As . . . " command from the Microsoft Word 97 menu bar and specifying native format of Microsoft Word 97, also known as "normal" format).
      <br/>
      The document editor then writes the document to a location specified by the user using the document editor's native format.
    </p>
    <p num="120">
      Microsoft Word 97 presents other ways for converting documents from HTML to the native format of Microsoft Word 97.
      <br/>
      For example, the user may create a new HTML document by using the "File, New . . . " command from the menu bar and specifying a document type of HTML.
      <br/>
      After entering HTML text into the document, the user may then save the document in Microsoft Word 97 format (i.e., by using the "File, Save As . . . " command of Microsoft Word 97).
      <br/>
      As another example, the user may choose "View, HTML Source" from the menu bar, and enter HTML text into the HTML source window.
      <br/>
      When the user switches from the HTML source, the HTML source is converted into Microsoft Word 97 native format.
      <br/>
      The user may subsequently save the document in Microsoft Word 97's native format.
      <br/>
      These methods use the above steps to convert the HTML source to an RTF stream and then to associated objects if required.
    </p>
    <p num="121">
      If an object relates to a form, its class identifier (CLSID) preferably denotes one of the ActiveX controls that are part of Forms3, a set of ActiveX controls provided by Microsoft Corporation.
      <br/>
      However, HTML elements other than form elements may be converted to ActiveX controls.
      <br/>
      For instance, an HTML element indicating a background sound or scrolling text (i.e. "MARQUEE") may be converted to an equivalent ActiveX control.
    </p>
    <p num="122">
      If the C++ programming language is used to represent an ActiveX control, it may be advantageous to use fewer C++ classes than ActiveX control classes.
      <br/>
      This arrangement avoids having a separate virtual function table for each ActiveX control and is accomplished by using a single C++ class to represent more than one object while changing a property of the class (e.g. a "style" property).
      <br/>
      This arrangement is also known as aggregating classes.
    </p>
    <p num="123">Overview of Document Native Format to HTML Document Conversion Process</p>
    <p num="124">
      Microsoft Word 97 can convert a Microsoft Word 97 document to an HTML document by performing the methods described below.
      <br/>
      For example, the user may select the "Save As HTML . . . " command from the menu bar, and the current document is saved as an HTML document.
      <br/>
      The current document may be a newly created document, a document that has converted according to the methods described above, or a document resulting from some other method.
    </p>
    <p num="125">
      The document to HTML document conversion process is illustrated at FIGS. 15 and 16. A document 602 is converted into an HTML document 614.
      <br/>
      At step 652, an HTML indicator "&lt;HTML&gt;" is written to the HTML document 614.
      <br/>
      The conversion process then continues at 654 by parsing the next item in the document 602.
      <br/>
      At step 656, if the item is determined to be a top of form break, an HTML "FORM" tag is written to the HTML document 614 at step 658.
      <br/>
      Certain information concerning the "FORM" tag is gathered from the object corresponding to a submit button or image associated with the top of form break.
      <br/>
      At step 660, if the item is determined to be a bottom of form break, an HTML "/FORM" tag is written to the HTML document 614 at step 662.
    </p>
    <p num="126">
      At step 664, if the item is an object 606, the flags 610 are examined to determine if it is to be converted to HTML.
      <br/>
      If so, the object 606 is converted to HTML and written to the HTML document 614 at step 666 using the SaveHTML member function of the IPersistHTML interface 608 (IPersistHTML::SaveHTML).
      <br/>
      Details concerning step 666 are described below.
      <br/>
      If the item is a storage representing an uninstantiated object, the HTML can be read out of the HTML stream in the storage and written to the HTML document 614 without instantiating an object.
    </p>
    <p num="127">
      Otherwise, at step 668, the item is translated to HTML according to well known methods.
      <br/>
      For example, the Microsoft Word 97 representation of boldface text is converted to the associated HTML tags denoting boldface text ("&lt;B&gt;" and "&lt;/B&gt;").
    </p>
    <p num="128">
      At step 670, it is determined if the end of the document 602 has been reached.
      <br/>
      If so, the end HTML indicator "&lt;/HTML&gt;" is written to the HTML document 614 and the method ends.
      <br/>
      Otherwise, the document 602 is parsed in a further iteration of steps 654-668.
    </p>
    <p num="129">
      The conversion process also handles certain additional details of generating HTML, such as the well known specialized "&lt;HEAD&gt;" and "&lt;BODY&gt;" tags.
      <br/>
      Further, the conversion process writes certain identifying information to the HTML document 614.
      <br/>
      Many other types of information relating to a variety of HTML tags may be placed in the HTML document 614 as part of the conversion process.
    </p>
    <p num="130">
      Microsoft Word 97 offers other methods for converting from Microsoft Word 97 native format to HTML.
      <br/>
      For instance, the user may select "View, HTML Source" from the menu bar to see the HTML source equivalent of the present document.
      <br/>
      This method uses the above steps, but presents the HTML to the user in a graphical window instead of writing it to an HTML document 614.
    </p>
    <p num="131">Converting an Object Into an HTML Element with IPersistHTML::SaveHTML</p>
    <p num="132">
      Step 666 of the above method performs the following method illustrated by the flowchart at FIG. 17 to convert an object 606 (FIG. 15) to a stream of HTML which is written to the HTML document 614.
      <br/>
      The method is implemented as a member function SaveHTML of the IPersistHTML interface 608 (IPersistHTML::SaveHTML).
    </p>
    <p num="133">
      At step 702, the HTML stream 612 is checked to see if it is empty, and the flags 610 are checked to see if they indicate that changes have been made to the object 606.
      <br/>
      If either condition is true, the method uses a stream of HTML generated from the object 606 at step 704 Otherwise, the method uses the HTML stream 612 from the object 606.
      <br/>
      Using the HTML stream 612 facilitates the conversion process because no additional conversion logic is required.
    </p>
    <p num="134">Generating a Stream of HTML from the Object</p>
    <p num="135">
      Step 704 includes logic further illustrated at FIGS. 18 and 19. The object 754 is converted to a stream of HTML which is then provided by the IPersistHTML interface 752.
      <br/>
      Although it is not required, the object 754 preferably uses a property reading software routine 778, SavePropertiesToHTMLStream, to assist in producing the stream of HTML.
      <br/>
      For example, an ActiveX control relating to scrolling text may first produce the initial part of the stream of HTML, (e.g., &lt;MARQUEE ), call SavePropertiesToHTMLStream to produce another part of the stream of HTML, (e.g., BEHAVIOR="ALTERNATE" WIDTH="764" HEIGHT="27" GIBBER="important"), and then produce the final part (e.g., &gt;Sample Text&lt;/MARQUEE&gt;), resulting in the following stream of HTML:
    </p>
    <p num="136">&lt;MARQUEE BEHAVIOR="ALTERNATE" WIDTH="764" HEIGHT="27" GIBBER="important"&gt;Sample Text&lt;/MARQUEE&gt;</p>
    <p num="137">The property reading software routine 778 SavePropertiesToHTMLStream is defined as follows:</p>
    <p num="138">
      --
      <br/>
      -- // Get properties of punkObject, convert to an HTML attribute format, save
      <br/>
      --  those
      <br/>
      -- // properties plus bstrNotRecognized to the stream.
      <br/>
      -- // Only properties whose corresponding bit is set in dwFound are written.
      <br/>
      -- // (if bit i is set, that means that the attribute described by
      <br/>
      -- //            ahtmlattrAttribute i  is saved.)
      <br/>
      -- HRESULT SavePropertiesToHTMLStream (
      <br/>
      --               IUnknown * punkObject,
      <br/>
      --               IStream * pStream,
      <br/>
      --               LONG    cAttributes,
      <br/>
      --               HTML_ATTR_DESC * ahtmlattrAttribute,
      <br/>
      --               DMORD * dwFound,
      <br/>
      --               BSTR   bstrNotRecognized );
    </p>
    <p num="139">
      SavePropertiesToHTMLStream uses a Structured Language Attribute-to-Embeddable Object Property Association Table 780.
      <br/>
      Preferably, this is the same Table 530 (FIG. 13) than can be used with the LoadPropertiesFromHTMLStream property setting software routine 516 described above.
      <br/>
      The method performed by SavePropertiesToHTMLStream is illustrated at FIG. 19. The method starts at the first entry 782 and proceeds to the last entry 784 in the Table 780.
    </p>
    <p num="140">
      At step 804, if the found bitmap 764 indicates that the value of the object property identified by the DISPID 788 is to written to the stream of HTML provided by IPersistHTML::SaveHTML, the method proceeds to step 806.
      <br/>
      At step 806, the HTML attribute keyword 786 and the value 762 of the property 756 identified by the DISPID 788 are written to the stream of HTML provided by the IPersistHTML interface 752.
      <br/>
      Preferably, the value 762 of the property 756 is read from the object 754 by using a call to the Invoke member function of the interface IDispatch 776 (IDispatch::Invoke) that specifies the DISPID 788 relating to the property 756, and that the value 762 is to be read.
    </p>
    <p num="141">
      Ordinarily, the HTML attribute keyword 786 is followed by a "=" character, and then a text representation of the value 762 of the property 756 in quotations follows, for example:
      <br/>
      MAXLENGTH="25"
    </p>
    <p num="142">
      If it is determined at step 808 that there are no more entries in the table, the HTML not recognized 768 is provided by IPersistHTML::SaveHTML (for the HTML document 614), and the method ends.
      <br/>
      Otherwise, the next entry in the Table 780 is considered in a further iteration of steps 804-806.
    </p>
    <p num="143">
      The process operates to properly handle special cases such as the radio button, described above.
      <br/>
      The process also ensures that HTML tag delimiters are written into appropriate locations in the stream of HTML provided by the IPersistHTML interface 752.
      <br/>
      The details of writing the properties may be varied.
      <br/>
      For example, quotations around the text representation of the value 762 (e.g., "25") may be omitted.
    </p>
    <p num="144">
      Microsoft Word 97 can convert ActiveX controls other than those corresponding to HTML form elements into HTML.
      <br/>
      For example, an ActiveX control representing scrolling text can be converted into an HTML "MARQUEE" element.
      <br/>
      Similarly, Microsoft Word 97 implements conversion of video and background sounds.
    </p>
    <p num="145">The IPersistHTML Interface</p>
    <p num="146">
      To load an HTML element from or save an HTML element to an ActiveX control, Microsoft Word 97 uses the IPersistHTML Interface.
      <br/>
      The IPersistHTML Interface is related to the well known IPersistStreamInit interface, except that the persisted state of the object is HTML.
      <br/>
      IPersistHTML provides IPersistHTML::SaveHTML, which generates a stream of HTML sufficient for the object to restore its present state and IPersistHTML::LoadHTML, which, given a stream of HTML, restores the object to a prior state.
      <br/>
      The streams written or read by these methods are streams comprising HTML.
      <br/>
      It should be noted that an exact equivalence between an HTML element and an ActiveX control may not be achieved, so some state information may be lost or slightly modified.
      <br/>
      The present invention addresses this problem by retaining the original HTML used to generate the ActiveX control and retaining any HTML not recognized by the ActiveX control.
      <br/>
      The HTML not recognized may be later retrieved when the ActiveX control produces a stream of HTML.
      <br/>
      The IPersistHTML interface uses Unicode, a well known format for representing characters.
      <br/>
      However, some other format for representing characters (e.g., ASCII) could be used.
    </p>
    <p num="147">
      Having described and illustrated the principles of our invention with reference to an illustrated embodiment, it will be recognized that the illustrated embodiment can be modified in arrangement and detail without departing from such principles.
      <br/>
      It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computer apparatus, unless indicated otherwise.
      <br/>
      Various types of general purpose or specialized computer apparatus may be used with or perform operations in accordance with the teachings described herein.
      <br/>
      Elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa.
    </p>
    <p num="148">
      In view of the many possible embodiments to which the principles of our invention may be applied, it should be recognized that the detailed embodiments are illustrative only and should not be taken as limiting the scope of our invention.
      <br/>
      Rather, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>We claim:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A computer-implemented method for converting a structured language element representing an element to be rendered within a document to a data structure representing a software object of a software object class having a method for setting properties of the software object based on a passed structured language element, the method comprising:</claim-text>
      <claim-text>reading the structured language element representing the element to be rendered within the document; determining a class identifier associated with the structured language element representing the element to be rendered within the document and indicative of the software object class having a method for setting properties of the software object based on a passed structured language element;</claim-text>
      <claim-text>and without instantiating an instance of the represented software object of the software object class, converting the structured language element representing the element to be rendered within the document to the data structure representing the software object of the software object class having a method for setting properties of the software object based on a passed structured language element, the data structure containing the persistent state of the represented object of the software object class, wherein the data structure comprises the class identifier associated with the structure language element representing the element to be rendered within the document and indicative of the software object class having a method for setting properties of the software object based on a passed structured language element.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1 wherein the structured language element has a tag name indicating characteristics of a visible element in the document and wherein determining the class identifier associated with the structured language element comprises: finding a class identifier associated with the tag name of the structured language element, wherein the class identifier identifies a software object class providing the characteristics of the visible element indicated by the tag name.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 2 wherein the class identifier identifies a software object class embeddable and editable in a converted document edited by a document editor.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 1 wherein the data structure further comprises the structured language element.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 1 wherein the data structure comprises the structured language element, the method further comprising: instantiating an instance of an object identified by the class identifier; locating the structured language element in the data structure;</claim-text>
      <claim-text>and setting the properties of the instance of the object by passing the located structured language element to the method for setting properties of the software object based on the passed structured language element.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 5 wherein the structured language element comprises and HTML attribute keyword and an associated HTML attribute value and the setting comprises: matching the HTML attribute keyword with an object property identifier identifying a property of the object; setting the property identified by the object property identifier to a value according to the associated HTML attribute value.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. A method for converting a structured language element to a data structure representing a software object, the method comprising: reading the structured language element; converting the structured language element to the data structure representing the software object without instantiating an instance of the represented software object, the represented software object being of a software object class having a method defined to set properties of the represented software object based on the data structure representing the software object.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 7 wherein the data structure representing a software object comprises a class identifier chosen according to the following method: selecting a structured language tag component of the structured language element;</claim-text>
      <claim-text>and finding the structured language tag component in an entry of a data structure associating the structured language tag component with the class identifier.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. A method of converting a software object to a structured language element, wherein the software object represents an original structured language element comprising a portion of structured language not recognized when creating the software object, and the software object comprises the portion of structured language not recognized when creating the software object, the method comprising: reading the portion of structured language not recognized when creating the software object;</claim-text>
      <claim-text>and reconstituting the original structured language element from the software object to produce the converted structured language element, including in the converted structured language element the portion of structured language not recognized when creating the software object.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of claim 9 wherein the converted structured language element is a form element representing an original structured language element that is a form element.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A method for converting a data structure representing a represented software object to a structured language element, wherein the data structure was created without creating an instance of the represented software object and comprises text of the structured language element, the method comprising: reconstituting the structured language element of the represented software object by reading the text of the structured language element stored in the data structure without instantiating the represented software object.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A method for converting a software object to a structured language element, the method comprising: providing a data structure to a software routine extrinsic to the software object, the data structure with entries associating a structured language attribute keyword with a property identifier, the software routine performing the following for a plurality of entries in the data structure:</claim-text>
      <claim-text>- reading a has-been-set value in the software object indicative of whether a property value of the software object identified by the property identifier in the entry has been set;</claim-text>
      <claim-text>and - if the has-been-set value is indicative of having set the property value, producing a portion of the structured language element comprising the structured language attribute keyword in the entry and the property value identified by the property identifier.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 12 wherein the structured language attribute keyword is an HTML attribute keyword and the property identifier is an integer value.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A converter for converting a structured language element to an embeddable data structure representing a represented object, the converter comprising: a parser operative for selecting a tag component of the structured language element; a data structure with an entry, the entry associating a structured language tag component with an object class identifier; a table look-up logic operative for selecting a class identifier associated in the data structure with the selected tag component;</claim-text>
      <claim-text>and a structured language element data structure logic operative for creating a data structure comprising the structured language element and the class identifier to generate an embeddable representation of the represented object without instantiating an instance of the represented object.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A computer-implemented method for converting an HTML element representing an HTML form user interface feature to a data structure representing a software object for depicting a form user interface feature corresponding to the HTML form user interface feature in a document editor, the represented software object being of a software object class having a method for setting properties of the represented software object when supplied with an HTML element, the method comprising: reading the HTML element representing the HTML form user interface feature; determining a class identifier associated with the HTML form user interface feature and indicative of the software object class having a method for setting properties of the represented software object when supplied with an HTML element; without instantiating an instance of the represented software object of the software object class, converting the HTML element to the data structure representing the software object for depicting the form user interface feature corresponding to the HTML form user interface feature in the document editor, the data structure comprising the persistent state of the represented object of the software object class, wherein the data structure comprises the class identifier associated with the HTML form user interface feature and indicative of the software object class having a method for setting properties of the represented software object when supplied with an HTML element.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 15 wherein the data structure further comprises the HTML element.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method of claim 15 wherein the HTML element representing an HTML form user interface feature comprises a tag name;</claim-text>
      <claim-text>and the determining determines the class identifier by determining the class identifier is associated with the tag name.</claim-text>
    </claim>
  </claims>
</questel-patent-document>