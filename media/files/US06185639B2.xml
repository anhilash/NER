<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185639B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185639</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185639</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="26778409" extended-family-id="1364219">
      <document-id>
        <country>US</country>
        <doc-number>09136645</doc-number>
        <kind>A</kind>
        <date>19980818</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09136645</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>1416349</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>13664598</doc-number>
        <kind>A</kind>
        <date>19980818</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09136645</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>8820198</doc-number>
        <kind>P</kind>
        <date>19980605</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1998US-60088201</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  13/24        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>13</main-group>
        <subgroup>24</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>710048000</text>
        <class>710</class>
        <subclass>048000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>710005000</text>
        <class>710</class>
        <subclass>005000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>710263000</text>
        <class>710</class>
        <subclass>263000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-013/24</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>13</main-group>
        <subgroup>24</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-013/24</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>13</main-group>
        <subgroup>24</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>24</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>16</number-of-drawing-sheets>
      <number-of-figures>16</number-of-figures>
      <image-key data-format="questel">US6185639</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">System and method to reduce a computer system's interrupt processing overhead</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>JIBBE MAHMOUD K, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5179704</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5179704</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>FUKUOKA KATSUHITO</text>
          <document-id>
            <country>US</country>
            <doc-number>5363506</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5363506</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>OHSHIMA MASAMICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5642509</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5642509</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>KAISER JOHN MICHAEL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5713029</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5713029</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>NCR INT INC</text>
          <document-id>
            <country>EP</country>
            <doc-number>0508602</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-508602</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>ADVANCED MICRO DEVICES INC</text>
          <document-id>
            <country>EP</country>
            <doc-number>0685798</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-685798</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>ECLIPSE TECHNOLOGIES INC</text>
          <document-id>
            <country>WO</country>
            <doc-number>9422082</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>WO9422082</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>MITSUBISHI ELECTRIC CORP</text>
          <document-id>
            <country>GB</country>
            <doc-number>2298306</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>GB2298306</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Oct. 19, 1999, PCT International Search Report; US99/12551.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <related-publication>
        <document-id>
          <country>US</country>
          <doc-number>60/088,201</doc-number>
          <date>19980605</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/088201</doc-number>
          <date>19980605</date>
        </document-id>
      </related-publication>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Kailash, Kailash</name>
            <address>
              <address-1>San Jose, CA, US</address-1>
              <city>San Jose</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Bayar, Balakrishna B.</name>
            <address>
              <address-1>Fremont, CA, US</address-1>
              <city>Fremont</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Chandramouli, Vytla P.</name>
            <address>
              <address-1>Fremont, CA, US</address-1>
              <city>Fremont</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Gokhale, Sanjeev B.</name>
            <address>
              <address-1>San Jose, CA, US</address-1>
              <city>San Jose</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Flehr Hohbach Test Albritton &amp; Herbert LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Ray, Gopal C.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      The invention provides structure and method to control the presentation of interrupts to a computer system by delaying communication of the interrupts to the host computer or processor according to predetermined rules.
      <br/>
      In particular, the method of the invention first detects the occurrence of an I/O interrupt related to a device.
      <br/>
      Next, the method reserves notification to the host processor of the I/O interrupt for a period of time based on a set of predetermined rules.
      <br/>
      Finally, the method notifies the host processor of substantially all I/O interrupts for which notification has been reserved during the period of time at expiration of the period of time, whereby the reserve notification lowers the overhead to the host processor in handling the I/O interrupts.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">This application claims benefit of provisional application 60/088,201, filed Jun. 5, 1998.</p>
    <heading>FIELD OF THE INVENTION</heading>
    <p num="2">This invention relates generally to the field of interrupt processing including clustering command completion in a computer system, and more particularly to apparatus and method for reducing the number of interrupts in a computer system and reducing the overhead as a result of posting command completion to reduce processing overhead and thereby enhance a computer system, particularly input/output performance.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="3">
      In a conventional computer server system, a primary measure of performance is the number of transactions per minute (TPM) handled by the server system.
      <br/>
      One of the major impediments to a high TPM throughput is the number of interrupts handled and processed per second by the host computer or server system.
      <br/>
      On most server systems, two types of interrupts predominate: (1) disk drive I/O interrupts handled in conjunction with a disk drive controller, and (2) workstation interrupts generated by one or more workstation nodes and handled through the network controller.
      <br/>
      There may be more than one of each of these types of controllers and there may be other types of controllers appropriate to the devices attached to the host as well.
    </p>
    <p num="4">
      If we consider a Redundant Array of Independent Disk (RAID) drive array and the disk I/O interrupts generated by or in conjunction with that RAID array, a better understanding of the impediments imposed by conventional systems will be appreciated.
      <br/>
      By way of example, a Transaction Processing Counsel-Type C (TPC-C) system running a 10,000 TPM load in a conventional system may typically generate about 6,000 input/output (I/O) operations per second.
      <br/>
      Handling each interrupt may typically involve executing between about 500 and about 4000 instructions.
      <br/>
      For example, the DAC960 requires about 564 instructions for each interrupt, and the Flashpoint requires about 3657 instructions.
      <br/>
      Therefore, the total I/O interrupt processing overhead for 6,000 I/O operations per second system may typically run into millions of instructions per second.
      <br/>
      For example, for a 6000 interrupts/sec system needing 500 instructions/interrupt, three million instructions/sec are executed.
    </p>
    <p num="5">
      The impact of interrupts can be particularly significant when the computer system is a network server configured and operable to serve input/output (I/O) requests for data or program information from a large number of workstation users.
      <br/>
      These conventional systems handle interrupts as they occur with only minor variations that may occur when the system is heavily loaded, and even under such heavily loaded condition, the delay in handling interrupts is not a controlled delay, rather it is the result of system capacity limitations.
      <br/>
      It will therefore be appreciated that in conventional systems, neither the number of I/O operations nor the number of interrupts generated by those I/O operations are constrained, controlled, or optimized to reduce the interrupt related overhead and improve system performance.
    </p>
    <p num="6">In similar manner, the total overhead to process one Input/Output (I/O) completion runs into thousands of processor instructions, and I/O completion processing overhead runs into millions of instructions per second.</p>
    <p num="7">
      Locking overhead, added by the multiprocessor system, is an additional burden.
      <br/>
      The locking cycle is particularly problematic and a burden on the system because for at least most microprocessors, locking stops all activity on the system bus during the lock cycle.
    </p>
    <p num="8">
      For every completed I/O, device drivers typically do number of calls before posting the completion to the file system or original request.
      <br/>
      In most of the operating systems, device drivers are layered, therefore the same functions are called for every I/O.
      <br/>
      For example, a low level controller driver typically makes calls to an upper level disk driver for every I/O.
      <br/>
      These call operations are summarized as follows:
    </p>
    <p num="9">(a) Controller driver calls disk driver.</p>
    <p num="10">(b) Controller driver frees up the associated I/O request buffer/resource.</p>
    <p num="11">(c) Controller driver does at least one set of lock/unlock per I/O request to free the buffer/resource.</p>
    <p num="12">(d) Disk driver calls upper level driver.</p>
    <p num="13">(e) Disk driver frees up the associated I/O request buffer/resource.</p>
    <p num="14">(f) Disk driver does at least one set of lock/unlock per I/O request to free the buffer/resource.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="15">
      The number of interrupts are controlled by delaying communication of the interrupt to the host computer or processor according to predetermined rules.
      <br/>
      In some cases, this controlled delay or interrupt clustering may result in a slight increase in I/O response time, but this possible response time increase is generally negligible relative to overall performance increase realized, and the effect of any response time increase actually lessens for higher performance systems.
      <br/>
      This reduces the processing overhead and greatly increases system performance.
      <br/>
      Application of the inventive structure and method to RAID disk drive storage arrays is particularly beneficial.
    </p>
    <p num="16">In one embodiment, the invention provides structure and method for reducing the number of system interrupts to the host processor to reduce host processor overhead for operation of a computer system having a host processor and a peripheral device coupled to the host processor by a device controller, where the method includes: detecting the occurrence of an input/output interrupt related to a device; reserving notification to the host processor of the input/output interrupt for a period of time according to predetermined rules; notifying the host processor of all input/output interrupts for which notification has been reserved during the period of time at the expiration of the period of time; where the reserved notification lowering the overhead to the host processor in handling the input/output interrupts.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="17">
      FIG. 1 is block diagram of an exemplary embodiment of a computer system incorporating inventive hardware features which may be used in conjunction with the inventive structure and method.
      <br/>
      FIG. 2 is block diagram of an exemplary embodiment of a computer system using conventional hardware components which may be used in conjunction with the inventive method.
      <br/>
      FIG. 3 is a flow chart diagram of an exemplary embodiment of a system interrupt reduction initialization procedure.
      <br/>
      FIG. 4 is a flow chart diagram of an alternative exemplary embodiment of a system interrupt reduction procedure in which there is no reason or requirement to select a master controller.
      <br/>
      FIG. 5 is a flow chart diagram of another alternative exemplary embodiment of a system interrupt reduction procedure in which a single interrupt controller is provided within the host so that only a single interrupt generator is required for all devices.
      <br/>
      FIG. 6 is a flow chart diagram of an exemplary embodiment of a system interrupt reduction slave (secondary) controller procedure.
      <br/>
      FIGS. 7A and 7B are a flow chart diagram of an exemplary embodiment of a system interrupt reduction master (primary) controller procedure.
      <br/>
      FIG. 8 is a flow chart diagram of an exemplary embodiment of a system interrupt reduction host interrupt procedure.
      <br/>
      FIG. 9 is a flow chart diagram of an exemplary embodiment of a system interrupt reduction slave (secondary) controller procedure implemented in special hardware.
      <br/>
      FIG. 10 is a flow chart diagram of an exemplary embodiment of a system interrupt reduction master (primary) controller procedure implemented in special hardware.
      <br/>
      FIG. 11 is a flow chart diagram of an exemplary embodiment of an adapter interrupt reduction slave (secondary) controller procedure.
      <br/>
      FIG. 12 is a flow chart diagram of an exemplary embodiment of an adapter interrupt reduction host controller procedure.
      <br/>
      FIG. 13 is a diagrammatic illustration of an embodiment of a structure for Clustered Command Completion.
      <br/>
      FIG. 14 is a flow chart diagram of aspects of an exemplary embodiment of an Clustered Command Completion procedure.
      <br/>
      FIG. 15 is a flow chart diagram of aspects of an exemplary embodiment of an Clustered Command Completion procedure.
      <br/>
      FIG. 16 is a flow chart diagram of aspects of an exemplary embodiment of an Clustered Command Completion procedure.
    </p>
    <heading>DETAILED DESCRIPTION OF THE EMBODIMENTS</heading>
    <p num="18">
      In the inventive structure and method, the number of interrupts per second are controlled by delaying communication of the interrupt to the host according to predetermined rules or procedures, as described in greater detail below, so that the number of interrupts are reduced.
      <br/>
      In some cases, this controlled delay or interrupt clustering may result in a slight increase in I/O response time.
      <br/>
      But this possible response time increase is usually negligible relative to overall performance increase realized, and the effect of any response time (the duration or period of time starting when the host sends the command to the controller and ending when the host gets the response back from the controller) increase actually lessens for higher performance systems.
      <br/>
      This reduces the processing overhead and increases system performance greatly.
      <br/>
      The performance improvement is greatest for faster systems, even though performance increases independent of system speed.
      <br/>
      Performance improvement is better because although the total overhead is the same, the per unit of overhead or equivalently, the overhead per transaction decreases for faster systems.
    </p>
    <p num="19">
      An "interrupt" as used in this description is the method or procedure by which any hardware controller can inform the host that some event has occurred.
      <br/>
      For example, an I/O interrupt informs the host that I/O has occurred.
      <br/>
      Interrupt handling conventionally means a method or procedure by which the interrupt condition is investigated, the interrupt acknowledged (so that the next interrupt that might occur can be raised), and taking appropriate action for the event.
    </p>
    <p num="20">
      We now describe the manner in which response time and system performance are related using an example of a disk drive of the type used for network server applications and having a response time (access time) of 8 ms (15 ms in TPC-C measurement).
      <br/>
      If we add an average 1 ms delay to each of these 8 ms disk response times, the system response time will not change by very much (about 12% in the most extreme case) but the processor or CPU system performance is improved because rather than the 6,000 interrupts per second typical of conventional systems, the number of interrupts is reduced to 500 interrupts per second.
      <br/>
      A system may do more than one I/O for a single transaction.
      <br/>
      For example, the system may perform 4 I/O and the transaction may take 100 ms to complete.
      <br/>
      In this example, adding 1 ms to each I/O will only add 4 ms to the 100 ms transaction time, resulting in only a 4% increase.
    </p>
    <p num="21">
      By way of numerical example, we have already described the manner in which a TPC-C system running at 10,000 TPM load generates about 6,000 I/O interrupts per second.
      <br/>
      By employing the inventive structure and method and limiting the number of interrupts to 500 I/O per second with possible average increase in response time of about 1 ms and an approximate maximum increase of response time of 2 ms, the system will generate only 500 interrupts per second instead of the 6,000 interrupts per second for the conventional system.
      <br/>
      In an analogous manner for a system processing 20,000 transactions per minute and employing the inventive structure and method, the system will generate only 500 interrupts per second versus the expected 12,000 interrupts per second using conventional techniques.
      <br/>
      Therefore it is clearly seen that on a faster system (e.g. 20,000 TPM system) fewer interrupts are generated per I/O than on the slower system (e.g. 10,000 TPM system).
      <br/>
      These are averages and maximum and the actual delay may be less than the cited number or even zero for any particular event.
    </p>
    <p num="22">
      Of course, the invention is not limited to controlling the number of interrupts to 500 interrupts per second or any other number, and the entries in the above table are merely illustrative of the average, maximum, and minimal increase in response time as a function of the number of interrupts per second ranging from 100 interrupts per second to 1,000 interrupts per second.
      <br/>
      Those workers having ordinary skill in the art in light of the disclosure provided herein, will appreciate that controlling the number of interrupts between the number of interrupts in an uncontrolled conventional system and some smaller number of interrupts will effect a performance improvement, where the nature and degree of the performance improvement may generally depend on the system speed, nominal device response time, system configuration, selected maximum number of interrupts per second, and other system parameters.
      <br/>
      Some of these considerations and tradeoffs are described more fully hereinafter.
    </p>
    <p num="23">
      The inventive structure and method may be implemented within software and/or firmware in conventional hardware without utilizing optional special purpose hardware so that the inventive method and procedures are applicable to existing computer system hardware, including disk controllers, disk devices, processors, memory, and the like computer system components without modification.
      <br/>
      Alternatively, and with certain advantages, certain specialized hardware structures may be employed to implement the inventive method either alone or with a combination of inventive software and firmware.
    </p>
    <p num="24">
      We now describe a first exemplary embodiment of the inventive structure with respect to FIG. 1.
      <br/>
      In this system 100, one or more processing units 102 (e.g. processor 1, processor 2, . . . , processor J) are coupled to system memory 104, and to a bus 130, such as a system bus.
      <br/>
      The system bus 130 may be any one of the conventionally known computer bus types such as for ISA, AT, PCI, SCSI, or Scalable Coherent Interface (SCI) busses; however, for a high performance computer server configuration, the system bus will more typically be a high performance bus, such as a PCI bus.
      <br/>
      Other conventional hardware components such as a display adapter 105, system I/O 106, keyboards, tape drives, mass storage devices, and the like may also be configured to interface via the system bus 130 or by other conventional connections.
      <br/>
      The inventive structure and method are not limited to any particular bus type or configuration, or hardware components or component connectivity, unless specifically described as requiring a particular structure or connectivity in the specification.
      <br/>
      Conventional computer elements not necessary to describe the inventive structure and method have been eliminated from the figures so as not to obscure the invention itself.
    </p>
    <p num="25">
      With further reference to the exemplary embodiment in FIG. 1, two types of device controllers are shown, disk drive controllers and network workstation or network node controllers.
      <br/>
      A disk subsystem 125 is responsible for interfacing between the devices (e.g. disk drive) and the host .
      <br/>
      The second type of unit generating interrupts within system 100 is a network controller 123.
      <br/>
      A network controller 123 is responsible for monitoring and controlling operation of a plurality of workstations 128 or other network nodes 129.
      <br/>
      In an analogy to the disk subsystem 125, each network node subsystem 127 includes one or more workstations or nodes, a network controller 123, and a hardware interrupt generator 120 coupled between the network controller 123 and the system bus 130.
      <br/>
      None, one, or a multiplicity of such subsystems 125, 127 may be provided.
      <br/>
      Operation of the invention for each subsystem type, peripheral device, and controller are substantially the same, so that in the remainder of the description we focus attention on the disk subsystem.
      <br/>
      Those workers having ordinary skill in the art in light of this description will appreciate that the inventive principles for reducing the number and/or frequency of interrupts to the host apply to other computer devices and/or controller structures.
    </p>
    <p num="26">
      Disk controller 1 (122a) is responsible for controlling one or more hard disk devices 126.
      <br/>
      Here an array of M disk drives are shown configured as RAID array 124.
      <br/>
      It is conventionally known that RAID is a technology used to improve I/O performance and reliability of mass storage devices.
      <br/>
      In such a configuration, data is stored across a plurality of disks in order to provide immediate access to the data despite one or more disk drive failures.
      <br/>
      The RAID technology is typically associated with a taxonomy of techniques, where each technique is referred to by a RAID level.
      <br/>
      Six basic RAID levels are conventionally acknowledged, each having certain benefits and disadvantages.
      <br/>
      The RAID configurations, and advantages and disadvantages of each, are well known in the art and not described further here.
    </p>
    <p num="27">
      A typical data storage system, such as may be implemented on a system file server for a network, can contain a number of disk storage devices that can be arranged in accordance with one or more RAID levels.
      <br/>
      A RAID controller is a device that is used to manage one or more arrays of RAID disk drives.
      <br/>
      The RAID controller, among other functions, is responsible for configuring the physical drives in a data storage system into logical drives where each logical drive is managed in accordance with one of the aforementioned RAID levels.
    </p>
    <p num="28">
      While the inventive structure are not limited to RAID configurations or to network servers, network server systems may frequently implement a RAID configuration to maintain data redundancy and data integrity.
      <br/>
      Therefore, RAID arrays are conveniently used to describe a exemplary embodiments of the inventive structure and method and to provide a standard basis of comparison between the operation and performance of the inventive structure and method as compared to conventional structures and methods.
    </p>
    <p num="29">
      In the exemplary embodiment of FIG. 1, disk controller 122a may for example be a RAID disk array controller controlling multiple disk drives 126 in RAID array 124.
      <br/>
      Disk controller 122a is coupled to an optional hardware interrupt generator D1120a which in turn is coupled to system bus 130.
      <br/>
      The set of disks may number from one or a few to a hundred or more disk drives and each of these disk drives is controlled by the same disk controller 122a.
      <br/>
      Hardware interrupt generator (HIG) D1 is described as "optional" because although it offers some performance advantages (such as for example, the software in the disk controller does not have to evaluate when to generate the interrupt), alternative embodiments that realize the inventive structure and method using conventional hardware may be used.
      <br/>
      Each of these alternative embodiments are described hereinafter.
    </p>
    <p num="30">
      This combination of disk drives, disk controller and hardware interrupt generator may for convenience be referred to as a disk subsystem 125.
      <br/>
      As illustrated relative to FIG. 1, the system 100 may include one or more of these disk subsystems 125, each including one or more disk drives, a disk controller and a optional hardware interrupt generator.
      <br/>
      For example, an nth disk subsystem 125 having a array of k disk drives, a disk controller n 122b coupled to a hardware interrupt generator DN 120b via a connect interface 121b may also be provided.
      <br/>
      The hardware interrupt generator (HIG) is required only for the hardware implementation, and is not provided in the software implementation.
    </p>
    <p num="31">
      In addition to these hardware elements, certain memory storage is provided in the disk and/or network controllers for storage of certain data and procedures related to the inventive method.
      <br/>
      Furthermore, for an all software or firmware implementation, certain hardware elements such as the HIG may be eliminated.
    </p>
    <p num="32">Particular data and other storage structures that may be provided in system memory and within the disk and/or network controllers and/or the various hardware interrupt generators are described relative to the particular inventive methodology.</p>
    <p num="33">
      A second inventive structure is now described relative to FIG. 2, which shows a hardware configuration wherein the controllers 122a, 122b, 122c, 122d are coupled directly to the system bus 130 without intervening hardware interrupt generators.
      <br/>
      While some sacrifices in performance, such as executing a greater number of instructions may occur, the second embodiment has the advantage that the inventive method and procedures can be implemented with conventional controllers, controlled devices, host processors, and the like.
      <br/>
      Certain modifications to the conventional hardware are beneficial, including the provision, allocation, and partition of certain data structures within the controller and host.
      <br/>
      These differences are further described relative to the inventive method which follows.
    </p>
    <p num="34">
      We now describe the inventive method for reducing the number of device and host interrupts.
      <br/>
      Advantageously, the procedures for reducing device and host interrupts are used concurrently; however, the procedure for reducing system interrupts may be used alone.
      <br/>
      The procedure for reducing device interrupts requires implementation of the inventive procedure for reducing host interrupts or a different procedure that provides comparable functionality relative to the device interrupts.
    </p>
    <p num="35">
      In the descriptions that follow, references to the host or system side refer to the host system, including the CPU, host system bus 130, bus controller or controllers, host memory 104, and like elements associated with the host.
      <br/>
      On the other hand, references to the controller or controller side, refer to the particular peripheral device controller, devices controlled by that peripheral device controller, and in certain embodiments of the invention, the hardware interrupt generator.
      <br/>
      For example, in the embodiment of FIG. 1, the controller side would refer to each of the RAID disk array 124 including disks 126 (or workstations 128 or nodes 129), the disk controller 122a (or network controllers 123), and the hardware interrupt generators 120.
    </p>
    <p num="36">
      In some instances, reference is made to master or primary controller, and one or more slave or secondary controllers.
      <br/>
      Procedures for selecting the primary and secondary controllers are described hereinafter.
      <br/>
      The structure of the primary and secondary controllers may actually be identical in some embodiments, and only the operation may differ in that the master controller has additional duties not performed by the slave controllers.
    </p>
    <p num="37">
      An exemplary procedure for a system interrupt reduction initialization procedure is now described relative to FIG. 3.
      <br/>
      Where two or more device controllers of the same type are provided in the computer system, performance is enhanced by identifying one of the two or more controllers as the master or primary controller and each of the other controllers of the same type as slave or secondary controllers.
      <br/>
      Master controllers and slave controllers may have the same physical structure but are assigned different functional duties according to their designation and configuration as master or slave.
      <br/>
      We address the different responsibilities of master and slave controllers in greater detail hereinafter.
    </p>
    <p num="38">
      For example, if there are four disk array controllers and four workstation controllers, one of the disk array controllers will be identified as the disk array master controller and the other three disk array controllers are identified as the associated slave controllers to that disk array master controller.
      <br/>
      The disk array master controller is responsible for its input/output interrupts as well as the input/output interrupts from the three other disk array controllers associated with it.
      <br/>
      In a sense the slave controllers report to the master controller in a hierarchical manner.
      <br/>
      Similarly, of the four workstation controllers, one is designated as the master or primary workstation controller, and the other three workstation controllers are designated as slave or secondary workstation controllers which report to the master workstation controller.
    </p>
    <p num="39">
      While a computer system operating with several types of controllers (e.g. disk array and workstation controllers) might be configured with a single master controller chosen from among the disk array and workstation controllers, such configuration and operation is not preferred because of the different operating characteristics, interrupt event frequency, and other factors.
      <br/>
      In the inventive structure and method, it may typically be desirable (though not necessary) to select the interrupt reduction parameters for each master controller or type of master controller differently to optimize system performance.
    </p>
    <p num="40">
      The manner in which master controller(s) are selected or designated from among a plurality of controllers present in the system is firstly dependent on whether the inventive interrupt reduction is implemented in general purpose computer hardware or in specialized hardware.
      <br/>
      Where specialized hardware is used, the hardware and its connectivity to other system components designates some controllers as masters and others as slaves.
      <br/>
      This specialized hardware and connectivity is described subsequently in connection with an exemplary hardware embodiment of the invention.
      <br/>
      In software and firmware implementations of the invention the master controller or master controllers are identified during boot, reset, power-on, plug-in, or the like initialization phase of operation.
    </p>
    <p num="41">
      With further reference to FIG. 3, there is shown a flow-chart diagram of an exemplary controller initialization procedure 300.
      <br/>
      The procedure starts (Step 301) upon one of the aforementioned initialization conditions, and one of the controllers is identified as the master controller (Step 302).
      <br/>
      While almost any rule or procedure may be used to select the master controller with correspondingly better or poorer performance results, at least four options make good sense.
      <br/>
      In a first option (Option A) the master controller is arbitrarily selected as any one of the plurality of controllers (Step 303).
      <br/>
      This selection criteria may be entirely feasible where each controller has similar input/output loading, or where input/output loading for each set of controlled devices is unknown or cannot be predicted accurately.
    </p>
    <p num="42">
      In a second option (Option B), the master controller is selected to be the controller that is expected to do the most input/output (Step 304) based on one or more predetermined factors or criteria.
      <br/>
      Selecting the master controller as the controller expected to perform the most input/output has certain performance advantages that are tied to an embodiment of the inventive method wherein a query is made relative to input/output interrupts, the master controller being queried first and the slave controllers being queried only if the master controller has had no activity.
      <br/>
      By designating the controller predicted to have the most activity as the master, on a statistical basis at least, it is more likely that the slave controllers will not require the query operation.
      <br/>
      Hence, performance is improved.
    </p>
    <p num="43">
      In a third option (Option C), the master controller is selected on a first-in-first served basis (Step 305).
      <br/>
      Under the first-in-first-served procedure, the master controller is selected to be the controller that was found first during the scan, such as for example, found according to the order on the PCI bus during system configuration.
      <br/>
      This procedure is particularly advantageous for writing code and physical determination of the master controller.
    </p>
    <p num="44">
      A fourth option (Option D), provides that the master controller is chosen dynamically during operation of the computer system based on the loading experienced by the several controllers (Step 306).
      <br/>
      Under this procedure, the designation as master controller and function performed by the controllers may change from one controller to another controller over time.
      <br/>
      These four options are meant to be exemplary, and the inventive structure and method are not limited to these selection procedures.
    </p>
    <p num="45">
      Once the master controller is selected, the remaining controllers are associated with a master controller (Step 310).
      <br/>
      Where several different types of controlled devices are attached to the computer system, each type of device advantageously has its own master controller selected in accordance with the above description.
      <br/>
      The selection criteria may be different or the same for each master controller.
    </p>
    <p num="46">
      Finally, once the master controller has been selected, the other controllers are designated as non-master or slave controllers associated with a particular master controller, and a master-slave communication space, preferably implemented with a data structure in physical memory of the host, is established (Steps 312, 314) for communicating the completed I/O activity information between each master and each associated slave controller.
      <br/>
      The information stored by each controller (including completed input/output counts-CIOC) and read by the master controller from this communication space is described subsequently.
      <br/>
      In principle, the memory could be located anywhere, including in any of the controllers if access was allowed between controllers across the bus; however, in some systems such cross-bus access is not supported.
    </p>
    <p num="47">By way of summary, on the host side during computer system initialization and prior to said receiving a request for interrupt generated by a controller, one of the plurality of device controllers is chosen and identified as a master controller, the other controllers being slave controllers, and a master-slave communication memory storage space is defined in a memory store for storage of said input/output related information, particularly including a count related to completed input/output for each controller.</p>
    <p num="48">
      Having described an exemplary embodiment for which a master controller is selected or otherwise designated or identified, we now describe alternative embodiments in which there is no reason or requirement to select a master controller.
      <br/>
      Such a system configuration is now described relative to the diagrammatic illustration in FIG. 4.
    </p>
    <p num="49">
      In this embodiment, each of the devices of a particular type (e.g. all of the disk drives, or all of the workstations) are connected to a single hardware interrupt generator which serves as the master.
      <br/>
      In the embodiment of FIG. 4, there is one disk drive HIG and one workstation HIG, each serving as the master.
      <br/>
      This configuration is advantageous because (i) the overhead for a system having only a single interrupt generator is reduced (as compared to a multiple interrupt generator configuration) because the predetermined number of interrupts (e.g. 500 interrupts) apply to all of the disk drives, rather than only to the disk drives connected to a particular master controller or slave controller.
      <br/>
      For example, in an embodiment having two disk controllers each serving three disk drives, there will be 500 interrupts for each controller and a total of 1000 interrupts for both controllers.
      <br/>
      The system response time will increase by some number of milliseconds, say x milliseconds.
      <br/>
      If each of the six disk drives are instead serviced by a single interrupt generator, then the response time will still be x milliseconds, but the total number of interrupts decreases from 1000 to 500.
    </p>
    <p num="50">
      In yet another alternative embodiment, such as the embodiment illustrated in FIG. 5, a single interrupt generator or controller is provided within the host so that only a single interrupt generator is required for all devices, independent of type or number.
      <br/>
      This configuration takes the advantages of the aforementioned configuration even further by reducing the number of interrupts to the predetermined number (e.g. 500 interrupts) for all of the devices configured to the interrupt generator.
    </p>
    <p num="51">
      Of course, other variations of these ganged or clustered interrupt generation may be implemented.
      <br/>
      For example, a number of disk drives might share a single (master) interrupt generator, while there may be a plurality of interrupt generators (master and slave) for other devices.
      <br/>
      Other variations include systems incorporating both hardware interrupt generators and controllers implementing software interrupt generation.
    </p>
    <p num="52">
      An exemplary software or firmware based procedure 400 for the portion of a system interrupt reduction method occurring in the slave or secondary controller procedure is now described relative to the flow-chart diagram in FIG. 6.
      <br/>
      Recall that the computer system includes a host processor (CPU) and a first plurality of peripheral devices coupled to the host processor by some number of peripheral device controllers.
      <br/>
      The number of peripheral device controllers is typically fewer than the number of controlled devices.
      <br/>
      One of the peripheral device controllers is chosen or identified as a master controller and the other controllers are slave or secondary controllers.
      <br/>
      Interrupts to the "system" or host computer are reduced by monitoring the occurrence of input/output operations, and then delaying acting on the interrupts in a controlled manner so as to reduce disruption of host processor operations.
      <br/>
      One embodiment of the inventive procedure, which we refer to as the System Interrupt Reduction Slave Controller Procedure (SIR-SCP) 400 and method, are described relative to FIG. 6.
    </p>
    <p num="53">
      The SIR-SCP procedure 400 is entered and executed by each master or slave controller upon receipt of a request for interrupt (RFI) by the controller (Step 402, 404) that was generated by the device.
      <br/>
      For some systems, that contain a mixture of new and old controller hardware, some of the controllers may not be compatible with the inventive procedure because, for example, in a software/firmware implementation the controller may not have implemented the required logic.
      <br/>
      Or, in a hardware implementation, either the host or the controller does not provide the hardware interrupt generator.
      <br/>
      Therefore, an initial determination is made as to whether the particular device controller receiving the RFI is enabled to delay processing of the requested interrupt (Step 406) and: (I) if the particular device controller is enabled to delay processing of the requested interrupt then delaying processing of the interrupt according to some set of predetermined rules (Step 408); and (ii) if the particular device controller is not enabled to process the requested interrupt with delay, then processing the interrupt in conventional manner without delay according to the capabilities of the controller (Step 410).
      <br/>
      In one embodiment of the invention, processing the interrupt with delay includes posting data and status transfer completion to the host memory (Step 422).
    </p>
    <p num="54">After the enabled controller has processed the interrupt request (Step 408), the enabled controller determines if the device controller is enabled to post completion of the interrupt request to the host (Step 414) and, (iii) if the device controller is enabled to post completion of the interrupt request, then the controller posts or writes data and status transfer completion information to the host (Step 422), and posts the number of completed input/output into the master/slave memory (Step 424); otherwise (if said device controller is not enabled to post completion of the interrupt request), the controller posts completion of the interrupt request in conventional manner (Step 418).</p>
    <p num="55">
      Conventional processing of a controller interrupt typically includes (i) identifying the controller, (ii) acknowledging the interrupt to the controller, (iii) identifying the completed request, and (iv) post-processing the completed request.
      <br/>
      Conventional controller posting of completion of the interrupt request typically includes: (i) posting data, (ii) posting status, and (iii) generating interrupt to the host.
    </p>
    <p num="56">After controller posting of the number of completed input/output counts (Step 424), processing of the interrupt for the non-enabled controller (Step 410), or posting of the completion of the completion of the interrupt by the non-enabled controller (Step 418), the SIR-SCP procedure (400) returns to the entry point and waits for the next request for interrupt (Steps 412, 418, or 426).</p>
    <p num="57">
      In one embodiment of the inventive method, the SIR-SCP procedure for delaying processing of the interrupt includes posting data and status transfer completion to the host (Step 422).
      <br/>
      The posting of data and status transfer completion to the host comprises writing data and status to memory.
      <br/>
      In another embodiment, the SIR-SCP procedure also includes writing or posting the number of completed input/output counts (CIOC) into a memory or other storage means (Step 424).
      <br/>
      This may be accomplished directly by writing the cumulative number of counts for a given time period, by incrementing a stored count for each complete input/output operation to accumulate the CIOC, or by other accounting means known in the art.
      <br/>
      Neither high accuracy nor knowledge of the absolute count are necessarily required, as the accumulated CIOC count will be used in a comparison operation to compare the accumulated CIOC from one period of time with the accumulated CIOC from a later period of time.
      <br/>
      In one embodiment, 4 Bytes (32 bits) are used.
      <br/>
      Even if for some reason (low probability), insufficient bits are provided and the bits for the current count are identical to the bits for the prior count, then the interrupt will be delayed for one period.
      <br/>
      So long as this is a low probability occurrence, the sacrifice in performance is substantially zero.
    </p>
    <p num="58">
      We now turn our attention to the operation of the master or primary controller relative to the slave controllers and the host.
      <br/>
      FIG. 7 is a diagrammatic flow chart illustration of an exemplary procedure for a system interrupt reduction master (primary) controller procedure, which we refer to as the SIR-MCP.
      <br/>
      The SIR-MCP procedure is executed or entered at predetermined intervals.
      <br/>
      These predetermined intervals may be fixed or variable, and may also be programmable.
      <br/>
      In one embodiment of the invention a clock or time runs continuously to generate a timer signal (timer interrupt) at predetermined time intervals.
      <br/>
      The time interval is chosen in accordance with consideration given to a trade-off between delay and response time, such that the delay is acceptable without sacrificing response time.
      <br/>
      It is the type of tuning that a system designer or system administrator may perform based on the characteristics of the connected devices, the purpose for which the system is operated, and other comparable parameters.
    </p>
    <p num="59">
      For example, in embodiments of the invention, the timer interrupt interval to the master controller has be set in the range from about 0.1 millisecond to about 10 millisecond.
      <br/>
      More usually the timer interrupt interval is set between 1 millisecond and 5 millisecond, and values of substantially 1 millisecond, 2 millisecond, and 3 millisecond have been used.
      <br/>
      Of course as the speed of computer system components increases, one would expect the range of timer interrupt interval to be adjusted in accordance with the evolving technology so that different ranges of timer interrupt interval may be appropriate.
      <br/>
      The timer interrupt interval may be preset, programmable, or may be under control of a statistically based feedback routine that adjusts the interval according to system or controller loading, and or other parameters.
      <br/>
      Furthermore, the timer interrupt interval or period may be stored in a memory store, hardwired or coded in some manner, or otherwise implemented in accordance with conventional practice.
    </p>
    <p num="60">
      Upon entry or initiation of the SIR-MCP procedure every x-millisecond, a determination is made as to whether the master controller or any other peripheral device controller has completed any input/output since the last entry of the SIR-MCP procedure--that is, within a predetermined elapsed time period (505).
      <br/>
      If such an input/output interrupt has occurred during the current interval, the a master controller interrupt (MCI) signal is generated by the master controller and communicated to the host (Step 516).
      <br/>
      If no input/output interrupt has occurred by any of the master or associated slave controllers during the current interval or alternatively after the master controller posts the interrupt, then the SIR-MCP procedure terminates and returns to the calling procedure to wait for the next timer interrupt (Step 514 or 518).
    </p>
    <p num="61">
      In one embodiment, the predetermined time interval is a time interval defined by a periodic clock signal, and the clock signal is generated by operating a clock within the master controller or deriving the timer interrupt signal from a clock signal communicated to the master controller from an external source, the clock in either case operates substantially continuously and generating a master controller timer interrupt signal every period of time t (Step 502).
      <br/>
      In this embodiment, the master controller performs the testing to determine whether any controller has completed any input/output (Step 505) every t seconds in response to receipt of each master controller timer interrupt signal.
    </p>
    <p num="62">In another embodiment of the invention, the step of testing the controllers to determine whether any master or slave controller has completed any input/output within a predetermined elapsed time period (Step 505) includes testing each slave controller according to predetermined rules for any slave controller that has completed at least one input/output (Step 530), where such determination may be limited to finding in any one controller has completed any input/output, and then generating a signal indicating that at least one controller has completed an input/output operation (Step 531).</p>
    <p num="63">In still another embodiment, the predetermined rules include testing each slave controller sequentially (Step 510) until a controller that has completed at least one input/output is identified (Step 512) and in response stopping testing of each slave, and then generating the signal indicating that at least one controller has completed an input/output operation (Step 516).</p>
    <p num="64">
      In yet another embodiment, the inventive structure and method for the SIR-SCP and SIR-MCP includes providing a memory storage within host memory for storing a completed input/output count (CIOC) for each controller (Step 532) (the CIOC optionally being initialized to a predetermined count (e.g. zero) after the master controller has communicated the master-host interrupt to the host to inform the host of all the interrupts pending by the controllers (Step 533) during the time period, and then incrementing or otherwise accumulating a count or value or generating a signal representing the CIOC for each completed input/output operation by the controller (Step 534).
      <br/>
      For this embodiment, the testing of each particular controller according to predetermined rules comprises querying the stored (accumulated) CIOC at predetermined time intervals, where the query includes reading a prior CIOC stored during the prior time interval (Step 541), reading a current CIOC stored during the present time interval (Step 542), and generating a first signal (Step 544) indicating that input/output has been completed since the last predetermined interval if the present CIOC is not equal to the prior CIOC (Step 543), and otherwise not generating the first signal or generating a second signal indicating that no input/output has been completed by the particular controller since the last predetermined interval (Step 545).
    </p>
    <p num="65">
      We now turn our attention to the host-master controller interaction.
      <br/>
      An exemplary procedure for a system interrupt reduction host interrupt procedure is now described relative to FIG. 8.
      <br/>
      The inventive structure and method further provide in the system or host port, circuit, register, or other interrupt signal receiving means for receiving and identifying an interrupt communicated from a controller.
      <br/>
      In general the interrupt may have been communicated by a master controller or any other controller, such as a non-enabled controller.
      <br/>
      The host receives the transmitted interrupt from the controller, including from a master controller or any one of said plurality of controllers (Step 603), and determines if the received interrupt was a master controller generated interrupt (604).
      <br/>
      If the received interrupt was a master controller generated (MCG) interrupt, then, the host: (i) identifies the particular master controller that generated the MCG interrupt (Step 606); (ii) acknowledges receipt of the MCG interrupt to the master controller that generated the interrupt (Step 608); and (iii) processes all completed input/output from the particular master controller and from all slaves associated with the particular master controller (Step 610).
      <br/>
      If the received interrupt was not a master controller generated interrupt, then within the host, the interrupt is processed in conventional manner for the controller that generated the interrupt (Step 618); and in either case: operation of the suspended activity is resumed after the interrupt has been processed (Step 620).
    </p>
    <p num="66">In one particular embodiment of the invention, processing all completed input/output from the particular master controller and from all slaves associated with the particular master controller, includes: (a) updating status (Step 612) such as, for example, that 10 Kbytes were requested but only 5 Kbytes were received; (b) informing the requestor that the requested item (e.g. data) is ready (Step 614); and (c) freeing local resources (Step 616), such as for example, memory allocated and special resources.</p>
    <p num="67">
      One embodiment of the inventive procedure, which we refer to as the System Interrupt Reduction Slave Controller Procedure (SIR-HWSCP) 800 and method, are described relative to FIG. 9.
      <br/>
      The SIR-HWSCP procedure 800 is entered and executed by each master or slave controller upon receipt of a request for interrupt (RFI) by the controller (Step 802, 804).
      <br/>
      For some systems, that contain a mixture of new and old controller hardware, some of the controllers may not be compatible with the inventive procedure.
      <br/>
      Therefore, an initial determination is made as to whether the particular device controller receiving the RFI is enabled to delay processing of the requested interrupt (Step 806) and: (i) if the particular device controller is enabled to delay processing of the requested interrupt then delaying processing of the interrupt according to some set of predetermined rules (Step 808); and (ii) if the particular device controller is not enabled to process the requested interrupt with delay, then processing the interrupt in conventional manner without delay according to the capabilities of the controller (Step 810).
      <br/>
      In one embodiment of the invention, processing the interrupt with delay includes posting data and status transfer completion to the hardware interrupt generator (HIG) (Step 822).
    </p>
    <p num="68">After the enabled controller has processed the interrupt request (Step 808), the enabled controller determines if the device controller is enabled to post completion of the interrupt request (Step 814) and, (iii) if the device controller is enabled to post completion of the interrupt request, then the controller posts or writes data and status transfer completion information to the hardware interrupt generator (Step 822); otherwise the controller posts completion of the interrupt request in conventional manner (Step 818).</p>
    <p num="69">
      After controller posting of the data and status transfer completion information to the hardware interrupt generator (Step 822), processing of the interrupt for the non- enabled controller (Step 810), or posting of the completion of the completion of the interrupt by the non-enabled controller (Step 818), the SIR-HWSCP procedure (800) returns to the entry point and waits for the next request for interrupt (Steps 812, 818, or 826).
      <br/>
      In one embodiment of the inventive method, the SIR-HWSCP procedure for delaying processing of the interrupt includes posting data and status transfer completion to the host (Step 822).
    </p>
    <p num="70">
      An exemplary procedure for a system interrupt reduction master (primary) controller procedure (SIR-HWMCP) 900 implemented in special hardware (the hardware interrupt generator) is now described relative to FIG. 10. Master controller timer runs continuously and generates a master controller interrupt signal at predetermined intervals, for example every x milliseconds (Step 902) where the number of milliseconds is selected according to rules that tune the system to have the desired response characteristics.
      <br/>
      Receipt of the master controller interrupt signal initiates the SIR-HWMCP procedure (Step 904) which executes at the same periodic intervals.
      <br/>
      Alternatively, the procedure may be viewed as running continuously in a loop (Step 906) and performing certain operations within the loop if the predetermined interval since the last execution has lapsed.
    </p>
    <p num="71">
      Under either implementation, a determination is made as to whether any controller has posted an input/output completion since the last interrupt completion (Step 910).
      <br/>
      If their have been no postings, then the procedure is iterated and a subsequent determination is made during the next time interval.
      <br/>
      On the other hand, if a controller has posted an input/output completion, then interrupt is posted the to the host (Step 910).
    </p>
    <p num="72">
      We now describe an alternative procedure that is conceptually a simplification of the System Interrupt Reduction structure and method already described.
      <br/>
      We refer to these procedures as Adapter Interrupt Reduction (AIR).
      <br/>
      AIR provides certain rules and procedures respective of when completion of a system interrupt should be posted to the host.
      <br/>
      A fundamental premise to AIR is not to post completion of interrupt on every completed input/output operation, but instead to accumulate a count and compare the count to a threshold.
      <br/>
      When the accumulated count has some predetermined magnitude relationship with the threshold (typically greater than, equal to, or the like) the interrupts are posted.
      <br/>
      This is a simplification of the SIR procedure described since AIR is event "count" or "counter" based rather than "time" or "timer" based as for SIR.
      <br/>
      In the SIR procedure we wait predetermined time periods, in the AIR procedure we wait predetermined number of counts.
      <br/>
      The SIR and AIR procedures also differ in that AIR is implemented within each controller or adapter.
      <br/>
      The AIR may be implemented completely in software or firmware or in hardware.
    </p>
    <p num="73">
      We first consider an exemplary numerical example of how the processing overhead is reduced with only a slight increase in response time.
      <br/>
      The increase in response time is typically expected to be negligible and decreases with faster system.
      <br/>
      In each of the examples described below in Table I, we assume that a fixed number of interrupts are generated each second independent of the number of I/O operations performed per second.
    </p>
    <heading>-- TABLE I</heading>
    <p num="74">
      -- Exemplary Effect of Number of Interrupts per Second on Response
      <br/>
      -- Time.
      <br/>
      -- Number of     Average        Maximum        Minimum
      <br/>
      -- Interrupts    Increase in    Increase in    Increase in
      <br/>
      -- per Second    Response Time  Response Time  Response Time
      <br/>
      -- 6,000         0.0 ms          0.0 ms   0.0 ms
      <br/>
      -- conventional conventional conventional conventional
      <br/>
      -- 1,000         0.5 ms          1.0 ms   0.0 ms
      <br/>
      --   500 1.0 ms          2.0 ms   0.0 ms
      <br/>
      --   250 2.0 ms          4.0 ms   0.0 ms
      <br/>
      --   100 5.0 ms         10.0 ms        0.0 ms
    </p>
    <p num="75">
      For example, one exemplary embodiment of the invention implements a set of rules wherein input/output completion is to be posted to the host when either: (i) a first predetermined number of input/output have completed and a second predetermined number of input/output are pending; or (ii) when a predetermined amount of time has expired after posting the first input/output completion after the last posted system interrupt.
      <br/>
      More particularly, in one embodiment, the interrupt is posted when at least twenty-five percent (25%) of pending input/output (that is, the total of completed input/output plus non-completed input/output pending on any particular controller) has been completed.
      <br/>
      A typical pending input/output count and completed input/output count illustrated in Table II.
      <br/>
      Of course other alternative rules for posting the interrupt may be implemented.
    </p>
    <heading>-- TABLE II</heading>
    <p num="76">
      -- Exemplary Rule for Posting Interrupt
      <br/>
      -- Number of     Number of
      <br/>
      -- Pending       Input/Output
      <br/>
      -- Input/Output  to Post
      <br/>
      -- Operations    Interrupt     Comments
      <br/>
      -- 1             1             No attempt to optimize for 1-3 pending
      <br/>
      -- 2             1             I/O Operations
      <br/>
      -- 3             1
      <br/>
      -- 4             2             Threshold count as indicated
      <br/>
      -- 5             2
      <br/>
      -- 6             2
      <br/>
      -- 7             3             Threshold count as indicated
      <br/>
      -- 8             3
      <br/>
      -- 9             3
      <br/>
      -- 10            4             Threshold count as indicated
      <br/>
      -- 11            4
      <br/>
      -- 12            4
      <br/>
      -- 13            4
      <br/>
      -- 14            5             Threshold count as indicated
      <br/>
      -- 15            5
      <br/>
      -- 16            5
      <br/>
      -- --       --
      <br/>
      -- 32            8             Threshold count as indicated
      <br/>
      -- 33            8
      <br/>
      -- --       --
      <br/>
      -- 64            10            Threshold count as indicated
    </p>
    <p num="77">
      This count based Adapter (or Controller) Interrupt Reduction (AIR) has some limitations over the timer based SIR approach.
      <br/>
      In some situations, it is possible that all pending input/output may be taking a relatively long time as compared to a different request that comes in a takes a relatively short time.
      <br/>
      For example, a magnetic tape rewind or a CD-ROM access may typically take longer than a hard disk drive access.
      <br/>
      For an event counter based approach, each event nominally has the same weight independent of its duration.
      <br/>
      Where a system includes both fast and slow response devices, some additional benefit is provided by posting the system interrupt to the host in response to a timer which generates an indication or signal after some predetermined amount of time has expired after posting the first input/output completion.
      <br/>
      This predetermined timer timeout may typically be chosen to be between 25% and 100% of the average response time, but the timer timeout is not limited to this range.
    </p>
    <p num="78">
      For example, for a disk drive device which has a average response (access) time of about 8 millisec, the timer timeout value would typically be set between 2 millisec (25% value) and 8 millisec (100% value).
      <br/>
      The inventive Adapter Interrupt Reduction method may readily be implemented in software or firmware procedures executing on the controller hardware.
      <br/>
      They may also be implemented in special purpose hardware which implements the same procedure.
    </p>
    <p num="79">
      An exemplary procedure for an adapter interrupt reduction slave (secondary) controller procedure 1100 is now described relative to FIG. 11. The AIR-SCP procedure 1100 is entered upon receipt of a request by the controller (Step 1106).
      <br/>
      In order to accommodate equipment that may not be enabled to implement the AIR procedures, the procedure includes optional steps to accommodate different hardware implementations.
      <br/>
      After receipt of the request (Step 1106), the controller determines whether it is possible to process the request (Step 1108).
      <br/>
      If it is possible to process the request, it is processed (Step 1110).
      <br/>
      The controller then determines whether it is possible to post completion of the input/output to the host memory (Step 1108).
      <br/>
      If it is possible to post completion (Step 1112), then the controller posts data/status transfer completion to host memory (Step 1114).
    </p>
    <p num="80">
      The number of completed input/output is incremented by 1 (Step 1116).
      <br/>
      Completion is posted to the host under predetermined conditions.
      <br/>
      In one embodiment, if the number of pending input/output is less than some predetermined number z (for example, in one embodiment z=8), then the interrupt is posted to the host (Step 1118).
      <br/>
      Furthermore, if the number of completed input/output since the last interrupt, then post the interrupt to the host (Step 1120).
    </p>
    <p num="81">
      The controller continues to receive requests, process requests, and post data/status transfer completion until a predetermined number of requests have been completed.
      <br/>
      Once the predetermined number of requests have been completed, the controller posts the interrupt to the host (Step 1124) for interrupts.
      <br/>
      It is noted that this description refers to "posting data/status transfer completion" and "posting the interrupt."
    </p>
    <p num="82">
      An exemplary procedure for an adapter interrupt reduction host controller procedure is now described relative to FIG. 12. The procedure in entered upon receipt of a physical interrupt to the host system by any controller (Step 1202).
      <br/>
      In an alternative embodiment the procedure may alternatively or additionally be entered in response to a timer timeout condition (Step 1203).
      <br/>
      Upon receipt of the controller generated interrupt, the host identifies which controller sent the interrupt (Step 1208) and acknowledges receipt to the sending controller (Step 1210).
      <br/>
      The host then processes all completed input/output from the particular controller (Step 1212).
      <br/>
      Processing the completed input/output may for example include, updating status (Step 1214), informing the requestor about the request (Step 1215), and freeing local resources (Step 1216) .
      <br/>
      Host operations, suspended earlier are resumed (Step 1218) after processing the completed input/output.
    </p>
    <p num="83">We now describe an additional aspect or enhancement to the inventive SIR and AIR stucture and method referred to as Clustererd Command Completion.</p>
    <p num="84">
      The inventive Clustered Command Completion advantageously operates in an environment where the number of interrupts are reduced so that other overhead resulting from interrupt processing generally is reduced.
      <br/>
      For example, the reduction may be achieved by controlling the number of interrupts by delaying communication of the interrupt to the host computer or processor according to predetermined rules.
      <br/>
      Reducing the number of interrupts effectively reduces the processing overhead and greatly increases system performance, particularly in a system including RAID disk drive storage arrays.
      <br/>
      Structure and method for reducing computer host system interrupts and adaptor interrupts is disclosed in co-pending U.S. Provisional Patent Application No. 60/088,201 (Attorney Docket No. P-65781/AJT/RMA) filed Jun. 5, 1998 to K. Kailash and titled "APPARATUS AND METHOD FOR COMPUTER HOST SYSTEM AND ADAPTOR INTERRUPT REDUCTION" which is hereby incorporated by reference in its entirety.
    </p>
    <p num="85">
      One procedure described in the above referenced patent application, includes the following steps: detecting the occurrence of an input/output interrupt related to a device; reserving notification to the host processor of the input/output interrupt for a period of time according to predetermined rules; and notifying the host processor of all input/output interrupts for which notification has been reserved during the period of time at the expiration of the period of time.
      <br/>
      Other variations of this process are described in the Kailash patent application and furthermore, other structures and methods for reducing interrupts may alternatively be used.
      <br/>
      The use of a system interrupt reduction (SIR) scheme such as that describe or a scheme offering comparable functionality (even if not the same degree of overhead or interrupt reduction) helps to collect all completed I/O requests at the same time without any additional burden.
      <br/>
      The embodiments of the invention described below typically assume that some system interrupt reduction scheme is operating.
    </p>
    <p num="86">
      The description also assumes that every structure passed for completion has at least one data field which can be used to chain the completed IO request, and that every structure received for I/O request has at least one bit available to indicate if clustered completion can be done.
      <br/>
      The reasons the described embodiments benefit from having a data field for chaining and a bit available as a clustered completion enabled flag will be understood in the context of the detailed description below.
    </p>
    <p num="87">
      We now highlight some of the operational theory on which the inventive Clustered Command Completion (CCC) structure and method are based.
      <br/>
      Clustered Command Completion is a method in which items received from one or more device drivers (for example, a device driver in a disk drive controller) are clustered in a linked-list data structure and delivered to the requestor when an appropriate interrupt occurs.
      <br/>
      In the preferred embodiment of the invention, an appropriate interrupt is an interrupt which occurs under the System Interrupt Reduction procedures already described., however other interrupt reduction procedures (independent of what they are called) may also be used.
      <br/>
      Such interrupt reduction schemes essentially collect the interrupts, and the clustered command completion gathers interrupts and sends them out simultaneously as a linked list.
      <br/>
      The linked list is sent to the requestor all at the same time thereby minimizing the overhead and providing the advantages described herein.
    </p>
    <p num="88">
      By way of example, but not limitation, the inventive clustered command completion structure and method may advantageously be used for a network controller, a disk controller, a RAID controller, or any other device.
      <br/>
      Actually, the inventive procedure is typically implemented at the software/firmware driver level of the device controller.
    </p>
    <p num="89">
      One embodiment of the inventive CCC structure is illustrated in FIG. 13. We note that the inventive structure includes a controller 1302 in which portions of the interrupt reduction is accomplished as already described, coupled to a host processor 1304 to that controller in which the system side of the interrupt reduction procedure is accomplished, some controlled device 1304 such as a disk drive or a RAID system, and host memory 1306 in which is defined a linked list data structure as well as other buffers described in greater detail hereinafter to support the CCC procedures.
      <br/>
      The procedures executing on the host should understand the linked list data structure and be able to sense and utilize various flags identifying compatibility with the CCC procedure.
    </p>
    <p num="90">The combination of controller, controlled device(s), host to that controller, and host memory may itself define a complete I/O system, or may represent only an I/O subsystem which is part of a larger system having a main host 1310 and a plurality of subsystems.</p>
    <p num="91">
      The inventive CCC procedure executing in the device drivers of the controller host.
      <br/>
      An I/O request buffer 1402 is provided which includes a storage element for a clustered completion mode bit (CCM bit) 1404 as well as data and command status.
      <br/>
      It is noted that the requestor builds the I/O request buffer when it asks for data from a device.
      <br/>
      If a driver, such as a disk drive driver is capable of accepting the completed command in clustered mode for a particular data read or write request, it sets the clustered completion mode (CCM) bit in the I/O request buffer 1402.
      <br/>
      For example, a driver may set the CCM bit for read/write request but not for a management-type (IOCTL) request, which are typically rare events.
      <br/>
      The read/write request may be supported for CCM while IOCTL may not be supported because, one is not typically interested in performance for rare events such as management and it is not efficient to implement the complexity of the CCM procedure in such instances.
    </p>
    <p num="92">
      When an I/O operation completes, an interrupt handler of the device driver performs several operations, including the following four operations: (i) Gathers all completed IO requests (which can be completed in clustered mode) to same receiver function (same call back function or equivalent); (ii) Chain all completed request with last I/O in chain pointing to NULL or other selected token, where NULL identifies the end of the chain; (iii) Send completion to requestor with one I/O pointer (having a single address) which is the head of the chained request and providing additional addresses for each element in the list via the linked list structure with the last element pointing to the afore described NULL; and (iv) free up all local resources, preferably in a single step based on the linked list.
      <br/>
      Freeing up all resources in this manner is advantageous, but optional and not required.
    </p>
    <p num="93">
      Having described the inventive concept and operations, we now describe one particular embodiment of the invention.
      <br/>
      For purposes of this exemplary embodiment, we assume that most of the read/write request will be coming from one requestor at any given time.
      <br/>
      Under this assumption we will complete only one clustered command, and complete other I/O requests as individual commands.
    </p>
    <p num="94">
      Now we address some definitional matters.
      <br/>
      Posting completion refers to a process by which command status information is provided to the requestor.
      <br/>
      For example, posting completion may entail providing information that 512 bytes of data were read, that the read operation was successfully completed, that there were no read errors, or alternatively that no bytes were read, that the read operation could not be completed, and the like.
      <br/>
      This is the conventional definition of posting completion for an I/O operation.
    </p>
    <p num="95">
      The Clustered Command Completion procedure provides for a data structure defined in host memory 1308 for providing a request buffer (mdac_req_t) 1402 used by a device driver, a chaining field (rq_Next), and a clustered completion mode (CCM) bit which is part of a larger a clustered completion operations flag (rq_OpFlags) having several bits.
      <br/>
      The other bits in the operations flag are not of particular concern to the CCC procedure, but may for example include, the nature of the operation (for example, read or write), whether the operation has been completed, whether any error occurred during the operation, and the like information.
      <br/>
      The request buffer is used for internal chaining and for storing an indication of clustered completion.
    </p>
    <p num="96">
      A first chain, referred to as Completed I/O Chain, is created for completed I/O by picking up all completed I/O request to the device driver interrupt handler.
      <br/>
      The Completed I/O Chain includes all completed I/O independent of whether clustering is enabled or not enabled for that driver or I/O.
      <br/>
      Completed I/O is typically picked up in time order sequence.
      <br/>
      A second chain, referred to as Clustered Completed IO Chain, is created from the first Completed I/O Chain by filtering that first chain to separate clusterable items for those items that cannot or are chosen not to be clustered.
    </p>
    <p num="97">
      The interrupt handler, typically implemented by a firmware procedure in the device driver, performs the following steps to collect the completed I/O request and create Completed I/O Chain.
      <br/>
      First (Step 2701), the interrupt handler selects a controller for I/O completion from among the several controllers in the I/O system, and where required or desired locks the controller (locking is typically required for multiprocessor system).
      <br/>
      Locking is desirable to prevent simultaneous access, and later unlocking again enables access by other processes.
      <br/>
      The controllers are generally selected in accordance to some predetermined rules, typically sequential order or the like.
      <br/>
      The manner of selection may be conventional and not important to the invention and therefore not described further.
    </p>
    <p num="98">
      Second (Step 2702), the interrupt handler, selects a completed I/O request and completes all status in all aspects except for posting the completion to the requestor and optional statistics collection.
      <br/>
      Third (Step 2703), the interrupt handler chains the completed I/O (data and status) from the controller with previously completed I/O.
      <br/>
      Fourth (Step 2704), if there are more completed I/O requests, then the interrupt handler selects the next completed I/O, and the above steps (Steps 2701-2703) are performed in the similar manner.
      <br/>
      That particular controller is then unlocked (Step 2705) to reenable access by others.
      <br/>
      Fifth (Step 2706), if there are more controllers to be checked, the interrupt handler selects the next controller based on predetermined rules, for example selects the next sequential controller, or selects according to a list stored on the system.
      <br/>
      The afore described steps of the process are then repeated for the next selected controller. (See FIG. 15.)
    </p>
    <p num="99">
      After all, or a predetermined set of, controllers have been checked, the interrupt handler performs the following procedures to post completion to the requestor and to create the Clustered Completed I/O Chain.
      <br/>
      In the preferred embodiment, all controllers are checked.
    </p>
    <p num="100">
      Posting completion to the requestor and creation of the second chain, or Clustered Completed I/O Chain, is performed by a procedure including the following steps.
      <br/>
      First (Step 2602), a NULL Clustered Completed I/O Chain is initiated or generated.
      <br/>
      Next (Step 2603), the first I/O request stored or identified in the previously created Completed I/O Chain is taken from the completed I/O chain and placed into the clustered completed I/O chain if it can be clustered, or posted in conventional manner if it cannot be clustered.
      <br/>
      Statistics may optionally be collected if desired if statistics collection is enabled (Step 2605).
    </p>
    <p num="101">If the particular I/O request taken from the Complete I/O chain does not have a clustered completion flag set (that is, if the CCM bit is not enabled, or if the operating system or device driver does not recognize CCC mode) then (Step 2606) the completion is posted to the requestor in conventional manner (Step 2609).</p>
    <p num="102">
      If the Clustered Completed IO Chain is NULL, queue this I/O request in the Clustered Completed I/O Chain and follow the procedure described above.
      <br/>
      If Completed IO Chain is not NULL, and if this request does not have same completion function, that is the same name associated with the completion as the first name as previous clustered completed I/O (See Step 2608), post the completion to the requestor (Step 2609).
      <br/>
      It is noted that in this particular embodiment of the CCC procedure, the first entry in the linked list defined the name to be associated with the linked list.
      <br/>
      For example if the first entry in the list is for a RAID device, then that list will be associated only with the RAID device.
      <br/>
      From this one may observe that this particular embodiment is optimized for a system having I/O requests predominantly from a dingle device type.
      <br/>
      However, the inventive CCC procedure is applicable and readily may be extended to support multiple linked lists for a plurality of device types, and to provide an additional level of filtering to not only separate clusterable form non-clusterable entries, but also to select from among multiple clusters.
      <br/>
      In such instances, multiple Clustered Completed I/O chains would be generated and exist concurrently.
      <br/>
      Otherwise the essential features and procedure remain the same.
    </p>
    <p num="103">
      If Completed IO Chain is not NULL, then a determination is made as to whether the request has the same completion function as the previous clustered completed I/O.
      <br/>
      If it does then that event is queued in the Clustered Completed I/O chain (Step 2610), otherwise the completion is posted to the requestor in conventional manner (Step 2609) Finally (Step 2611), post the completion to the requestor with first request in the Clustered Completed IO Chain.
    </p>
    <p num="104">The diagrammatic flow chart illustrations in FIG. 14, FIG. 15, and FIG. 16 illustrate top level, first chain gneration, and second chain generation respectively.</p>
    <p num="105">
      In the above described method and procedures, certain of the steps described may be considered advantageous or beneficial but are optional and not required, for example the following steps may be eliminated or modified, without detracting from the fundamental character of the invention: For example, one may optionally provide either single or multiple clustering as described.
      <br/>
      Collection of statistics is optional.
      <br/>
      Finally, other interrupt reduction procedures may be used instead of the inventive SIR or AIR procedures described herein.
      <br/>
      For example, under one interrupt reduction procedure, no interrupts are generated for outgoing data, the data is merely sent and that is enough.
    </p>
    <p num="106">
      We now consider the effect on the. overhead on Very Light Load.
      <br/>
      If interrupt handler posts one I/O request per clustered completion, it adds little extra overhead compared to non-clustered completion.
      <br/>
      Every layer in the may typically be expected to add at least 6 extra instructions to overhead.
      <br/>
      The overheads arise from: (i) Completion overhead, including (a) Saving the head of I/O request (one or two instruction), (b) One compare instruction, and (c) One jump instruction; and (ii) free buffer/resource overhead, including (a) restoring the head of I/O request (one or two instruction), (b) One compare instruction, and (c) One jump instruction.
      <br/>
      If system is not loaded, this little extra overhead does not matter much other than academic reasons.
    </p>
    <p num="107">
      The foregoing description, for purposes of explanation, used specific nomenclature to provide a thorough understanding of the invention.
      <br/>
      However, it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention.
      <br/>
      In other instances, well known structures and devices are shown in block diagram form in order to avoid unnecessary distraction from the underlying invention.
      <br/>
      Thus, the foregoing descriptions of specific embodiments of the present invention are presented for purposes of illustration and description.
      <br/>
      They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, many modifications and variations are possible in view of the above teachings.
      <br/>
      The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated.
      <br/>
      Therefore, while the invention has been described with reference to specific embodiments, the description is illustrative of the invention and is not to be construed as limiting the invention.
      <br/>
      Thus, various modifications and amplifications may occur to those skilled in the art without departing from the true spirit and scope of the invention as defined by the appended claims.
    </p>
    <p num="108">All publications and patent applications mentioned in this specification are herein incorporated by reference to the same extent as if each individual publication or patent application was specifically and individually indicated to be incorporated by reference.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>In a computer system having a host processor and a first plurality of peripheral devices coupled to said host processor by a second plurality of peripheral device controllers, one of said peripheral device controllers identified as a master controller, a method for reducing, over a predetermined amount of time, the number of system interrupts to said host processor comprising:</claim-text>
      <claim-text>for each said peripheral device controller; receiving a request for interrupt; determining if said device controller is enabled to delay processing of said requested interrupt and:</claim-text>
      <claim-text>- (i) if said device controller is enabled to delay processing of said requested interrupt then processing said interrupt with delay, said processing with delay including a step of posting data and status transfer completion;</claim-text>
      <claim-text>and - (ii) if said device controller is not enabled to process said requested interrupt with delay, then processing said interrupt without delay;</claim-text>
      <claim-text>and, determining if said device controller is enabled to post completion of the interrupt request, and: - (iii) if said device controller is enabled to post completion of the interrupt request, then posting data and status transfer completion to said host processor;</claim-text>
      <claim-text>and - (iv) if said device controller is not enabled to post completion of the interrupt request, then posting completion of the interrupt request in conventional manner.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method in claim 1, further comprising: for said master controller, a step of determining whether said master controller or a slave controller has completed any input/output within a predetermined elapsed time period, and generating an interrupt from said master controller to said host processor.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method in claim 2, wherein said step of determining whether the master or slave controller has completed any input/output within a predetermined elapsed time period comprises a step of: testing said slave controller according to predetermined rules for a controller that has completed at least one input/output;</claim-text>
      <claim-text>and, if said slave controller has completed at least one input/output, generating a signal indicating that at least one controller has completed an input/output operation.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method in claim 3, wherein said predetermined rules comprise steps of: testing said slave controller sequentially until a controller that has completed at least one input/output is identified; stopping testing of said slave controller;</claim-text>
      <claim-text>and, generating a signal indicating that at least one controller has completed an input/output operation.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method in claim 4, wherein for said slave controller, said method further comprises: providing a memory storage for storing a completed input/output count (CIOC), initializing said stored CIOC after said master controller has interrupted said host to inform said host of the all interrupts pending by said slave controller, and incrementing said CIOC for each completed input/output operation by said slave controller;</claim-text>
      <claim-text>and wherein said step of testing of said slave controller comprises a step of querying said stored CIOC at predetermined time intervals, said step of querying comprising steps of: - reading a prior CIOC stored during the poor time interval; - reading a current CIOC stored during the present time interval; - if said current CIOC is greater than said prior CIOC, generating a first signal indicating that input/output has been completed since a last predetermined interval if said current CIOC is greater than said prior CIOC;</claim-text>
      <claim-text>and, - if said current CIOC is not greater than said prior CIOC, not generating said first signal or generating a second signal indicating that no input/output has been completed by said slave controller since the last predetermined interval.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method in claim 5, wherein said predetermined time intervals are defined by a periodic clock signal, and wherein said method further comprises a step of operating a clock within said master controller which operates substantially continuously and generates a master interrupt signal every period of time t, said master controller performing said step of testing of said slave controller in response to receipt of each said master controller interrupt signal.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method in claim 6, wherein said period of time t, is a period of time in the interval between substantially 0.1 milliseconds and 10 milliseconds.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method in claim 6, wherein said period of time t, is a period of time in the interval between substantially 1 milliseconds and 5 milliseconds.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method in claim 6, wherein said period of time t, is a programmable period of time stored in a memory store, said predetermined time interval being programmable in the range between substantially 0.5 milliseconds and 5 milliseconds.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method in claim 1 further comprising prior to said receiving a request for interrupt, steps of: choosing one of said plurality of device controllers as a master controllers; identifying said selected one of said plurality of controllers as said master controller; identifying other of said controllers as slave controllers;</claim-text>
      <claim-text>and, allocating a master-slave communication memory storage space in memory for storage of completed input/output count (CIOC) information.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method in claim 10, wherein said step of choosing of said master controller comprises choosing as said master controller, any one of said plurality of controllers arbitrarily.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method in claim 10, wherein said step of choosing of said master controller comprises choosing as said master controller, the one of said plurality of controllers expected to have the most input/output based on predetermined factors.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method in claim 10, wherein said step of choosing of said master controller comprises choosing as said master controller, the one of said plurality of controllers as the controller that is first-in-first-served.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method in claim 10, wherein said step of choosing of said master controller comprises choosing as said master controller, the one of said plurality of controllers dynamically based on the controller load.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method in claim 14, wherein said step of choosing of said dynamically chosen master controller, the dynamically chosen master controller changes from time-to-time during operation of said computer system.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method in claim 1, wherein said computer system comprises a network server computer system.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method in claim 16, wherein said network computer system further comprises a first plurality of disk drives coupled to said master controller and a second plurality of disk drives coupled to said slave controller, and wherein said method further comprises receiving requests for interrupts from said first and second plurality of disk drives.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method in claim 17, wherein said network computer system further comprises a third plurality of workstations coupled to a second slave controller.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method in claim 1, wherein said step of determining whether any controller has completed any input/output within a predetermined elapsed time period comprises steps of: evaluating whether said master controller has completed any input/output since the last time period expired; identifying, after the step of evaluating, if said slave controller has completed any input/output within said predetermined elapsed time period.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The method in claim 1, wherein said computer system includes a timer circuit that generates an interrupt every predetermined number of seconds to provide said master controller interrupt.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The method in claim 1, wherein said step of processing with delay further comprises steps of: posting data and status transfer completion to said host processor;</claim-text>
      <claim-text>and, writing a number of completed input/output counts (CIOC) into memory for each completed input/output.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The method in claim 1, wherein said system further comprises a hardware interrupt generator, and wherein said step of processing with delay further comprises a step of posting data and status transfer completion information to said hardware interrupt generator.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. In a computer system having a host processor and a peripheral device coupled to said host processor by a device controller, a method for reducing the number of system interrupts to said host processor to reduce host processor overhead, said method comprising: detecting the occurrence of an input/output interrupt related to a device; reserving notification to said host processor of said input/output interrupt until expiration of a predetermined period of time according to a set of predetermined rules that are used to determine whether a master or a slave controller has completed any input/output within a predetermined elapsed time period;</claim-text>
      <claim-text>and, notifying said host processor of all input/output interrupts for which notification has been reserved during said predetermined period of time at the expiration of said predetermined period of time, said reserved notification lowering the overhead to said host processor in handling said input/output interrupts.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A method for clustering command completion prior to posting completion comprising: identifying completed I/O requests which can be completed in clustered mode; gathering all completed I/O requests which can be completed in clustered mode to the same receiver function; chaining all completed requests with the last I/O in the chain;</claim-text>
      <claim-text>and sending completion to requestor with one pointer which is at the head of the chained request.</claim-text>
    </claim>
  </claims>
</questel-patent-document>