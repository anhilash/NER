<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185577B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185577</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185577</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22295619" extended-family-id="42113631">
      <document-id>
        <country>US</country>
        <doc-number>09103515</doc-number>
        <kind>A</kind>
        <date>19980623</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09103515</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43171923</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>10351598</doc-number>
        <kind>A</kind>
        <date>19980623</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09103515</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  17/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F  11/14        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>14</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <further-classification sequence="1">
        <text>707999201</text>
        <class>707</class>
        <subclass>999201</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>707999202</text>
        <class>707</class>
        <subclass>999202</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>707E17005</text>
        <class>707</class>
        <subclass>E17005</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>714015000</text>
        <class>714</class>
        <subclass>015000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>714E11130</text>
        <class>714</class>
        <subclass>E11130</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/30368</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30368</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130814</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/1471</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>1471</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20150924</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/1474</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>1474</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20150924</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/30377</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30377</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130814</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99952</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99952</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="6">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99953</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99953</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>18</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>6</number-of-drawing-sheets>
      <number-of-figures>8</number-of-figures>
      <image-key data-format="questel">US6185577</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and apparatus for incremental undo</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>BAKER JERRY W, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4498145</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4498145</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>STOLFO SALVATORE J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5363473</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5363473</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>SAETHER CHRISTIAN D</text>
          <document-id>
            <country>US</country>
            <doc-number>5481699</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5481699</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>LOMET DAVID B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5524205</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5524205</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>HARRIS JACK C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5835698</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5835698</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>NGAI GARY C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5850507</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5850507</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>BOHANNON PHILIP LEWIS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5864849</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5864849</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>BAMFORD ROGER J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5870758</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5870758</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>CHEN QIMING, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5940839</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5940839</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>NORI ANIL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5999943</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5999943</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Strom et al "Optimistic Recovery in Distributed systems", ACM Transactions on Computer Systems, vol. 3, No. 3, Aug. 1985, pp. 204-226.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Weikum et al "Multi-Level Recovery", ACM 1990, pp. 109-123.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Gomes et al "Multiplexed State Saving for Bounded Rollback", Proceedings of the 1997 Winter simulation conference, Atlanta, GA, pp. 460-467.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>Microsoft Word User's Guide. Microsoft Corporation. 1993, pp. 14, 15, 40.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Oracle Corporation</orgname>
            <address>
              <address-1>Redwood Shores, CA, US</address-1>
              <city>Redwood Shores</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>ORACLE</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Nainani, Bhagat</name>
            <address>
              <address-1>Foster City, CA, US</address-1>
              <city>Foster City</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Ngai, Gary C.</name>
            <address>
              <address-1>Saratoga, CA, US</address-1>
              <city>Saratoga</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Huang, Wei</name>
            <address>
              <address-1>Foster City, CA, US</address-1>
              <city>Foster City</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Klein, Jonathan D.</name>
            <address>
              <address-1>Redwood City, CA, US</address-1>
              <city>Redwood City</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="5">
          <addressbook lang="en">
            <name>Bamford, Roger J.</name>
            <address>
              <address-1>San Francisco, CA, US</address-1>
              <city>San Francisco</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Lyon &amp; Lyon LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Black, Thomas G.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method and apparatus for incremental undo is provided.
      <br/>
      A process, executing in a database system, establishes a rollback entry in an undo log file as a current rollback entry.
      <br/>
      The rollback entry, which was selected from a set of rollback entries contained in an undo record, contains data that indicates a change made by a transaction to a data block in the database system.
      <br/>
      The process first determines whether the rollback entry has been applied by testing a status flag.
      <br/>
      In one embodiment, the status flag is a bit in a bit vector in the undo block.
      <br/>
      If the rollback entry has been applied to the database, then the rollback entry is not re-applied; rather, a next rollback entry is established from the set of rollback entries and the process repeats.
      <br/>
      If the rollback entry has not been applied, then undo information from the rollback entry is retrieved from the undo block and change is generated.
      <br/>
      The status flag is set to indicate that the rollback entry has been applied and a next rollback entry corresponding to the data block is retrieved.
      <br/>
      The process repeats until there are no more rollback entries to be performed, then the multiple changes are applied to disk in a single atomic operation.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates to log files in a database management system, and more specifically to a method and apparatus for incrementally applying an undo record during transaction recovery or rollback.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      In a database management system (DBMS) executing a transaction that updates, deletes or modifies a body of data, the possibility exists for the transaction to fail (e.g., a communication failure) or for the computer system to fail (e.g., a device failure or a power failure).
      <br/>
      In either event, it is likely that changes made by one or more committed transactions will not yet have been written to disk, and/or that changes made by one or more uncommitted transactions will have been written to disk.
    </p>
    <p num="3">
      Transaction failures and computer failures are highly undesirable in a DBMS.
      <br/>
      One reason why failures in a DBMS can be particularly undesirable is because a DBMS can have hundreds or even thousands of users concurrently accessing and updating data.
      <br/>
      Changes written to disk by uncommitted transactions that fail can corrupt the database by placing the database in an inconsistent state.
      <br/>
      Similarly, the database can be corrupted by a failure if changes made by a committed transaction are lost before they are written to disk.
    </p>
    <p num="4">
      Maintaining log files is one method for protecting data from becoming corrupted by the occurrence of failures.
      <br/>
      A redo log is a record of changes made by transactions.
      <br/>
      An undo log is a record of how to undo changes made by transactions.
      <br/>
      Together, the redo log and the undo log assist in recovery of a DBMS after a failure.
    </p>
    <p num="5">
      FIG. 1 depicts a recovery process 100 that involves two general phases: a "redo" phase and an "undo" phase.
      <br/>
      Database 102 needs to be recovered (e.g., a power failure occurred).
      <br/>
      Prior to the failure, two transactions 132 and 136 performed changes to data contained in database 102.
      <br/>
      One of those transactions, transaction 132, committed prior to the failure.
      <br/>
      Transaction 132 is said to have committed because the change(s) completed and were persistently saved to disk in redo log 112, even though the changes themselves were not applied to the database 102.
      <br/>
      Transaction 136 was also written to redo log 112, which was persistently saved to disk; it too did not get applied to disk.
      <br/>
      However, transaction 136 did not commit.
    </p>
    <p num="6">
      Referring to the state of the DBMS depicted in FIG. 1, immediately after the power failure, changes made by committed transaction 132 are not reflected in database 102.
      <br/>
      However, changes made by a committed transaction must be durable, which means that they must persist on disk even if a failure occurred.
    </p>
    <p num="7">
      Redo log 112 fixes part of the problem.
      <br/>
      The redo log 112 contains a series of redo records that save changes made by statements in each transaction. (The redo log 112 may contain data for multiple transactions.) Redo log 112 is temporarily stored in memory and is saved to disk at a regular interval, called a savepoint, or by explicit or implicit instruction from a user or process (e.g., a redo log runs out of space in memory and must flush the redo to disk).
    </p>
    <p num="8">
      Redo log 112 contains redo records for changes made by committed transaction 132 and uncommitted transaction 136.
      <br/>
      When the database 102 is recovered, the first step in the recovery process is to apply the redo log 112, specifically, to apply the changes recorded in redo log 112 to database 102.
      <br/>
      After the redo log 112 has been applied, the database 102 will look like database 104, which reflects the changes made by transactions 132 and 136.
    </p>
    <p num="9">
      As may be apparent, applying redo log 112 created a problem, specifically, changes made by uncommitted transaction 136 are reflected in database 104.
      <br/>
      However, changes made by an uncommitted transaction must be removed from the database after a failure occurs.
      <br/>
      Uncommitted transactions should not be durable.
      <br/>
      Thus, the data modified by the changes made by transaction 136 is in an inconsistent state.
      <br/>
      The undo log 120 is designed to fix this problem.
    </p>
    <p num="10">
      Undo log 120 comprises one or more rollback segments.
      <br/>
      For example, segment 122 contains data for undoing the changes made by uncommitted transaction 136.
      <br/>
      After the redo phase, an "undo phase" is performed.
      <br/>
      During the undo phase, the undo log 120 is used to remove from the database 104 changes that were made to the database 104 by uncommitted transactions.
      <br/>
      Database 106 is a version of database 104 after applying undo log 120.
      <br/>
      Notice that changes made by uncommitted transaction 136 are not contained in database 106.
    </p>
    <p num="11">
      Thus, the changes made by uncommitted transaction 136, which were made when redo log 112 was applied in the redo phase can be "rolled back" using undo log 120 in the undo phase.
      <br/>
      As uncommitted transaction 136 is rolled back, each change made by transaction 136 is undone, one complete undo record at a time, in an opposite order than the order in which the changes were made.
    </p>
    <p num="12">
      The undo process described above, whereas simple and predictable, has significant drawbacks.
      <br/>
      For example, each undo record in the undo log 120 comprises an undo header and a single rollback entry (or "change").
      <br/>
      Consequently, when rollback entries in the same undo block store similar information in their headers (e.g., same table space, block identifier, etc.) valuable space is wasted in the undo block.
      <br/>
      Further, valuable processing resources may also be wasted when generating a header for every rollback entry, as well as when reading the header for every rollback entry.
    </p>
    <p num="13">
      Further still, the undo records are applied to disk one complete undo record at a time, and then removed from the undo block to prevent the change from being applied more than once.
      <br/>
      This process further taxes valuable processing cycles.
    </p>
    <p num="14">There is a need for an improved method for applying an undo log.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="15">
      A method and system for incremental undo is provided.
      <br/>
      According to one aspect of the techniques described herein, an undo record can correspond to more than one data block.
      <br/>
      In one embodiment, a process, executing in a database management system, establishes a rollback entry as a current rollback entry.
      <br/>
      The rollback entry, which was selected from a set of rollback entries in an undo record, corresponds to a change made by a transaction to a data block in the system.
      <br/>
      The process determines whether the rollback entry has been applied.
      <br/>
      In one embodiment, this is accomplished by testing a status flag in the undo record.
    </p>
    <p num="16">
      According to one embodiment, if the rollback entry has been applied to the data block, then the rollback entry is not re-applied.
      <br/>
      Subsequently, a next rollback entry is established in the undo record and the process repeats.
      <br/>
      If the rollback entry has not been applied, then undo information from the rollback entry is retrieved from the undo record so the change recorded in the rollback entry may be applied to the data block.
      <br/>
      A change is generated for the data block based upon the rollback entry and the status flag is set to indicate that the entry has been applied.
      <br/>
      Subsequently, a next rollback entry corresponding to the data block is retrieved.
      <br/>
      The process repeats until there are no more rollback entries corresponding to the data block.
      <br/>
      According to one embodiment, the application of a plurality of rollback entries is performed as a single atomic operation.
    </p>
    <p num="17">
      An advantage of the techniques described herein is that more than one change can be stored in an undo record.
      <br/>
      Further, less overhead is used when recording changes in the undo record.
      <br/>
      Additionally, the undo information takes up less space both in memory and on persistent storage.
      <br/>
      Further, more than one change may be applied to disk in a single atomic operation.
      <br/>
      The overall result is a more efficient recovery process.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="18">
      The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:
      <br/>
      FIG. 1 is a block diagram of a recovery process;
      <br/>
      FIG. 2 is a block diagram of an undo log;
      <br/>
      FIG. 3 is a computer system for implementing one embodiment of the present invention;
      <br/>
      FIG. 4A is a block diagram of an undo block according to one embodiment of the present invention;
      <br/>
      FIG. 4B is block diagram of an undo record according to one embodiment of the present invention;
      <br/>
      FIG. 4C is a block diagram depicting a change vector;
      <br/>
      FIG. 5 is a flowchart depicting the steps for incrementally applying an undo record according to one embodiment of the present invention; and
      <br/>
      FIG. 6 is a block diagram depicting a persistent disk.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="19">
      A method and apparatus for incremental undo is described.
      <br/>
      In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention.
      <br/>
      It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details.
      <br/>
      In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.
    </p>
    <p num="20">Hardware Overview</p>
    <p num="21">
      FIG. 3 is a block diagram that illustrates a computer system 300 upon which an embodiment of the invention may be implemented.
      <br/>
      Computer system 300 includes a bus 302 or other communication mechanism for communicating information, and a processor 304 coupled with bus 302 for processing information.
      <br/>
      Computer system 300 also includes a main memory 306, such as a random access memory (RAM) or other dynamic storage device, coupled to bus 302 for storing information and instructions to be executed by processor 304.
      <br/>
      Main memory 306 also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor 304.
      <br/>
      Computer system 300 further includes a read only memory (ROM) 308 or other static storage device coupled to bus 302 for storing static information and instructions for processor 304.
      <br/>
      A storage device 310, such as a magnetic disk or optical disk, is provided and coupled to bus 302 for storing information and instructions.
    </p>
    <p num="22">
      Computer system 300 may be coupled via bus 302 to a display 312, such as a cathode ray tube (CRT), for displaying information to a computer user.
      <br/>
      An input device 314, including alphanumeric and other keys, is coupled to bus 302 for communicating information and command selections to processor 304.
      <br/>
      Another type of user input device is cursor control 316, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor 304 and for controlling cursor movement on display 312.
      <br/>
      This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.
    </p>
    <p num="23">
      The invention is related to the use of computer system 300 for incrementally applying undo information.
      <br/>
      According to one embodiment of the invention, incremental undo is provided by computer system 300 in response to processor 304 executing one or more sequences of one or more instructions contained in main memory 306.
      <br/>
      Such instructions may be read into main memory 306 from another computer-readable medium, such as storage device 310.
      <br/>
      Execution of the sequences of instructions contained in main memory 306 causes processor 304 to perform the process steps described herein.
      <br/>
      In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention.
      <br/>
      Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.
    </p>
    <p num="24">
      The term "computer-readable medium" as used herein refers to any medium that participates in providing instructions to processor 304 for execution.
      <br/>
      Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media.
      <br/>
      Non-volatile media includes, for example, optical or magnetic disks, such as storage device 310.
      <br/>
      Volatile media includes dynamic memory, such as main memory 306.
      <br/>
      Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus 302.
      <br/>
      Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.
    </p>
    <p num="25">Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.</p>
    <p num="26">
      Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor 304 for execution.
      <br/>
      For example, the instructions may initially be carried on a magnetic disk of a remote computer.
      <br/>
      The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem.
      <br/>
      A modem local to computer system 300 can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal.
      <br/>
      An infra-red detector coupled to bus 302 can receive the data carried in the infra-red signal and place the data on bus 302.
      <br/>
      Bus 302 carries the data to main memory 306, from which processor 304 retrieves and executes the instructions.
      <br/>
      The instructions received by main memory 306 may optionally be stored on storage device 310 either before or after execution by processor 304.
    </p>
    <p num="27">
      Computer system 300 also includes a communication interface 318 coupled to bus 302.
      <br/>
      Communication interface 318 provides a two-way data communication coupling to a network link 320 that is connected to a local network 322.
      <br/>
      For example, communication interface 318 may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line.
      <br/>
      As another example, communication interface 318 may be a local area network (LAN) card to provide a data communication connection to a compatible LAN.
      <br/>
      Wireless links may also be implemented.
      <br/>
      In any such implementation, communication interface 318 sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.
    </p>
    <p num="28">
      Network link 320 typically provides data communication through one or more networks to other data devices.
      <br/>
      For example, network link 320 may provide a connection through local network 322 to a host computer 324 or to data equipment operated by an Internet Service Provider (ISP) 326. ISP 326 in turn provides data communication services through the world wide packet data communication network now commonly referred to as the "Internet" 328.
      <br/>
      Local network 322 and Internet 328 both use electrical, electromagnetic or optical signals that carry digital data streams.
      <br/>
      The signals through the various networks and the signals on network link 320 and through communication interface 318, which carry the digital data to and from computer system 300, are exemplary forms of carrier waves transporting the information.
    </p>
    <p num="29">
      Computer system 300 can send messages and receive data, including program code, through the network(s), network link 320 and communication interface 318.
      <br/>
      In the Internet example, a server 330 might transmit a requested code for an application program through Internet 328, ISP 326, local network 322 and communication interface 318.
      <br/>
      In accordance with the invention, one such downloaded application provides for incremental application of an undo log as described herein.
    </p>
    <p num="30">
      The received code may be executed by processor 304 as it is received, and/or stored in storage device 310, or other non-volatile storage for later execution.
      <br/>
      In this manner, computer system 300 may obtain application code in the form of a carrier wave.
    </p>
    <p num="31">Functional Overview</p>
    <p num="32">
      A method and system are provided for incrementally applying undo information.
      <br/>
      According to one aspect of the invention, a single undo record stores rollback entries for changes to more than one data block.
      <br/>
      In addition, individual rollback entries within a given undo record need not be applied as a single atomic operation.
      <br/>
      Rather, a selected set of one or more rollback entries within the undo record may be applied completely independent of the other rollback entries within the same undo record.
      <br/>
      Flags within the undo record are provided for keeping track of which rollback entries have and have not been applied.
    </p>
    <p num="33">
      According to one embodiment, a process, executing in a database system, establishes a rollback entry in an undo record as a current rollback entry.
      <br/>
      The rollback entry, which was selected from a set of rollback entries contained in the undo record, corresponds to a change made by a transaction to a data block in the database system.
      <br/>
      The process first determines whether the rollback entry has been applied.
      <br/>
      In one embodiment, this is accomplished by testing a bit vector in the undo record.
      <br/>
      For example, if a bit corresponding to a particular rollback entry is set to TRUE, then the rollback entry has already been applied to the data block.
      <br/>
      However, if the bit is set to FALSE, then the rollback entry has not been applied to the data block.
    </p>
    <p num="34">
      If the rollback entry has been applied to the data block, then the rollback entry is not re-applied; rather, a next rollback entry in the undo record is established and the process repeats.
      <br/>
      If the rollback entry has not been applied, then undo information from the rollback entry is retrieved from the undo record and a change is generated for the data block.
      <br/>
      A status flag is set to indicate that the rollback entry has been performed and a next rollback entry corresponding to the data block is retrieved.
      <br/>
      The process repeats until there are no more rollback entries to apply to that data block, then the generated changes are written to disk in a single atomic operation.
      <br/>
      If all the rollback entries have been applied, the undo record will be removed from the transaction undo chain.
      <br/>
      The next undo record will become the current rollback entry.
    </p>
    <p num="35">Undo Log Structures</p>
    <p num="36">
      FIG. 2 illustrates the structure of an undo log 200 according to one embodiment of the present invention.
      <br/>
      Undo log 200 comprises a rollback segment 204.
      <br/>
      Segment 204 comprises a plurality of extents 212, 214, 216 and 218.
      <br/>
      An extent is a logical unit of database storage space.
      <br/>
      Extents 212, 214, 216 and 218 are used to store a plurality of contiguous undo blocks.
      <br/>
      Each undo block in an extent may store a plurality of undo records.
    </p>
    <p num="37">
      In order to keep track of changes made by each transaction, undo log 200 also contains a transaction table 260 to record information about the changes of each transaction stored in the segment 204.
      <br/>
      The transaction table 260 is useful in identifying the most recently saved undo record(s) for a transaction.
      <br/>
      For example, in transaction table 260, transaction identifier 262 identifies a particular transaction and pointer 264 points to an undo record in a string of undo records for the particular transaction identified by identifier 262.
      <br/>
      Likewise, transaction identifier 266 identifies a particular transaction and pointer 268 points to an undo record in a string of undo records associated with transaction identifier 266, as do transaction identifier 270 and pointer 272.
    </p>
    <p num="38">Although not depicted in FIG. 2, segment 204 may keep a header for additional information about changes stored therein, for example information about the transactions, data blocks and undo blocks in the segment 204.</p>
    <p num="39">
      According to one embodiment, additional data structures are also associated with the undo log 200.
      <br/>
      It is useful to describe these data structures before describing, in detail, the steps of incremental undo.
    </p>
    <p num="40">
      An additional data structure used by undo log 200 is undo block 450, which is depicted in FIG. 4A. According to one embodiment, undo block 450 is employed as a data structure in which general information about undo records is stored, as well as the undo records themselves.
      <br/>
      The undo block 450 is used to help the undo process identify and navigate to particular undo records 472 (depicted in further detail with reference to FIG. 4B).
      <br/>
      The undo block 450 is typically stored on persistent disk (e.g., storage device 310).
    </p>
    <p num="41">
      Another data structure is undo record 472, depicted in FIG. 4B. An undo record 472 stores general information about the rollback entries therein, as well as the rollback entries themselves.
      <br/>
      The undo record stores the specific change information for data blocks updated, deleted or modified by changes in a transaction.
      <br/>
      The undo record 472 depicted in FIG. 4B is a linearized structure and it is typically stored on disk.
    </p>
    <p num="42">
      Yet another data structure, depicted in FIG. 4C, is a change vector 400.
      <br/>
      According to one embodiment, a change vector 400 is employed as a data structure in which undo information is stored in memory (e.g., main memory 306) before being saved to disk.
      <br/>
      The change vector 400 is used to help the undo process identify and navigate to a particular rollback entry.
    </p>
    <p num="43">Each of the additional structures referenced above shall be described in greater detail below.</p>
    <p num="44">
      Undo block 450, as depicted in FIG. 4A, holds data representing the changes made to one or more data blocks in the database system.
      <br/>
      According to one embodiment, undo block 450 comprises a block header 454, an array of offsets 458, 460 and 462, and undo records 468, 470 and 472.
      <br/>
      According to one embodiment, the block header 454 is used to identify and the undo records (e.g., 468, 470 and 472) in the undo block 450.
      <br/>
      Additionally, the block header 454 may be used to store linking information that identifies an order in which the undo records should be performed and/or the transactions the undo records 468, 470 and 472 correspond to.
      <br/>
      The offsets 458, 460 and 462 are used as tools to facilitate navigation to particular undo records (e.g., 468, 470 and 472) within the undo block 450, specifically, the offsets each give an offset to an address where a particular undo record is located.
    </p>
    <p num="45">
      Undo block 450 also has a range of storage 464.
      <br/>
      Range 464 is unused space in the undo block 450 that is designed to be allocated as changes are made and recorded into undo block 450.
      <br/>
      Undo records 468, 470 and 472 in undo block 450 are stored from the bottom (479) of undo block 450 to the top (451), whereas offsets 458, 460 and 462 are stored from the top (451) of undo block 450 to the bottom (479).
      <br/>
      The first offset 458 corresponds to rollback entry 468, the second offset 460 corresponds to the second to last rollback entry 470, the third offset 462 corresponds to rollback entry 472 and so on and so forth until range 464 is filled with rollback entries and offsets.
    </p>
    <p num="46">
      According to one embodiment, and as depicted in FIG. 4B, each undo record (e.g., 472) comprises a header 482 and a plurality of rollback entries (e.g., 490, 492, 494, 496 and 498).
      <br/>
      As was mentioned above, a rollback entry stores a change made by a transaction and there may be many changes associated with a single transaction.
      <br/>
      Header 482 comprises data about the undo record, as well as data about the rollback entries in the undo record (e.g., database address, tablespace and rollback entry offsets).
      <br/>
      Although FIG. 4B depicts only four rollback entries, there may be many more rollback entries in a particular undo record.
      <br/>
      Further, according to one aspect of the invention, the rollback entries in a particular undo record can correspond to different data blocks.
    </p>
    <p num="47">
      Also depicted in undo record 472 is a bit vector 484.
      <br/>
      Bit vector 484 has four bits 485, 486, 487 and 488.
      <br/>
      Each bit in the bit vector 484 indicates a status of a particular rollback entry.
      <br/>
      For example, the status bit that corresponds to a particular rollback entry may initially be set to FALSE to indicate that the rollback entry has not been applied.
      <br/>
      The bit may then be set to TRUE (or "applied") once the rollback entry is applied to its corresponding data block.
      <br/>
      Although bit vector 484 has only four bits, it may have as many bits as there are rollback entries in the undo record 472.
      <br/>
      As depicted in FIG. 4B, bits 485, 486, 487 and 488 are status bits for rollback entries 490, 492, 494 and 496 respectively.
      <br/>
      According to one embodiment, the last rollback entry 498 is modifiable during the undo application process.
      <br/>
      In this embodiment, information about which rollback entries have been applied, or a "status flag" may be stored in the modifiable last rollback entry 498 (e.g., bit vector 484).
    </p>
    <p num="48">
      The invention described herein does not need the change vector 400, depicted in FIG. 4C, to be practiced.
      <br/>
      However, according to one embodiment, a change vector 400 is utilized to temporarily store change information in memory before it is linearized and saved to disk.
      <br/>
      As used in one embodiment, change vector 400 is used to store control and processing information for undo segments.
      <br/>
      Additionally, change vector 400 may be used to store redo and undo records for the redo and undo processes themselves.
      <br/>
      For example, the change vector 400 is used by the undo process to identify and locate changes made either to a particular data block or by a particular transaction.
    </p>
    <p num="49">
      Change vector 400 includes a set of pointers to buffers and an array of lengths for each of the buffers.
      <br/>
      The change vector 400 also stores information about itself, such as the number of entries in the change vector 400, the size of the change vector 400, information about data blocks and transactions for which there is corresponding undo information in the change vector 400 and an array of lengths for the buffers in the change vector 400.
    </p>
    <p num="50">In the illustrated embodiment, change vector 400 comprises: a pointer 410, redo information 414, undo information 418, a plurality of buffer pointers 422, 426 and 430, a header 434 and an array of lengths 442.</p>
    <p num="51">
      Pointer 410 points to header 434.
      <br/>
      Header 434 contains information that describes change vector 400.
      <br/>
      For example, header 434 may be used to store the number of entries in the change vector 400, a disk block identifier and the size of the change vector 400.
    </p>
    <p num="52">Redo information 414 comprises data describing how to redo changes made by the undo process, whereas undo information 418 comprises data describing how to undo (or rollback) changes made by the undo process.</p>
    <p num="53">
      Buffer pointers 422, 426 and 430 point to buffers 424, 428 and 432 (there may be more than just the three buffer pointers and buffer pairs depicted in change vector 400).
      <br/>
      According to one embodiment, undo blocks 450 are temporarily stored in the buffers (e.g., 424 and 428).
      <br/>
      According to another embodiment, the last buffer 432 is a modifiable buffer.
      <br/>
      An advantage of employing modifiable buffer 432 is that information about the undo (e.g., state information) can be modified while changes are being applied to disk.
    </p>
    <p num="54">Array of lengths 442 stores lengths for each of the buffers 424, 428 and 432.</p>
    <p num="55">
      In one embodiment, the change vector 400 structure is created by a caller or a process that initiates a change to a data block.
      <br/>
      The caller stores information about the change (e.g., data block identifiers, block descriptors and undo records) in memory, but does not save the information to disk.
      <br/>
      Instead, one or more processes responsible for removing changes from data blocks, referred to herein as the "undo process", commit the information to disk and will, if necessary, remove the changes recorded therein.
      <br/>
      In this embodiment, the header 434, the array of lengths 442 and the buffers 424, 428 and 432 are committed to disk by the undo process before the change is made to disk.
    </p>
    <p num="56">Steps For Incremental Undo</p>
    <p num="57">
      FIG. 5 is a flowchart depicting the steps for incremental undo according to one embodiment.
      <br/>
      With reference to FIG. 5 and the description that follows, it is assumed that the database server has initiated an undo process to rollback a series of changes which correspond to a transaction.
      <br/>
      Further, the description is a detailed description of a generic undo process, however, a specific example of the undo process is also provided.
    </p>
    <p num="58">
      According to one embodiment, isolation is provided by acquiring a transaction lock when beginning the undo process.
      <br/>
      According to another embodiment, the data blocks and/or undo blocks needed in the undo process are locked in exclusive mode.
      <br/>
      By locking the blocks, the database can be assured that the changes made by the undo process can be isolated so that other, concurrent processes or transactions will not see or create an inconsistency in the data and vice-versa.
      <br/>
      In either event, the undo block 450 is locked before the process begins.
    </p>
    <p num="59">
      Referring to FIG. 5, in step 500, a test is performed to determine whether there are any undo records in the transaction to rollback.
      <br/>
      If there are not any undo records, then the process terminates; however, if there are undo records to rollback, then the process continues to step 504.
      <br/>
      In step 504, the undo block 450 is read.
      <br/>
      Next, in step 508, a rollback entry is selected from undo record 472.
      <br/>
      According to one embodiment, "selecting" a rollback entry means that a particular rollback entry is identified.
      <br/>
      In later steps of the undo process described herein, information about the selected rollback entry will be analyzed to determine the appropriate steps to perform.
      <br/>
      For example, on the undo process' first pass through undo block 450, information about rollback entry 496 may be selected if rollback entry 496 holds information about the last change for a particular data block and transaction contained in the undo block 450.
    </p>
    <p num="60">
      In step 512, a test is performed to determine whether the status of the selected rollback entry (or a corresponding bit from bit vector 484) has been set as "applied".
      <br/>
      In one embodiment, the bit vector 484 is tested to determine whether the bit 488, corresponding the rollback entry 496, is set to TRUE (or "applied").
      <br/>
      In response to testing, if the rollback entry has been applied, then the process returns to step 508 and a next rollback entry is selected from the undo record 472.
      <br/>
      However, in response to testing in step 512, if the status of the rollback entry has not been set as "applied", then the process continues to step 516.
    </p>
    <p num="61">
      In step 516, change information stored in the rollback entry is retrieved.
      <br/>
      According to one embodiment, an offset is read from the header 482 and, based on the rollback entry offset, the rollback entry (490, 492, 494 or 496) is retrieved from undo record 472.
      <br/>
      In step 520, an appropriate data block is locked, and in step 524 a change is generated for the data block.
      <br/>
      Next, in step 528, the status flag is set.
      <br/>
      According to one embodiment, a bit (e.g., 488) in bit vector 484 is set to TRUE.
      <br/>
      Although steps 508 through 528 have been described with reference to a single rollback entry, according to one embodiment, a plurality of rollback entries are selected in step 508, tested in step 512, and changes retrieved in step 516.
      <br/>
      The plurality of rollback entries are preferably related to the same data block.
      <br/>
      Thus, the change generated in step 524 would correspond to the plurality of rollback entries, and, in step 528, status flags would be set for each of the rollback entries for which a change was retrieved.
    </p>
    <p num="62">
      Next, the process continues to step 532.
      <br/>
      In step 532, a test is performed to determine if the caller that initiated the undo process is done with the undo record 472.
      <br/>
      Note that, according to one embodiment, the caller that initiated the undo process may choose to apply all or only one of the rollback entries stored in the undo record 472.
      <br/>
      Consequently, this will affect whether the caller has any more use for (or is "done" with) the undo record 472.
      <br/>
      For example, only rollback entries corresponding to a particular data block may be applied, even though the undo record 472 contains rollback entries for changes to numerous data blocks.
      <br/>
      If the client that initiated the undo process is done with the undo record 472, then the process continues to step 536, which is described in further detail below.
      <br/>
      If the client is not done with the undo record 472, then the process continues to step 548, which is also described below.
    </p>
    <p num="63">
      In step 536, a test is performed to determine whether the undo record 472 is the last undo record in the undo block 450.
      <br/>
      If the undo record 472 is the last undo record in the undo block 450, then the process continues to step 540, which is described below.
      <br/>
      However, if the undo record 472 is not the last undo record, then the process continues to step 576.
      <br/>
      In step 576, a change is generated for the undo block 450.
      <br/>
      Next, in step 580, changes are applied to the undo block 450 and the data block, and the processing continues to step 568, described below.
    </p>
    <p num="64">
      In step 548, a change is generated for the undo block 450.
      <br/>
      Next, in step 552, the change to the undo block 450 is applied, as is the change to the data block.
      <br/>
      In step 556, the lock on the data block is released and the process continues to step 508.
    </p>
    <p num="65">
      In step 540 the transaction table 260 is locked.
      <br/>
      Changes are generated for the transaction table 260 and the undo block 450 in step 544.
      <br/>
      Next, the process continues to step 560 where the changes are applied to the transaction table 260, the data block and the undo block 450.
    </p>
    <p num="66">
      In step 564, the lock on the transaction table 260 is released.
      <br/>
      In step 568, the lock on the data block is released, and in step 572, the lock on the undo block 450 is released.
      <br/>
      Finally, the process continues to step 500, described above.
    </p>
    <heading>EXAMPLE</heading>
    <p num="67">
      For example, referring to undo record 472 depicted in FIG. 4B, and disk 600 depicted in FIG. 6, assume that rollback entries 490 and 492 correspond to changes to data block 602, which is contained in disk 600, whereas rollback entries 494 and 496 correspond to changes to data block 604 (also contained in disk 600.) (Notice that a single undo record is associated with more than one data block.) Further, assume an undo process is initiated and the changes stored in undo record 472, the only undo record in a string of undo records (e.g., a transaction undo chain), needs to be applied to data block 602.
      <br/>
      The steps for incremental undo, according to one embodiment, are described in the example below.
    </p>
    <p num="68">
      Turning again to FIG. 5, the undo process begins by determining whether there are any undo records to apply in step 500.
      <br/>
      Since undo record 472 needs to be applied, in the next step, 504, the undo block 450 is read.
      <br/>
      Implicit in the request is a call to the cache layer or lock manager to lock the desired undo block before the undo block is read.
      <br/>
      According to one embodiment, block header 454 is read.
      <br/>
      Based on the data read, the undo records storing change information for the desired data block(s) are determined.
      <br/>
      Header 482 in undo record 472 is read, thereby identifying the last change, as well as the other changes, to data block 602 recorded in the undo record 472 (rollback entries 492 and 490).
    </p>
    <p num="69">
      In step 508, the undo record 672 is analyzed so as to select a rollback entry (or entries) to apply.
      <br/>
      For example, undo record header 482 and data about rollback entry 492 is read (e.g., bit 486 is read from bit vector 484 as well as an offset to rollback entry 492), as is the same of rollback entry 490 and bit 485.
      <br/>
      In step 512, the process determines whether the selected rollback entries 492 and 490 have been applied, in other words, have bits 486 and 485 been set to "applied?" Since bits 486 and 485 are not set to applied, the changes recorded in rollback entries 492 and 490 are retrieved from undo record 472 in step 516.
      <br/>
      Next, the data block 602 is locked in step 520, and in step 524, based on the change recorded in rollback entries 492 and 490, a change is generated for data block 602.
      <br/>
      According to one embodiment, this change is saved temporarily in a change vector 400, for example in one of the buffers 424 or 428.
      <br/>
      In step 528, bits 486 and 485 are set to "applied."
    </p>
    <p num="70">
      In step 532, a test is performed to determine whether any more rollback entries in the undo record 472 need to be applied.
      <br/>
      In response to testing, the undo process determines that more changes are needed from undo record 472, so the process continues to step 548 (in particular those changes for data block 604 need to be applied).
      <br/>
      In step 548, a change is generated for undo block 450.
      <br/>
      According to one embodiment, the change is generated for change vector 400 in modifiable buffer 432 (e.g., a memory copy of bit vector 484 is updated to reflect that bits 486 and 485 should be set as "applied").
      <br/>
      Next, in step 552, the changes generated for undo block 450 and data block 602 in steps 548 and 524 respectively are applied to disk 600.
      <br/>
      In step 556, the lock on data block 602 is released and the process continues to step 508.
    </p>
    <p num="71">
      In step 508, rollback entries 496 and 494 are selected, and in step 512, the process determines whether the rollback entry 496 and 494 have been applied (e.g., are either bit 488 or 487 set to "applied?") Neither bit 488 or bit 487 is set to "applied," so the changes recorded in rollback entry 496 and 494 are retrieved from undo record 472 in step 516.
      <br/>
      In step 520, data block 604 is locked.
      <br/>
      Next, based on the changes recorded in rollback entries 496 and 494, a change is generated at step 524.
      <br/>
      In step 528, bits 488 and 487 are set to "applied."
    </p>
    <p num="72">
      In step 532, a test is performed to determine whether any more rollback entries in the undo record 472 need to be applied.
      <br/>
      In response to testing, the undo process determines that no more changes are needed from undo record 472, so the process continues to step 536.
      <br/>
      In step 536, a test is performed to determine whether there are any more undo records with changes in the undo block 450.
      <br/>
      In response to testing, the process determines the current undo record 472 is the last undo record in the undo block 450.
      <br/>
      Next, in step 540, the transaction table 260 is locked, and in step 544 a change is generated for the transaction table 260 and the undo block 450.
      <br/>
      In step 560, the changes to the transaction table 260, the data block 604 and the undo block 450 generated in steps 544, 524 and 548 are applied to disk 600.
      <br/>
      The lock on the transaction table 260 is released in step 564.
      <br/>
      The lock on the data block 604 is released in step 568, and the lock on the undo block 450 is released in step 572.
      <br/>
      Finally, the process continues to step 500, where a test is performed to determine whether there are any more undo records to apply.
      <br/>
      The test at step 500 is negative and the process terminates.
    </p>
    <p num="73">
      In the present example, more than one change was applied to data blocks 602 and 604 as a single atomic operation, but not all the changes in undo record 472 had to be applied at once.
      <br/>
      Rather, the changes may be performed in a divide and conquer fashion by first applying batches of changes to data block 602 and then applying batches of changes to data block 604.
      <br/>
      Additionally, the undo process is able to track the state (e.g., "applied" or "not applied") of individual rollback entries.
    </p>
    <p num="74">
      Because the techniques described herein allow rollback entries to be applied incrementally, or in non-contiguous batches of rollback entries, the undo process is afforded the option of applying a plurality of changes to a particular data block all at once and then moving to a next data block and applying all the changes.
      <br/>
      In the prior method, individual changes were applied as a single atomic operation rather than grouping the changes and applying multiple changes as a single atomic operation.
      <br/>
      In other words, there was one undo record per one data item changed in the prior method, whereas according to the present technique one undo record may be used to protect multiple data items changed.
      <br/>
      As a result, changes may be applied to data blocks in a divide and conquer manner.
    </p>
    <p num="75">
      Another advantage of the techniques described herein is that the overhead associated with rolling back changes to a particular data block is amortized over a plurality changes to the data block (e.g., each rollback entry), which results in a more efficient recovery process.
      <br/>
      Further, creating the undo log file will require less overhead too.
    </p>
    <p num="76">
      Still another advantage is that changes in the undo will exhibit the property of idempotency, which will support block or object level recovery.
      <br/>
      Idempotency means that if a change has been applied, then it will not be reapplied.
      <br/>
      For example, if a change is supposed to add the number "1" to a prior value of a data item, and the undo process did not have the property of undo idempotency, then "1" would be added to the prior value as many times as the change is re-applied to the prior value.
      <br/>
      However, using the status flag according to the present technique protects the prior value data item from having the change applied more than once.
    </p>
    <p num="77">
      Still another advantage of the present invention is that undo blocks are more compact and therefore take up less memory and less disk space.
      <br/>
      This is because information previously stored in the entry header 254 of the undo record 228 is now stored only once in the header 482 in the undo record 472, thereby eliminating redundancy.
      <br/>
      Additionally, an undo record can now comprise multiple rollback entries corresponding to more than one data block, and the likelihood of using previously unallocated/used space in the undo block is increased.
      <br/>
      This attribute also has the advantage of reducing the I/O associated with the undo operation.
    </p>
    <p num="78">
      The present invention is also useful when used in conjunction with "BATCH PROCESSING OF UPDATES TO INDEXES", which is described in U.S. patent application Ser.
      <br/>
      No. 08/855,544 filed on Jun. 4, 1997, which is incorporated herein by reference.
    </p>
    <p num="79">
      In the foregoing specification, the invention has been described with reference to specific embodiments thereof.
      <br/>
      It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention.
      <br/>
      For example, various methods of acquiring and releasing locks may be employed (e.g., hierarchical locking or hash locking), and the elements in the data structures (e.g., undo block 450 and change vector 400) may be reordered, enhanced or combined into a single data structure.
      <br/>
      The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for performing incremental undo when recovering a computer database from a failure, the method comprising:</claim-text>
      <claim-text>storing changes for a plurality of data blocks in a single undo record; establishing as a current rollback entry, a rollback entry that belongs to a plurality of rollback entries within said single undo record, said plurality of rollback entries corresponding to a particular data block in said plurality of data blocks; examining a status flag corresponding to said current rollback entry to determine whether said current rollback entry has been applied; establishing a next rollback entry in said plurality of rollback entries as said current rollback entry without applying said current rollback entry when said current rollback entry has been applied;</claim-text>
      <claim-text>and when said current rollback entry has not been applied, then:</claim-text>
      <claim-text>- retrieving said current rollback entry from said plurality of rollback entries; - applying one or more changes indicated by said current rollback entry to said particular data block;</claim-text>
      <claim-text>and - setting said status flag in said undo record to indicate said current rollback entry has been applied.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein said step of applying said one or more changes indicated by said current rollback entry comprises applying all rollback entries for at least one transaction that are stored in said plurality of rollback entries in a single atomic operation.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 1, further comprising the step of retaining said rollback entry in said undo record after said step of applying said current rollback entry to said particular data block.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 1, further comprising the step of maintaining a change vector in a buffer cache, wherein said change vector comprises a plurality of buffers for storing said change information, said change vector including a modifiable change buffer for storing information corresponding to said status flag.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 4, further comprising: examining said change vector to identify changes to apply to said particular data block;</claim-text>
      <claim-text>and retrieving address information identifying a particular rollback entry from said change vector.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 4, further comprising the step of storing recovery information about the incremental undo process itself in said change vector.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. A computer-readable medium carrying one or more sequences of instructions for performing incremental undo when recovering a computer database from a failure, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of: storing changes for a plurality of data blocks in a single undo record; establishing as a current rollback entry, a rollback entry that belongs to a plurality of rollback entries within said single undo record, said plurality of rollback entries corresponding to a particular data block in said plurality of data blocks; examining a status flag corresponding to said current rollback entry to determine whether said current rollback entry has been applied; establishing a next rollback entry in said plurality of rollback entries as said current rollback entry without applying said current rollback entry when said current rollback entry has been applied;</claim-text>
      <claim-text>and when said current rollback entry has not been applied, then: - retrieving said current rollback entry from said plurality of rollback entries; - applying one or more changes indicated by said current rollback entry to said particular data block;</claim-text>
      <claim-text>and - setting said status flag in said undo record to indicate said current rollback entry has been applied.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The computer-readable medium of claim 7, wherein said step of applying said one or more changes indicated by said current rollback entry comprises applying all rollback entries for at least one transaction that are stored in said plurality of rollback entries in a single atomic operation.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The computer-readable medium of claim 7, wherein execution of the one or more said sequences of instructions by one or more processors causes the one or more processors to further perform the step of retaining said rollback entry in said undo record after said step of applying said current rollback entry to said particular data block.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The computer-readable medium of claim 7, wherein executing the one or more sequences of instructions by one or more processors causes the one or more processors to further comprising the step of maintaining a change vector in a buffer cache, wherein said change vector comprises a plurality of buffers for storing said change information, said change vector including a modifiable change buffer for storing information corresponding to said status flag.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The computer-readable medium of claim 10, wherein executing the one or more sequences of instructions by one or more processors causes the one or more processors to further perform the steps of: examining said change vector to identify changes to apply to said particular data block;</claim-text>
      <claim-text>and retrieving address information identifying a particular rollback entry from said change vector.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The computer-readable medium of claim 10, wherein executing the one or more sequences of instructions by one or more processors causes the one or more processors to further perform the step of storing recovery information about the incremental undo process itself in said change vector.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. A computer system comprising a database server, wherein said database server is configured to recover a particular data block from a failure by performing the steps of: storing changes for a plurality of data blocks in a single undo record, said plurality of data blocks including said particular data block; establishing as a current rollback entry, a rollback entry that belongs to a plurality of rollback entries within said single undo record, said plurality of rollback entries corresponding to said particular data block; examining a status flag corresponding to said current rollback entry to determine whether said current rollback entry has been applied; establishing a next rollback entry in said plurality of rollback entries as said current rollback entry without applying said current rollback entry when said current rollback entry has been applied;</claim-text>
      <claim-text>and when said current rollback entry has not been applied, then: - retrieving said current rollback entry from said plurality of rollback entries; - applying one or more changes indicated by said current rollback entry to said particular data block;</claim-text>
      <claim-text>and - setting said status flag in said undo record to indicate said current rollback entry has been applied.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The computer system of claim 13, wherein said step of applying said one or more changes indicated by said current rollback entry comprises applying all rollback entries for at least one transaction that are stored in said plurality of rollback entries in a single atomic operation.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The computer system of claim 13, said computer system further configured to perform the step of retaining said rollback entry in said undo record after said step of applying said current rollback entry to said particular data block.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The computer system of claim 13, said computer system further configured to perform the step of maintaining a change vector in a buffer cache, wherein said change vector comprises a plurality of buffers for storing said change information, said change vector including a modifiable change buffer for storing information corresponding to said status flag.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The computer system of claim 16, said computer system further configured to perform the steps of: examining said change vector to identify changes to apply to said particular data block;</claim-text>
      <claim-text>and retrieving address information identifying a particular rollback entry from said change vector.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The computer of claim 16, said computer system further configured to perform the step of storing recovery information about the incremental undo process itself in said change vector.</claim-text>
    </claim>
  </claims>
</questel-patent-document>