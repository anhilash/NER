<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06188334B1.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as first publication">
      <document-id>
        <country>US</country>
        <doc-number>06188334</doc-number>
        <kind>B1</kind>
        <date>20010213</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6188334</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B1</original-publication-kind>
    <application-reference is-representative="YES" family-id="26718785" extended-family-id="3876166">
      <document-id>
        <country>US</country>
        <doc-number>09565443</doc-number>
        <kind>A</kind>
        <date>20000505</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>2000US-09565443</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43180338</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>56544300</doc-number>
        <kind>A</kind>
        <date>20000505</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>2000US-09565443</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>4200798</doc-number>
        <kind>A</kind>
        <date>19980313</date>
        <priority-linkage-type>3</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1998US-09042007</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="3">
        <country>US</country>
        <doc-number>5449597</doc-number>
        <kind>P</kind>
        <date>19970731</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="3">
        <doc-number>1997US-60054495</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010213</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H03M   7/40        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>7</main-group>
        <subgroup>40</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>341051000</text>
        <class>341</class>
        <subclass>051000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>341107000</text>
        <class>341</class>
        <subclass>107000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>H03M-007/40A</text>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>007</main-group>
        <subgroup>40A</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H03M-007/4006</classification-symbol>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>7</main-group>
        <subgroup>4006</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>9</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>5</number-of-drawing-sheets>
      <number-of-figures>9</number-of-figures>
      <image-key data-format="questel">US6188334</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Z-coder: fast adaptive binary arithmetic coder</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>ONO FUMITAKA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>RE35781</doc-number>
            <kind>E</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>USRE35781</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>IMANAKA YOSHIFUMI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5781136</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5781136</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>SLATTERY MICHAEL JOHN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5859604</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5859604</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <document-id>
            <country>CA</country>
            <doc-number>1291820</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>CA1291820</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <document-id>
            <country>CA</country>
            <doc-number>1292070</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>CA1292070</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <document-id>
            <country>CA</country>
            <doc-number>1291821</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>CA1291821</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <document-id>
            <country>CA</country>
            <doc-number>2008943</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>CA2008943</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>PENNEBAKER WILLIAM B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4935882</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4935882</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>ONO FUMITAKA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5059976</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5059976</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>ONO FUMITAKA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5307062</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5307062</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>Paul G. Howard, Jeffrey Scott Vitter, Arithmetic Coding for Data Compression, Proceedings of the IEEE, vol. 82, No. 6, Jun. 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>Langdon, Jr. "An Introduction to Arithmetic Coding", IBM Journal of Research and Development, U.S., IBM Corp., Armonk, vol. 28, No. 2, pp. 135-149.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>Mitchell et al, "Software Implementations of the Q-Coder", IBM Journal of Research and Development, U.S., IBM Corp., Armonk, vol. 32, No. 6, pp. 753-774.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>"Speed-Up Mode" for Q-Coder Software Implementation, IBM Technical Bulletin, U.S. IBM Corp., New York, vol. 32, No. 8B, pp. 17-20.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>Ono et al, "Bi-Level Image Coding with Melcode-Comparison of Block Type Code and Arithmetic Type Code-", Communication Systems Development Lab., Mitsubishi Electric Corp., CH2682-3/89/000-0255 1989 IEEE.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <division>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>4200798</doc-number>
              <kind>A</kind>
              <date>19980313</date>
            </document-id>
          </parent-doc>
        </relation>
      </division>
      <related-publication>
        <document-id>
          <country>US</country>
          <doc-number>60/054,495</doc-number>
          <date>19970731</date>
        </document-id>
        <document-id>
          <country>US</country>
          <doc-number>60/054495</doc-number>
          <date>19970731</date>
        </document-id>
      </related-publication>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>AT&amp;T Corp.</orgname>
            <address>
              <address-1>New York, NY, US</address-1>
              <city>New York</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>AT&amp;T</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Bengio, Yoshua</name>
            <address>
              <address-1>Montreal, CA</address-1>
              <city>Montreal</city>
              <country>CA</country>
            </address>
          </addressbook>
          <nationality>
            <country>CA</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Bottou, Leon</name>
            <address>
              <address-1>Highlands, NJ, US</address-1>
              <city>Highlands</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Howard, Paul G.</name>
            <address>
              <address-1>Morganville, NJ, US</address-1>
              <city>Morganville</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Kenyon &amp; Kenyon</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Wamsley, Patrick</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A binary arithmetic coder and decoder provides improved coding accuracy due to improved probability estimation and adaptation.
      <br/>
      They also provide improved decoding speed through a "fast path" design wherein decoding of a most probable symbol requires few computational steps.
      <br/>
      Coded data represents data that is populated by more probable symbols ("MPS") and less probable symbols ("LPS").
      <br/>
      In an embodiment, a decoder receives a segment of the coded data as a binary fraction C.
      <br/>
      It defines a coding interval of possible values of C, the interval extending from a variable lower bound A to a constant upper bound 1.
      <br/>
      For each position in the decoded symbol string, the decoder computes a test value Z that subdivides the coding interval into sub-intervals according to the relative probabilities that an MPS or an LPS occurs in the position.
      <br/>
      A first sub-interval extends from the lower bound A to the test value Z; the second sub-interval extending from the test value Z to 1.
      <br/>
      If C is greater than Z, the decoder emits an MPS for the current position in the decoded symbol string and sets the lower bound A to the test variable Z for use during decoding of the next position in the decoded symbol string.
      <br/>
      If C is less than Z, the decoder emits an LPS and computes a new lower bound A and a new binary fraction C for use during decoding of the next position in the decoded symbol string.
      <br/>
      The encoder operates according to analogous techniques to compose coded data from original data.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This application is a Division of Ser.
      <br/>
      No. 09/042,007, filed Mar. 13, 1998, which claimed the benefit of Provisional No. 60/054,495 filed Jul. 31, 1997.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="3">The present invention relates to an improved adaptive binary arithmetic coder that provides improved processing speed and accuracy over conventional arithmetic coders.</p>
    <p num="4">2. Related Art</p>
    <p num="5">
      Arithmetic coders provide well-known algorithms for encoding data.
      <br/>
      Compression ratios of the arithmetic coders can reach the information theory limit.
      <br/>
      The arithmetic coder and decoder must possess good estimates of the probability distribution of each symbol to code.
      <br/>
      For each symbol to be coded in a string element, the encoder and decoder must possess a table containing estimated probabilities for the occurrence of each possible symbol at each point in the symbol string.
      <br/>
      The coders themselves must perform a table search and at least one multiplication.
      <br/>
      For this reason, arithmetic coders incur high computational expense.
      <br/>
      Binary adaptive arithmetic coders, such as the "Q-Coder," by Pennebaker, et al. (1998) and the "QM-Coder," by Ono (1993), have been developed to overcome this drawback.
    </p>
    <p num="6">
      A high-level system diagram of a prior art binary arithmetic coder is shown in FIG. 1.
      <br/>
      Data to be coded is input to an-encoder 100.
      <br/>
      The encoder 100 encodes the data and outputs a string of coded data to a channel 200.
      <br/>
      A decoder 300 retrieves the code string from the channel 200 and replicates the original data by decoding the coded data.
    </p>
    <p num="7">
      The coding process often is described by the operation of the decoder 300.
      <br/>
      In the decoder, the code string is interpreted as a binary representation of a real number contained in the unit interval �0,1�. The binary arithmetic coder divides the unit interval into two sub-intervals having lengths that are proportional to the estimated probabilities of each value of the first bit in the symbol string.
      <br/>
      Any code string located in a first, lower sub-interval represents a symbol string starting with a zero (0).
      <br/>
      Conversely, any code string located in the upper sub-interval represents a symbol string starting with a one (1).
    </p>
    <p num="8">
      Each of the sub-intervals can be divided into two smaller sub-intervals having lengths that are proportional to the estimated conditional probabilities of the second symbol bit given the previously encoded symbol bit.
      <br/>
      Any code string located in one of these sub-intervals represents a symbol string starting with the corresponding two bit prefix.
    </p>
    <p num="9">
      The decoding process is repeated.
      <br/>
      Sub-intervals are themselves divided into smaller sub-intervals representing probabilities of the value of the next bit in the symbol string.
      <br/>
      The process produces a partition of the unit interval having sub-intervals that correspond to each possible value of the symbol string.
      <br/>
      Any code string in the interval can be chosen corresponding to the encoded symbol string.
    </p>
    <p num="10">
      According to theory, when an interval is divided into sub-intervals, the length of each sub-interval should be proportional to the probability of the value of the next data symbol to be decoded given the previous symbol bits.
      <br/>
      The probability distribution of the code string therefore would be uniform in the interval.
      <br/>
      Since each code bit is equally likely to be a 0 or a 1, it would carry as much information as information theory allows.
      <br/>
      In other words, the coder would achieve entropic compression.
    </p>
    <p num="11">
      The known Q-Coder and QM-Coder, while they represent advances over traditional arithmetic coders, do not provide performance that approaches entropic compression.
      <br/>
      Thus, there is a need in the art for a binary arithmetic coder that provides improved compression ratios than the Q-Code and the QM-Coder.
    </p>
    <p num="12">
      Decoding speed is an important performance characteristic of data coding systems.
      <br/>
      Decoding latency, the time that is required to generate decoded data once the coded data is received should be minimized wherever possible.
      <br/>
      Thus, decoders that introduce lengthy or complex computational processes to the decoding operation are disfavored.
      <br/>
      Accordingly, there is a need in the art for a data decoding scheme that is computationally simple and provides improved throughput of decoded data.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="13">
      The present invention provides a binary arithmetic coder and decoder having important advantages over the prior art.
      <br/>
      The coding scheme provides improved coding accuracy over the prior art due to improved probability estimation and adaptation.
      <br/>
      It provides improved decoding speed through a "fast path" design wherein decoding of a most probable symbol requires few computational steps.
    </p>
    <p num="14">
      According to the present invention, coded data represents data that is populated by more probable symbols ("MPS") and less probable symbols ("LPS").
      <br/>
      In an embodiment, the decoder receives a segment of the coded data as a binary fraction C. It defines a coding interval of possible values of C, the interval extending from a variable lower bound A to a constant upper bound 1.
      <br/>
      For each position in the decoded symbol string, the decoder computes a test value Z that subdivides the coding interval into sub-intervals according to the relative probabilities that an MPS or an LPS occurs in the position.
      <br/>
      A first sub-interval extends from the lower bound A to the test value Z; the second sub-interval extending from the test value Z to 1.
      <br/>
      If C is greater than Z, the decoder emits an MPS for the current position in the decoded symbol string and sets the lower bound A to the test variable Z for use during decoding of the next position in the decoded symbol string.
      <br/>
      If C is less than Z, the decoder emits an LPS and computes a new lower bound A and a new binary fraction C for use during decoding of the next position in the decoded symbol string.
      <br/>
      The encoder operarates according to analogous techniques to compose coded data from original data.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="15">
      FIG. 1 is a high-level system block diagram of a known binary arithmetic coder.
      <br/>
      FIG. 2 illustrates a method of operation of a decoder according to a first embodiment of the present invention.
      <br/>
      FIGS. 3 and 4 respectively illustrate interval parameters as a function of interval splitting variables in an entropic coding application and a QM Coder of the prior art.
      <br/>
      FIG. 5 illustrates interval parameters as a function of an interval splitting variable in the present invention.
      <br/>
      FIG. 6 illustrates a method of operation of a decoder according to a second embodiment of the present invention.
      <br/>
      FIG. 7 illustrates a method of operation of an encoder according to an embodiment of the present invention.
      <br/>
      FIG. 8 is a graph illustrating a comparison between an optimal increment parameter and an increment parameter in use in an embodiment of the present invention.
      <br/>
      FIG. 9 illustrates a method of operation of a decoder according to a third embodiment of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION</heading>
    <p num="16">
      The present invention provides a data coding system, labeled the "Z-Coder," that provides improved compression ratios over traditional binary arithmetic coders.
      <br/>
      The decoder of the Z-Coder system may be optimized to provide very fast decoding of coded data.
    </p>
    <p num="17">
      To facilitate an understanding of the invention, the decoding scheme of the present invention is described first.
      <br/>
      A method of operation 1000 of a decoder according to a first embodiment of the present invention is shown in FIG. 2.
      <br/>
      The decoder decodes a coded data string, labeled "C(t)," into decoded data.
      <br/>
      The decoded data is a string of symbols that may be either a most probable symbol ("MPS") or a least probable symbol ("LPS"). C(t) is treated by the decoder as a binary fraction.
      <br/>
      For example, a coded data string "1010101011111111" is treated as "0.1010101011111111".
    </p>
    <p num="18">
      When C(t) is received and before the decoder tests its value, C(t) may take any value between 0 and 1 (C(t) OMICRON  �0,1�).
      <br/>
      The decoder maintains a second variable, labeled "A(t)," that represents a lower bound of possible values of C(t).
      <br/>
      Thus, the decoder sets A(1)=0 as an initial step (Step 1010) and further sets C(1) to a code string received from the channel (Step 1020).
    </p>
    <p num="19">
      Decoding of the tth code symbol operates according to steps 1030-1080.
      <br/>
      At step 1030, the decoder computes a test variable, labeled "Z(t)", that divides the interval �A(t),1� in proportion to the relative probabilities of MPS and LPS (Step 1030).
      <br/>
      The decoder compares the actual value of C(t) against the test variable Z(t) to determine which is greater (Step 1040).
      <br/>
      If C(t) is greater than Z(t), the decoder determines that the next symbol to be decoded is a MPS (Step 1050).
      <br/>
      The decoder sets A(t+1)=Z(t), because Z(t) is established as the lower bound of C(t) (Step 1060).
    </p>
    <p num="20">
      However, if C(t) is less than Z(t), the next bit to be decoded is the LPS (Step 1070).
      <br/>
      When a least probable symbol occurs, C(t) falls between A(t) and Z(t).
      <br/>
      To prepare for the next decoding iteration, C(t+1) should be bounded by A(t+1) and 1.
      <br/>
      Accordingly, the decoder shifts the values of A(t) and C(t) in an amount sufficient to shift Z(t) to 1, the higher bound of C(t) (Step 1080). A(t+1)=A(t)+1-Z(t) and C(t+1)=C(t)+1-Z(t).
    </p>
    <p num="21">
      After step 1060 or step 1080, the decoder may re-normalize the variables A(t) and C(t) (Step 1070).
      <br/>
      Re-normalization occurs when the most significant bit positions of C(t) and of A(t) are equal to one.
      <br/>
      When this occurs, the most significant bit position provides no more useful information to the decoding of data.
      <br/>
      The most significant bit position is "consumed" by the decoding process.
    </p>
    <p num="22">
      The decoder of the present invention may be implemented in a microprocessor or a digital signal processor.
      <br/>
      In such an implementation, values of A(t) and C(t) are stored in data registers having a fixed length, such as 16 bit registers.
      <br/>
      Renormalization causes a shift of data in each register one bit position to the left.
      <br/>
      It shifts the most significant bit out of A(t) and C(t).
      <br/>
      The shift of data in the register storing C(t) permits a new bit to be retrieved from the channel and stored in the least significant position in the register.
    </p>
    <p num="23">
      Because A(t) is always less than or equal to C(t), it is necessary to test only the first bit position of A(t).
      <br/>
      If that bit position is a one (1), then the decoder determines that renormalization shift should be performed.
    </p>
    <p num="24">The method of FIG. 2 works so long as both the encoder and the decoder use the same test values Z(t) for testing and adjusting the lower bound of register A(t).</p>
    <p num="25">
      The Z-Coder provides compression ratios that approach entropic compression ratios.
      <br/>
      It provides a closer approximation of entropic compression than prior art coders.
      <br/>
      Entropic compression is achieved when Z(t) splits the interval �A(t),1� precisely in proportion with the probabilities PLPS and PMPS.
      <br/>
      For entropic compression:
      <br/>
      Ze(t)=1-(1-PLPS) (1-A(t))=A(t)+PLPS (1-A(t))
    </p>
    <p num="26">
      Unfortunately, calculation of a test value that achieves entropic compression would require a multiplication to be performed, a computationally slow operation.
      <br/>
      FIG. 3 illustrates lines-representing the test value Z(t) as a function of PLPS for several values of A(t) under entropic conditions.
      <br/>
      The multiplication arises because each line has a different slope.
      <br/>
      FIG. 4 illustrates an approximation used by the QM-Coder implemented to avoid the slow multiplications.
      <br/>
      The QM-Coder deviates significantly from entropic compression.
    </p>
    <p num="27">
      The Z-Coder avoids slow multiplications.
      <br/>
      The Z-Coder computes an approximation of the entropic test value using two line segments having constant slopes.
      <br/>
      Shown in FIG. 5, the first line segment has slope 1.
      <br/>
      It is used for small values of PLPS.
      <br/>
      The second line segment has slope k and is used for large values of PLPS.
    </p>
    <p num="28">
      This solution is implemented by computing Z(t) as the minimum of the two following quantities:
      <br/>
      Z1(t)=A(t)+p  (first line segment)
      <br/>
      Z2(t)=1/2+A(t)/2+k(p-1/2)  (second line segment)
    </p>
    <p num="29">
      where p is approximately equal to but slightly lower than PLPS.
      <br/>
      The computation of Z1(t) involves only an addition, a computationally efficient operation.
      <br/>
      The computation of Z2(t) requires a multiplication but is subject to significant simplifications when k is a power of two:
    </p>
    <p num="30">
      when k=1/2, for instance, Z2(t) may be computed as 1/4+Z1(t)/2.
      <br/>
      when k=1/4, for instance, Z2(t) may be computed as 3/8+�A(t)+Z1(t)�/4
    </p>
    <p num="31">
      Multiplication of binary numbers by values which are a power of two (1/4, 1/2, 2, 4, 8, . . . ) requires only a data shift to be performed rather than a true multiplication.
      <br/>
      Thus, the simplified expressions can be computed quickly.
    </p>
    <p num="32">The decoding algorithm of FIG. 2 may be implemented in software code by the following subroutine:</p>
    <p num="33">
      --
      <br/>
      -- boolean decoder (int p, boolean mps)
      <br/>
      -- +
      <br/>
      --      z = a + p; // compute Z1(t)
      <br/>
      --      d = 0 * 6000 + (z+a)&gt;&gt;2; // compute Z2(t) (here with k = 1/4)
      <br/>
      --      if (d &lt; z)        // compute Z(t) = min �Z1(t), Z2(t)�
      <br/>
      --         z = d;
      <br/>
      --      if (z &gt; c)
      <br/>
      --         + a += 0 * 10000-z; c += 0 * 10000-z; bit = 1-mps; }
      <br/>
      --      else
      <br/>
      --         + a = z; bit = mps}
      <br/>
      --      while (a &gt;= 0 * 8000)
      <br/>
      --         + a = ((a - 0 * 8000) &lt;&lt;1);
      <br/>
      --         c = ((c - 0 * 8000)&lt;&lt;1) + next_code_bit(); }
      <br/>
      --      return bit;
      <br/>
      -- }
    </p>
    <p num="34">
      The decoding method of FIG. 2 provides adaptive binary arithmetic decoding that achieves compression ratios that are much closer to entropic compression ratios than are achieved by arithmetic decoders of the prior art.
      <br/>
      The Z-Coder provides much better data compression than the prior art adaptive binary arithmetic decoders.
    </p>
    <p num="35">
      FIG. 6 illustrates a method of operation of a decoder according to a second embodiment of the present invention.
      <br/>
      The decoding method 2000 provides a fast decoding path for encoded MPS bits.
      <br/>
      Because the MPS is, by definition, the most probable symbol, the fast decoding path is traversed more often than other decoding paths.
      <br/>
      Fast decoding of the MPS, therefore, provides for improved performance.
    </p>
    <p num="36">
      The design of the fast decoder capitalizes upon the fact that an MPS may be returned as soon it is determined that Z1(t) is smaller than C(t) and also smaller than 1/2:
      <br/>
      Z(t) is rarely greater than 1/2 because p is often very small;
      <br/>
      Z(t) is rarely less than C(t) because PLPS is usually very small; and
      <br/>
      Re-normalization rarely occurs because the compression ratio of the Z-Coder is very good (The decoding algorithm produces many more bits than it consumes).
    </p>
    <p num="37">
      The fast decoding method is initialized in the same manner as the traditional method of FIG. 2. A(1) is set to 0 (Step 2010).
      <br/>
      The decoder receives C(t) from the channel (Step 2020).
      <br/>
      The decoder computes a new "fence" variable, labeled F(t), to be the lesser of either C(t) or 1/2 (Step 2030).
      <br/>
      Further, the decoder computes Z1(t) as above (Step 2040).
    </p>
    <p num="38">
      The decoder compares Z1(t) against F(t) (Step 2050).
      <br/>
      If Z1(t) is less than F(t), the next bit to be decoded is an MPS.
      <br/>
      The decoder outputs the MPS as the next bit in the decoded data and sets A(t+1)=Z1(t) (Steps 2060-2070).
      <br/>
      Next, the decoder loops back to Step 2040.
    </p>
    <p num="39">If, at step 2050, Z1(t) is greater than F(t), the decoder computes Z2(t) and finally determines Z(t) to be the minimum of Z1(t) and Z2(t) (Steps 2080-2110).</p>
    <p num="40">
      The decoder determines whether Z(t) is greater than C(t) (Step 2120).
      <br/>
      If so, it decodes the next bit as an MPS and sets A(t+1)=Z(t) in a manner similar to steps 2060-2070 (Step 2130-2140).
      <br/>
      If, at step 2120, Z(t) is not greater than C(t), the decoder determines the next bit to be an LPS (Step 2150).
      <br/>
      It sets A(t+1)=A(t)+1-Z(t) and sets C(t)=C(t)+1-Z(t) (Step 2160).
    </p>
    <p num="41">
      Thereafter, the decoder may perform re-normalization in a manner similar to the decoding method of FIG. 2 (Step 2170).
      <br/>
      After renormalization, the decoder loops back to step 2030 to compute a fence variable for the next decoded bit position (t=t+1).
    </p>
    <p num="42">The optimized decoder may be implemented in software using the following code:</p>
    <p num="43">
      --
      <br/>
      -- boolean decoder_fast(int p, boolean mps)
      <br/>
      -- +
      <br/>
      --      z=a + p;  // Compute Z1(t)
      <br/>
      --      if (z&lt;=fence)
      <br/>
      --         + a=z; return mps} //Fast path returns MPS immediately
      <br/>
      --      d = 0 * 6000 + (z+a)&gt;&gt;2; // Compute Z2(t) (here with k=1/4)
      <br/>
      --      if (d &lt; z)         // compute Z(t) = min�Z1(t), Z2(t) }
      <br/>
      --         z = d;
      <br/>
      --      if (z &gt; c)
      <br/>
      --         + a += 0 * 10000-z;  c += 0 * 100000-z;  bit = 1-mps; }
      <br/>
      --      else
      <br/>
      --         + a = z; bit = mps; }
      <br/>
      --      while ( a &gt;= 0 * 8000)
      <br/>
      --         + a = ((a - 0 * 8000)&lt;&lt;1);
      <br/>
      --         c = ((c - 0 * 8000)&lt;&lt;1) + next_code_bit(); }
      <br/>
      --      fence = c;
      <br/>
      --      if (fence &gt;= 0 * 8000)
      <br/>
      --         + fence = 0 * 7FFF; }
      <br/>
      --      return bit;
      <br/>
      -- }
    </p>
    <p num="44">
      As is shown, if Z1(t) is less than or equal to F(t), labeled "fence" in the software description, the decoder performs only a single step and then returns.
      <br/>
      The remainder of the decoding sub-routine is not performed.
      <br/>
      The fast decoder therefore provides improved decoding performance by minimizing decoding latency.
    </p>
    <p num="45">
      The encoder performs data encoding using the same principles as the decoding methods described above.
      <br/>
      A method of operation of an encoder constructed in accordance with an embodiment of the present invention is illustrated in FIG. 7.
      <br/>
      The encoder maintains a code string interval of the form �A(t)-S(t),1-S(t)�. The interval can be interpreted as a lower bound A(t) on a number that plays the same role that C(t) does in the decoder.
      <br/>
      The code string is obtained by subtracting S(t) from the number.
      <br/>
      The quantity S(t) accumulates all the terms that are added to C(t) in the LPS branch of the decoder described above with regard to either FIGS. 2 or 6.
    </p>
    <p num="46">
      To encode a MPS, a new interval �Z(t)-S(t),1-S(t)� must be set.
      <br/>
      This is achieved by setting A(t)+1=Z(t).
      <br/>
      To encode an LPS, a new interval must be set to �A(t)-S(t), Z(t)-S(t)� which is readily achieved by setting A(t+1)=A(t)+1-Z(t) and S(t+1)=S(t)+1-Z(t).
    </p>
    <p num="47">
      The encoding method is initialized by setting A(1) and S(1) to 0 (Step 3010).
      <br/>
      Data to be encoded is input to the encoder (Step 3020).
      <br/>
      Encoding of a symbol begins with the computation of test value Z(t) just as in the decoding methods (Steps 3030-3070).
    </p>
    <p num="48">
      The encoder examines a bit in the data stream to be coded (Step 3080).
      <br/>
      If the bit is an MPS, the encoder sets A(t+1)=Z(t) (Step 3090).
      <br/>
      If the bit is an LPS, the encoder sets A(t+1)=A(t)+1-Z(t) and S(t+1)=S(t)+1-Z(t) (Step 3100).
      <br/>
      These steps ensure that operation of the encoder and decoder track each other.
    </p>
    <p num="49">Coded data bits are emitted from the encoder only if A(t) &gt;= 1/2. While A(t) &gt;= 1/2, the decoder iteratively emits a bit of the code string (as the most significant bit of 1-S(t)) and shifts A(t) and S(t) a bit position to the left (Steps 3110-3130).</p>
    <p num="50">Thereafter, the encoder returns to step 3030 to decode another bit in the data string.</p>
    <p num="51">
      In a microprocessor or digital signal processor implementation, the encoder again stores values of A(t) and S(t) in data registers having fixed lengths.
      <br/>
      However, it should be appreciated that when an LPS is encoded, the shift S(t+1)=S(t)+1-Z(t) may cause a carry in the register storing the S value.
      <br/>
      The carry must be preserved.
      <br/>
      Accordingly, if a 16-bit register is used for example to store values of A(t), then S(t) must be stored in a 17-bit register.
    </p>
    <p num="52">
      Because the result of register S can overflow to a 17th bit, the subtraction in step 3120 can result in a negative number. S(t) can be greater than 1.
      <br/>
      The borrow must be propagated through previously emitted bits in C(t).
      <br/>
      The Z-Coder borrow propagation is similar to the carry propagation problem attendant in known binary arithmetic coders.
      <br/>
      The solutions obtained in the prior art apply equally well to the Z-Coder:
      <br/>
      Bit counting consists of delaying issuance of the coded data string until a one is emitted or until a borrow propagation turns all the zeros into ones.
      <br/>
      This method may be implemented by keeping count of the number of zeros recently emitted.
    </p>
    <p num="53">
      Bit stuffing consists of inserting a dummy one when no lengths-of sequence of zeros exceed the predefined limit.
      <br/>
      Bit stuffing may reduce the compression ratio but it sets an upper limit on the delay between encoding of a symbol and the emission of the corresponding code bits.
    </p>
    <p num="54">The encoding method of FIG. 6 may be implemented in software, employing the follow code:</p>
    <p num="55">
      --
      <br/>
      -- void encoder(boolean bit, int p, boolean mps)
      <br/>
      -- +
      <br/>
      --      z = a + p;
      <br/>
      --      d = 0 * 6000 + (z+a)&gt;&gt;2; // compute Z2(t) (here with k=1/4)
      <br/>
      --      if (d &lt; z)        // compute Z(t) = min�Z1(t), Z2(t) �
      <br/>
      --         z = d;
      <br/>
      --      if (bit == mps)
      <br/>
      --         +a = z; }
      <br/>
      --      else
      <br/>
      --         + s += 0 * 100000-z; a += 0 * 100000-z; }
      <br/>
      --      while (a &gt;= 0 * 8000)
      <br/>
      --         + emit(1-(s&gt;&gt;15));
      <br/>
      --      s = (s&amp;0 * 7fff)&lt;&lt;1; a + (a&amp;0 * 7fff)&lt;&lt;1; }
      <br/>
      -- }
    </p>
    <p num="56">
      The encoders and decoders of the Z-Coding system use an increment parameter p that represents the estimated probabilities of the LPS and MPS symbols.
      <br/>
      This section presents an analytic derivation of the relation between the symbol probability distribution PLPS and the optimal increment parameter p. This derivation relies on the analysis of a theoretical experiment that included a decoding a random string of independent equiprobable bits with a particular value of the increment p. The probability PLPS in the decoded symbol string can be calculated with the following simplifying assumptions:
      <br/>
      A(t) contains a uniform random number in internal (0,1/2�. This uniform distribution hypothesis is reasonably supported by empirical evidence, as long as the greatest common divisor of the increment p and the interval size 1/2 is small.
    </p>
    <p num="57">C(t) contains a uniform random number in interval �A(t),1�. This assumption is implied by the definition of the lower bound A(t) and by the random nature of the code string.</p>
    <p num="58">
      The assumptions also eliminate dependencies between consecutive decoded symbols.
      <br/>
      It is assumes that each bit is decoded with random values A(t) and C(t), regardless of previous decoding actions.
      <br/>
      Eliminating dependencies between consecutive symbols is surprisingly realistic.
      <br/>
      Real life applications tend to mix many streams of symbols with different probabilities into a single arithmetic coder.
      <br/>
      The interleaved mixture randomizes A(t) and C(t) quite efficiently.
    </p>
    <p num="59">
      Under these assumptions, the decoded symbols are independent identically distributed random variables.
      <br/>
      The probability of LPS can be derived using the following decomposition:
      <br/>
      P*(LPS)=P+Z1(t)&lt;Z2(t)} P+Z1(t)&gt;C(t) .vertline.
      <br/>
      Z1(t)&lt;Z2(t)}+P+Z1(t)&gt;Z2(t)} P+Z2(t)&gt;C(t) .vertline.
      <br/>
      Z1(t)&gt;Z2(t)}
    </p>
    <p num="60">Using this decomposition and the simplifying assumptions described above, a simple exercise in integral calculus provides analytical formulas relating P*(LPS) and p for each chosen value of the slope k (see, FIG. 8).</p>
    <p num="61">
      The case k=1/2, for instance, resolves to the following formula:
      <br/>
      P*(LPS)=p-(p+1/2) log (p+1/2)-(p-1/2) log 1/2
    </p>
    <p num="62">
      Decoding a random sequence of independent equiprobable bits produces a random sequence of independent symbols distributed as derived above.
      <br/>
      Conversely, encoding such a random sequence of symbols, under the same assumptions, produces a random sequence of equiprobable bits.
      <br/>
      That means that the increment p is the optimal increment for symbol string distribution P*(LPS).
    </p>
    <p num="63">
      This formula has been confirmed by empirical experiments seeking the optimum increment for chosen symbol probability distributions.
      <br/>
      Encoding a random symbol string with this optimal increment produces about 0.5% more code bits than predicted by the information theoretical limit.
      <br/>
      This is probably the price of the additive approximation to the computation of the z-value.
    </p>
    <p num="64">This following discussion presents a stochastic algorithm that automatically adapts the Z-Coder parameters (p and MPS) while encoding or decoding symbol strings.</p>
    <p num="65">
      The adaptation algorithm must remember some information about the observed symbol frequencies in the symbol string.
      <br/>
      It is convenient in practice to represent this information as a single integer state.
      <br/>
      Typical data compression applications maintain an array of state variables (also called "coding contexts").
      <br/>
      Each symbol is encoded with a coding context chosen according to application specific prior information about its probability distribution.
    </p>
    <p num="66">
      The integer state is used as an index into a table defining the actual coder parameters, i.e., the identity of the MPS (zero or one) and the probability PLPS (a number in �0,1/2�).
      <br/>
      The Z-Coder adaptation algorithm modifies the value of the state variable when certain conditions are verified:
      <br/>
      Encoding or decoding an LPS always triggers an LPS adaptation.
      <br/>
      The state variable is then changed to point a table entry with a larger value of the increment p, or, if the increment is already large, to point a table entry with swapped definition of the MPS and LPS symbols.
    </p>
    <p num="67">
      Encoding or decoding an MPS triggers an MPS adaptation if and only if A(t) is greater than a threshold m in �1/2-p, 1/2� tabulated as a function of the current state.
      <br/>
      The state variable is changed to point a table entry with a smaller value of the increment p. In another embodiment encoding or decoding a MPS triggers a MPS adaptation if and only if Z(t), which is related to A(t) in a known way, is greater than a threshold tabulated as a function of the current state.
    </p>
    <p num="68">
      FIG. 9 illustrates a method of operation 3000 of a decoder that integrates adaptation with the fast decoding of FIG. 6.
      <br/>
      Like steps from FIG. 6 are indicated with like reference numerals.
      <br/>
      After step 2130, when the decoder determines that a next bit to be decoded is an MPS, the decoder tests for MPS adaptation.
      <br/>
      Specifically, the decoder determines whether A(t)&gt;m, the threshold test variable for MPS adaptation (Step 3010).
      <br/>
      If so, the decoder performs the MPS adaptation (Step 3020).
      <br/>
      Thereafter, or if Z(t) fails the threshold of step 3010 (Z(t).notgreaterthan.m), the decoder resets A(t) for the next iteration (Step 2070).
      <br/>
      Equivalently, the decoder may test Z(t) against m.
    </p>
    <p num="69">At step 2150, when the decoder determines that the next bit to be decoded is an LPS, the decoder always performs LPS adaptation (Step 3030).</p>
    <p num="70">
      The remaining discussion pertains to symmetrical linear transition tables.
      <br/>
      These tables are organized like a ladder.
      <br/>
      The first rung represents the symbol distribution with the highest probability of zeroes.
      <br/>
      The last rung represents a symbol distribution with the highest distribution of ones.
      <br/>
      Each LPS transition moves the state variable on step towards the center of the ladder.
      <br/>
      Each MPS transition moves the state variable one step towards the closest tip of the ladder.
    </p>
    <p num="71">
      The limiting distribution of the state variable depends on the respective probabilities of the adaptation events.
      <br/>
      In the case of a symmetrical transition table, these probabilities must fulfill the following conditions:
      <br/>
      P(MPS adaptation)&lt;P(LPS adaptation) if p is too small
      <br/>
      P(MPS adaptation)&gt;P(LPS adaptation) if p is too large
      <br/>
      P(MPS adaptation)=P(LPS adaptation) if p is optimal
    </p>
    <p num="72">
      These conditions imply that the probability of both adaptation events must have the same order of magnitude.
      <br/>
      The Z-Coder adaptation algorithm uses Z(t) as a pseudo-random number generator to tune the probability of the MPS adaptation events.
    </p>
    <p num="73">
      Analytical expressions for the probabilities of the adaptation event are derived by assuming again that the lower bound register a contains a uniform random number in �0,1/2�. The following formulae are easily obtained by analyzing the encoding algorithm:
      <br/>
      P(LPS adaptation)=P(LPS)=PLPS
      <br/>
      P(MPS adaptation)=P(A(t)&gt;m.vertline.MPS) P(MPS)=(1-2m) (1-PLPS)
    </p>
    <p num="74">
      FIG. 8 compares the adaptation event probabilities as a function of the optimal increment p when the threshold m is equal to 1/2.
      <br/>
      These curves show that this value of the threshold makes the probability of the MPS adaptation event too high.
      <br/>
      A larger threshold is needed to reduce the probability of MPS adaptation event until it becomes equal to the probability of LPS adaptation event.
    </p>
    <p num="75">
      For each value of the state variable, a threshold m is chosen in order to ensure that both adaptation events occur with the same probability when the increment p is optimal for the current value of PLPS.
      <br/>
      The following expression gives the correct value of the threshold m as a function of the optimal increment p:
      <br/>
      m=1/2(1-P*(LPS)/(1-P*(LPS)))
    </p>
    <p num="76">where P*(LPS) is the expression derived above.</p>
    <p num="77">
      The Z-Coder adaptation algorithm differs significantly from the adaptation scheme introduced by the Q-Coder and used by the QM-Coder.
      <br/>
      These coders perform a MPS adaptation whenever encoding or decoding a MPS produces or consumes a code bit.
      <br/>
      This is similar to using a constant threshold m=1/2 with the Z-Coder adaptation algorithm.
      <br/>
      An optimally tuned Q-Coder or QM-Coder therefore produces more MPS adaptation events than LPS adaptation events.
      <br/>
      This is compensated by a careful design of asymmetrical state transition tables.
    </p>
    <p num="78">
      The Z-Coder state transition tables however are free of these constraints.
      <br/>
      This can be a significant advantage for creating efficient state transition tables in an analytically principled way.
    </p>
    <p num="79">The encoder or decoder of the present invention may be provided on a processor or digital signal processor with appropriate program instructions.</p>
    <p num="80">
      As shown herein, the Z-Coder is an adaptive binary arithmetic coder having the following characteristics:
      <br/>
      A new multiplication-free approximation of the interval splitting point provides an improved coding accuracy.
    </p>
    <p num="81">The decoder only keeps a lower bound on the code number, a simplification that leads to very fast implementation of the decoding algorithm.</p>
    <p num="82">The two registers used by both the encoding and the decoding algorithm require only sixteen bits and a carry bit, an implementation benefit that reduces the cost of implementation of the Z-Coder.</p>
    <p num="83">A new probability adaptation scheme reduces the constraints on state transition tables.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>We claim:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for encoding data, the data represented by a symbol string populated by more probable symbols ("MPS") and less probable symbols ("LPS"), the method comprising the steps of:</claim-text>
      <claim-text>initializing a code accumulator S; defining a coding interval extending from a variable lower bound A to a constant upper bound 1; for each position in the symbol string:</claim-text>
      <claim-text>- computing a test value Z subdividing the coding interval into sub-intervals in accordance with the relative probabilities of an MPS and an LPS occur in the position, a first sub-interval extending from the lower bound A to the test value Z, the second sub-interval extending from the test value Z to 1; - if the symbol located at the current position in the symbol string is a MPS, setting the lower bound A to the test variable Z for use in encoding of a next position in the decoded symbol string; - if the symbol located at the current position in the symbol string is an LPS, - adding the length of the second sub-interval to the accumulator S, and - computing a new lower bound A for use in encoding of a next position in the decoded symbol string;</claim-text>
      <claim-text>and - when a predefined criterion is met, outputting a segment of coded data and computing new values for both the accumulator S and the lower bound A.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein the computation of the test value Z comprises the steps of: computing a first test value Z1 derived from the lower bound A and from a current estimate P of the probability of the LPS symbol, computing a second test value Z2 derived the lower bound A and from the current estimate P of the probability of the LPS symbol, setting the test value Z to the lesser of Z1 and Z2.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 2, wherein Z1 and Z2 are computed according to: wherein R1 and R2 are powers of two.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 3, wherein R2 is twice R1.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 4, wherein R2 is four times R1.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 1, wherein the computation of the test value Z depends on the value of a parameter P approximating a probability of the occurrence of LPS symbols in the decoded symbol string, said method comprising the additional steps of: if the decoded symbol is a LPS, setting the parameter P to a value representing an increased estimated probability for the LPS symbol;</claim-text>
      <claim-text>and if the decoded symbol is a MPS; - comparing the lower bound A with a threshold value M depending on P, and - if the lower bound A is greater than the threshold value M, setting the parameter P to a value representing a decreased estimated probability for the LPS symbol.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 6, wherein the parameter P is indirectly represented by an integer index for accessing table entries specifying: the actual value of the parameter P, the value of the threshold M, the new value of the index used for representing an increased estimated probability for the LPS symbol and the new value of the index used for representing a decreased estimated probability for the LPS symbol.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 1, wherein the computation of the test value Z depends on the value of a parameter P representing the estimated probability of the LPS symbols, said method comprising the additional step of: if the decoded symbol is an LPS, setting the parameter P to a value representing an increased estimated probability for the LPS symbol. if the decoded symbol is a MPS, - comparing the test value Z with a threshold value M depending on P, and - if the test value Z is greater than the threshold value M, setting the parameter P to a value representing a decreased estimated probability for the LPS symbol.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 8, wherein the parameter P is indirectly represented by an integer index for accessing table entries specifying: the actual value of the parameter P, the value of the threshold M, the new value of the index used for representing an increased estimated probability for the LPS symbol and the new value of the index used for representing a decreased estimated probability for the LPS symbol.</claim-text>
    </claim>
  </claims>
</questel-patent-document>