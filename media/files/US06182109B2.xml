<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182109B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182109</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182109</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="24455880" extended-family-id="14411094">
      <document-id>
        <country>US</country>
        <doc-number>08613106</doc-number>
        <kind>A</kind>
        <date>19960308</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1996US-08613106</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>14730264</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>61310696</doc-number>
        <kind>A</kind>
        <date>19960308</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1996US-08613106</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/46        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>46</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F  15/16        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>15</main-group>
        <subgroup>16</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F  13/00        20060101AFI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>13</main-group>
        <subgroup>00</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="4">
        <text>G06F   9/50        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>50</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="5">
        <text>H04L  29/06        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>29</main-group>
        <subgroup>06</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>718104000</text>
        <class>718</class>
        <subclass>104000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>709203000</text>
        <class>709</class>
        <subclass>203000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>709226000</text>
        <class>709</class>
        <subclass>226000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-029/06</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>29</main-group>
        <subgroup>06</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131026</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/5027</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>5027</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131026</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/505</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>505</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131026</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/544</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>544</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131026</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-2209/5011</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>2209</main-group>
        <subgroup>5011</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140923</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="6">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-2209/5018</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>2209</main-group>
        <subgroup>5018</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20141003</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="7">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-2209/5022</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>2209</main-group>
        <subgroup>5022</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20141003</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="8">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H04L-067/42</classification-symbol>
        <section>H</section>
        <class>04</class>
        <subclass>L</subclass>
        <main-group>67</main-group>
        <subgroup>42</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131017</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>20</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>20</number-of-drawing-sheets>
      <number-of-figures>24</number-of-figures>
      <image-key data-format="questel">US6182109</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Dynamic execution unit management for high performance user level network server system</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>HOSCHLER HANS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4099235</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4099235</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>HIROSAWA TOSHIO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4748558</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4748558</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>MORTEN RICHARD M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5021949</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5021949</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>HEIZER ISAAC J</text>
          <document-id>
            <country>US</country>
            <doc-number>5249290</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5249290</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>PITKIN RICHARD P, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5341477</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5341477</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>CIDON ISRAEL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5446737</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5446737</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>FERGUSON DONALD F, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5504894</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5504894</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>PETTUS CHRISTOPHER E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5515508</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5515508</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>KLEIMAN STEVEN R</text>
          <document-id>
            <country>US</country>
            <doc-number>5515538</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5515538</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>DAVY WILLIAM</text>
          <document-id>
            <country>US</country>
            <doc-number>5517643</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5517643</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="11">
          <text>MILLER C KENNETH</text>
          <document-id>
            <country>US</country>
            <doc-number>5553083</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5553083</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="12">
          <text>AMAN JEFFREY D, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5603029</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5603029</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="13">
          <text>KONNO CHISATO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5752030</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5752030</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="14">
          <text>CUTLER DAVID N, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5752031</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5752031</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="15">
          <text>CHOQUIER PHILIPPE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5774668</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5774668</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="16">
          <text>GOSSLER THOMAS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5799173</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5799173</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="17">
          <text>DIGITAL EQUIPMENT CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0384339</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-384339</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="18">
          <text>AMERICAN TELEPHONE &amp; TELEGRAPH</text>
          <document-id>
            <country>EP</country>
            <doc-number>0413490</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-413490</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="19">
          <text>DIGITAL EQUIPMENT CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0384339</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-384339</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="20">
          <text>AMERICAN TELEPHONE &amp; TELEGRAPH</text>
          <document-id>
            <country>EP</country>
            <doc-number>0413490</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-413490</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="21">
          <text>IBM</text>
          <document-id>
            <country>EP</country>
            <doc-number>0473913</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-473913</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="22">
          <text>IBM</text>
          <document-id>
            <country>EP</country>
            <doc-number>0666665</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-666665</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="23">
          <text>IBM</text>
          <document-id>
            <country>EP</country>
            <doc-number>0694837</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-694837</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>IBM TDB, "Control of Dynamic Threads Pool for Concurrent Remote Procedure Calls", vol. 38, No. 5, pp. 199-200, May 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Rodley, John, "Thread Programming in UNIXWARE 2.0" Dr. Dobb's v20 n6 p(56)7, Jun. 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Frentzen et al, "Secure Servers" PC Week, v12 n43 p95(2), Oct. 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>Hajek, "Performance of global load balancing by local adjustment", IEEE digital library, 1990.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>Lin et al, "A dynamic load balancing policy with a central job dispatcher", IEEE digital library, 1991.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Sharma, Mohan</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Yeung, Leo Yue Tak</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>LaBaw, Jeffrey S.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Banankhah, Majid</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method, system and product for dynamically managing a pool of execution units in a server system, the pool devoted to a communication process between client and server processes.
      <br/>
      A minimum and a maximum number of execution units in the communication process poolis established.
      <br/>
      The minimum number of execution units is the number necessary to support a typical client load.
      <br/>
      The maximum number of execution units is an upper bound to support a peak client load without overloading the server system.
      <br/>
      As client requests for service are received by the server system, a number of determinations are made.
      <br/>
      It is determined whether assigning an execution unit to the request would bring a current number of execution units in the communication process pool over the maximum number of execution units.
      <br/>
      If so, the client request is rejected.
      <br/>
      It is determined whether assigning an execution unit to the request would bring the number of assigned execution units to a client task making the request over an allotted number of execution units for the client task.
      <br/>
      If so, the client request is rejected.
      <br/>
      The client request if the determinations are negative thereby assigning an execution unit in the commnication process pool to the client request.
      <br/>
      The number of unused execution units in the communication pool is periodically reviewed to determine whether it should be increased or decreased to improve system performace.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      This invention relates generally to data communication on computer networks and computer protocols which facilitate such communication.
      <br/>
      More particularly, it relates to an object oriented communication interface for network protocol access.
    </p>
    <p num="2">
      In the very early days of computing, computer systems were standalone processors to which peripheral devices such as displays and printers and input devices were connected.
      <br/>
      Each computer system was independent and there was little communication between computer systems.
      <br/>
      Today, it is well known to interconnect computer systems in computer networks such as local area networks or wide area networks to achieve a variety of benefits including the sharing of data, services and resources available from the various computer systems coupled to the networks.
    </p>
    <p num="3">
      To communicate between the different computer systems along a network, many communication protocols have been developed.
      <br/>
      Some examples of well-known network protocols include the System Network Architecture (SNA), Transmission Control Protocol/Internet Protocol (TCP/IP), Network Basic Input Output System (NetBIOS), and Internet Packet Exchange/Sequence Packet Exchange (IPX/SPX).
      <br/>
      Other communication protocols are known and widely used and described in various standards of ISO, IEEE and other organizations.
      <br/>
      To facilitate an understanding of the computer network, the network functions and associated software are often described as a series of layers.
      <br/>
      Data transfer between one copy of a distributed application over the network to another copy of the distributed application is accomplished by using the services of an underlying series of communication layers.
      <br/>
      Generally, each layer in one computer system has a counterpart layer in the receiving computer system so that each layer communicates with respective peer layers.
    </p>
    <p num="4">
      The seven layer Open Systems Interconnect (OSI) model is one of the best known descriptions of network communications, although many communication implementations combine or omit one or more of the OSI layers.
      <br/>
      In OSI, the physical layer is the lowest layer which interacts directly with the network.
      <br/>
      It includes the actual bit stream transmission across the physical connections to the network.
      <br/>
      The second layer is the datalink layer which provides multiplexing and framing of the physical layer stream into messages.
      <br/>
      It also provides error detection, synchronization information and physical channel management.
      <br/>
      The third layer is the network layer which controls routing of information through the network.
      <br/>
      Services such as addressing, network initialization, switching, segmenting and formatting are provided in this layer.
      <br/>
      Sometimes acknowledgement of data delivery is accomplished in this layer; sometimes in the datalink layer.
    </p>
    <p num="5">
      The fourth layer is the transport layer which controls transparent data delivery, multiplexing and mapping.
      <br/>
      Reliable delivery as opposed to best effort in the layers below is accomplished by this layer if desired by the application.
      <br/>
      Services such as retransmission of missing data, reordering of data delivered out of order and correction of transmission errors are usually accomplished in this layer.
      <br/>
      The fifth layer is the session layer which uses the information from the transport layer to group pieces of data together as a common activity between two nodes in the network called a session.
      <br/>
      The sixth layer is the presentation layer which includes the interface between the session layer and the seventh layer the application layer.
      <br/>
      The presentation layer presents the information for use in the application layer without compromising the integrity of the session layer.
      <br/>
      The presentation layer provides data interpretation and format and code transformation while the application layer provides user application interfaces and management functions.
    </p>
    <p num="6">
      Another well known network standard is the IEEE Standard.
      <br/>
      The primary difference between the IEEE model and OSI, is the splitting of the second OSI layer, the datalink layer into two sublayers, the media access layer (MAC) sublayer and the logical link control (LCC) sublayer.
      <br/>
      Media access control manages the medium access attachment in its control access to the communications media.
      <br/>
      The logical link control provides state machine for supporting the protocol specified by an associated data link control.
    </p>
    <p num="7">
      Another well known technology is object oriented programming which encapsulates data and methods into a programming entity called an object.
      <br/>
      By protecting certain methods and data through a public interface, an object oriented program can insulate each component from changes to other components yet provide the needed functions with a minimum of reprogramming.
      <br/>
      For more background information on object oriented technologies, concepts and conventions, the reader is referred to references such as Object Oriented Design With Applications, Grady Booch (The Benjamin/Cummins Publishing Company, 1990) and Object Oriented Software Construction, by B. Meyer, (Prentice Hall, 1988).
    </p>
    <p num="8">
      There have been previous attempts to apply object oriented technology to the general area of communication protocol in a multiprocessor network.
      <br/>
      As will be seen below, it remains a fertile area of invention.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="9">
      A method, system and product for dynamically managing a pool of execution units in a server system, the pool devoted to a communication process between client and server processes.
      <br/>
      A minimum and a maximum number of execution units in the communication process poolis established.
      <br/>
      The minimum number of execution units is the number necessary to support a typical client load.
      <br/>
      The maximum number of execution units is an upper bound to support a peak client load without overloading the server system.
      <br/>
      As client requests for service are received by the server system, a number of determinations are made.
      <br/>
      It is determined whether assigning an execution unit to the request would bring a current number of execution units in the communication process pool over the maximum number of execution units.
      <br/>
      If so, the client request is rejected.
      <br/>
      It is determined whether assigning an execution unit to the request would bring the number of assigned execution units to a client task making the request over an allotted number of execution units for the client task.
      <br/>
      If so, the client request is rejected.
      <br/>
      If the determinations are negative, thereby assigning an execution unit in the communication process pool is assigned to the client request.
      <br/>
      The number of unused execution units in the communication pool is periodically reviewed to determine whether it should be increased or decreased to improve system performace.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="10">
      These objects, features and advantages will be more readily understood with reference to the attached figures and following description.
      <br/>
      FIG. 1 depicts a computer system configured according to the teachings of the present invention.
      <br/>
      FIG. 2A illustrates a class hierarchy for network definition object.
      <br/>
      FIG. 2B illustrates the class hierarchy for the network address classes.
      <br/>
      FIG. 2C illustrates the class hierarchy for the protocol interface classes.
      <br/>
      FIG. 2D is an illustration of the class hierarchy for the protocol layer classes invention.
      <br/>
      FIG. 3A shows a state diagram for the connection oriented transitions.
      <br/>
      FIG. 3B is a state diagram of the connectionless state transitions.
      <br/>
      FIG. 4A shows the class relationships for TCP/IP embodiment of the invention.
      <br/>
      FIG. 4B is a flow diagram of the process for setting up a network connection according to the present invention.
      <br/>
      FIG. 5 is an architectural diagram of the various objects in their network layers in the network connection process shown in FIG. 4.
      <br/>
      FIG. 6A is a class hierarchy for the network event objects.
      <br/>
      FIG. 6B is a flow diagram for the process for collecting events from a single communication endpoint.
      <br/>
      FIG. 6C is a flow diagram for the process for collecting events from multiple communication endpoints.
      <br/>
      FIGS. 7A and 7B are architectural diagrams of a first and second embodiment for managing a pool of communication threads for handling client requests of a network protocol server.
      <br/>
      FIGS. 8A-8D are flow diagrams of the management process for the pool of communication threads.
      <br/>
      FIGS. 9A and 9B are class heirarchy diagrams for network operation objects.
      <br/>
      FIG. 9C shows the class relationships between various classes for the present invention.
      <br/>
      FIG. 9D depicts the flow of messages between various objects in the network according to the invention.
      <br/>
      FIG. 10 is a flow diagram for passing network protocol requests in a network operation object.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="11">
      The invention may be run on a variety of computers or collection of computers under a number of different operating systems.
      <br/>
      The computer could be, for example, a personal computer, a mini computer, mainframe computer or a computer running in a distributed network of other computers.
      <br/>
      Although the specific choice of computer is limited only by disk and disk storage requirements, computers in the IBM PC series of computers could be used in the present invention.
      <br/>
      For additional information on IBM's PC series of computers, the reader is referred to IBM PC 300/700 Series Hardware Maintenance Publication No. S83G-7789-03 and User's Handbook IBM PC Series 300 and 700 Publication No. S83G-9822-00.
      <br/>
      One operating system which an IBM personal computer may run is IBM's OS/2 Warp 3 0 (slashed zero)  For more information on the IBM OS/2 Warp 3.0 Operating System, the reader is referred to OS/2 Warp V3 Technical Library Publication No. GBOF-7116-00.
    </p>
    <p num="12">
      In the alternative, the computer system might be in the IBM RISC System/6000 (TM) line of computers which run on the AIX (TM) operating system.
      <br/>
      The various models of the RISC System/6000 is described in many publications of the IBM Corporation for example, RISC System/6000, 7073 and 7016 POWERstation and POWERserver Hardware Technical reference, Order No. SA23-2644-00.
      <br/>
      The AIX operating system is described in General Concepts and Procedure--AIX for RISC System/6000 Publication No. SC23-2202-02 as well as other publications of the IBM Corporation.
    </p>
    <p num="13">
      In FIG. 1, a computer 10, comprising a system unit 11, a keyboard 12, a mouse 13 and a display 14 are depicted in block diagram form.
      <br/>
      The system unit 11 includes a system bus or plurality of system buses 21 to which various components are coupled and by which communication between the various components is accomplished.
      <br/>
      The microprocessor 22 is connected to the system bus 21 and is supported by read only memory (ROM) 23 and random access memory (RAM) 24 also connected to system bus 21.
      <br/>
      A microprocessor in the IBM PS/2 series of computers is one of the Intel family of microprocessors including the 386 or 486 microprocessors.
      <br/>
      However, other microprocessors including, but not limited to, Motorola's family of microprocessors such as the 68000, 68020 or the 68030 microprocessors and various Reduced Instruction Set Computer (RISC) microprocessors such as the PowerPC chip manufactured by IBM, or others made by Hewlett Packard, Sun, Motorola and others may be used in the specific computer.
    </p>
    <p num="14">
      The ROM 23 contains among other code the Basic Input-Output system (BIOS) which controls basic hardware operations such as the interaction of the disk drives and the keyboard.
      <br/>
      The RAM 24 is the main memory into which the operating system and application programs are loaded.
      <br/>
      The memory management chip 25 is connected to the system bus 21 and controls direct memory access operations including, passing data between the RAM 24 and hard disk drive 26 and floppy disk drive 27.
      <br/>
      The CD ROM 32 also coupled to the system bus 21 is used to store a large amount of data, e.g., a multimedia program or presentation.
    </p>
    <p num="15">
      Also connected to this system bus 21 are various I/O controllers: The keyboard controller 28, the mouse controller 29, the video controller 30, and the audio controller 31.
      <br/>
      As might be expected, the keyboard controller 28 provides the hardware interface for the keyboard 12, the mouse controller 29 provides the hardware interface for mouse 13, the video controller 30 is the hardware interface for the display 14, and the audio controller 31 is the hardware interface for the speakers 15.
      <br/>
      An I/O controller 40 such as a Token Ring Adapter enables communication over a network 46 to other similarly configured data processing systems.
    </p>
    <p num="16">
      One of the preferred implementations of the invention is as sets of instructions 48-52 resident in the random access memory 24 of one or more computer systems configured generally as described above.
      <br/>
      Until required by the computer system, the set of instructions may be stored in another computer memory, for example, in the hard disk drive 26, or in a removable memory such as an optical disk for eventual use in the CD-ROM 32 or in a floppy disk for eventual use in the floppy disk drive 27.
      <br/>
      One skilled in the art would appreciate that the physical storage of the sets of instructions physically changes the medium upon which it is stored electrically, magnetically, or chemically so that the medium carries computer readable information.
      <br/>
      While it is convenient to describe the invention in terms of instructions, symbols, characters, or the like, the reader should remember that all of these and similar terms should be associated with the appropriate physical elements.
      <br/>
      Further, the invention is often described in terms of comparing or validating, or other terms that could be associated with a human operator.
      <br/>
      No action by a human operator is desirable in any of the operations described herein which form part of the present invention; the operations are machine operations processing electrical signals to generate other electrical signals.
    </p>
    <p num="17">
      The network in which the workstation is integrated is a Local Area Network (LAN) or a Wide Area Network (WAN), the latter comprising a teleprocessing connection to other nodes or a network of systems operating under a known computer architecture.
      <br/>
      At any of the nodes, there may be one or more processing systems each of which may be a single user or a multi-user system configured more or less as described above.
      <br/>
      These processing systems operate as a client or server workstation depending upon whether it is requesting or supplying services.
      <br/>
      In one particular implementation, the invention runs on a plurality of IBM compatible workstations interconnected by a network communicating by one or more of various communication protocols.
      <br/>
      The software applications may be packaged together or sold as separate applications.
      <br/>
      A simplified description of local area networks may be found in a book by Larry E. Jordan and Bruce Churchill entitled: Communications and Networking For The IBM PC Published by: Robert J. Brady (A Prentice Hall Company 1983).
    </p>
    <p num="18">
      In a preferred embodiment, the invention is implemented in the C++ programming language using object-oriented programing techniques. C++ is a compiled language.
      <br/>
      Programs are written in a human-readable script and this script is provided to another program called a compiler to generate a machine-readable numeric code which can be loaded into, and directly executed by a computer.
      <br/>
      The C++ language possesses certain characteristics which allow a software developer to easily use programs written by others while still providing a great deal of control over the reuse of programs to prevent their destruction or improper use.
      <br/>
      The C++ language is well-known and many articles and texts are available which describe the language in detail.
    </p>
    <p num="19">
      As known by those skilled in the art, object-oriented programming techniques involve the definition, creation, use and destruction of "objects".
      <br/>
      These objects are software entities comprising data elements and routines, or methods, which manipulate the data elements.
      <br/>
      The data and related methods are treated by the software as an entity and can be created, used and deleted as such.
      <br/>
      The data and functions enable objects to model real-world entity in terms of its attributes, which can be presented by the data elements, and its behavior, which can be represented by its methods.
    </p>
    <p num="20">
      Objects are defined by creating "classes" which are not objects themselves, but which act as templates which instruct a compiler how to construct the actual object.
      <br/>
      A class may, for example, specify the number and type of data variables and the steps involved in the functions which manipulate the data.
      <br/>
      An object is actually created in the program by means of a special function called a constructor which uses the corresponding class definition and additional information, such as arguments provided during object creation, to construct the object.
      <br/>
      Objects are destroyed by a special function called a destructor.
    </p>
    <p num="21">
      Many benefits arise out of three basic properties of object-oriented programming techniques: encapsulation, polymorphism and inheritance.
      <br/>
      Objects can be designed to hide, or encapsulate, all, or a portion of, the internal data structure and the internal functions.
      <br/>
      More particularly, during program design, a program developer can define objects in which all or some of the data variables and all or some of the related methods are considered "private" or for use only by the object itself.
      <br/>
      Other data or methods can be declared "public" or available for use by other programs.
      <br/>
      Access to the private variables and methods by other programs can be controlled by defining public methods which access the objects private data.
      <br/>
      The public methods form an interface between the private data and external programs.
      <br/>
      An attempt to write program code which directly accesses the private variables causes the compiler to generate an error during program compilation.
      <br/>
      This error stops the compilation process and prevents the program from being run.
    </p>
    <p num="22">
      Polymorphism allows objects and functions which have the same overall format, but which work with different data, to function differently to produce consistent results.
      <br/>
      For example, an addition method may be defined as variable A plus variable B, (A+B).
      <br/>
      This same format can be used whether the A and B are numbers, characters or dollars and cents.
      <br/>
      However, the actual program code which performs the addition may differ widely depending on the type of variables which comprise A and B. Thus, three separate method definitions can be written, one for each type of variable (numbers, characters and dollars).
      <br/>
      After the methods have been defined, a program can later refer to the addition method by its common format (A+B) and, during compilation, the C++ compiler will determine which of the three methods to be used by examining the variable types.
      <br/>
      The compiler will then substitute the proper function code.
    </p>
    <p num="23">
      A third property of object-oriented programming is inheritance which allows program developers to reuse pre-existing programs.
      <br/>
      Inheritance allows a software developer to define classes and the objects which are later created from them as related through a class hierarchy.
      <br/>
      Specifically, classes may be designated as subclasses of other base classes.
      <br/>
      A subclass "inherits" and has access to all of the public functions of its base classes as though these functions appeared in the subclass.
      <br/>
      Alternatively, a subclass can override some or all of its inherited functions or may modify some or all of its inherited functions by defining a new function with the same form.
    </p>
    <p num="24">The creation of a new subclass borrowing the functionality of another class allows software developers to easily customize existing code to meet their particular needs.</p>
    <p num="25">
      Although object-oriented programming offers significant improvements over other programming concepts, program development still requires significant outlays of time and effort, especially if no pre-existing software programs are available for modification.
      <br/>
      Consequently, a set of pre-defined, interconnected classes are sometimes provided to create a set of objects and additional miscellaneous routines which are all directed to performing commnonly-encountered tasks in a particular environment.
      <br/>
      Such pre-defined classes and libraries are typically called "frameworks" and essentially provide a pre-fabricated structure for working application.
    </p>
    <p num="26">
      For example, framework for a user interface might provide a set of pre-defined graphic interface objects which create windows, scroll bars, menus, etc. and provide the support and "default" behavior for these graphic interface objects.
      <br/>
      Since many frameworks are based on object-oriented techniques, the predefined classes can be used as base classes and the built-in default behavior can be inherited by developer-defined sublcasses and either modified or overridden to allow developers to extend the framework and create customized solutions in a particular area of expertise.
      <br/>
      This object-oriented approach provides a major advantage over traditional programming since the programmer is not changing the original program, but rather extending the capabilities of the original program.
      <br/>
      In addition, the framework provides architectural guidance and modeling and, at the same time, frees the developers to supply specific actions unique to the problem domain.
    </p>
    <p num="27">A networking framework is provided by the invention described below to provide network services for the applications of various computer systems in a computer network.</p>
    <p num="28">Protocol Interface Model</p>
    <p num="29">
      The object oriented protocol interface model and mechanism are described in this section.
      <br/>
      The generic nature of this interface enables the development of any layer of the OSI network model.
      <br/>
      As such, all the network layers will have similar syntax, the semantics of which will be defined by the particular layer specifications.
      <br/>
      In other words, objects embodying different layers in the OSI network model are similar in syntax, however, their implementation could differ depending on the particular layer responsibilities.
      <br/>
      Further, the objects embodying respective layers for a particular protocol, e.g., TCP/IP, may differ in capabilities and implementations for similar layers of a different protocol, e.g., Net BIOS, because of the differences in responsibilities of the respective layers in the two protocols.
      <br/>
      The model also provides mechanisms for defining a communication endpoint, reusing the endpoint, and monitoring network events.
      <br/>
      Being an object oriented model, it inherits all the features of object oriented implementation such as code reusability, maintainability, and ability to update the implementations without affecting the client applications.
    </p>
    <p num="30">1. Creating a Communication Endpoint</p>
    <p num="31">
      The creation of a communication endpoint is facilitated through the network definition objects.
      <br/>
      Each network definition object contains the definition of a client interface.
      <br/>
      These are the abstractions for the different types of objects the client program would want to access.
      <br/>
      The communication endpoint is the TAccessDefinition object which is derived from the network definition class.
    </p>
    <p num="32">
      FIG. 2A gives the class hierarchy for the network definition objects.
      <br/>
      The TNetworkDefinition class 100 contains methods for instantiating the endpoint and destroying the communication endpoint, InstantiateDefinition and DeinstantiationDefinition, respectively.
      <br/>
      Methods for constructing a new instance of TNetworkDefinition or destruction the particular class object are also provided, these methods are common to all the classes and will not be repeated below.
    </p>
    <p num="33">
      The TAccessDefinition object 101 contains the protocol interface objects that define the particular protocol type and its layers.
      <br/>
      The TAccessDefinition object 101 serves as the handle for the communication endpoint.
      <br/>
      In addition, to the methods inherited from its parent, TNetworkDefinition, the TAccessDefinition object 101 also include methods that add an interface layer to the access definition on top of the ones already added, Add to top, methods to add an interface layer to the AccesssDefinition to the ones already added at the bottom, add to bottom, and methods to get the highest protocol layer interface, GetTopOfStack.
      <br/>
      The TEventDefinition, class 103 is used to monitor the network events.
      <br/>
      The TEventDefinition class 103 will be described in greater detail below in the NetworkEvent section.
    </p>
    <p num="34">2. Network Address Classes</p>
    <p num="35">
      The TNetworkAddress class 111 is the base class used to define all the protocol address classes and the hardware address classes.
      <br/>
      FIG. 2B illustrates the class hierarchy of the protocol address classes.
      <br/>
      The TNetworkAddress class 111 contains methods for testing a type of address, IsOf AddressType, testing for a group address IsGroup, testing for a broadcast address, IsBroadCast, testing for a multicast address, IsMulticast and testing for a null address, IsNullAddress.
      <br/>
      This class also contains methods for getting the wire length of an address, GetWireLength, formatting the address into a header, AddressToWire, and getting the address from a header, WireToAddress.
      <br/>
      There are operators to determine whether a stream is coming into the endpoint or the stream is originating from the endpoint are also part of the class.
      <br/>
      A method for getting a pointer which is unique for each class, GetClassIdentifier, is provided by the class.
    </p>
    <p num="36">
      An instance of the TProtocol Address class object serves as a communication endpoint so that the protocol address can be passed.
      <br/>
      The TProtocolAddress object 113 adds methods for getting a broadcast address, BroadCastAddress, and for getting a null address, NullAddress.
      <br/>
      Instances of the THardwareAddress object 115 pass hardware addresses to an application if needed.
      <br/>
      The THardwareAddress object 115 similarly adds methods for getting a broadcast address, BroadCastAddress and getting a null address, NullAddress.
      <br/>
      It also adds a method for testing for a functional address, IsFunctional.
      <br/>
      The TIEEE8023 Address class changed the hardware class address according to the IEEEE802.3 addressing conventions.
      <br/>
      In addition, it adds methods for testing for group address, IsGroup, setting to the group address, SetGroup, reset the group address, ClearGroup.
      <br/>
      Other methods include BroadCastAddress which gets a BroadCastAddress, IsMulticast which tests for a multicast address, null address which gets a NullAddress and CanonicalAddress which gets an address from canonical input.
    </p>
    <p num="37">
      The TTCPAddr 117 and 119 TNBAddr are the examples of some concrete address classes that represent the TCP/IP and NetBIOS addressing specifics, respectively.
      <br/>
      Similarly, the TIEEE8023Addr 121 and TIEEE8025Addr 123 represent the concrete hardware addresses for IEEE802.3 and IEEE802.5 addressing.
    </p>
    <p num="38">3. Protocol Interface Classes</p>
    <p num="39">
      The invention supports both the connection oriented and connectionless transactions.
      <br/>
      It also describes the state machines that a protocol independent applications would follow.
      <br/>
      The object hierarchy for the protocol interface classes is illustrated in FIG. 2C. The protocol interface classes are derived from a base class called MProtocolServe 133 which contains methods for all the common functions that a protocol must have.
      <br/>
      The TProtocolInterface class 135 contains additional methods for the network functions.
      <br/>
      These methods are detailed below in Table 1 and Table 2.
      <br/>
      A network protocol such as TCP/IP will derive its TCPIPInterface class from the TProtocolInterface to override the default implementations and add its own specific features.
      <br/>
      Such as a check for valid flags on a send or receive request Separate classes which derive from the TProtocolInterface class are provided for the session layer, TSessionInterface 137, for the transport layer TTransportInterface 138, for the network layer TNetworkInterface 141, for the family layer TFamilyInterface 143, and for the data link layer TDLCInterface 145.
      <br/>
      In the object hierarchy is illustrated in this embodiment, the OSI network layer is split into a Network Layer and a lower layer called a protocol Family Layer.
      <br/>
      The family layer contains the non-replicated portion of the OSI Network Layer such as routing information.
      <br/>
      The Network Layer contains information relative to a particular endpoint such as the peer address and local SAP.
      <br/>
      This is done to ensure that only one object such as a FamilyLayer object stays resident in the system keeping all the global information relative to the protocol.
      <br/>
      As each endpoint is created and destroyed by the client applications, the other protocol layer objects such as the sessions layer and the transport layer objects and network layer object are created and destroyed while the family layer object and the datalink layer objects stay resident.
    </p>
    <p num="40">
      The concrete classes are derived from the individual interface classes.
      <br/>
      For example, as is discussed below concrete classes are provided for transport, network, and family interface classes for a particular protocol, e.g., TCP/IP, to build the protocol stack.
    </p>
    <p num="41">
      -- TABLE 1
      <br/>
      -- As mentioned above, the MProtocolService object
      <br/>
      -- serves as the base class for the protocol layer
      <br/>
      -- definitions.
      <br/>
      Following are the list of methods that are
      <br/>
      -- provided in the MProtocolService object.
      <br/>
      Most of these
      <br/>
      -- methods are pure virtual functions.
      <br/>
      --      Bind                  -Initialize and bind a local
      <br/>
      --                             address
      <br/>
      --      Unbind                -Unbind a local address
      <br/>
      --      SendRelease           -Orderly release initiation
      <br/>
      --      ReceiveRelease        -Acknowledge receipt of orderly
      <br/>
      --                             release initiation.
      <br/>
      --      GetLocalAddress       -Get the local address
      <br/>
      --      SetLocalAddress       -Set the local address
      <br/>
      --      GetPeerAddress        -Get the peer address
      <br/>
      --      SetPeerAddress        -Set the peer address
      <br/>
      --      GetProtocolInfo       -Get the protocol info
      <br/>
      --      SetProtocolInfo       -Set the protocol info
      <br/>
      --      GetProtocolOptions    -Set the protocol options
      <br/>
      --      GetRequestMode        -Get the request mode
      <br/>
      --      SetRequestMode        -Set the request mode
      <br/>
      --      GetRetry              -Get the protocol layer retry
      <br/>
      --                             parameter
      <br/>
      --      SetRetry              -Set the protocol layer retry
      <br/>
      --                             parameter
      <br/>
      --      GetTimeout            -Get the protocol layer timeout
      <br/>
      --                             Parameter
      <br/>
      --      SetTimeout            -Set the protocol layer timeout
      <br/>
      --                             parameter
      <br/>
      --      GetStatistics         -Get the protocol layer statistics
      <br/>
      --      SetStatistics         -Set the protocol layer statistics
      <br/>
      --      IsSession             -Return TRUE if protocol layer is a
      <br/>
      --                             session layer
      <br/>
      --      IsTransport           -Return TRUE if protocol layer is a
      <br/>
      --                             transport layer
      <br/>
      --      IsNetwork             -Return TRUE if protocol layer is a
      <br/>
      --                             network layer
      <br/>
      --      IsFamily              -Return TRUE if protocol layer is a
      <br/>
      --                             family layer
      <br/>
      --      Operator&lt;&lt;= -Operator for receiving the object
      <br/>
      --                             into a data stream
      <br/>
      --      Operator&lt;&lt;= -Operator for sending the object
      <br/>
      --                             into a data stream
    </p>
    <p num="42">
      -- TABLE 2
      <br/>
      -- The following are the list of functions that are provided
      <br/>
      -- in TProtocolInterface class.
      <br/>
      --      GetLayerIndex         -Get the index of the protocol layer
      <br/>
      --      Cancel Requests       -Cancel all the current outstanding
      <br/>
      --      requests
      <br/>
      --      ReceiveEvent          -Receive events on this stack
      <br/>
      --      GetConnectionInfo     -Obtain connection info &amp; memory
      <br/>
      --                             constraints
      <br/>
      --      BorrowMemory          -Borrow system memory for network
      <br/>
      --                             data
      <br/>
      --      ReturnMemory          -Return system memory for network
      <br/>
      --      data
      <br/>
      --      GetAccessDefinition   -Get the pointer to the
      <br/>
      --                             TAccessDefinition
      <br/>
      --      GetLocalAddress       -Get the local address for a layer
      <br/>
      --      SetLocalAddress       -Get the local address for a layer
      <br/>
      --      GetPeerAddress        -Get the peer address for a layer
      <br/>
      --      SetPeerAddress        -Get the peer address for a layer
      <br/>
      --      GetProtocolInfo       -Get the protocol info for a layer
      <br/>
      --      SetProtocolInfo       -Set the protocol info for a layer
      <br/>
      --      GetProtocolOptions    -Get the protocol options for a
      <br/>
      --      layer
      <br/>
      --      SetProtocolOptions    -Set the protocol options for a
      <br/>
      --      layer
      <br/>
      --      GetRequestMode        -Get the request mode for a layer
      <br/>
      --      SetRequestMode        -Set the request mode for a layer
      <br/>
      --      GetRetry              -Get the protocol layer retry
      <br/>
      --                             parameter
      <br/>
      --      SetRetry              -Set the protocol layer retry
      <br/>
      --      parameter
      <br/>
      --      GetStatistics         -Get the protocol layer statistics
      <br/>
      --      GetTimeout            -Get the protocol layer timeout
      <br/>
      --                             parameter
      <br/>
      --      SetTimeout            -Set the protocol layer timeout
      <br/>
      --                             parameter
      <br/>
      --      Bind                  -Bind a protocol stack
      <br/>
      --      Unbind                -Unbind a protocol stack
      <br/>
      --      Receive               -Receive network data
      <br/>
      --      Send                  -Send network data
      <br/>
      --      Connect               -Initiate an attempt to establish a
      <br/>
      --                             connection
      <br/>
      --      ReceiveConnection     -Wait for an attempt to establish
      <br/>
      --                             connection
      <br/>
      --      Disconnect            -Terminate a connection
      <br/>
      --      ReceiveDisconnect     -Wait for a disconnection
      <br/>
      --      AcceptConnection      -Accept an attempt to establish a
      <br/>
      --                             connection
      <br/>
      --      RejectConnection      -Reject an attempt to establish a
      <br/>
      --                             connection
      <br/>
      --      Listen                -Listen for attempts to establish
      <br/>
      --                             connections
      <br/>
      --      ListenForConnection   -Listen for an attempt to establish
      <br/>
      --                             a connection
      <br/>
      --      SendRelease           -Orderly release initiation =&gt; no
      <br/>
      --                             more data to send
      <br/>
      --      ReceiveRelease        -Acknowledge receipt of orderly
      <br/>
      --                             release indication
      <br/>
      --      Operator&lt;&lt;= -Operator to stream-in the object to
      <br/>
      --                             a data stream
      <br/>
      --      Operator&gt;&gt;= -Operator to stream-out the object
      <br/>
      --                             to a data stream
    </p>
    <p num="43">
      4.
      <br/>
      Protocol Layer Implementation Classes
    </p>
    <p num="44">
      As discussed above, the protocol interface model functions as an object based API to access the protocol layers.
      <br/>
      The implementation of a protocol stack such as TCP/IP as a layered set of linked objects is achieved by using the TProtocolLayer class.
      <br/>
      The FIG. 2D shows the class hierarchy for the protocol layer classes.
      <br/>
      The TProtocolLayer class 151 serves as a base class for all the layers of a protocol implementation.
    </p>
    <p num="45">
      The TProtocolLayer class 151 contains methods for functions such as Transmit, Connect, Receive, and Disconnect which are implemented at each layer.
      <br/>
      These methods are detailed in Table 3 below.
    </p>
    <p num="46">The concrete classes for protocols such as TCP/IP derive from these layer objects and incorporate their specific protocol layer semantics.</p>
    <p num="47">Each of the child objects 153-161 inherit these methods and override them where appropriate for the specific protocol layer.</p>
    <p num="48">
      -- TABLE 3
      <br/>
      -- The following are the main functions of the
      <br/>
      -- TProtocolLayer class.
      <br/>
      --      Dispatch              -  Dispatch an inbound packet to a
      <br/>
      --                               higher layer
      <br/>
      --      Transmit              -  Transmit an outbound packet to a
      <br/>
      --                               lower layer
      <br/>
      --      DispatchEvent         -  Dispatch an event to a higher
      <br/>
      --                               layer
      <br/>
      --      TransmitEvent         -  Transmit an event to a lower layer
      <br/>
      --      ReceiveEvent          -  Enable reporting of events
      <br/>
      --      CancelReceiveEvent    -  Cancel reporting of events
      <br/>
      --      InstantiateInterface  -  Create an interface object from a
      <br/>
      --                               layer object
      <br/>
      --      GetUpperProtocol      -  Get the pointer to the next higher
      <br/>
      --                               layer
      <br/>
      --      GetLowerProtocol      -  Get the pointer to the next lower
      <br/>
      --                               layer
      <br/>
      --      Bind                  -  Bind a protocol stack
      <br/>
      --      Unbind                -  Unbind a protocol stack
      <br/>
      --      Connect               -  Initiate an attempt to establish a
      <br/>
      --                               connection
      <br/>
      --      ReceiveConnection     -  Wait for an attempt to establish
      <br/>
      --                               connection
      <br/>
      --      Disconnect            -  Terminate a connection
      <br/>
      --      GetPacketQueue        -  Return the pointer to the packet
      <br/>
      --                               queue from
      <br/>
      --                               which to obtain inbound data
      <br/>
      --                               packets
      <br/>
      --      ReceiveDisconnect     -  Wait for a disconnection
      <br/>
      --      AcceptConnection      -  Accept an connection initiation
      <br/>
      --      RejectConnection      -  Reject an attempt to establish a
      <br/>
      --                               connection
      <br/>
      --      Listen                -  Listen for attempts to establish
      <br/>
      --                               connections
      <br/>
      --      ListenForConnection   -  Listen for an attempt to establish
      <br/>
      --                               a connection
      <br/>
      --      SendRelease           -  orderly release initiation =&gt; no
      <br/>
      --                               more data to send.
      <br/>
      --      ReceiveRelease        -  acknowledge receipt of orderly
      <br/>
      --                               release indication.
      <br/>
      --      operator&lt;&lt;= -  Operator to marshal the
      <br/>
      --                               TProtocolLayer object to a data
      <br/>
      --                               stream
      <br/>
      --      operator&gt;&gt;= -  Operator to unmarshal the
      <br/>
      --                               TProtocollayer object to a
      <br/>
      --                               datastream
    </p>
    <p num="49">
      5.
      <br/>
      Protocol State Machines
    </p>
    <p num="50">
      This section describes the possible states of the protocol interface object for both connection oriented and connectionless operations.
      <br/>
      The protocol state machines are illustrated in FIGS. 3A and 3B. These state machines depict typical state transitions in protocols although a particular implementation of a protocol may choose to differ.
      <br/>
      The state machines, however, ensures portability of applications and enables protocol independence.
      <br/>
      Applications which require protocol independence would use the state machines described below and the protocols supporting protocol independence would implement the state machines.
    </p>
    <p num="51">
      A protocol endpoint for a particular protocol interface layer object could be in any of the states described below.
      <br/>
      These states are typically the application states.
      <br/>
      The layer objects follow the state machine which a particular protocol defines.
      <br/>
      Typically, these states are to indicate valid calls that a user can make in different "endpoint" states and how an application should be written.
      <br/>
      The layer states are controlled by the layer semantics and states.
    </p>
    <p num="52">
      The Uninitialized state 201 defines the start state of the endpoint which is also the final state of the endpoint.
      <br/>
      This is the state before an access definition is created.
    </p>
    <p num="53">
      When a TAccessDefinition object is created 202, the endpoint is said to be initialized.
      <br/>
      In the Initialized state 203, the interface objects could be built and initialized using the Set operations.
      <br/>
      Since the Set operations are cached locally in the interface objects, there is little scope to validate the set values.
      <br/>
      In other words, before the protocol layer objects are created via the InstantiateDefinition method the send/receive capacity, can be set on the interface objects.
      <br/>
      Since the information on the limits to these capacities is known only to the layer objects, it is not possible to validate these values on the interface as the layer objects do not exist until the InstantiateDefinition method is called on the AccessDefinition object.
      <br/>
      A request to destruct the TAccessDefinition object 204 moves the endpoint from the initialized state 203 to an uninitialized state 201.
    </p>
    <p num="54">
      An instantiate request 206 on the TAccessDefinition object, moves the endpoint to the unbound state 207.
      <br/>
      The Unbound state 207 defines the state that occurs immediately after the layer object has been instantiated.
      <br/>
      Get/Set operations can be issued to modify values.
      <br/>
      These requests are no longer cached in the interface object, but are sent to the corresponding layer object for processing and storage.
      <br/>
      A deinstantiate request 208 on the TAccessDefinition object moves the endpoint to the initialized state 203.
    </p>
    <p num="55">
      The endpoint moves from the unbound state 207 to the bound state 209 when the Bind operation 210 is issued to bind a local address.
      <br/>
      An endpoint for connectionless mode of data transfer can begin sending and receiving data once it is in the "bound" state.
      <br/>
      An unbind request 212 issued to a stack in the Bound state 209 returns the endpoint to the unbound state 207.
    </p>
    <p num="56">
      The endpoint moves from the bound state 209 to the listening state 213 when a Listen request 214 is issued.
      <br/>
      The protocol stack will accept incoming connection requests for that local name until the user specified queue size is exhausted.
      <br/>
      Incoming connections 216 cause new active protocol stacks to be created.
    </p>
    <p num="57">
      The endpoint moves from the bound state 209 to the connecting (client) state 219 when the Connect request state 219 is issued in an active endpoint.
      <br/>
      As shown in FIG. 3B, an endpoint using connectionless mode of service enters the "Data Transfer" state 225 after a successful request for connection is made.
      <br/>
      In the case of a passive endpoint, the protocol stack upon receiving an incoming connection request creates a copy of the layer and interface objects and new TAccessDefinition for the received connection request.
      <br/>
      The newly created endpoint is then put in the connecting (server) state 221.
      <br/>
      The arrow is on the dotted line from the Listening state to the Connecting(Server) state.
      <br/>
      An application may choose to accept the connection or reject it.
      <br/>
      An AcceptConnection would put the endpoint into the data transfer state 225.
      <br/>
      If the connection request 226 is rejected, then the endpoint moves to the Inactive state 229.
    </p>
    <p num="58">
      The endpoint enters the DataTransfer state 225 after a newly created stack completed the connect request 222.
      <br/>
      A connected endpoint will move to the bound state 209 upon receiving a Disconnect request 228 from the local application or after the connection is terminated by the connected partner.
      <br/>
      Note that in such a case, the application can issue a ReceiveDisconnect request to receive the termination data.
    </p>
    <p num="59">
      The endpoint moves to the Inactive state 229 when an incoming connection request is rejected by the application.
      <br/>
      The endpoint is then discarded by Issuing the destruct TAccessDefinition operation 230.
    </p>
    <p num="60">6. An Example</p>
    <p num="61">
      This section contains an example of how the object-oriented model of the present invention be used for a network protocol such as TCP/IP.
      <br/>
      The TCP/IP implementation will contain a transport layer, a network layer, and a TCP/IP Family layer.
      <br/>
      Further, that the networking subsystem contains a TDatalink layer object which is resident in the system and that the TCP/IP FamilyLayer object has a way to access the TDatalink layer.
      <br/>
      Note that in this embodiment, the TDataLink Layer object is common to all network protocol stacks such as TCP/IP, SNA, and NetBIOS and that the TDatalink Layer object derives from the TProtocolLayer class object.
    </p>
    <p num="62">
      The TCP/IP interface (API) classes are derived from the TProtocolInterface class.
      <br/>
      FIG. 4A shows the class hierarchy of some of the objects in the TCP/IP implementation.
      <br/>
      As discussed above, TProtocol Interface and TProtocol layer are child classes of the MProtocol Service class providing the API and Protocol implementation functions.
      <br/>
      The TTCPTINF 251, TTCPNINF 253 and TTCPFINF 255 objects (collectively referred to as TTCPXINF) are examples of concrete classes of TProtocollnterface that represent the TTransportInterface, TNetworkInterface, and TFamilylnterface classes for TCP/IP protocol.
      <br/>
      Note that since the TCP/IP protocol does not have a notion of a "sessions", there is no instance of the TSession Layer class.
      <br/>
      Similarly, the TTCPTIMP 257, TTCPNIMP 259 and TTCPFIMP 261 objects (collectively referred to as TTCPXIMP) are instances of the TTransportInterface, INetworkInterface and TFamily Interface classes for the TCP/IP protocol.
    </p>
    <p num="63">As mentioned above, the TDatalinkLayer 161 is an implementation object for all network protocols in this embodiment and is a subclass of the TProtocolLayer class 151.</p>
    <p num="64">
      Also, applications are provided with a TTCPProtocolAddress class so that the IP address can be passed.
      <br/>
      The TTCPProtocolAddress will contain the 4-byte IP address and a 2-byte port address.
    </p>
    <p num="65">
      The process which an application needs to access the TCP/IP protocol is discussed below in reference to FIG. 4B. In most cases, the "application" is most likely a communications API layer such as a BSD sockets interface to which a user level application would make API calls.
      <br/>
      The sockets interface would shield the application developer from the need to know particular syntax of the network protocol objects.
      <br/>
      However, the "application" could also be an operating system service familiar with the names of the object model of the present invention.
      <br/>
      The application is accessing the transport layer in the following example.
      <br/>
      An application can access any of the layers.
      <br/>
      It could talk to the network layer directly.
      <br/>
      There are few user applications which currently access the network layer directly, however.
      <br/>
      These steps are very similar at a high level to those in a procedural implementation of the TCP/IP protocol.
      <br/>
      However, they are implemented in an object oriented manner using the protocol interface model of the present invention.
    </p>
    <p num="66">
      In step 301, a communication endpoint is created to access TCP/IP protocol.
      <br/>
      This is done by first creating an TAccessDefinition object.
      <br/>
      For example, using C++, a "new TAccessDefinition" is constructed.
      <br/>
      Next, the TTCPxINF interface objects are created and added to the AccessDefinition using the methods in TAccessDefinition Then the InstantiateProtocol method is called on the TAccessDefinition object which then creates TTCPxIMP layer objects.
    </p>
    <p num="67">
      In step 303, an address is bound to the communication endpoint created in step 301.
      <br/>
      This is accomplished by creating a TTCPProtocolAddress object with the required IP address from the provided TTCPProtocolAddress class object.
      <br/>
      Next, the TTCPTINF-&gt;Bind( ) method is called to bind the address.
      <br/>
      This step will trigger the TTCPIMP-&gt;Bind( ) method on the protocol implementation layers which contain the bind semantics.
    </p>
    <p num="68">
      Next, in step 307, the application connects to a listening peer by calling the TTCPTINF-&gt;Connec( ) method (in the TTCPTINFobject) to initiate a connection request.
      <br/>
      This triggers the TTCPTIMP-&gt;Connect ( ) method (in the TTCPTIMP object) which then performs the necessary steps for setting up a TCP/IP connection by calling the lower layers namely the TTCPNIMP and TTCPFIMP objects for the TTCPNIP-&gt;Connect( ) and TTCPFIMP-&gt;Connect methods respectively.
    </p>
    <p num="69">
      After a successful connection, data may be sent and received over the resulting protocol stack in step 309.
      <br/>
      The application calls TTCPTINF-&gt;Send( ) and TTCPTINF-&gt;Receive( ) methods to send and receive network data.
      <br/>
      The TTCPTINF-&gt;Send( ) in turn calls the TTCPTIMP-&gt;Xmit( ) method to begin the data transmission semantics of the TCP protocol.
      <br/>
      The data is passed from protocol layer object to protocol layer object using the Xmit( ) function in each protocol layer and then delivered to the TDataLinkLayer object for it send it over the communication adapter.
      <br/>
      Similarly, for the receive function.
      <br/>
      The TDataLinkLayer receives the data from the physical layer and gives it to the appropriate protocol family layer which in turn passes it to the appropriate stack.
      <br/>
      In one implementation, the data is queued until a receive data request from the client is made and data is copied from the data queue to the client.
    </p>
    <p num="70">
      A connection is closed in step 311 after completion of the desired communication.
      <br/>
      The application calls the TTCPTINF-&gt;Disconnect( ) method to initiate the connection termination.
      <br/>
      This in turn invokes the TTCPTIMP-&gt;Disconnect( ) which takes care of TCP/IP disconnect state machine in TTCPTIMP which might send the method and down to the family layer for a particular implementation.
    </p>
    <p num="71">Finally, in step 313, the endpoint is closed by the deleting the TAccessDefinition object.</p>
    <p num="72">
      It may help the reader to appreciate the relationship between the various objects and the network layers to refer to FIG. 5.
      <br/>
      At the left side of the drawing, the TCP/IP embodiment discussed above in connection with FIGS. 4A and 4B is shown.
      <br/>
      TCP/IP applications 313, 315 communicate via a sockets API 317 both of which are in the application layer to the object oriented protocol stack in the layers below.
      <br/>
      The TProtocolAddreas object used by the sockets API to create a communication endpoint is not shown in the figure.
      <br/>
      A separate communication endpoint, and therefore, a separate TProtocolAddress object is needed for each TCP/IP application 313, 315.
    </p>
    <p num="73">
      As mentioned above, TCP/IP does not have a notion of a session layer so the sockets API 317 communicates with the TTCPTINF object 251 in the transport layer.
      <br/>
      As discussed above, the TAccessDefinition object 318 contains the TTCPxINF objects 251, 253, 255 in the transport, network and family layers.
      <br/>
      It would be relatively rare for user level processes to commicate to the protocol stack through the network or family layers, however, the TTCPNINF object 253 and TTCPFINF object 255 are provided for communication to those layers, primarily by operating system services.
    </p>
    <p num="74">
      The TTCPTINF object 251 connects to the TTCPTIMP object 257 with the TTCPTINF--&gt;Connect( ) method.
      <br/>
      This triggers the TTCPTIMP--&gt;Connect( ) method to connect to the TTCPNIMP object 259 and the TTCPNIMP--&gt;Connect( ) method to connect to the TTCPFIMP object 261.
      <br/>
      The TTCPFIMP--&gt;Connect( ) method is triggered which connects to the TDatalinkLayer object 161.
      <br/>
      As shown in the figure, the TTCPTIMP 257, TTCPNIMP 259, TTCPFIMP 261 and TDatalinkLayer 161 objects are in the transport, network, family and datalink layers respectively.
      <br/>
      As discussed above, the send and receive methods allow network data to be sent over the protocol stack via the physical adapter 319 in the physical layer.
    </p>
    <p num="75">
      In the preferred embodiment, the TDataLinkLayer object 161 and TTCPFIMP object 261 are persistent and singular as communication endpoints are created and deleted.
      <br/>
      A separate thread and instance of each of the other objects (251, 253, 255, 257, 259, 318) is required for each active endpoint.
      <br/>
      As one skilled in the art could readily appreciate, in the case of a network protocol server with potentially thousands of client connections, the overhead associated with such an arrangement could cause performance problems.
      <br/>
      As discussed in the Dynamic Execution Unit Management section below, the present invention provides a means to dynamically manage the execution threads to maximize performance.
    </p>
    <p num="76">
      On the right side of the figure, a NetBIOS implementation is shown.
      <br/>
      Thus, the present invention contemplates a multiprotocol environment wherein the system may support multiple applications running multiple network protocols.
      <br/>
      As shown in FIG. 5, the NetBIOS applications 331, 333 may communicate with the lower layers either through the sockets API 317 or a specialized NetBIOS API layer 335.
      <br/>
      Thus, the invention also contemplates multiple applications able to access the object oriented protocol stacks of the present invention.
      <br/>
      These applications can be object based or procedurally based, either user level applications or operating system level processes.
    </p>
    <p num="77">
      A similar process as described above is used to establish the NetBIOS stack.
      <br/>
      Note that as NetBIOS does have session layer semantics the API layers 317, 335 connect to the TNSINF object 337 in the session layer.
      <br/>
      After the NetBIOS interface objects, TNSINF 337, TNTINF 339, TNNINF 341, TNFINF 343, and the NetBIOS protocol layer objects, TNSIMP 347, TNTIMP 349, TNNIMP 351, TNFIMP 353, are created, the communication pathway is established through the TNSINF object 337 through the protocol layer objects to the TDataLinkLayer object 161.
      <br/>
      As in the TCP/IP embodiment, the TDataLinkLayer object 161 and the TNFIMP object 353 are persistent and singular, whereas a separate instance of each of the other objects is created and deleted for each of the active communication endpoints.
    </p>
    <p num="78">
      Multiple adapters 319, 321 may be accommodated by the present invention coupled to the TDataLinkLayer 161.
      <br/>
      These adapters may be used for different network protocols concurrently as the upper layers will provide the proper routing to the communication endpoints.
      <br/>
      Furthermore, the adapters can be of different types, e.g., Ethernet and Token Ring, so that the server can service requests from different networks.
    </p>
    <p num="79">7. Protocol Utility Classes</p>
    <p num="80">
      These classes are used by the TProtocolInterface and TProtocolLayer classes.
      <br/>
      Most of these classes serve as parameters of various methods in the Interface and implementation classes.
      <br/>
      These classes highlight the generic nature of the proposed model.
    </p>
    <p num="81">This section contains some of the important classes of which protocol interface makes use.</p>
    <p num="82">a. TProtocolInfo Class</p>
    <p num="83">
      This class identifies various characteristics of the protocol such as service type, maximum message size, and expedited data length.
      <br/>
      The following are some of the important methods the class provides.
    </p>
    <p num="84">These are used to specify the endpoint characteristics at the time of creating these endpoints.</p>
    <p num="85">
      --
      <br/>
      --      GetPSDUSize           -Get the protocol service Data
      <br/>
      --      Unit                   maximum size SetPSDUSize
      <br/>
      --                            -Get the Protocol Service Data
      <br/>
      --                             Unit maximum size
      <br/>
      --      GetEPSDUSize          -Get the Expedited Protocol
      <br/>
      --                             Service Data Unit maximum size
      <br/>
      --      PSDUSize              -Set the Expedited Protocol
      <br/>
      --                             Service Data Unit maximum size
      <br/>
      --      GetConnectionDataSize -Get the Connect Data maximum
      <br/>
      --                             size
      <br/>
      --      SetConnectDataSize    -Set the Connect Data maximum
      <br/>
      --                             size
      <br/>
      --      GetDisconnectDataSize -Get the Disconnect Data maximum
      <br/>
      --                             size
      <br/>
      --      SetDisconnectDataSize -Set the Connect Data maximum
      <br/>
      --                             size
      <br/>
      --      GetDisconnectDataSize -Get the Disconnect Data maximum
      <br/>
      --                             size
      <br/>
      --      SetDisconnectDataSize -Set the Disconnect Data maximum
      <br/>
      --                             size
      <br/>
      --      GetServiceType        -Get the service type such as
      <br/>
      --                             connection/connectionless
      <br/>
      --      SetServiceType        -Set the Service Type
      <br/>
      --      SetServiceType        -Set the Service Type
      <br/>
      --      SetServiceFlags       -Set the Service Flags
    </p>
    <p num="86">
      b.
      <br/>
      TProtocolOptions Class
    </p>
    <p num="87">
      This class is used to define protocol specific options including quality of service.
      <br/>
      However, the base class does not include any.particular quality of service.
      <br/>
      The concrete classes are expected to derive from the TProtocolOptions and include their specific options.
    </p>
    <p num="88">
      --
      <br/>
      --      GetLingerTime        -Get the protocol linger time
      <br/>
      --      SetLingerTime        -Set the protocol linger time
      <br/>
      --      GetSendbufSize       -Get the protocol Send Buffer size
      <br/>
      --      SetSendbufSize       -Set the protocol Send Buffer size
      <br/>
      --      GetRcvbufSize        -Get the protocol Receive Buffer size
      <br/>
      --      SetRcvbufSize        -Set the protocol Receive Buffer size
    </p>
    <p num="89">
      c.
      <br/>
      TSendModifiers Class
    </p>
    <p num="90">
      The Tsendmodifiers class qualifies the flags that are associated with a network Send function in TProtocolInterface::Send and TProtocolLayer::Xmit( ) methods.
      <br/>
      The indications that could affect a send function are as follows besides supporting a send timeout.
    </p>
    <p num="91">
      --
      <br/>
      --        kPush                -request immediate processing
      <br/>
      --        kEdnOfMessage        -mark end of message
      <br/>
      --        kExpeditedData       -treat data as expedited
      <br/>
      --        kNotify              -notify sender when client buffer
      <br/>
      --                              is available
      <br/>
      --        kSendAll             -block until all "n" bytes are
      <br/>
      --                              buffered
      <br/>
      --        kNoFragmentation     -do not fragment the data
    </p>
    <p num="92">The following are some of the important functions supported in this class.</p>
    <p num="93">
      --
      <br/>
      --      GetSendModifier       -Get the value for a SendModifier
      <br/>
      --      SetSendModifier       -Set a SendModifier ON
      <br/>
      --      ClearSendModifier     -Set a SendModifier OFF
      <br/>
      --      GetTimeout            -Get the send timeout
      <br/>
      --      SetTimeout            -Set the send timeout
    </p>
    <p num="94">
      d.
      <br/>
      TReceiveModifiers Class
    </p>
    <p num="95">This class is used to define the receive flags in the TProtocolInterface::Receive( ) function.</p>
    <p num="96">
      This class contains the methods and definitions for setting flags and timeouts while receiving network data.
      <br/>
      These are as follows:
    </p>
    <p num="97">
      --
      <br/>
      --        kPeek                     -peek user data
      <br/>
      --        kExpeditedData            -receive expedited data
      <br/>
      --        kReceiveAll               -block until "n" bytes
      <br/>
      --                                   are received
      <br/>
      --        kBroadcastData            -receive broadcast
      <br/>
      --                                   datagrams
      <br/>
      --        kDiscardBufferOverflow    -discard the part of
      <br/>
      --                                   message that
      <br/>
      --                                   overflows the receive
      <br/>
      --                                   buffer
      <br/>
      --        kDatagramAny              -receive either normal
      <br/>
      --                                   or broadcast
      <br/>
      --                                   datagrams
    </p>
    <p num="98">The following are some of the important functions of this class.</p>
    <p num="99">
      --
      <br/>
      --         GetReceiveModifier      -Get the value for a
      <br/>
      --                                  ReceiveModifier
      <br/>
      --         SetReceiveModifier      -Set a
      <br/>
      --                                  ReceiveModifier ON
      <br/>
      --         ClearReceiveModifier    -Set a
      <br/>
      --                                  ReceiveModifier OFF
      <br/>
      --         GetTimeout              -Get the receive
      <br/>
      --                                  timeout
      <br/>
      --         SetTimeout              -Set the receive
      <br/>
      --                                  timeout
    </p>
    <p num="100">
      e.
      <br/>
      Send Completion Class
    </p>
    <p num="101">
      The sendcompletion object is returned in response to a network data send operation.
      <br/>
      It indicates the status of the send function and also indicates the total number of bytes sent.
      <br/>
      The following are the status indications.
    </p>
    <p num="102">
      --
      <br/>
      --         kNormal            -normal completion
      <br/>
      --         kTimeout           -send timeout
      <br/>
      --         kCancelled         -application cancelled the send
      <br/>
      --                                request
    </p>
    <p num="103">The following are some of the important methods of this class.</p>
    <p num="104">
      --
      <br/>
      --      GetSTatus             -Get the SendCompletion status
      <br/>
      --      SetStatus             -Set the SendCompletion status
      <br/>
      --      GetBytesTransferred   -Get the number of bytes of client
      <br/>
      --                                data sent
      <br/>
      --      SetBytesTransferred   -Set the number of bytes of client
      <br/>
      --                                data sent
    </p>
    <p num="105">
      f.
      <br/>
      TReceiveCompletion Class
    </p>
    <p num="106">
      The receive completion object is returned in response to a network data receive request.
      <br/>
      It indicates the status of the receive function and the total number of bytes of data received.
      <br/>
      The following are the status indications.
    </p>
    <p num="107">
      --
      <br/>
      --        kNormal               -normal completion
      <br/>
      --        kPushed               -sender "pushed" the data
      <br/>
      --        kNoMoreData           -stream is ending or the
      <br/>
      --                                receive pipe closed
      <br/>
      --        kEndOfMessage         -end-of-message encountered
      <br/>
      --        kExpeditedData        -expedited data received
      <br/>
      --        kTimeout              -receive timeout
      <br/>
      --        kMessageTruncated     -partial msg &amp; the rest is
      <br/>
      --                                discarded.
      <br/>
      --        kCancelled            -cancel request processed
      <br/>
      --        kMore                 -more data ready to be
      <br/>
      --                                received
    </p>
    <p num="108">The following are some of the important functions of this class.</p>
    <p num="109">
      --
      <br/>
      --        GetStatus               -Get the ReceiveCompletion
      <br/>
      --                                 status
      <br/>
      --        SetStatus               -Set the ReceiveCompletion
      <br/>
      --                                 status
      <br/>
      --        GetBytesTransferred     -Get the number of bytes of
      <br/>
      --                                 client data received
      <br/>
      --        SetBytesTransferred      Set the number of bytes of
      <br/>
      --                                 client data received
    </p>
    <p num="110">Network Event Management</p>
    <p num="111">
      This section discloses an object-oriented solution to the problem of accessing multiple network events over multiple network protocol stacks and storing them at various protocol layers is described in this section.
      <br/>
      A single and consistent set of class definitions for all network events based on the OSI network protocol layer model are provided by the invention.
      <br/>
      Events are defined for each generic OSI layer and each implementation of these layers could choose to add additional layer specific events by defining additional subclasses.
      <br/>
      Being an object-oriented model, this solution takes full advantage of polymorphism and inheritance in OO technology.
    </p>
    <p num="112">
      The classification of events based on OSI layers provides a clear categorization of events which are stored and reported at a protocol layer.
      <br/>
      With this categorization, events can be retrieved for a particular layer, if it is of interest to the applications.
      <br/>
      These events may describe conditions of the communication session of the client has established, e.g., data received and is available for receipt or the connection has been aborted.
      <br/>
      A client can monitor these asynchronous events on any protocol layer of multiple protocol stacks using a single call.
      <br/>
      The invention spans event reporting over multiple protocols such as TCP/IP and NetBIOS so that the application need not look for individual endpoint events.
      <br/>
      In addition, the network event mechanism facilitates interaction between network protocol layers to send and receive network events between layer objects.
    </p>
    <p num="113">1. Event Description</p>
    <p num="114">
      Events are defined using a base class known as the TProtocolEvent.
      <br/>
      FIG. 6A illustrates the class hierarchy between the various event objects.
      <br/>
      FIG. 6A is similar to FIG. 2A, accept that it also shows the TProtocolEvent class 401 which is a subclass of the TEventDefinition class 103.
      <br/>
      The TProtocolEvent class 401 contains an enumerated class of events, a set of comnonly used events at all OSI layers and reserved range of values for individual protocol layer events.
      <br/>
      The TProtocolEvent class has methods for setting and getting events and membership questions.
      <br/>
      In one embodiment, network events are set as bit vectors in this class and the GetCnt method returns the number of events currently in this object.
      <br/>
      This is a typical way of specifying a list of options, events in this case: another way used commonly is to use bit masks.
      <br/>
      Only a single object is required due to the power of object oriented technology, hiding all data within the object and provides method to get them.
    </p>
    <p num="115">
      A particular network protocol may define protocol events by redefining the event values in the TProtocolEvent class.
      <br/>
      Some of the important methods in TProtocolEvent are: GetEvent returns the event of the index identified; HasA which Searches for a particular event in the list (membership); GetCnt which returns the number of events in the object; GetAccessDefinition which returns the access definition which indicates the endpoint; SetAccessDefinition which sets the access definition for the endpoint and SetEvent which Sets a single event in the TProtocolEvent object.
    </p>
    <p num="116">2. Event Interface to a OSI Layer Implementation</p>
    <p num="117">
      As discussed in the Protocol Interface Model section above, in the preferred embodiment, the network protocol layers are implemented as a sequence of TProtocolLayer objects, each representing a particular OSI layer.
      <br/>
      These objects are chained to each other to complete a protocol stack.
      <br/>
      For example, a TCP/IP stack may have objects for the transport layer, the network layer, and the datalink layer.
      <br/>
      Each protocol layer object has two event interfaces, namely the ReceiveEvent interface and the CancelEvent interface as defined in the TProtocolLayer object.
      <br/>
      The layers use the DispatchEvent method to pass an event to an object in a higher layer and the TransmitEvent method to send an event to a lower protocol layer.
      <br/>
      It is up to an implementation of a protocol stack to store the events in appropriate layers.
    </p>
    <p num="118">The event related methods in the TProtocolLayer class are: DispatchEvent which dispatches an event to a higher layer; TransmitEvent which transmits an event request queue to a lower layer; ReceiveEvent which reports event(s) by adding a TProtocolEvent object to the EventRequestQueue; and, CancelReceiveEvent which disregards the EventRequestQueue.</p>
    <p num="119">3. Event Monitoring by an Application</p>
    <p num="120">
      The TProtocolInterface class object which provides the base class for the object based API to each of the network protocol layers contains a function which an endpoint can use to receive network events.
      <br/>
      The event related function in the class TProtocolInterface is the ReceiveEvent method which receive event(s) set in the TProtocolEvent object for a particular communication endpoint.
    </p>
    <p num="121">
      The TEventDefinition object is used when an application needs to monitor events over multiple communication endpoints.
      <br/>
      The TEventDefinition object serves as a object-endpoint to monitor events.
      <br/>
      An instance of this object is created and deleted as needed by the application.
      <br/>
      The main methods in the TEventDefinition object are: InstantiateDefinition which instantiates an instance of the TEventDefinition object; DeInstantiateDefinition which destroys the instance of the TEventDefinition object; ReceiveEventAny which receive events from multiple stacks, either in an array or queue of TProtocolEvent objects; and CancelRequest which cancels a pending event request.
    </p>
    <p num="122">a. Receiving Events on One Communication Endpoint</p>
    <p num="123">
      An application can receive events on a particular endpoint using the ReceiveEvent method on an instance of the TProtocolInterface class for a particular network layer.
      <br/>
      Note that the endpoints access protocols using the TProtocolInterface object for that protocol.
      <br/>
      The application program sets the required events in a TProtocolEvent object and then calls the ReceiveEvent method.
      <br/>
      The TProtocolInterface object returns a TProtocolEvent object containing the events, if any, which have occurred.
    </p>
    <p num="124">The process of receiving events on one communication endpoint is illustrated in the flow diagram in FIG. 6B. In this example, the transport layer is the top layer and the event is stored in the network layer and the request from the application is made to the transport layer.</p>
    <p num="125">
      Another alternative is to set up an event interface directly to the layer to receive the event.
      <br/>
      However, the process will have to do so with every layer for events which is not much of advantage.
      <br/>
      It is better to get it from one point and the client makes one call to get events from all layers using the event vector as a selection criterion.
    </p>
    <p num="126">
      FIG. 6B describes the event receiving mechanism over a single endpoint.
      <br/>
      A request to receive one or many events over the endpoint is made to the interface object using the TProtocolInterface::Receive Even( )to 411 method.
      <br/>
      A ProtocolEventQueue 413 created internally which eventually contain the TProtocolEvents reported by the endpoint.
      <br/>
      The request is then sent to the corresponding layer object using the TProtocolLayer::ReceiveEvent( ) 415 method.
      <br/>
      The figure shows the request is sent betwen the layer objects.
      <br/>
      The TProtocolVentQueue is sent as a parameter in the ReceiveEvent request.
      <br/>
      The protocol layer object enqueues a TProtocolEvent to this queue whenever an event occurs and before receiving a TProtocolLayer::CancelEvent( ) request which invalidates the TProtocolEventQueue.
      <br/>
      Depending on the requested events, TxxTransportLayer may send the request down to the TxxNetworkLayer 417 using the TransmitEvent( ) method in TProtocolLayer class.
      <br/>
      Similarly, the TxxNetworkLayer may send the request 419 down to the TxxFamilyLayer if the event request should reach the lower layers.
    </p>
    <p num="127">
      Whenever an event occurs asynchronously, the TProtocolLayer object may report the event to a higher layer using the DispatchEven( ) 421. The network layer then reports this event to the TxxTransportLayer 423.
      <br/>
      The TxxTransportLayer enqueues the reported event in the ProtocolEventQueue 415.
      <br/>
      The event is then reported back to the caller 411.
    </p>
    <p num="128">b. Receiving Events Over Multiple Communication Endpoints</p>
    <p num="129">
      Applications may create an endpoint for events for multiple communication endpoints by using the TEventDefinition object.
      <br/>
      As shown in FIG. 6A, TEventDefinition class 103 is derived from the TNetworkDefinition class 100.
      <br/>
      The TEventDefinition object 103 serves as an endpoint for monitoring events over any protocol and for any number of endpoints.
      <br/>
      For each communication endpoint of interest to the application program, the required number of ProtocolEvents is set in the TProtocolEvent object.
      <br/>
      In other words, pairs of the 2-tuple (endpoint, protocolevent) are formed for all the endpoints whose events are to be monitored.
      <br/>
      The application then makes a call to ReceiveEventAny( ) method in the TEventDefinition object passing the set of requested events from various endpoints.
      <br/>
      The ReceiveEventAny returns with events in a queue of TProtocolEvents or times out.
      <br/>
      It should be noted that all the communication endpoints are created using the TAccessDefinition class.
    </p>
    <p num="130">
      FIG. 6C illustrates the receive event mechanism over multiple endpoints.
      <br/>
      The application creates a TEventDefinition object 451 which serves as an event endpoint.
      <br/>
      The application then creates an array of TProtocolEvent objects 453 one per endpoint.
      <br/>
      The array of requested events over the endpoints is passed as a parameter to the TEventDefinition::ReceiveEventAny( ) 455. The ReceiveEventAny( ) method creates a TProtocolEventQueue 457 and sends the queue 461 to all the endpoints over which the events are sought.
      <br/>
      The TxxProtocolLayer which receives the request via the ReceiveEvent request 463 may transmit the event request to the layer below.
      <br/>
      This is the same for all the endpoints 465.
      <br/>
      Whenever a TxxProtocolLayer receives an event asynchronously, it may either dispatch the event to a higher layer or report the event in the TProtocolEventQueue.
      <br/>
      Once an event is in the TprotocolEventQueue, a TxxProtocolLayer::CancelEvent( ) is sent to the TxxProtocolLayer of all the associated endpoints.
      <br/>
      The ReceiveEventAny method 455 then retrieves 459 all the TProtocolEvents from the TProtocolEventQueue and reports them to the caller.
      <br/>
      If there are no events reported, then the queue would be empty.
    </p>
    <p num="131">
      After a response is received from any of the endpoints, then all the endpoints receive a CancelEvent request to indicate that the life of the ProtocolEventQueue object is over.
      <br/>
      Even though, the request has been canceled, the event still are saved in the protocol layer.
      <br/>
      The client can come back with another ReceiveEvent next time to get new events.
      <br/>
      In this embodiment, a pull model from the client is used meaning the client obtains the event when convenient to the client.
      <br/>
      The collected set of ProtocolEvents are returned to the caller.
      <br/>
      The collected set of ProtocolEvents are returned to the caller.
    </p>
    <p num="132">Dynamic Execution Unit Management</p>
    <p num="133">
      In a multi-tasking system, a network protocol stack such as TCP/IP can be efficiently implemented using a client/server model.
      <br/>
      The server may be a user level task using multi-tasking techniques to support a large number of clients.
      <br/>
      To guarantee satisfactory performance when supporting a large number of clients, it is often necessary to preallocate a fixed set of server resources to a particular process.
      <br/>
      One critical server resource is the number of allocated server execution units.
      <br/>
      In a modern operating system such as OS/2 and Windows NT, the basic unit of execution is a thread.
      <br/>
      While many today's systems have "light-weight" threads (meaning fast thread switching), unfortunately, thread creations/deletions are not "light-weight" enough to support the performance requirements of a network protocol server like that proposed by the present invention when scaling up to support thousands of clients.
    </p>
    <p num="134">
      Furthermore, as the number of threads increases, the system, i.e. the server, performance degrades significantly.
      <br/>
      Thread switching overhead tends to increase proportionally as the number of threads increases in addition to footprints allocated in the system.
      <br/>
      This is further complicated for a network server which may need to support multiple concurrent requests from the same client, e.g., performing a send and receive data in two threads in full duplex communication under a network session.
      <br/>
      As a result, the number of threads in the server dedicated to service multiple concurrent clients may be very large.
      <br/>
      Therefore, managing the server execution units, e.g., threads, efficiently is critical to the server's ability to support large number of clients with satisfactory performance.
    </p>
    <p num="135">
      This section discloses a method for a Network Protocol Server to dynamically manage the number of execution threads.
      <br/>
      This method reduces the threads resources required to serve a large number of clients.
      <br/>
      Admission control is provided to keep individual clients from consuming all of the server allocated thread resources.
      <br/>
      At the same time, a particular client will not be starved indefinitely waiting for server thread resources.
    </p>
    <p num="136">1. Server Execution Unit Management</p>
    <p num="137">
      Server threads are created and managed in a server thread pool.
      <br/>
      When the server is first started up, a server management thread is created.
      <br/>
      In one preferred object oriented embodiment, this is done by instantiating a TNetworkServer class object which contains methods for managing the client port pool and network server threads pool described below.
      <br/>
      The server management thread is responsible for management of the server thread pool by coordinating the creation or deletion of server threads in the thread pool.
      <br/>
      The server management thread is normally asleep.
      <br/>
      It will be wakened up by a request signal and a timer periodically.
    </p>
    <p num="138">
      All client requesting services must establish a session with the server initially.
      <br/>
      The session request is sent to a single server communication end point called session_port.
      <br/>
      Each client is assigned an unique communication end point called client_port after a communication session with the server has been established.
      <br/>
      In a preferred embodiment, there is a one to one correspondence between a TAccess Definition Object with each client_port assigned on the Server Side.
    </p>
    <p num="139">
      The client and the server may communicate with each other using an RPC mechanism.
      <br/>
      The remote procedure call (RPC) mechanism provides the necessary request routing and admission control as discussed below.
      <br/>
      The RPC mechanism can be built on top of internal process communication Internal procedure call (IPC) services of the underlying operating system.
      <br/>
      In addition to locating the server task, the following are the basic RPC primitives:
    </p>
    <p num="140">Client side,</p>
    <p num="141">SendRequest(server_port(session or client), request_data, reply_data)</p>
    <p num="142">
      Server side,
      <br/>
      ReceiveRequest (request_data)
      <br/>
      SendReply (reply_data)
    </p>
    <p num="143">
      The client_ports of all the clients are collected into a client_port pool.
      <br/>
      Using its assigned client_port, the client can now issue a network request to the server.
      <br/>
      The server manages requests from the client_port pool, and assigns a thread in the thread pool to service requests received from any member of the client_port pool.
      <br/>
      FIG. 7A illustrates the flow of control and management of the client_port pool and thread pool in a first object oriented network embodiment wherein the client and server application objects reside in memory allocated to different processors in a multiprocessor configuration such as a symmetrical multiprocessor (SMP) and the two communicate via an object oriented RPC interface.
    </p>
    <p num="144">
      A plurality of client machines 500 communicate to a server machine 503 over a network 505.
      <br/>
      Each of the client machines 500 may have a plurality of client application objects 507 resident each capable of making client requests.
      <br/>
      As shown, the client objects 507 send their requests to an appropriate RPC/API object in the RPC/API layer 509 which makes the connection to the server using an IPC object 511 running in a different address space.
      <br/>
      The protocol stack establishes the communication path to the network 505.
      <br/>
      According to the embodiment, a thread counting object, described in more detail below, is added to the protocol stack to determine whether the client machine or client task has exceeded its allowance of communication threads at the requested server.
      <br/>
      Otherwise, the communication path will not be created and the client process will be told to wait for an available thread or the protocol stack will simply deny service to the client process.
      <br/>
      Although only one server is pictured in the diagram, the thread counting object can keep track of the client accounts at a plurality of server machines in the network.
    </p>
    <p num="145">
      Presuming that the communication path to the server is established, the protocol stack 513 receives the client request which it sends to the session port object 519 which assigns a session port, a communication endpoint at the server end.
      <br/>
      The client request is assigned a client port from the client pool object 521.
      <br/>
      The client port is a client communication endpoint which is returned to the client protocol stack if there are sufficient threads available at in the thread pool 522 at the server.
      <br/>
      The set of network protocol server objects which manage the session port allocation, the client port pool and the thread pool are described in greater detail below.
      <br/>
      Once the threads, client port and session port have been allocated, communication can proceed to the server set of RPC/API objects 515 and upward to the server services 517.
    </p>
    <p num="146">
      The dynamic execution unit management can also be performed in a procedurally based system.
      <br/>
      Also, as shown in FIG. 7B, the mechanism can be applied to a single processor machine whose memory is divided into a client space 531 and a server space 533, an environment wherein a plurality of client tasks 535, 537, 539 are running in the same machine as a server task 540.
      <br/>
      The client tasks send their requests to the server task via a client side RPC library interface 541.
      <br/>
      The requests are first handle on the server side by a server side RPC library 543.
      <br/>
      Next, a session port is allocated by the session port process 545 and a client port is allocated from the client port pool 547.
      <br/>
      Threads are assigned from the thread pool 549 so that the protocol stack 551 can handle the client requests out to the network 553.
    </p>
    <p num="147">
      The number of threads within the pool is controlled by several system configured variables.
      <br/>
      These variables may be modified by a system administrator with a user configuration program.
      <br/>
      (MinThreads)--This is the minimum number of threads reserved to service client requests.
      <br/>
      This limit is used to maintain the minimum number of threads used to support a typical server load of clients.
      <br/>
      (MaxThreads)--This is the maximum number of threads reserved to service client requests.
      <br/>
      This limit is used as an upper bound on thread resources dedicated to serve a peak load of clients without overloading the server system.
      <br/>
      (MaxReq)--This is the maximum number of concurrent requests that the given client is allowed.
      <br/>
      (TotalThreads)--This is the total number of threads created to service all client requests.
      <br/>
      This value is always between the minThreads and MaxThreads.
      <br/>
      (ReservedThreads)--This is the total number of reserved to support all the client sessions.
      <br/>
      (Unusedthreads)--This is the number of unused threads in the pool.
      <br/>
      (Clientthreads)--For each client, this is the number of active requests being serviced by the server.
    </p>
    <p num="148">The number of threads in the pool grows or shrinks dynamically based on the number of concurrently active clients requests being processed.</p>
    <p num="149">The processes, or methods in the object oriented embodiment, used to manage the number of threads is discussed in greater detail below in reference to FIGS. 8A-8D.</p>
    <p num="150">
      Referring now to FIG. 8A, in step 575 at server initialization, a &lt;MinThreads&gt; number of threads are created and inserted into the thread pool.
      <br/>
      Also in this step, (UnusedThreads) &amp; (TotalThreads) is set to (MinThreads), and (ReservedThreads) is set to 0.
      <br/>
      In step 577, a new client requests a session with the server.
      <br/>
      On the server, after receiving the client request, a test in step 579 is performed to determine if (ReservedThreads)+(MaxReq)&lt;=(MinThreads).
      <br/>
      If this is true, no action will be taken to adjust the thread pool as there are sufficient threads to support the existing and the new clients.
    </p>
    <p num="151">
      In step 581, the server assigns and returns a client_port to the client task.
      <br/>
      In step 583, (ReservedThreads) is incremented by (MaxReq) and returns to step 577 to wait for a new client to request a session.
    </p>
    <p num="152">
      If the test in step 579 is negative, a test in step 585 is formed to determine whether the maximum number of threads would be exceeded if the client request were granted.
      <br/>
      The test of whether (MinThreads)&lt;(ReservedThreads)+(MaxReq)&lt;(MaxThreads) is performed.
      <br/>
      If this is true, then the thread limit is not exceeded and the process goes to step 581 to assign and return the client port to the client task.
      <br/>
      In step 583, (ReservedThreads) is incremented by (MaxReq).
      <br/>
      While the process in this figure looks similar for this branch and the one described above, as described below, the management thread will increase the threads asynchrounously in the thread pool the next time it is wakened based on the new (ReservedThreads) count.
    </p>
    <p num="153">
      If the test in step 585 is positive, that is, if (ReservedThreads)+(MaxReq)&gt;(MaxThreads), then the client request is rejected in step 587.
      <br/>
      Thus, the server administers client session admission control to avoid an overload situation.
      <br/>
      In step 589, the server could enter a wait state until threads are released by other client tasks, possibly informing the client of the wait state.
      <br/>
      Alternatively, the server could just reject the client request and allow the client to try again later.
    </p>
    <p num="154">The psuedocode below provides an example of implementing this process:</p>
    <p num="155">New Client Request Session with Server</p>
    <p num="156">
      On the Server
      <br/>
      If (ReservedThreads)+(MaxReq)&lt;=(MinThreads), (ReservedThreads) increment by (MaxReq) Assign and return a client_port to the client
      <br/>
      If (MinThreads&lt;(ReservedThreads)+(MaxReq)&lt;(MaxThreads) Increment (ReservedThreads) by (MaxReq) Assign and return a client_port to the client
      <br/>
      If (ReservedThreads)+(MaxReq)&gt;(MaxThreads) Reject the network request
    </p>
    <p num="157">
      In FIG. 8B, the client side process for administering client request admission control is depicted.
      <br/>
      In step 601, a client task issues a new network request using an assigned client port to the server.
      <br/>
      In step 603, a test is performed to determine whether the client task has some available threads of the allowed number of threads at the server.
      <br/>
      The test if (ClientThreads)&lt;(MaxReq) can be used to determine this fact.
      <br/>
      If so, the client request is sent to the server in step 607.
      <br/>
      In step 609, the number of current client threads is incremented.
    </p>
    <p num="158">
      If all of the allowed number of threads at the server are in use, the network request is either rejected or put into a wait state until the number of concurrent requests from this client is less than (MaxReq) in step 605.
      <br/>
      If in a wait state, and one of the allowed threads is released, the process can proceed from step 605 to step 607.
    </p>
    <p num="159">
      Also depicted in FIG. 8B, is the process on the server side for assigning server thread in threads pool to service client requests and adjusting the number of threads in the pool.
      <br/>
      In step 611, a server thread is assigned to a client request for the duration of time required for processing the client request.
      <br/>
      In step 613 the (UnusedThreads) variable is decremented.
      <br/>
      A test is performed in step 615 to determine whether the number of threads in the thread pool is acceptable.
      <br/>
      The test if ((UnusedThreads)&lt;(MinThreads) &amp; (TotalThreads)&lt;(MaxThreads)) is one test to perform this step.
      <br/>
      If the number of available threads in the thread pool is not acceptable, the management thread is signaled to increase the number of threads in the thread pool.
      <br/>
      The process ends in step 619.
    </p>
    <p num="160">The following psuedocode shows a possible implementation of these processes:</p>
    <p num="161">
      Client issues network request to the server
      <br/>
      If (ClientThreads)&lt;(MaxReg),
    </p>
    <p num="162">
      - Send the request to the server.
      <br/>
      - Increment (ClientThreads)
      <br/>
      else
      <br/>
      - Reject the network request
    </p>
    <p num="163">Assign server thread to service client request</p>
    <p num="164">Decrement (UnusedThreads)</p>
    <p num="165">
      If (UnusedThread)&lt;(MinThread) &amp; (TotalThread)&lt;(MaxThread)
      <br/>
      Increase threads in the thread pool
    </p>
    <p num="166">
      The process followed by the client and server when the server completes a client network request is depicted in FIG. 8C. On the server side, the server has completed whatever processing is required for the client request in step 625.
      <br/>
      In step 627, the reply to the client request is sent via the protocol stack.
      <br/>
      The server thread is then returned to the thread pool in step 629.
      <br/>
      Next, in step 631, the (UnusedThreads) variable is incremented.
    </p>
    <p num="167">
      On the client side, the protocol stack receives the reply from the server in step 635.
      <br/>
      In step 637, the (ClientThreads) variable is decremented to allow other client tasks to use the client's allocation of communication threads.
      <br/>
      In step 639, a signal to wake up any threads from the same client waiting to send request to the server due to (ClientThread) over the (MaxReq) limit is issued.
      <br/>
      In step 641, the process goes to step 607 in FIG. 8B.
    </p>
    <p num="168">
      The server management thread process is illustrated in FIG. 8D. The server management thread is wakened either by a timer or by signals for thread allocation when the number of unused threads in the thread pool falls below some lower limit.
      <br/>
      A test is performed in step 653 to determine whether more threads need to be added.
      <br/>
      One suitable test is If ((UnusedThreads)&lt;(MinThreads) &amp; (TotalThreads)&lt;(MaxThreads)).
      <br/>
      If not, the management thread goes back to sleep in step 654.
      <br/>
      If so, in step 655, communication threads are added to the thread pool according to the equation: Add ((UnusedThreads)-(MinThreads)) number of threads into pool.
      <br/>
      In step 657, (UnusedThreads) are set to equal (MinThreads).
      <br/>
      Note that threads will only be added when immediately when UnusedThreads falls below the (MinThreads) limit.
      <br/>
      Otherwise, threads will be delayed until the next timer interval.
      <br/>
      In step 659, the (TotalTThreads) varaible is incremented by the number of threads added.
      <br/>
      The management thread goes back to sleep, step 654.
    </p>
    <p num="169">
      FIG. 8D also shows the server management thread method for reducing the number of unused threads in the communication thread pool to improve performance.
      <br/>
      In step 661, the thread is wakened by a timer which periodically wakens the thread for communication thread allocation or deallocation.
      <br/>
      A test is performed in step 663 to determine whether there are too many threads in the thread pool, e.g., If ((ReservedThreads)&lt;(MinThreads)) &amp; ((UnusedThread)&gt;(MinThreads)).
      <br/>
      If not, the thread sleeps, step 664, until the next interval.
      <br/>
      If so, the number of threads in the pool is reduced by 1 in step 665.
      <br/>
      The (TotalThreads) is decremented by 1 in step 667.
      <br/>
      If there is no activity for a period of time, the (TotalThreads) variable will return to (MinThread) eventually.
      <br/>
      A test in step 669 determines whether there are too few unused threads in the thread pool.
      <br/>
      The equation If (ReservedThreads)&gt;(TotalThreads) &amp; ((ReservedThreads)&lt;(MaxThreads)) can be used.
      <br/>
      If so, threads are added to the thread pool according to the equation Add ((ReservedThreads)-(TotalThreads)).
      <br/>
      In step 673, the (TotalThreads) variable is set to (ReservedThreads).
      <br/>
      The management thread goes back to sleep, step 675.
    </p>
    <p num="170">
      The advantages of this invention include admission control for session and normal client requests.
      <br/>
      Further, there are always guaranteed thread resources to service client requests, up to the limit allowed for the client task.
      <br/>
      No client will be starved indefinitely waiting for server thread resources.
    </p>
    <p num="171">
      With pre-allocated threads which can be shared among all clients, the performance of the server improves response time to client requests as thread creation or deletion are not performed at the thread execution path serving the client request.
      <br/>
      The overcommitted thread resources are minimized by periodically pruning back the number of allocated threads to (MinThreads) in times of inactivity.
      <br/>
      The total number of server threads in the pool can grow up to the configured (MaxThreads) value.
      <br/>
      This reduces system overhead as inactive threads will be kept to a minimum.
    </p>
    <p num="172">
      Dynamic thread resource adjustment is accomplished by the invention since (MaxThreads) and (MinThreads) are configured limits and can be made accessible to the system administrator.
      <br/>
      They can be adjusted either by manually configured and tuned to the minimum values optimal for the installation.
      <br/>
      Alternatively, statistics can be kept on the number of clients and concurrent client requests at various times of the day, and the values of the (MinThreads) and (MaxThreads) can be computed and adjusted automatically based on these statistics.
    </p>
    <p num="173">
      While a thread pool concept may have been used in generally in a multi-threaded client/server system, dynamic adjustment of the communication thread pool based on number of clients and client usage has not been done before.
      <br/>
      This invention has equal application for serving long or short running client requests.
      <br/>
      Further, the use of a thread pool to implement a Network Protocol Server running at user level has not been implemented in the prior art.
    </p>
    <p num="174">
      This invention can be implemented in any client/server system in which the server is multi-tasked and has to support a large number of clients efficiently.
      <br/>
      The solution is especially useful for systems which do not have a light-weight unit of execution, e.g., IBM mainframe MVS and many UNIX based systems.
    </p>
    <p num="175">
      As mentioned above, a Network Protocol Server using the above algorithm can be implemented using object oriented technology by defining a set of Network Server classes.
      <br/>
      The following is an example definition of these classes:
    </p>
    <p num="176">
      --
      <br/>
      -- class TNetworkServer: public TNetworkThreadHandle
      <br/>
      -- +
      <br/>
      --  public:
      <br/>
      --         TNetworkServer - Class constructor
      <br/>
      --         .about.TNetworkServer - Class Destructor
      <br/>
      --         AddClientPort - Add the Port to the Client Port
      <br/>
      -- Pool
      <br/>
      --         RemoveClientPort - Remove the Port from client
      <br/>
      -- Port Pool
      <br/>
      --         AddServerThread - Add a Thread to the Threadpool
      <br/>
      --         DeleteServerThread - Delete a Thread from the
      <br/>
      -- ThreadPool
      <br/>
      --         ExecuteMgmtThread - Management Thread Entry
      <br/>
      --         Execute Thread - NetworkThread Entry point
      <br/>
      --  private:
      <br/>
      --         RegisterNames - Publish Server names to be
      <br/>
      -- available to client
      <br/>
      --         Network Threads class using for Network
      <br/>
      -- Server Execution
      <br/>
      -- class TNetworkThreadHandle :
      <br/>
      -- +
      <br/>
      --  public:
      <br/>
      --      TNetworkThreadHandle - Class Constructor
      <br/>
      --      TNetworkThreadHandle - Class Destructor
      <br/>
      --       Fork - Start a new thread executing a class function
      <br/>
      --       Join - Wait for a thread to complete
      <br/>
      --       Release - Indicate thread can delete its object
      <br/>
      --   RPC class for Network client/server communication
      <br/>
      -- class TNWRPCMessage +
      <br/>
      -- public:
      <br/>
      --      virtual TNWRPCMessage ();
      <br/>
      --      virtual .about.TNWRPCMessage ();
      <br/>
      --      /* client side methods: SendRequest () */
      <br/>
      --      virtual kern_return_t SendRequest (const port_t&amp;
      <br/>
      -- clientport,
      <br/>
      --         void* buffer, int&amp; buflen); // buffer used for
      <br/>
      -- inbound/outbound
      <br/>
      --      virtual kern_return_t SendRequest (const port_t&amp;
      <br/>
      -- sessionport,
      <br/>
      --         port_t&amp; clientport, void* buffer, int&amp; buflen);
      <br/>
      --      /* Server side methods: ReceiveRequest () &amp;
      <br/>
      -- Reply&amp;Receive () */
      <br/>
      --      virtual kern_return_t ReceiveRequest (const port_t&amp;
      <br/>
      -- sessionport
      <br/>
      --         void* buffer, int&amp; buflen);
      <br/>
      --      virtual kern_return_t ReceiveRequest (const port_t&amp;
      <br/>
      -- clientport_pool,
      <br/>
      --         void* buffer, int&amp; buflen, port_t&amp; clientport);
      <br/>
      --      virtual kern_return_t SendReply (const port_t&amp;
      <br/>
      -- newclientport,
      <br/>
      --         void* buffer, int&amp; buflen, port_t&amp; sessionport);
      <br/>
      --      virtual kern_return_t SendReply (const port_t&amp;
      <br/>
      -- clientport,
      <br/>
      --         void* buffer, int&amp; buflen);
      <br/>
      -- };
    </p>
    <p num="177">Representation of Network Requests in a Client/Server Environment</p>
    <p num="178">
      An object-oriented representation of network protocol requests for a client/server model is presented in this section.
      <br/>
      The object-oriented representation of protocol requests is of importance whenever the protocol APIs are object oriented and the protocol implementation is also object oriented.
      <br/>
      The object based client requests to access network protocols are sent to the server that in turn deliver these requests to the appropriate network protocol layer object.
      <br/>
      This invention presents a new scheme for transporting the client network requests and delivering them to the appropriate network protocol layer that resides on the server, and retrieving the results of the request to the client application.
      <br/>
      The client requests are wrapped in a "Network Operation" object which contains all the necessary information so that the server can present the request to the network protocol layer object.
    </p>
    <p num="179">
      Consider the following scenario.
      <br/>
      The client API contains a set of object-oriented network protocol interface requests and the protocol is implemented as a stack of objects, each object representing a particular OSI layer.
      <br/>
      The network protocol stacks provide various network protocols which reside on a network server and there exists a communication mechanism such as RPC or IPC to communicate between the clients and the server.
      <br/>
      Whenever a client requests a network activity such as sending some data, the request needs to be conveyed to the appropriate network protocol stack on the server.
      <br/>
      The invention presents a unified scheme to transport such client requests to the server.
      <br/>
      The scheme takes advantage of polymorphism so that the process of shipping such requests and processing them at the server remains the same for all requests and protocol stacks.
    </p>
    <p num="180">
      The client interface to access network protocols is primarily via the TProtocolInterface class.
      <br/>
      The protocol implementation is based on the TProtocolLayer class to represent each of the OSI layers.
      <br/>
      The network subsystem consists of TFamilyLayer objects for each protocol such as TCP/IP and SNA, and TDataLinkLayer objects, both of which are resident in the system.
      <br/>
      The stack of TProtocolLayer objects to represent the session, transport, and network layers is created for every client endpoint and the client communication endpoint is described by the TAccessDefinition object.
      <br/>
      All these concepts, relevant classes and their functions are described in the Protocol Interface Model section above.
    </p>
    <p num="181">1. Network Operation Objects</p>
    <p num="182">
      All the network requests from the client to the server and vice-versa are transported using the TNetworkOperation objects.
      <br/>
      The TNetworkOperation objects provide a mechanism to convey the client network requests to a protocol layer in the server and relay the results to the clients from the server.
    </p>
    <p num="183">
      The TNetworkOperation class is the base class for all requests.
      <br/>
      For each request that the client interface makes to the server, a subclass is derived from TNetworkProtocol.
      <br/>
      For every one of the TProtocolInterface methods, a corresponding "operation object" class is defined.
      <br/>
      FIG. 9A shows the class heirarchy for class objects for a few of the client requests.
      <br/>
      The TNetworkOperation class 701 sits at the top of the heirarchy.
      <br/>
      The TConnectop class 703, TSendOp class 705, TReceiveop class 707, TDisconnectOp class 709 and TBindOp class 713 are all derived from the base class and correspond to the connect, send, receive, disconnect and bind operations in the TProtocolInterface classes.
      <br/>
      The getter and setter requests such as GetPeerName and GetLocalName are bundled in to one operation class called the TGetSetNetworkOpclass 711.
    </p>
    <p num="184">
      A TNetworkOperation object is created by TProtocolInterface to satisfy a request that requires servicing in the Network Server.
      <br/>
      Classes derived from TNetworkOperation represent specific requests from the interface.
      <br/>
      The TNetworkOperation object is sent to the network server using RPC/IPC mechanism for the request to be conveyed to the appropriate protocol layer.
      <br/>
      Once the NetworkOperation object is received by the Network Server, it calls the Execute( ) method on the operation object which then calls the corresponding function on the appropriate protocol implementation layer object.
    </p>
    <p num="185">
      The TNetworkOperation object thus has the "in-built intelligence" to do the task required of it.
      <br/>
      The Network Server, upon receiving a TNetworkOperation object calls the Execute( ) method in that object.
      <br/>
      The server function is the same irrespective of the nature of the client request.
      <br/>
      The Execute( ) method for each client request contains all the necessary information in it to convey the client request to the appropriate protocol layer object.
    </p>
    <p num="186">
      The TNetworkOperation object can also be created by a concrete class of TProtocolInterface.
      <br/>
      For example, if the default class of TBindOp does not satisfy the needs of TCP/IP, then TCP/IP interface overrides the TBindOp to create a TTCPBindOp class.
      <br/>
      Then the TTCPINF class representing the concrete TCP/IP client API creates the TTCPBindOp object whenever the client makes a bind request.
      <br/>
      The ability to inherit from the TNetworkOperation class to redefine semantics of a particular client request or add new requests and their operation objects makes this scheme extremely flexible and powerful.
    </p>
    <p num="187">
      FIG. 9B illustrates the class heirarchy of class objects created according to fill specific lient requests.
      <br/>
      In the figure, the TTCPBindOp object 715 is created by the TTCPTINF::Bind( ) method which serves the bind request from a client application.
      <br/>
      This overrides the TProtocolInterface::Bind( ) method.
      <br/>
      The TTCPNew1Op 717 and TTCPNew2Op 719 are the examples of two new operation objects that are specific to TCP/IP for some client requests.
    </p>
    <p num="188">2. TNetworkoperation Functions</p>
    <p num="189">Following are some of the important functions that are provided by the TNetworkOperation class.</p>
    <p num="190">Class constructor: This function sets the protocol layer index to which the request is being made by the client application.</p>
    <p num="191">The layer index identifies whether the request should be sent to the Transport or Network or the Family layer of the protocol stack.</p>
    <p num="192">
      Execute( ): This function is called by the server upon receiving a TNetworkOperation object.
      <br/>
      This function gets the layer index from the operation object, collects the relevant parameters from the operation object, and then makes a call to the appropriate TProtocolLayer object of the stack.
      <br/>
      For example, a TBindOp::Execute( ) would call the TProtocolLayer::Bind( ) with the TTCPProtocolAddress object as a parameter to the Bind( ) function.
    </p>
    <p num="193">Get/SetLayerIndex: This function returns/sets the layer index in the operation object.</p>
    <p num="194">
      SetLocationToClient: By default. an operation object is sets its location to server.
      <br/>
      The operation object behaves differently if it is on the server or the client.
      <br/>
      For example, the TBindOp has to send the TNetworkAddress object to the server as it is a parameter to the TProtocolLAyer::Bind( ) function.
      <br/>
      But the server need not send the address back to the client.
      <br/>
      Using the location flag, the parameter passing is controlled.
      <br/>
      Whenever a Network operation object is created by the client, it sets the location to client.
    </p>
    <p num="195">
      Stream-out Operator: This function is used to flatten an operation object and put the data members of the object in to a data stream.
      <br/>
      For example, the Stream-out operator for the TBindOp flattens a TNetworkAddress object if it is sending the object from the client.
      <br/>
      A TSendOp may flatten the buffer addresses and TNetworkAddress objects to send the buffers and the destination address to the server.
      <br/>
      The server then calls the SendOp::Execute( ) which calls the TProtocolLayer::Xmit( ) method with the user data to send the data to the destination.
      <br/>
      Upon completion of send, the server sends back a TSendCompletion object to the client using RPC/IPC mechanisms.
      <br/>
      The Stream-out operator for TSendOp then checks if it is a server and then streams-out TSendCompletion object.
    </p>
    <p num="196">
      Stream-in Operator: This function is used to re-build an object from a data stream where the object is flattened.
      <br/>
      Obviously it is the inverse operation of the Stream-out operator.
      <br/>
      Operation objects use the location flag to flatten/re-build objects to/from data streams.
    </p>
    <p num="197">3. Client-Server Communication</p>
    <p num="198">
      For every communication endpoint which a user creates, there must be a unique ID that must be maintained to associate an endpoint to a stack of protocol layer objects.
      <br/>
      The protocol layer objects represent the endpoint on the server process.
      <br/>
      Note that this correspondence is one-to-one.
      <br/>
      For this purpose, during the creation of the endpoint using the TACcessDefinition:: Instantiate( ) method, the TAccessOp object is created.
      <br/>
      The TAccessOp object then creates a ClientStackHead object which represents the client side of communication.
      <br/>
      The AccessOp object is then flattened and sent to the server using either the RPC or IPC mechanism by the ClientStackHead.
      <br/>
      The server then rebuilds the TAccessop object from the data stream using stream-in operator of TNetworkOperation and calls the TAccessop::Execute( ) method.
      <br/>
      This function creates a ServerStackHead object which creates the protocol layer objects from the protocol interface objects and keeps a list of the pointers to these protocol layer objects in the TServerStackHead object.
      <br/>
      The TServerStackHead pointer is stored in a global table of the network server and the index is streamed-out to the client.
      <br/>
      The TClientStackHead object stores the ServerStackHead ID and uses it for all subsequent operations.
      <br/>
      Thus, the ServerStackHeadID serves as a unique ID between a client and the server.
      <br/>
      Subsequent requests such as a TBindop when recieved by a server, it locates the corresponding server stack head using the ID that is passed in the TBindOp.
    </p>
    <p num="199">
      The TClientStackHead and the TServerStackHead manage communication between the client and the server for a given endpoint.
      <br/>
      These objects provide the link between the TAccessDefinition object which is the client endpoint handle and the corresponding stack of TProtocolLayer objects that represent the endpoint on the server.
      <br/>
      The ClientStackHead and the ServerStackHead pair constitute the internally managed objects that link the client and the server.
    </p>
    <p num="200">
      The following are some of the important function of TClientStackHead:
      <br/>
      1.
      <br/>
      ProcessOperation: This function is called by the TProtocolInterafce or TAccessDefinition objects for the TClientStackHead to process the TNetworkOperation object.
      <br/>
      This function flattens the TNetworkOperation object and send the flattened operation object to the server using RPC/IPC mechanisms provided by the system.
      <br/>
      This function also rebuilds the NetworkOperation object when the server responds to the request that was sent.
      <br/>
      Basically, this function sends and receives NetworkOperation objects to and from the server.
      <br/>
      2. SaveServerInfo: This method is called to save the ServerStackHead ID in the ClientsStackHead.
      <br/>
      When an AccessDefinition is instantiated, the server returns the TAccessOp object with the ID for the ServerStackHead that was created for the endpoint.
      <br/>
      The NetworkOperation uses this ID whenever requests are sent to the server subsequently.
      <br/>
      3. CancelRequests: This function is called whenever the TProtocolInterface:: CancelRequests is called by the client application or when client application terminates abnormally.
      <br/>
      The ClientStackHead creates a CancelRequestsOp operation object which informs the ServerStackHead to do the necessary clean-up.
    </p>
    <p num="201">
      The following are some of the important functions of ServerStackHead:
      <br/>
      1.
      <br/>
      Class Constructor: The constructor receives a stack of TProtocolInterface objects and builds the corresponding TProtocolLayer objects.
      <br/>
      It maintains pointers to these layer objects to call these layer objects fro subsequent requests.
      <br/>
      2. ProcessOperation: This function is called by the NetworkServerProcess upon. receiving a NetworkOperation object from the client.
      <br/>
      This function calls the Execute( ) method on the TNetworkOperation object after locating appropriate ProtocolLayer object.
      <br/>
      The Execute( ) method then calls the required method on the ProtocolLayer object.
      <br/>
      3. GetProtcolLayer: This function returns a pointer to the TProtocolLayer object given an index.
      <br/>
      The index is passed by the client application.
      <br/>
      4. CancelRequests: This function is called opon receiving the TCancelRequestsOp to cancel all the pending requests on the protocol stack.
      <br/>
      This is the server counterpart of the CancelRequests of TClientStackHead,
    </p>
    <p num="202">
      FIG. 9C illustrates the class hierarchy for these objects.
      <br/>
      Describes the object model using the Booch notations.
      <br/>
      The TAccessDefinition 101 is derived from TNetworkDefiniton 100.
      <br/>
      The TAccessDefinition 101 contains various TProtocolInterface 135 objects that constitute the endpoint.
      <br/>
      The TAccessDefinition 101 also contains a TClientStackHead 721 which performs all the client-server communication primitive functions.
      <br/>
      The TServerStackHead 723 is the server counterpart of the ClientStackhead.
      <br/>
      The TClientStackHead and the TSserverStackHead pair represents the link between the protocol interface and protocol implemtnation layer objects, thus linking the client application and the protocol stack on the server.
      <br/>
      Both TProtocolInterface 135 and the TProtocolLayer 151 classes are derived from the common base class MProtocolService 133.
      <br/>
      Any network request from the client is sent to the server wrapped in the TNetworkOperation 701 object.
      <br/>
      In other words, a method in the TProtocolInterface creates an appropriate TNetworkOperation object and the operation object is flattened and sent to the server by the TClientStackHead.
      <br/>
      The TNetworkOperation object uses both the TClientStackHead and the TServerStackHead.
    </p>
    <p num="203">
      FIG. 9D illustrates the flow of requests from client to server and vice-versa.
      <br/>
      As explained above, an endpoint is represented by the TAccessDefinition object on the client and a stack of TProtocolLayer objects on the server.
      <br/>
      The communication between the client and the server is managed by the TclientStackHead and the TServerStackHead objects.
      <br/>
      The figure shows two endpoints 725.
      <br/>
      A network request from the client is sent to the ServerProcess/Thread 727 as a TNetworkOperation object using the system RPC or IPC mechanisms.
      <br/>
      The ServerProcess rebuilds the TNetworkOperation object, then locates the TServerStackHead object that represents the endpoint1, and routes the request to ServerStackHead 1729.
      <br/>
      Similar processing is done to route the request from endpoint 2 to ServerStackHead2 that represents this endpoint on the server.
      <br/>
      The ServerStackl then calls TNetworkOperation::Execute( ) method which then calls an appropriate method in TTransportLayer of stack1733.
      <br/>
      The TTransportLayer may choose to call a method in the TNetworklayer which then sends the request to the TFamilyLayer 737.
      <br/>
      The family layer then sends the request to the TDataLinkLayer of stack1733.
      <br/>
      The TTransportLayer may chose to call a method in the TNetworkLayer which then ends the request to the TFamilyLayer 737.
      <br/>
      The family layer then sends the request to the TDataLinkLayer 739 after processing the request which may send a request to the adapter.
      <br/>
      Whenever the DataLinkLayer receives some packet over the adapter, it dispatches the packet to the family layer.
      <br/>
      The TFamilyLayer routes the packet to appropriate stack.
      <br/>
      Upon returning from the call to TTransportLayer, the TNetworkOperation::Execute( ) collects the response and sends the TNetworkOperation object back to the appropriate TClientStackHead using the system RPC/IPC mechanisms.
      <br/>
      The procedure is the same for any request on endpoint 2 and stack2735 that represents the endpoint on the server.
    </p>
    <p num="204">
      FIG. 9D illustrates the relationships between class objects in the client and server.
      <br/>
      The example assumes the general network client/server model.
    </p>
    <p num="205">3. An Example</p>
    <p num="206">
      Consider TTCPTINF which represents the TCP/IP transport interface.
      <br/>
      Assume that TTCPTINF::Bind( ) takes a TTCPAddress as input parameter and returns a TTCPAddress object.
      <br/>
      Note that the TTCPAddress is derived from the TProtocolAddress.
      <br/>
      As shown in FIG. 10, the TTCPTINF::Bind( ) method does the following:
    </p>
    <p num="207">In step 801, the TNetworkOperation object TTCPBindOp is created.</p>
    <p num="208">In step 803, gets the ClientStackHead object for this AccessDefinition.</p>
    <p num="209">
      In step 805, ClientStackHead::ProcessOperation( ) is calledto flatten the TTCPAddress in the TTCPBindOp object and send the request to the server.
      <br/>
      The server re-builds the flattened TTCPBindOp from the message stream, e.g., RPC/IPC in step 807.
    </p>
    <p num="210">In step 809, the server locates the ServerStackHead object from the stackID passed in the TTCPBindOp object.</p>
    <p num="211">In step 811, the ServerStackHead object then calls TProtocolLAyer::Bind( ) to the appropriate protocol layer object.</p>
    <p num="212">
      The call to bind returns a TTCPAddress object and the server restores the return information (the address) in the TTCPBindOp and streams it back to the client, step 813 the ClientStackHead re-builds the TTCPBindOp( ) object from the message stream.
      <br/>
      Finally, in step 817, the TTCPINF::Bind( ) then retrieves the TTCPAddress from the TTCPBindOp and returns it to the client program.
    </p>
    <p num="213">
      While the invention has been shown and described with reference to particular embodiments thereof, it will be understood by those skilled in the art that the invention can be practiced, with modification, in other environments.
      <br/>
      For example, although the invention described above can be conveniently implemented in a general purpose computer selectively reconfigured or activated by software, those skilled in the art would recognize that the invention could be carried out in hardware, in firmware or in any combination of software, firmware or hardware including a special purpose apparatus specifically designed to perform the described invention.
      <br/>
      Therefore, changes in form and detail may be made therein without departing from the spirit and scope of the invention as set forth in the accompanying claims.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>We claim:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for dynamically managing a pool of execution units in a server system, the pool devoted to a communication process between client and server processes, the method comprising the steps of:</claim-text>
      <claim-text>creating and setting a minimum number of execution units in the communication process pool in the server system, the minimum number of execution units needed a number necessary to support a typical client load; setting a maximum number of execution units allowed in the communication process pool, the maximum number of execution units an upper bound to support a peak client load without overloading the server system; setting a maximum allotted number of execution units which can be allotted to a respective client; receiving client requests for service by the server system; for each received client request, determining whether assigning an execution unit to the received client request would bring a current number of execution units in the communication process pool over the maximum number of execution units, and if so, rejecting the client request; determining whether assigning an execution unit to the received client request would bring a current number of assigned execution units to a client making the request over the maximum allotted number of execution units for the client, and if so, rejecting the client request;</claim-text>
      <claim-text>and granting the client request if the determining steps are negative so that an execution unit in the communication process pool is assigned to the client request.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method as recited in claim 1, further comprising the steps of: responsive to determining that the received client request would bring the current number of execution units in the communication process pool over the maximum number of execution units, placing the received client request in a wait state;</claim-text>
      <claim-text>and responsive to an execution unit being released by a second client, assigning the released execution unit to the received client request.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method as recited in claim 1, further comprising the steps of: responsive to determining that the received client request would bring the current number of execution units in the communication process pool over the allotted maximum number of execution units, placing the received client request in a wait state;</claim-text>
      <claim-text>and responsive to an execution unit being released by a client task of the client, assigning the released execution unit to the received client request.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method as recited in claim 1, wherein the client and server processes are resident in the same computer system.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method as recited in claim 1, further comprising the steps of: determining whether a number of unassigned execution units in the communication process pool is less than a predetermined, desired number of unassigned execution units;</claim-text>
      <claim-text>and responsive to determining that the number of unassigned execution units is less than the desired number, creating additional unassigned execution units in the communication process pool so long as the additional unassigned execution units would not bring the current number of execution units over the maximum number of execution units.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method as recited in claim 1, further comprising the steps of: determining whether the number of unassigned execution units in the communication process pool is greater than a predetermined, desired number of unassigned execution units;</claim-text>
      <claim-text>and responsive to determining that the number of unassigned execution units is greater than the desired number, reducing the number of execution units in the communication process pool.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method as recited in claim 1, further comprising the steps of: monitoring client requests to establish an average number of concurrent client requests;</claim-text>
      <claim-text>and dynamically changing the minimum number and the maximum number of execution units in the communication process pool according to the average number of concurrent client requests.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A system for dynamically managing a pool of execution units in a server system, the pool devoted to a communication process between client and server processes, the system comprising: means for creating and setting a minimum number of execution units needed in the communication process pool, in the server system, the minimum number of execution units a number necessary to support a typical client load; means for setting a maximum number of execution units allowed in the communication process pool, the maximum number of execution units an upper bound to support a peak client load without overloading the server system; means for setting a maximum allotted number of execution units which can be allotted to a respective client; means for receiving client requests for service by the server system; means for determining whether assigning an execution unit to the received client request would bring a current number of execution units in the communication process pool over the maximum number of execution units; means for determining whether assigning an execution unit to the received client request would bring a current number of assigned execution units to a client task making the request over an allotted number of execution units for the client task;</claim-text>
      <claim-text>and means for granting the client request if the determining means establish that an execution unit in the communication process pool can be assigned to the client request.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The system as recited in claim 8, further comprising: means responsive to determining that the received client request would bring the current number of execution units in the communication process pool over the maximum number of execution units for placing the received client request in a wait state;</claim-text>
      <claim-text>and means responsive to an execution unit being released by a second client for assigning the released execution unit to the received client request.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The system as recited in claim 8, further comprising: means responsive to determining that the received client request would bring the current number of execution units in the communication process pool over the allotted maximum number of execution units for placing the received client request in a wait state;</claim-text>
      <claim-text>and means responsive to an execution unit being released by a client task of the client for assigning the released execution unit to the received client request.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The system as recited in claim 8, further comprising: means for determining whether a number of unassigned execution units in the communication process pool is less than a predetermined, desired number of unassigned execution units;</claim-text>
      <claim-text>and means responsive to determining that the number of unassigned execution units is less than the desired number for creating additional unassigned execution units in the communication process pool so long as the additional unassigned execution units would not bring the current number of execution units over the maximum number of execution units.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The system as recited in claim 8 , further comprising: means for determining whether the number of unassigned execution units in the communication process pool is greater than a predetermined, desired number of unassigned execution units;</claim-text>
      <claim-text>and means responsive to determining that the number of unassigned execution units is greater than the desired number for reducing the number of execution units in the communication process pool.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The system as recited in claim 8, further comprising: means for monitoring client requests to establish an average number of concurrent client requests;</claim-text>
      <claim-text>and means for dynamically changing the minimum number and the maximum number of execution units in the communication process pool according to the average number of concurrent client requests.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A computer program product in a computer readable medium for dynamically managing a pool of execution units in a server system, the pool devoted to a communication process between client and server processes, the product comprising: means for causing the system to creating and setting a minimum number of execution units needed in the communication process pool, in the server system, the minimum number of execution units a number necessary to support a typical client load; means for setting a maximum number of execution units allowed in the communication process pool, the maximum number of execution units an upper bound to support a peak client load without overloading the server system; means for setting a maximum allotted number of execution units which can be allotted to a respective client; means for causing the system to receive client requests for service by the server system; means for causing the system to determine whether assigning an execution unit to the received client request would bring a current number of execution units in the communication process pool over the maximum number of execution units; means for causing the system to determine whether assigning an execution unit to the received client request would bring a current number of assigned execution units to a client task making the request over an allotted number of execution units for the client task;</claim-text>
      <claim-text>and means for causing the system to grant the client request responsive to determination that an execution unit in the communication process pool can be assigned to the client request.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The product as recited in claim 14, further comprising: means responsive to determining that the received client request would bring the current number of execution units in the communication process pool over the maximum number of execution units for placing the received client request in a wait state;</claim-text>
      <claim-text>and means responsive to an execution unit being released by a second client for assigning the released execution unit to the received client request.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The product as recited in claim 14, further comprising: means responsive to determining that the received client request would bring the current number of execution units in the communication process pool over the allotted maximum number of execution units for placing the received client request in a wait state;</claim-text>
      <claim-text>and means responsive to an execution unit being released by a client task of the client for assigning the released execution unit to the received client request.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The product as recited in claim 14, further comprising: means for determining whether a number of unassigned execution units in the communication process pool is less than a predetermined, desired number of unassigned execution units;</claim-text>
      <claim-text>and means responsive to determining that the number of unassigned execution units is less than the desired number for creating additional unassigned execution units in the communication process pool so long as the additional unassigned execution units would not bring the current number of execution units over the maximum number of execution units.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The product as recited in claim 14, further comprising: means for determining whether the number of unassigned execution units in the communication process pool is greater than a predetermined, desired number of unassigned execution units;</claim-text>
      <claim-text>and means responsive to determining that the number of unassigned execution units is greater than the desired number for reducing the number of execution units in the communication process pool.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The product as recited in claim 14, further comprising: means for monitoring client requests to establish an average number of concurrent client requests;</claim-text>
      <claim-text>and means for dynamically changing the minimum number and the maximum number of execution units in the communication process pool according to the average number of concurrent client requests.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. A method for dynamically managing a pool of execution units in a computer system, the pool devoted to a given type of task between client processes and server processes, the given type of task a subset, of all tasks performed by the computer system, comprising the steps of: managing a current number of execution units in the pool in the computer system between a minimum number of execution units necessary to support a typical client load for the given type of task and a maximum number of execution units to avoid overloading the computer system; managing a current number of execution units in the pool assigned to each client process to be less than or equal to an allotted number of execution units for the client process for the given type of task;</claim-text>
      <claim-text>and assigning execution units to client requests for service, if possible according to the managing steps.</claim-text>
    </claim>
  </claims>
</questel-patent-document>