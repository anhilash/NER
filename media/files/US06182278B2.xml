<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182278B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182278</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182278</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="15933637" extended-family-id="21265153">
      <document-id>
        <country>US</country>
        <doc-number>08814427</doc-number>
        <kind>A</kind>
        <date>19970310</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08814427</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>21808638</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>JP</country>
        <doc-number>17199896</doc-number>
        <kind>A</kind>
        <date>19960702</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1996JP-0171998</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/45        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>45</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/06        20060101AFI20060310RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>06</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20060310</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   9/44        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>44</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>717107000</text>
        <class>717</class>
        <subclass>107000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>715763000</text>
        <class>715</class>
        <subclass>763000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>715967000</text>
        <class>715</class>
        <subclass>967000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>717110000</text>
        <class>717</class>
        <subclass>110000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-008/20</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>20</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/45508</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>45508</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-715/967</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>715</main-group>
        <subgroup>967</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>4</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>21</number-of-drawing-sheets>
      <number-of-figures>21</number-of-figures>
      <image-key data-format="questel">US6182278</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Program development support system and support method and storage medium for storing program components which are used for program development support</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>YAMAMOTO TAKEMI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5293478</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5293478</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>COGGINS EDWARD W</text>
          <document-id>
            <country>US</country>
            <doc-number>5367622</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5367622</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>CAIN RONALD A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5487141</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5487141</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>BERRY RICHARD E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5537630</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5537630</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>SWANSON SARA J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5600778</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5600778</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>CAIN RONALD ALLEN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5651108</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5651108</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>MARUYAMA TAKEO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5710920</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5710920</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>MAURER JOSEPH CLARK</text>
          <document-id>
            <country>US</country>
            <doc-number>5710926</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5710926</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>MCINERNEY PETER JOSEPH, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5758160</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5758160</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>JORDAN DAVID A</text>
          <document-id>
            <country>US</country>
            <doc-number>5778227</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5778227</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="11">
          <text>WILLIAMS DAVID MARK</text>
          <document-id>
            <country>US</country>
            <doc-number>5850548</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5850548</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="12">
          <text>MORRIS ROBERT M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5862372</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5862372</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="13">
          <text>COPELAND GEORGE PRENTICE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5878260</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5878260</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="14">
          <text>HAMILTON GRAHAM, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5950001</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5950001</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Burnett, M., Goldberg, A., Lewis, T., editors "Visual Object-Oriented Programming: Concepts and Environments"; Manning Publications Co.; pp. 185-267, Oct., 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>"Components Let Developers Drive Applications Out the Door Faster"; InfoWorld; Apr. 29, 1996, pp. 076. PROMT[online] Retrieved from STN International, Accession No. 96:223325.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>"HP Readies Component Factory"; InformationWeek; Jun. 3, 1996, pp. A15. PROMT [online] Retrieved from STN International, Accession No. 96:275564.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>"Lotus Components: Developing Notes Applications with Lotus Components"; Lotus Development Corporation; pp. 5-28, 31-44, 47-63, 68-84, 93-119, 130-147, 162-163 &amp;180-186, Nov. 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>"Object Pallet for Visual Code Generation"; IBM Technical Disclosure Bulletin; vol. 38, No. 1, p. 19, Jan. 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="6">
          <text>Brazile, Robert P., A System for Program Component Specification and Code Generation, Proceedings of the 1992 ACM/SIGAPP Symposium on Applied Computing, vol. II, pp. 904-910.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Hamada, Seiji</name>
            <address>
              <address-1>Yokohama, JP</address-1>
              <city>Yokohama</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Nakamura, Yuichi</name>
            <address>
              <address-1>Yokohama, JP</address-1>
              <city>Yokohama</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Tago, Kazuya</name>
            <address>
              <address-1>Yamato, JP</address-1>
              <city>Yamato</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Scully, Scott, Murphy, &amp; Presser</orgname>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>Underweiser, Esq., Marian</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Chaki, Kakali</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      The present invention is directed to making a variety of programming operations, which a programmer desires, possible by using a program component.
      <br/>
      More specifically, an apparent function of program component 131 is extended by component-information editor 101 which updates the information of component-information storage 110 that holds the information about the property and method of the program component.
      <br/>
      The component information is utilized both when an application program is developed and when the application program is executed.
      <br/>
      When a program is developed, the component information is utilized by property editor 103 and code editor 107.
      <br/>
      Therefore, users can utilize the component information for generating a programming code with a feeling as if the function of the program component were extended.
      <br/>
      Furthermore, there is no possibility that the user will be conscious of the difference between the existent function and the extended function of the program component.
      <br/>
      When, on the other hand, a program is executed, the component information is utilized to call out program component 131 from interpreter 120, so the extended function can be suitably executed.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      1.
      <br/>
      Technical Field
    </p>
    <p num="2">
      The present invention relates to a method and system for supporting the generation of a program, and componenticularly to a method of integrating program components into a program construction (development) support system.
      <br/>
      More specifically, the invention relates to a method which integrates program components, adding a new function to the function that the program component inherently has.
    </p>
    <p num="3">2. Prior Art</p>
    <p num="4">
      When a programmer generates an application program by an interactive program generation support system, such as Visual Basic (trademark of Microsoft), the system provides program components to support the generation.
      <br/>
      FIGS. 13, 14 are diagrams showing the form of utilization of conventional program components.
    </p>
    <p num="5">
      In the aforementioned example as FIG. 13, there is provided a program component 230 constituted by a button icon 203.
      <br/>
      The example includes variable information (x, y) to define a position at which a button icon is displayed and variable information (w, h) to define the width and height of a button icon, as property 231, and further includes information about "move(x, y)" which indicates that the button icon is moved to a specified position of (x, y) and information about "resize(w, h)" which changes the button icon to a specified size of (w, h), as method 233.
    </p>
    <p num="6">If the aforementioned program component is positioned on an application window 320 and a value of the property is set by a property editor described later, an interpreter will interpret the two pieces of information and a button icon will be displayed according to the property value set on the application window 320.</p>
    <p num="7">
      However, in the program components provided in the conventional technique, the properties and methods are previously given and usable properties and methods are limited.
      <br/>
      The conventional technique, therefore, cannot meet a variety of programmer's demands, such as "Wanting to attach a plurality of labels to a button component (in a conventional program support system, only a single label is usually given to one button of program components)" and "Wanting to change the size of a button in correspondence with the number of characters of a label that is attached to the button (in a conventional program support system, normally the button size is defined by a fixed value but cannot be defined by a function value)." Thus, there are a great number of limitations on the programming operation using program components.
    </p>
    <p num="8">
      The conventional program component is provided only to a graphical object which is visually displayed as a graphic figure, such as a button icon and a ruler bar, but it is not provided to a non-graphical object which is described by using characters and symbols by a code editor described later.
      <br/>
      For this reason, the programmer needs to make a program by uniting and describing a plurality of instructions constituted by a programming language which performs a coding operation.
      <br/>
      In addition, when making another program, such description cannot be reused, so there is the need to perform nearly the same coding operation again.
      <br/>
      Even in the coding operation using subroutines, the management of the characteristic variables of an object becomes complicated and the reutilization is not easy, because each subroutine cannot hold a state as does a program component.
    </p>
    <p num="9">
      In connection with the aforementioned problems, Published Unexamined Patent Application No. 7-28636 has proposed a graphical user interface construction support system, using a table where an input operation and a visual object are correlated.
      <br/>
      However, since the graphical user interface construction support system presents a candidate for a visual object in order of the higher degree of compatibility to the input operation in order to indicate what degree the visual object in the application program corresponding to each input operation of a user is compatible with the input operation, the selection of program components can be performed quickly, but the function itself of program components cannot be extended.
    </p>
    <p num="10">
      Also, Published Unexamined Patent Application No. 7-219753 has proposed an interactive program development support system which enhances development efficiency by using, as a resource, component of a callback function which instructs an operation that executes an event generated when a button icon is depressed with the pointer of a pointing device.
      <br/>
      This support system can change the content of a process that is executed by the method, but it cannot add a new method.
      <br/>
      Therefore, the system cannot meet a variety of programmer's demands such as "Wanting to change the size of a button in correspondence with the number of characters of a label that is attached to the button."
    </p>
    <p num="11">
      Furthermore, Published Unexamined Patent Application No. 4-353926 has proposed a system where an interactive component-defining body input operation and a visual object are correlated with a table.
      <br/>
      However, in this system a method is previously correlated with the interactive component and the method is customized, so the method desired by the user cannot be added to the interactive component.
      <br/>
      This system, therefore, cannot satisfy a variety of programmer's demands, such as "Wanting to attach a plurality of labels" and "Wanting to change the size of a button in correspondence with the number of characters of a label that is attached to the button" and also the system cannot define a non-graphical object as a program component.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="12">An objective of the present invention is for the component-information storage to utilize a program component in order to realize a variety of programming operations that a programmer desires, which could not be realized by a conventional program component, by accumulating not only information about the original function of the program component but also information about a new function which is not present in an actual component in such a manner that a program builder and an interpreter can utilize the two pieces of information.</p>
    <p num="13">Another objective of the present invention is to make it possible to change both the original property of a program component and an additional property by a property editor without making a distinction between them.</p>
    <p num="14">Still another objective of the present invention is to make it possible to utilize an additional method and an additional property by a program builder and an interpreter without distinguishing them from the original method and property of a program component.</p>
    <p num="15">
      An application program support system of the present invention has a component-information storage which holds information about program components.
      <br/>
      By updating this information, an apparent function is extended without extending the actual function of the program component.
      <br/>
      Updating of the component information is performed so that a new property and method can be added to the component, and an edit operation such as this is performed by a component-information editor.
      <br/>
      The component information is utilized both when an application program is developed and when an application program is executed.
      <br/>
      More specifically, when a program is developed, the component information is utilized by a property editor and a code editor.
      <br/>
      With this, the user can utilize the component information for generating a programming code with a feeling as if the function of the component were extended.
      <br/>
      Furthermore, there is no possibility that the user will be conscious of the difference between the original function of a normal program component (which is not a program component defined by the user but a program component with a fixed function) and the extended function.
      <br/>
      When, on the other hand, a program is executed, the component information is utilized to call out a program component from an interpreter and the extended function can be suitably executed.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="16">
      Preferred embodiments of the present invention will now be described, by way of example only, with reference to the accompanying drawings, in which;
      <br/>
      FIG. 1 is a block diagram showing an embodiment of hardware structure;
      <br/>
      FIG. 2 is a functional block diagram showing an embodiment of the system structure of the present invention;
      <br/>
      FIG. 3 is a functional block diagram showing the portions differing from prior art, in the embodiment of the system structure of the present invention;
      <br/>
      FIG. 4 is a diagram showing the property table of a component-information storage in a preferred embodiment of the present invention;
      <br/>
      FIG. 5 is a diagram showing the method table of the component-information storage in a preferred embodiment of the present invention;
      <br/>
      FIG. 6 is a diagram showing the property table of a program component in a preferred embodiment of the present invention;
      <br/>
      FIG. 7 is a diagram showing the method table of the program component in a preferred embodiment of the present invention;
      <br/>
      FIG. 8 is a diagram showing the flow of data as component information is updated in a preferred embodiment of the present invention;
      <br/>
      FIG. 9 is a diagram showing the flow of data as a builder utilizes component information in a preferred embodiment of the present invention;
      <br/>
      FIG. 10 is a diagram showing the flow of data as component information is utilized at the time of program execute in a preferred embodiment of the present invention;
      <br/>
      FIG. 11 is a diagram showing the flow of data as component information is utilized at the time of program execute in a preferred embodiment of the present invention;
      <br/>
      FIG. 12 is a diagram showing the flow of data as component information is utilized at the time of program execute in a preferred embodiment of the present invention;
      <br/>
      FIG. 13 is a diagram showing an example of the utilization of a conventional program component;
      <br/>
      FIG. 14 is a diagram showing a conventional program generation support system;
      <br/>
      FIG. 15 is a diagram showing a procedure of setting a program component in a preferred embodiment of the present invention;
      <br/>
      FIG. 16 is a diagram showing a procedure of setting a program component in a preferred embodiment of the present invention;
      <br/>
      FIG. 17 is a diagram showing a procedure of setting a program component in a preferred embodiment of the present invention;
      <br/>
      FIG. 18 is a diagram showing a procedure of setting a program component in a preferred embodiment of the present invention;
      <br/>
      FIG. 19 is a diagram showing a procedure of setting a program component in a preferred embodiment of the present invention;
      <br/>
      FIG. 20 is a diagram showing a procedure of setting a program component in a preferred embodiment of the present invention; and
      <br/>
      FIG. 21 is a diagram showing a procedure of utilizing a program component in a preferred embodiment of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS OF THE INVENTION</heading>
    <p num="17">In a preferred form of the present invention, there is provided a data processing system which comprises: a program component including a component-property table which manages the user-defined property name and user-defined property value of a user-defined property and also including a method call adapter which points to the code of a user-defined method by receiving a user-defined method name and a generic method function; a component-information storage having a program component name, a property table which manages a user-defined property name and a generic property access function, and a method table which manages a user-defined method name and a generic method function; a component editor for registering the user-defined property name of the property table and the user-defined method name of the method table; a property editor for updating the user-defined property value of the program component; a code editor for editing a method code which specifies the content of execute of a method and also editing a main logic having specification of a component name, a property name, and a method name; a code storage for storing the method code edited by the code editor so that the method code can be specified with the component name and the method name and also storing the main logic; and a code executor receiving the main logic stored in the code storage, specifying the generic property access function managed by the property table of the component-information storage from the component name and property name included in the main logic, issuing the user-defined property name and the generic property access function to the program component, specifying the generic method function managed by the method table of the component-information storage from the component name and method name included in the main logic, and issuing the user-defined method name and the generic method function to the program component.</p>
    <p num="18">In another preferred form of the present invention, there is provided a program development support system which comprises: a program component including a component-property table which manages the user-defined property name and user-defined property value of a user-defined property; a component-information storage provided with a property table which manages a user-defined property name for having access to the user-defined property value of the program component and also manages a generic property access function; and a component editor for registering the user-defined property name of the property table and the user-defined property name of the component-property table.</p>
    <p num="19">In still another preferred form of the present invention, there is provided a system which comprises: a program component including a method call adapter which points to the code of a user-defined method by receiving a user-defined method name and a generic method function; a component-information storage provided with a method table which manages a program component name, a user-defined method name, and a generic method function; a component editor for registering the user-defined method name of the method table; a code editor for editing a method code which specifies the content of execute of a method and also editing a main logic which includes specification of a component name and a method name; a code storage for storing the method code edited by the code editor so that the method code can be specified with the component name and the method name and also storing the main logic; and a code executor receiving the main logic stored in the code storage, specifying the generic method function managed by the method table of the component-information storage from the component name and method name included in the main logic, and issues the user-defined method name and the generic method function to the program component.</p>
    <p num="20">In a further preferred form of the present invention, there is provided a method of extending a function of a program component which comprises the steps of: detecting specification of a program component which is performed by a user; displaying a property information entry to input a property name of the specified program component and also displaying a method information entry to input a method name of the specified program component; registering the user-defined property name input to the property information entry in the property table; and registering the user-defined method name input to the method information entry in the method table.</p>
    <p num="21">
      In another preferred form of the present invention, there is provided a method of extending a function of a program component which comprises the steps of: displaying an icon of a new program component representative of a program component for user registration of the new program component onto the display unit; detecting specification of the icon of the new program component which is performed by the user; displaying a program component name input entry to input a program component name of the specified new program component; making a component-property table which has entries of a property name and a property value corresponding to the user-defined program component name input to the program component input entry; displaying a property information entry to input a property name of the specified program component; registering the information input to the property information entry in the component-property table; displaying a property value input entry to input the property value corresponding to the user-defined property name; and registering a value input to the property value input entry in the component-property table.
      <br/>
      The aforementioned function extending method is used in a data processing system, which includes an input unit, a display unit, a code executor, and a program component that manages a property value which is provided to the code executor.
    </p>
    <p num="22">
      In another preferred form of the present invention, there is provided a method of extending a function of a program component which comprises the steps of: detecting specification of a program component which is performed by a user; displaying a property information entry to input a property name of the specified program component; relating the user-defined property name input to the property information entry to the specified program component; displaying a property value input entry to input a property value corresponding to the user-defined property name; and relating a value input to the property value input entry to the specified program component.
      <br/>
      The aforementioned function extending method is used in a data processing system, which includes an input unit, a display unit, a code executor, and a program component that manages a property value which is provided to the code executor.
    </p>
    <p num="23">In another preferred form of the present invention, there is provided a program code executing method which comprises the steps of: receiving a program code which includes a description for specifying the program component name, the property name of the program component, and the method name of the program component; specifying the generic property access function managed in the property table of the component-information storage from the component name and property name included in the program code; specifying the property value of the program component, based on the program component name and on the generic property access function managed in the property table of the component-information storage; specifying the generic method function managed in the method table of the component-information storage from the component name and method name included in the program code; issuing the user-defined method name and the generic method function to the program component; receiving generic method code access information which points to the code of the user-defined method, issued in response to reception of the user-defined method name and the generic method function performed by the program component; accessing the code of the user-defined method stored in the code storage, based on the generic method code access information; and executing the code of the user-defined method.</p>
    <p num="24">
      In another preferred form of the present invention, there is provided a program code executing method which comprises the steps of: receiving a program code which includes a description for specifying the program component name and the property name of the program component; specifying the generic property access function managed in the property table of the component information storage from the component name and property name included in the program code; and specifying the property value of the program component, based on the program component name and on the generic property access function managed in the property table of the component-information storage.
      <br/>
      The program code executing method is used in a data processing system, which includes a program component which manages property information, a property table which manages a property name and a generic property access function of the program component, a code executor, a code storage which includes description of a program component name and a property name and which stores a program code which is executed by the code executor, and a code editor for editing the code.
    </p>
    <p num="25">
      In another preferred form of the present invention, there is provided a program code executing method which comprises the steps of: receiving a program code which includes a description for specifying the program component name and the method name of the program component; specifying the generic method function managed in the method table of the component-information storage from the component name and method name included in the program code; issuing the user-defined method name and the generic method function to the program component; receiving generic method code access information which points to the code of the user-defined method, issued in response to reception of the user-defined method name and the generic method function performed by the program component; accessing the code of the user-defined method stored in the code storage, based on the generic method code access information; and executing the code of the user-defined method.
      <br/>
      The program code executing method is used in a data processing system, which includes a program component which manages method information, a method table which manages a method name and a generic method function of the program component, a code executor, a code storage which includes description of a program component name and a method name and which stores a code of a user-defined method stored in relation to a program code which is executed by the code executor and to a method of the program component, and a code editor for editing the code.
    </p>
    <p num="26">
      In another preferred form of the present invention, there is provided a storage medium for storing a program component which manages a method and a property that are provided at the time of execute and which is loaded into a program development support system for program development support.
      <br/>
      The storage medium comprises: a component-property table having entries of a user-defined property name and a user-defined property value of a user-defined property; and a method call adapter which points to a code of the method by receiving a user-defined method name and a generic method function from the program development support system.
    </p>
    <p num="27">In another preferred form of the present invention, there is provided a storage medium for storing a program to extend a function of a program component, which comprises: program code means for instructing a data processing system to detect specification of a program component which is performed by a user; program code means for instructing the data processing system to display a property information entry to input a property name of the specified program component and also display a method information entry to input a method name of the specified program component; program code means for instructing the data processing system to register the user-defined property name input to the property information entry in the property table; and program code means for instructing the data processing system to register the user-defined method name input to the method information entry in the method table.</p>
    <p num="28">In another preferred form of the present invention, there is provided a storage medium for storing a program to execute a program code, which comprises: program code means for instructing a data processing system to receive a program code which includes a description for specifying the program component name, the property name of the program component, and the method name of the program component; program code means for instructing the data processing system to specify the generic property access function managed in the property table of the component-information storage from the component name and property name included in the program code; program code means for instructing the data processing system to specify the property value of the program component, based on the program component name and on the generic property access function managed in the property table of the component-information storage; program code means for instructing the data processing system to specify the generic method function managed in the method table of the component-information storage from the component name and method name included in the program code; program code means for instructing the data processing system to issue the user-defined method name and the generic method function to the program component; program code means for instructing the data processing system to receive generic method code access information which points to the code of the user-defined method, issued in response to reception of the user-defined method name and the generic method function performed by the program component; program code means for instructing the data processing system to access the code of the user-defined method stored in the code storage, based on the generic method code access information; and program code means for instructing the data processing system to execute the code of the user-defined method.</p>
    <p num="29">A. Hardware Structure</p>
    <p num="30">
      An embodiment of the present invention will hereinafter be described in reference to the drawings.
      <br/>
      Referring to FIG. 1, there is shown a block diagram of hardware structure used for carrying out the present invention.
      <br/>
      A system 100 includes a central processing unit (CPU) 1 and a memory 4.
      <br/>
      The CPU 1 and the memory 4 are connected through a bus 2 to a hard-disk drive 13 used as a secondary storage.
      <br/>
      A floppy-disk drive (or a drive for a storage medium such as a CD-ROM, an MO, an MD, a ZIP, a DVD, and so on) 20 is connected to the bus 2 through a floppy-disk controller 19.
    </p>
    <p num="31">
      A floppy disk (or a storage medium such as a CD-ROM) is inserted into the floppy disk drive (or a drive for a storage medium such as a CD-ROM) 20.
      <br/>
      In cooperation with an operating system, an instruction is given to the CPU so that the code of a computer program for executing the present invention can be recorded on the floppy disk (or the hard-disk drive 13) and a ROM 14.
      <br/>
      The code is loaded into the memory 4 and executed.
      <br/>
      The code of the computer program can be compressed, or it can be divided into a plurality of blocks and recorded on a plurality of storage media.
    </p>
    <p num="32">
      The system 100 can be further made as a system equipped with user interface hardware.
      <br/>
      The user interface hardware includes, for example, a pointing device (such as a mouse and/or a joy stick) 7 or a keyboard 6 for inputting data and a display 12 for displaying visual data to users.
      <br/>
      Also, it is possible to connect a printer through a parallel port 16 and to connect a modem through a serial port 15, and it is possible to communicate with another computer through the same port 15 and a modem or through a communication adapter 18.
    </p>
    <p num="33">
      Therefore, it will easily follow that the present invention can be implemented by an ordinarily used personal computer (PC), a work station, or a combination of them.
      <br/>
      However, the aforementioned constituent components are illustrative and not restrictive and all the constituent components do not always become the essential constituent components of the present invention.
      <br/>
      For example, FIG. 1 shows a stand-alone system, but the present invention may be realized as a client server system.
      <br/>
      The system 100 of the present invention may be disposed in a server machine and a client machine may be connected to the server machine through a local network by an Ethernet token ring.
      <br/>
      Also, an input unit for various kinds of inputs and a display for displaying a result of execute of a program may be disposed on the client machine side.
      <br/>
      In addition, a program-component library 130 to be described later or some program components of the library may be disposed on the server side.
      <br/>
      The remaining program components may be disposed on the client side and only a builder 100 may be disposed on the client side.
      <br/>
      The others may be disposed on the server side.
      <br/>
      Thus, the layout can be freely changed when it is designed.
    </p>
    <p num="34">
      It is preferable that the operating system be an operating system which supports a GUI multi-window environment at standard, such as Windows (trademark of Microsoft), OS/2 (trademark of IBM), and an X-window system (trademark of MIT) on AIX (trademark of IBM).
      <br/>
      However, the present invention can be realized even under a character-based environment such as PC-DOS (trademark of IBM) and MS-DOS (trademark of Microsoft) and is not to be limited to a componenticular operating system because only a non-graphical object to be described later can be defined as a program component.
    </p>
    <p num="35">B. System Structure</p>
    <p num="36">
      The system structure of the present invention will next be described in reference to a block diagram of FIG. 2.
      <br/>
      Program components 131 and 133 are stored in the program-component library 130.
      <br/>
      The program component manages the information about the property and method of that component.
      <br/>
      The managed information will be described later.
      <br/>
      The program development support system of the present invention (hereinafter referred to as a "builder") includes a component-information storage 110 which stores the information about a program component.
      <br/>
      The information can be rewritten or corrected by a programmer by using a component-information editor 101.
      <br/>
      The builder 100 further has a property editor 103, with which the property values of the program components 131 and 133 can be changed.
      <br/>
      An object visually-expressing section 105 displays a graphical program component.
    </p>
    <p num="37">
      The programmer can also encode a program by using the code editor 107.
      <br/>
      The coded program code is stored in code storage 109.
      <br/>
      An interpreter 120 executes a program, based on the program code stored in the code storage 109 and the information about a program component.
      <br/>
      In a preferred embodiment of the present invention, the code executor 120 is executed by an interpreter.
      <br/>
      However, the code executor 120 is not a concept that is limited to the interpreter, but it can be executed by a compiler, etc.
      <br/>
      In the block diagram of FIG. 2, a structure having a fixed function is expressed as a block in order to facilitate an understanding of the present invention.
      <br/>
      For example, the component-information editor 101 and the property editor 103 can be united and executed as a united component-information editor.
      <br/>
      Also, the component-information editor 101 can be split into a component-property information editor and a component-method information editor and executed.
    </p>
    <p num="38">
      In order to clarify the difference between the present invention and prior art, in FIG. 3 there is shown the different component (indicated by oblique lines) between the embodiment of the system structure of the present invention and prior art.
      <br/>
      In this figure, the program component 131 is a program component of the present invention and the program component 133 is a conventional program component.
      <br/>
      It is shown that the builder of the present invention can be handled without making a distinction between the conventional program component and the program component of the present invention.
      <br/>
      It is also shown that a component-information editing 101 is newly added and that a change has been made in both the component-information storage 110 and the interpreter 120.
    </p>
    <p num="39">B1. Property Table of Component-Information Storage</p>
    <p num="40">
      FIG. 4 is a diagram showing a property table of the component-information storage in a preferred embodiment of the present invention.
      <br/>
      The property table of the component-information storage (hereinafter referred to as simply a "property table" in order to distinguish it from a component-property table) exists in correspondence with the component name of the program component.
      <br/>
      The property table 150, as shown in FIG. 4, manages property name 155, property type 156, "GET" function 157, "PUT" function 158, and user-defined flag 159.
    </p>
    <p num="41">
      The GET function 157 is a function to have access to the program components 131 and 133 and to get the property values from the program components 131 and 133, and the PUT function 158 is a function to put property values to the program components 131 and 133.
      <br/>
      Depending on the properties of the program components 131 and 133, there are cases where only the GET function 157 is necessary and the PUT function 158 is unnecessary (data is only read from the program component), or cases where only the PUT function 158 is necessary and the GET function 157 is unnecessary (data is only written to the program component).
      <br/>
      In the specification of the present invention "a property access function" is used as a general term for the GET function 157 and the PUT function 158.
    </p>
    <p num="42">
      The property table 150 is segmented into an existent property information portion 151 and a user-defined property information portion 153.
      <br/>
      If the program component 133 is installed in the system, the information about the property name, property type, GET function, and PUT function of the program component 133 will be copied and registered in the existent property information portion 151 of the property table 150.
    </p>
    <p num="43">
      on the other hand, in the user-defined property information portion 153, if a program component is specified and newly registered by a programmer with the component-information editor 101, the registered property name and property type will be set and the property access function (GET function and PUT function) will be automatically generated.
      <br/>
      In the specification of the present invention, the property or method which a user defines by specifying a property name or a method name is called the "user-defined property" or "user-defined method," and the conventional property or method is called the "existent property" or "existent method."
    </p>
    <p num="44">The property access function, in a preferred embodiment of the present invention, is set as a property access function called "GetProperty/PutProperty," which is common to user-defined properties. (The property access function which is common to a plurality of pieces of user-defined property information will hereinafter be referred to as a "generic property access function.")</p>
    <p num="45">
      As shown in FIG. 4, since the existent property information portion 151 and the user-defined property information portion 153 are managed in common format, the property editor 103, the program builder 100, and the interpreter 120, as with the existent property information portion 151, can handle the user-defined property information portion 153.
      <br/>
      However, the existent property information and the user-defined property information are not always managed in common format, but the present invention can also be executed by making a change in the property editor 103 which has access to the property table 150 of the component-information storage 110 so that two kinds of tables can be accessed.
      <br/>
      Furthermore, the existent property information and the user-defined property information are not always managed by a table.
      <br/>
      If a property name is stored in a key in the form where the information corresponding to the property name can be accessed, the present invention can be executed.
    </p>
    <p num="46">
      In a preferred embodiment of the present invention, in the property made by user's registration there is set the flag 159 indicating that the property is a property defined by a user.
      <br/>
      Note that such a flag is not the essential constituent component of the present invention but is sufficient if a system can judge whether information is existent property information or user-defined property information.
      <br/>
      The judgment can be performed by the information about the positions at which the existent property information and the user-defined property information are stored, or it can be done by the name which can make a distinction between the property name of the user-defined property information and the property name of the existent property information (for example, the head or last of the property name is given "USR").
    </p>
    <p num="47">B2. Method Table of Component-Information Storage</p>
    <p num="48">
      FIG. 5 is a diagram showing a method table of the component-information storage in a preferred embodiment of the present invention.
      <br/>
      The method table of the component-information storage (hereinafter referred to as simply a "method table"), as with the property table 150, exists in correspondence with the component name of the program component and is constituted by an existent method information portion 161 and a user-registered method information 163.
      <br/>
      The existent method information portion 161 of the method table 160, as shown in the figure, manages method name 165, mounting-function address information (in a preferred embodiment of the present invention a C language is used) 167, method type 168, and user-defined flag 169.
    </p>
    <p num="49">
      The mounting-function address information 167 manages address information for pointing to a module which is started up when a method is executed in the program component managed by the method table.
      <br/>
      For example, in the case where the program component is a button icon component and the method is "move", address information for pointing to a program module which is executed for moving the button icon is managed.
      <br/>
      Because the mounting function of the existent method information is managed by the program component, the mounting-function address information is an address for pointing to the mounting functions of the program components 131 and 133.
      <br/>
      The method type 168 defines property needed for executing the method.
      <br/>
      Specifically, the property is defined in the form of "argument 1, argument 2, . . . , and argument n/ return value 1, return value 2, . . . , and return value m." The method has only an argument, only a return value, both an argument and a return value, or neither an argument nor a return value, depending upon the kind.
    </p>
    <p num="50">
      Likewise, the user-defined method information portion 163 manages the method name 165, the mounting-function address information 167, the method type 168, and user-defined flag 169.
      <br/>
      Thus, since the existent method information portion 161 and the user-defined method information portion 163 are managed in common format, the property editor 103, the program builder 100, and the interpreter 120, as with the existent method information portion 161, can handle the user-defined method information portion 163.
      <br/>
      In the user-defined method information portion 163, the mounting-function address information 167 is defined with respect to a single program component and common to a plurality of pieces of user-defined method information.
      <br/>
      The mounting-function address information 167 manages address information for pointing to the method call adapter 137 of the program component 131 which will be described later.
    </p>
    <p num="51">
      As with the property information in the program component, if the program component 133 is installed in the system, the information about the method name, mounting function, and method type of the program component 133 will be copied and registered in the existent method information portion 161 of the method table 160.
      <br/>
      On the other hand, in the user-defined method information portion 163, if a program component is specified and newly registered by a programmer with the component-information editor 101, the registered method name and method type will be set and the mounting function will be automatically generated.
    </p>
    <p num="52">
      In a preferred embodiment of the present invention, in the mounting function there is set information for pointing to a false mounting function called "CallMethod," which exists in a program component common to user-defined methods. (The mounting-function address information which is common to a plurality of pieces of user-defined method information will hereinafter be referred to as a "generic method function.") Also, in a preferred embodiment of the present invention, as with the property defined by a user, in the method made by user's registration there is set the flag 169 indicating that the method is a method defined by a user.
      <br/>
      Note that such a flag, as with the flag 159 in the property information, is not the essential constituent component of the present invention but is sufficient if a system can judge whether information is existent method information or user-defined method information.
      <br/>
      Also, as described in the property information, it is not indispensable to manage the existent method information and the user-defined method information in common format.
      <br/>
      Furthermore, it is not indispensable to manage them in the form of a table.
    </p>
    <p num="53">B3. Program-Component Property Information</p>
    <p num="54">
      A description will next be made of information that is managed by the program component 131.
      <br/>
      The program component 131, as with the information managed by the component-information storage 110, manages information about the property of a program component and information about the method of a program component.
      <br/>
      However, as described in the component-information storage 110, there are cases where the program component manages only the property information or only the method information, so it is not the essential constituent condition of the present invention to have the two kinds of pieces of information at the same time.
    </p>
    <p num="55">
      FIG. 6 is a diagram showing the property information of a program component (hereinafter referred to as "component-property information") and the property table of a program component (hereinafter referred to as a "component-property table for distinguishing it from the property table of the component-information storage 110) in a preferred embodiment of the present invention.
      <br/>
      The information, managed by the component-property property name 175, property type 176, "GET" function 177, "PUT" function 178, and user-defined flag 179 information 171, is information that corresponds to the existent property information 151 described in the component-information storage 110.
      <br/>
      The information managed by the component-property table 173 is information that corresponds to the user-defined property information 153.
      <br/>
      The component-property information 171, as the name implies, is not managed in the form of a table even in a preferred embodiment of the present invention.
      <br/>
      When a program component is introduced into a system, the content of the component-property information 171 is declared to the side of the builder 100 and therefore the builder 100 can recognize the content or kind of the information.
    </p>
    <p num="56">
      The component-property information 171 manages nearly the same information as the information of the property table 151 in the existent property of the component-information storage 110.
      <br/>
      The differing point between pieces of information managed by the property table 151 and the component-property information 171 is that the component-property information 171 manages the information of an actual property value with respect to property.
      <br/>
      There is the case where the property value 179 is set by a default value when the program component 131 is installed, or the case where the property value 179 is set by the property editor 103.
    </p>
    <p num="57">
      The component-property table 173, on the other hand, manages property name 175, type 176, and property value 179.
      <br/>
      The information of the property table 173 is set by the programmer's registration in the component-information editor 101.
      <br/>
      Note that the information of the property value 179 can also be input from the property editor 103.
    </p>
    <p num="58">B4. Program-Component Method Information</p>
    <p num="59">
      A description will next be made of how the method information is managed in the program component 131.
      <br/>
      FIG. 7 is a diagram showing the method information of a program component (hereinafter referred to as simply "component-method information") in a preferred embodiment of the present invention.
      <br/>
      The component-method information 180, as the method table 160 in the component-information storage 110, manages the method name 185 and method type 188 of existent method information.
      <br/>
      The mounting function 187, unlike the method table 160 of the component-information storage 110, manages a module which is started up when the method is executed.
    </p>
    <p num="60">
      For the user-defined method information, on the program component 131 it is not managed on the program component side, as in the existent method information, and instead, a method call adapter 137 is present.
      <br/>
      Although the method call adapter will be described in detail later, it manages a function for pointing to a module which is started up when the method of the user-defined method information is executed.
    </p>
    <p num="61">C. System Operation</p>
    <p num="62">
      In a preferred embodiment of the present invention, in order to extend the function of the program component, the component-information storage 110, the program component 131, and the interpreter 120 are respectively extended and the component-information editor 101 is newly added, as shown in FIG. 3.
      <br/>
      The expansion of each section and the operation of the system will hereinafter be described from the viewpoint of the user definition of component information, the use of component information by the builder, and the use of component information at execute.
    </p>
    <p num="63">C1. User Definition of Component Information</p>
    <p num="64">
      FIG. 8 is a diagram showing the flow of data as component information is defined by a programmer (user), in a preferred embodiment of the present invention.
      <br/>
      Updating of component information, that is, property addition, property change, and property deletion, and method addition, method change, and method deletion can be performed by the function of the component-information editor 101.
    </p>
    <p num="65">(1) Property Definition</p>
    <p num="66">
      A programmer specifies a program component in the component-information editor 101 and then an entry for inputting property information can be displayed.
      <br/>
      In a preferred embodiment of the present invention the program component is provided as a new program-component registration icon or an existent program-component icon, so the program component can be selected by clicking on the icon of the program component.
    </p>
    <p num="67">
      When the program component specified by a programmer has already existed (in a preferred embodiment of the present invention a program component already registered can be selected at a pull-down menu), the property information of the program component is displayed so that it can be corrected and deleted by the user.
      <br/>
      The programmer can correct the property type 156.
      <br/>
      Also, if the property name 155 is corrected, it will be registered as a new property after correction.
      <br/>
      When the program component selected by the programmer is a new one, the programmer inputs the property name 155 and the property type 156.
      <br/>
      In a preferred embodiment of the present invention, when updating (addition/correction/deletion) is performed, the updating where contradiction occurs internally can be checked by syntax checking and thus the updating where contradiction occurs can be automatically corrected or rejected.
    </p>
    <p num="68">In the case where the existent property information is updated by the user's registration operation, the property information of the property table 153 in the component-information storage 110 is updated internally (in the case of the updating of the existent property information, the property type 156 is updated, and in the case of the deletion of the existent property, the property name 155, property type 156, property access functions 157 and 158, and flag 159 of the property are deleted), and furthermore, the information of the component-property information 171 of the corresponding program component 131 is also changed correspondingly.</p>
    <p num="69">
      In the case where the program component specified by the programmer is a new one which does not exist in the system, the name of the program component specified by the user is registered in the component-information storage 110 and the corresponding program component.
      <br/>
      Also, the property name 155 and the property type 156, defined by the user, are registered in the property table 153 of the registered program component.
      <br/>
      Furthermore, the generic property access function is automatically set to the property access functions 157 and 158, and "1", for indicating that property is user-defined property, is automatically set to the flag 159.
      <br/>
      Finally, the property name and the property type, defined by the user, are set to the property name 175 and the property type 176 of the component-property table 173 in the corresponding program component 131.
    </p>
    <p num="70">(2) Method Definition</p>
    <p num="71">
      As with the definition of the property, if a programmer specifies a program component in the component-information editor 101, an entry for inputting method information will be displayed.
      <br/>
      When the program component specified by a programmer has already existed, the method information of the program component is displayed so that it can be corrected and deleted by the user.
      <br/>
      The programmer can correct the method type 168.
      <br/>
      Also, if the method name 165 is corrected, it will be registered as a new method after correction.
      <br/>
      When the program component selected by the programmer is a new one, the programmer inputs the method name 165 and the method type 168.
      <br/>
      In a preferred embodiment of the present invention, when updating (addition/correction/deletion) is performed, the updating where contradiction occurs internally can be checked by syntax checking and thus the updating where contradiction occurs can be automatically corrected or rejected.
    </p>
    <p num="72">In the case where the existent method information is updated by the user's registration operation, the method information of the method table 163 in the component-information storage 110 is updated internally (in the case of the updating of the existent method information, the method type 168 is updated, and in the case of the deletion of the existent method information, the method name 165, mounting-function address information 167, method type 168, and flag 169 of the method are deleted), and furthermore, the information of the component-method information 180 of the corresponding program component 131 is also changed correspondingly.</p>
    <p num="73">
      In the case where the program component specified by the programmer is a new one which does not exist in the system, the name of the program component specified by the user is registered in the component-information storage 110 and the corresponding program component.
      <br/>
      Also, in the method table 163 of the registered program component, the method name 165 and the method type 168, defined by the user, are set to the content defined in the component-information editor 101.
      <br/>
      Furthermore, the generic method function is automatically set to the mounting-function address information 167, and "1" for indicating that a method is a user-defined method is automatically set to the flag 169.
      <br/>
      In this respect, the movement of the component-information editor 101 and the component-information storage 110 is the same as the case of the property information.
      <br/>
      However, in the case of the method information, in a preferred embodiment of the present invention the method information of the method table 163 in the component-information storage 110 is updated only and there is no updating of the program component 131.
      <br/>
      This is because the code of a method, stored in another place, can be utilized by the operation of a method call adapter which will be described later.
      <br/>
      However, if a sufficient storage area can be assured in the program component, it will also be possible to manage the code of a method at the program component side, as in the case of the property.
    </p>
    <p num="74">C2. Program Generation Support by User-defined Component Information</p>
    <p num="75">
      A description will next be made of how the program component defined in the aforementioned way by the user is utilized when a program is generated.
      <br/>
      FIG. 9 is a diagram showing the flow of data as the builder utilizes program component information, in a preferred embodiment of the present invention.
    </p>
    <p num="76">(1) Property Value Setting</p>
    <p num="77">
      A programmer can set the property value of the program component specified with the property editor 103.
      <br/>
      In a preferred embodiment of the present invention the property table 150 of the component-information storage 110 manages an existent property and a user-defined property with a common table, so the property editor 103 can access the property information of the user-defined property table 153 of the component-information storage 110, even if a change is not made in the function of a conventional property editor.
      <br/>
      It is not indispensable that the property table 150 of the component-information storage 110 manages the existent property table 151 and the user-defined property table 153 in common format, and the property table 150 of the component-information storage 110 can execute the property editor 103 by extending the function of the property editor so that the property table 150 can be accessed to two different tables, the existent property table 151 and the user-defined property table 153.
    </p>
    <p num="78">When a property value defined by a programmer is existent property information, the builder 100 has access to the property value 179 of the component-property information 171 of the program component 131 by using the property access functions 157 and 158 of the property table 151 and employing a conventional method and then can set the property value of the specified program component by using the property editor 103.</p>
    <p num="79">When a property value specified by a programmer is the property value of user-defined property, the builder 100 has access to the property value 179 of the component-property table 173 of the program component 131 by employing the property name 155 and the generic property access functions 157 and 158 of the property table 153 of the component-information storage 110 and then can set the property value by employing the property editor 103.</p>
    <p num="80">
      Specifically, the builder 100 first displays the property name 155 stored in the property table 150 of the component-information storage 110, in order to make it possible to register a user-defined property value with the property editor 103.
      <br/>
      Also, in order to display a property value corresponding to the property name 155, it is first judged whether the property is an existent property or a user-defined property, by checking the flag 159 of the property table 150.
    </p>
    <p num="81">
      When it is judged that the property is a user-defined property, the component-property table 173 of the program component 131 is accessed by employing the "GetProperty" 157 of one of the generic property access functions.
      <br/>
      Then, it becomes possible that the property value 179 of the component-property table 173 is displayed on the property editor 103, by retrieving the property name 175 by a key and sending the value to the property editor 103. (When there is no registered value, a blank is displayed.)
    </p>
    <p num="82">Then, if a programmer changes the property value of the property editor 103, the builder 100 has access to the property value 179 of the component-property table 173 of the program component 131 by employing the property name 155 and the "PutProperty" 158 of one of the generic property access functions, stored in the property table 153 of the component-information storage 110, and updates the property value.</p>
    <p num="83">(2) Utilization of Method Information</p>
    <p num="84">
      A programmer can makes a description in the code editor 107 so that the method of a user-defined program component is specified.
      <br/>
      With this, the method can be executed in the code executor 120, and a detailed description will be made later.
    </p>
    <p num="85">C3. Execute of a Program Made by Using User-defined Component Information</p>
    <p num="86">A description will next be made of how a program, made by using a program component defined by a user, is executed.</p>
    <p num="87">
      FIG. 10 is a diagram showing the flow of data as program component information is utilized at the time of program execute, in a preferred embodiment of the present invention.
      <br/>
      First, the code described in the code storage 109 is interpreted by the interpreter 120 for the call of existent property information (which is not user-defined information but conventional program component information) and method information.
      <br/>
      Here, if the program component name and the property name are specified, or if the program component name and the method name are specified, the interpreter 120 can utilize the program component information.
    </p>
    <p num="88">(1) Utilization of Property Information</p>
    <p num="89">
      FIG. 11 is a diagram showing the flow of data as user-defined property information is utilized at the time of program execute, in a preferred embodiment of the present invention.
      <br/>
      When the interpreter 120 utilizes the property information of a program component, the interpreter requests information for having access to the property value 179 of the program component 131 from the builder 100.
      <br/>
      The builder 100 retrieves the property name of the property table 150 of the component-information storage 110 sent by the interpreter 120 from a key.
      <br/>
      The builder 100 judges whether the property requested by the interpreter 120 is user-defined property information or existent property information by checking the flag 159 of the property table 150 of the component-information storage 110.
    </p>
    <p num="90">
      When the property is existent property information, the builder 100 sends back the property access functions 157 and 158 of the property table 150 to the interpreter 120.
      <br/>
      At this time, the interpreter 120 can judge from the content of the code whether the access to the property value of the program component is "get" or "put." Therefore, there is a method where the interpreter 120 specifies and receives either the GET property access function 157 or the PUT property access function 158 from the builder 100, or a method where the interpreter 120 receives both the GET property access function 157 or the PUT property access function 158 and selects either one.
    </p>
    <p num="91">
      With the obtained information, the interpreter 120 has access to the component-property information of the program components 131 and 133 and also has access to the property value 179.
      <br/>
      In the case of the GET property access function 157, a read operation is performed with respect to the property value 179.
      <br/>
      In the case of the PUT property access function 158, a write operation is performed with respect to the property value 179.
    </p>
    <p num="92">
      On the other hand, in the case of user-defined property, the builder 100 sends back the generic property access functions 157 and 158, where a property name is an argument, to the interpreter 120.
      <br/>
      At this time, as with the access to the existent property information, the interpreter 120 can judge from the content of the code whether the access to the property value of the program component is "get" or "put." Therefore, there is a method where the interpreter 120 specifies and receives either the generic GET property access function 157 or the generic PUT property access function 158 from the builder 100, or a method where the interpreter 120 receives both the generic GET property access function 157 or the generic PUT property access function 158 and selects either one.
    </p>
    <p num="93">
      Also, the interpreter 120 may obtain a property name from a key for information of whether property is user-defined property or existent property, with respect to the builder 100.
      <br/>
      The builder 100 may return only the flag 159 of the property table 150 to the interpreter 120 and issue a generic property access function at the side of the interpreter 120.
      <br/>
      Furthermore, by sending a program component name and a property name to the interpreter 120 when property information is registered in the program component 131, it becomes unnecessary that the interpreter 120 makes an inquiry of information of whether user-defined property or existent property to the side of the builder 100.
    </p>
    <p num="94">
      With the aforementioned information, the interpreter 120 has access to the component-property table of the program component 131 and also has access to the property value 179.
      <br/>
      In the case of the generic GET property access function 157, a read operation is performed with respect to the property value 179.
      <br/>
      In the case of the generic PUT property access function 158, a write operation is performed with respect to the property value 179.
    </p>
    <p num="95">(2) Access to Method Information</p>
    <p num="96">
      FIG. 12 is a diagram showing the flow of data as user-defined method information is utilized at the time of program execute, in a preferred embodiment of the present invention.
      <br/>
      The call of an existent method is done by directly calling out a function which corresponds to the method.
      <br/>
      However, a function corresponding to a newly added method is not present on the program component side but is managed by the interpreter 120.
      <br/>
      Hence, a dummy function is prepared and the interpreter calls out this function, together with the function name.
      <br/>
      The interpreter issues a generic method function where a method name is an argument, according to a method which is nearly identical with property information.
    </p>
    <p num="97">
      The method call adapter 137 of the program component 131 converts the generic method function received from the interpreter 120 to information which points to a position at which the method code 123 managed by the interpreter 120 is stored. (This information will hereinafter be referred to as "generic method code access information.") In a preferred embodiment of the present invention, the generic method code access information is returned to the interpreter side with a method name as an argument.
      <br/>
      In a preferred embodiment of the present invention, the method code 123 is generated by the code editor 107, and the method name is stored in a key and the method code 123 is stored in the code storage 109 so that the interpreter 120 can retrieve the code.
      <br/>
      If the interpreter 120 receives generic method code access information, the method name will be retrieved from a key and the method code 123 will be retrieved and the method code 123 will be executed.
    </p>
    <p num="98">D. Programmer's Operation Procedure</p>
    <p num="99">The form of utilization of a program component in a preferred embodiment of the present invention will next be described along programmer's operation procedure.</p>
    <p num="100">D1. Definition Procedure of Component Information</p>
    <p num="101">
      FIGS. 15 through 19 are diagrams showing a procedure of setting a program component, in a preferred embodiment of the present invention.
      <br/>
      FIG. 15 is a diagram showing the initial state in the setting procedure of the program component.
      <br/>
      In the figure a main window 310 is the main window of the builder and is a window for managing various kinds of forms corresponding to an application window 320 and various kinds of codes stored in the code storage 109.
    </p>
    <p num="102">
      The application window 320 is a window corresponding to the object visually-expressing section 105 shown in FIGS. 2 and 3.
      <br/>
      In the initial state there is no information, so a programmer specifies a program component by employing the application window 320.
      <br/>
      This application window will enable a programmer to make an intuitively understandable program.
      <br/>
      Note that it is possible to display specification of a program component even by extending the display function of a component-library described later, so the application window does not form the essential constituent component of the present invention.
    </p>
    <p num="103">
      A set of icons disposed on the left upper side of FIG. 15 is a component-library 330 which holds various components.
      <br/>
      Each one of the icons corresponds to a program component.
      <br/>
      Among the icons, icon 331 labeled "UDObj" is an icon that is provided exclusively to a user-defined program component.
      <br/>
      When a programmer makes a new program component, the UDObj icon 331 is first dropped onto the application window 320, as shown in FIG. 16 (icon 321).
      <br/>
      In the method of positioning the icon 331 on the application window 320, a double clicking operation can be performed in addition to a dragging and dropping operation.
      <br/>
      Also, a previously set key can be depressed with the icon 331 selected.
      <br/>
      The positioning method is a matter which can be set in various ways when designed.
    </p>
    <p num="104">
      As shown in FIG. 17, if a programmer selects by a clicking operation an item of the window of the main window 310 to display a pull-down menu and also selects an item of property editor, then a property editor window 340 will be opened.
      <br/>
      As an example of the method or procedure of opening a window which corresponds to this icon, there are various methods, such as a method where the property editor window 340 is opened when a double clicking operation is performed so that the icon 321 on the application window 320 is selected.
      <br/>
      Those skilled in the art can select and implement a desired method or procedure from various methods or procedures when it is designed.
      <br/>
      In a preferred embodiment of the present invention, if the icon 331 for new registration is dropped onto the application window 320, the property editor window 340 will be automatically opened and a cursor will be positioned on a program component name input entry 347 which is highlighted so that the programmer can input a program component name.
      <br/>
      Notice that the property editor window 340 corresponds to the property editor 103 shown in FIGS. 2 and 3.
    </p>
    <p num="105">
      The programmer can first set the name of a program component.
      <br/>
      In the figure, the programmer sets the program component name to "Order" by inputting it to the program component name input entry 347 of the property editor window 340 through a keyboard.
      <br/>
      Then, the content of the programmer's input is registered by selecting a button icon 341 labeled "registration." With this operation, an empty property table 150 and method table 160 are made in the component-information storage 110 in correspondence with the program component name, "Order." Also, a new program component of the program component name "Order" is made in the component-library 130.
    </p>
    <p num="106">
      In a preferred embodiment of the present invention, the property table 150 which is registered in the component-information storage 110 is not empty in the initial state of registration.
      <br/>
      That is, "Container" indicating which application window a program component is positioned on, a property name such as an index, or a property value is automatically set and registered in the property table 150 of the component-information storage 110 or the property information of the program component.
      <br/>
      It is also possible to display this program component on the component-library 330 as an icon so that the icon can be selected.
      <br/>
      Note that a button icon 343 for cancellation is provided on the property editor window 340.
      <br/>
      If this button is selected by clicking on the button, an unregistered character string, input to each entry of the property editor window 340, will become invalid.
    </p>
    <p num="107">
      If the setting of the program component name is completed, then the programmer will perform registration of the property or method.
      <br/>
      The window 350, displayed in FIG. 18, is an object window and corresponds to the component-information editor shown in FIGS. 2 and 3.
      <br/>
      In the object window 350 there is shown a program component name 355, so the programmer can easily know that the property or method of the program component "Order" has been defined.
      <br/>
      In FIG. 518 the registration of the property is first performed.
      <br/>
      The definition of the property can be performed by inputting the property name and the property type to the property input entry 357 through a keyboard.
      <br/>
      Also, if a button icon 361, named "List," is selected by a clicking operation, a typical property name and property type will be displayed in the form of a pull-down menu and the programmer can select and utilize one from the list.
    </p>
    <p num="108">
      The character string, described in the property input entry 357, is registered by clicking on the button icon 363 for registration.
      <br/>
      If the property is registered, the content of the definition registered in the list 359 of the registered property, will be updated in the object window 350.
      <br/>
      In the figure, it is shown that the defined sentence of the property, "ProductID as long," has been registered when the property is updated.
    </p>
    <p num="109">
      If the aforementioned property is registered, the property name 155 and the property type of the property table 150 of the component-information storage 110 will be updated according to the content defined by the user, and information indicating the generic property access function will be set to the entries of the property access functions 157 and 158.
      <br/>
      Also, a "1," which indicates that the registered property is a user-defined property, is set to the flag 159.
      <br/>
      Similarly, the property name and the property type of the component-property table 173 are registered in the program component 131.
      <br/>
      Note that by detecting that the button icon, where the property has been registered, was selected by a clicking operation, it is also possible to again display the property editor window 340 with the content after registration.
    </p>
    <p num="110">
      In FIG. 19, following the registration of the property the registration of the method has been performed.
      <br/>
      For registrations of the property and the method, either may first be performed.
      <br/>
      In the present invention, the property will first be described and the method will be described later, for alleviating reader's burden.
      <br/>
      In the registration of the method, as with the registration of the property, the method name and the method type can be input to the input entry 365 through a keyboard.
      <br/>
      Also, if the button icon 369 labeled "List" is selected by a clicking operation, a typical method name and method type will be displayed in the form of a pull-down menu and the programmer can select and utilize one from the list.
    </p>
    <p num="111">
      The character string, described in the method input entry 365, is registered by clicking on the button icon 371 for registration.
      <br/>
      If the method is registered, the content of the definition registered in the list 367 of the registered method will be added in the object window 350.
      <br/>
      In the figure it is shown that the defined sentence of the method, "QueryPrice(ID as long) as string," has been registered when the method is updated.
    </p>
    <p num="112">
      If the aforementioned method is registered, the method name 165 and the method type 168 of the method table 160 of the component-information storage 110 will be updated according to the content defined by the user, and information indicating the generic method function will automatically be set to the entry of the mounting-function address information 167.
      <br/>
      Also, a "1," which indicates that the registered method is a user-defined method, is set to the flag 169.
    </p>
    <p num="113">D2. Program Generation Procedure</p>
    <p num="114">
      A description will next be made of how the aforementioned information of the user-defined program component is employed by a programmer when a program is developed.
      <br/>
      FIGS. 20 and 21 are diagrams showing a procedure of utilizing a program component, in a preferred embodiment of the present invention.
      <br/>
      In FIG. 20 a programmer has set the property value of the user-defined property.
      <br/>
      Because an entry corresponding to a user-defined property is provided if the property editor window 340 is redisplayed, the programmer can set a property value.
    </p>
    <p num="115">
      If the redisplay of the property editor window 340 is performed, the builder 100 will all display the property names 155 stored in the property table 150 of the component-information storage 110.
      <br/>
      Also, in order to display a property value corresponding to this, it is first judged whether the property is an existent property or a used-defined property by checking the flag 159 of the property table 150.
      <br/>
      In the case of the user-defined property, the judgment can be made because the value of the flag 159 is 1.
      <br/>
      In this case the programmer has access to the component-property table 173 of the program component 131 by employing the "GetProperty" function 157 of one of the generic property access functions.
      <br/>
      Then, the property value 179 of the component-property table 173 is displayed on the property editor 103 by retrieving the property name 175 by a key and sending the value to the property editor 103.
      <br/>
      At this time, a blank will be displayed because there is set no value in the property value of the user-defined property.
    </p>
    <p num="116">Then, the programmer inputs the property value, "PS/55 (trademark of IBM)," to the property name, "Product" 349, and the property value, "5433," to the property name, "ProductID" 352 Next, the builder 100 has access to the property value 179 of the component-property table 173 of the program component 131 by employing the "PutProperty" function 158 among the property names 155 and the generic property access functions stored in the property table 153 of the component-information storage 110 and then updates the property value.</p>
    <p num="117">
      A description will next be made of how information is employed by a programmer when a program is developed in the code editor.
      <br/>
      In FIG. 21 the programmer is coding a program.
      <br/>
      The programmer can perform generation of the code of a user-defined method and generation of the code in the main logic section in the code editor window 380.
      <br/>
      In the figure, reference numeral 380 denotes a code editor window, which corresponds to the code editor in FIGS. 2 and 3.
      <br/>
      In FIG. 21, a program component name "Order" and the code of the user-defined method of a method name "QueryCustomer" are defined.
      <br/>
      The content of the code described in the code description entry 393 in the figure is stored in the code storage 109 and is sent to the interpreter 120, in which it is executed as the code of the user-defined method.
      <br/>
      From the description of the method code the main logic can be described in the same coding technique as a description to use the property and method of another program component.
      <br/>
      In the code description entry 393, as shown in the figure, the property and method of another program component can also be utilized by specifying the component name 395 or property 397 of the other program component, or by specifying the component name 399 or method name 401 of the other program component while adding arguments.
    </p>
    <p num="118">
      In the code editor window there are provided three kinds of entries, module entry 387, object entry 389, and method entry 391.
      <br/>
      By inputting a code directly to these entries through a keyboard, the programmer can specify the component name and method name of the code input to the code description entry.
      <br/>
      Each of the entries 387, 389, and 391 has the function of a pull-down menu.
    </p>
    <p num="119">
      The pull-down menu of the module entry 387 is provided for calling out another form (another code edited by the code editor).
      <br/>
      The form selected by this pull-down menu is displayed on the code description entry 393.
      <br/>
      The pull-down menu of the object entry 389 is a pull-down menu to retrieve and select another program component.
      <br/>
      The pull-down menu of the method entry 391 is a pull-down menu for retrieving and selecting another method. if the button icon 381 for execute is selected by a clicking operation, then this code will be sent to the interpreter 120 and executed according to the aforementioned procedure.
      <br/>
      In addition to the execute button icon 381, button icons 383 and 385 for interrupt and abortpage are provided, and if the icon 383 or 385 is selected by a clicking operation, the execute of a program will be interrupted or aborted.
    </p>
    <p num="120">According to the present invention, as described above, the information about original function of a program component is not only accumulated in the component-information storage but also the information about a new function which is not present in an actual component is accumulated, so other devices or interpreters in the program construction support system can be utilized.</p>
    <p num="121">Also, in accordance with the present invention, an apparent function of a program component can be extended in the component-information editor by adding a new property and a new method to the program component.</p>
    <p num="122">In addition, the original property of a program component and an additional property can be changed based on the information stored in the component-information storage by the property editor without making a distinction between them.</p>
    <p num="123">
      Furthermore, based on the information stored in the component-information storage, the code of the skeleton of a method can be automatically generated and an additional method can be described by the code editor.
      <br/>
      Therefore, when an additional method and an additional property are utilized, they can be used without distinguishing them from the original method and property of a program component.
    </p>
    <p num="124">Moreover, when a program component is called out from an interpreter to execute a program, an additional property can be referred to or changed and an additional method can be called out, by using the information stored in the component-information storage.</p>
    <p num="125">
      Since a program component is usually described by languages such as a C language, the addition of a new property and a new method to a certain program component cannot be performed by a basic language differing from the C language and the addition must be performed by the C language.
      <br/>
      However, if a method of adding property information and method information to a program component of the present invention is employed, a program can be coded with a language easily understandable for users, such as a basic language, and development efficiency can also be enhanced.
    </p>
    <p num="126">While the invention has been particularly shown and described with respect to preferred embodiments thereof, it will be understood by those skilled in the art that the foregoing and other changes in form and details may be made therein without departing from the spirit and scope of the invention.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A program code executing method in a program development support system which includes a program component which manages method information and property information, a property table which manages a property name and a generic property access function of said program component, a method table which manages a method name and a generic method function of said program component, a code executor, a code storage which includes description of a program component name, a property name, and a method name and which stores a code of a user-defined method stored in relation to a program code which is executed by said code executor and to a method of said program component, and a code editor for editing said code, said program code executing method comprising the steps of:</claim-text>
      <claim-text>(a) receiving a program code which includes a description for specifying the program component name, the property name of said program component, and the method name of said program component; (b) specifying the generic property access function managed in the property table of said component-information storage from the component name and property name included in said program code; (c) specifying the property value of said program component, based on said program component name and on the generic property access function managed in the property table of said component-information storage; (d) specifying the generic method function managed in the method table of said component-information storage from the component name and method name included in said program code; (e) issuing the user-defined method name and the generic method function to said program component; (f) receiving generic method code access information which points to the code of the user-defined method, issued in response to reception of the user-defined method name and the generic method function performed by the program component; (g) accessing the code of the user-defined method stored in said code storage, based on said generic method code access information;</claim-text>
      <claim-text>and (h) executing the code of said user-defined method, wherein said method information included in program components is integrated to extend an apparent function of an existing program component without extending an actual function of the existing program component when an application program is being developed and when said application program is executed.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. A program code executing method in a program development support system which includes a program component which manages property information, a property table which manages a property name and a generic property access function of said program component, a code executor, a code storage which includes description of a program component name and a property name and which stores a program code which is executed by said code executor, and a code editor for editing said code, said program code executing method comprising the steps of: (a) receiving a program code which includes a description for specifying the program component name and the property name of said program component; (b) specifying the generic property access function managed in the property table of said component-information storage from the component name and property name included in said program code;</claim-text>
      <claim-text>and (c) specifying the property value of said program component, based on said program component name and on the generic property access function managed in the property table of said component-information storage, wherein said property information included in program components is integrated to extend an apparent function functionality of an existing program component without extending an actual function of the existing program component when an application program is being developed and when said application program is executed.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. A program code executing method in a program development support system which includes a program component which manages method information, a method table which manages a method name and a generic method function of said program component, a code executor, a code storage which includes description of a program component name and a method name and which stores a code of a user-defined method stored in relation to a program code which is executed by said code executor and to a method of said program component, and a code editor for editing said code, said program code executing method comprising the steps of: (a) receiving a program code which includes a description for specifying the program component name and the method name of said program component; (b) specifying the generic method function managed in the method table of said component-information storage from the component name and method name included in said program code; (c) issuing the user-defined method name and the generic method function to said program component; (d) receiving generic method code access information which points to the code of the user-defined method, issued in response to reception of the user-defined method name and the generic method function performed by the program component; (e) accessing the code of the user-defined method stored in said code storage, based on said generic method code access information;</claim-text>
      <claim-text>and (f) executing the code of said user-defined method, wherein said method information included in program components is integrated to extend an apparent function of an existing program component without extending the actual function of the existing program component when an application program is being developed and when said application program is executed.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A computer program device readable by a machine, tangibly embodying a program of instructions executable by a machine to perform method steps for storing a program to execute a program code, in a program development support system which includes a program component which manages method information and property information, a property table which manages a property name and a generic property access function of said program component, a method table which manages a method name and a generic method function of said program component, a code executor, a code storage which includes description of a program component name, a property name, and a method name and which stores a code of a user-defined method stored in relation to a program code which is executed by said code executor and to a method of said program component, and a code editor for editing said code, the program comprising: (a) program code means for instructing said program development support system to receive a program code which includes a description for specifying the program component name, the property name of said program component, and the method name of said program component; (b) program code means for instructing said program development support system to specify the generic property access function managed in the property table of said component-information storage from the component name and property name included in said program code; (c) program code means for instructing said program development support system to specify the property value of said program component, based on said program component name and on the generic property access function managed in the property table of said component-information storage; (d) program code means for instructing said program development support system to specify the generic method function managed in the method table of said component-information storage from the component name and method name included in said program code; (e) program code means for instructing said program development support system to issue the user-defined method name and the generic method function to said program component; (f) program code means for instructing said program development support system to receive generic method code access information which points to the code of the user-defined method, issued in response to reception of the user-defined method name and the generic method function performed by the program component; (g) program code means for instructing said program development support system to access the code of the user-defined method stored in said code storage, based on said generic method code access information;</claim-text>
      <claim-text>and (h) program code means for instructing said program development support system to execute the code of said user-defined method, wherein said property and method information included in program components are integrated to extend an apparent function of an existing program component without extending an actual function of the existing program component when an application program is being developed and when said application program is executed.</claim-text>
    </claim>
  </claims>
</questel-patent-document>