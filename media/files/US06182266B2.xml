<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182266B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182266</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182266</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="25456870" extended-family-id="42109131">
      <document-id>
        <country>US</country>
        <doc-number>08928848</doc-number>
        <kind>A</kind>
        <date>19970912</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08928848</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165811</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>92884897</doc-number>
        <kind>A</kind>
        <date>19970912</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08928848</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>H03M  13/00        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>00</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   7/24        20060101A N20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>24</subgroup>
        <classification-value>N</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F  11/08        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>08</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>714807000</text>
        <class>714</class>
        <subclass>807000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>365218000</text>
        <class>365</class>
        <subclass>218000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>714006130</text>
        <class>714</class>
        <subclass>006130</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-011/08</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>08</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>H03M-013/00</text>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>00</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/08</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>08</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-007/24</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>24</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>H03M-013/00</classification-symbol>
        <section>H</section>
        <class>03</class>
        <subclass>M</subclass>
        <main-group>13</main-group>
        <subgroup>00</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-007/24</classification-symbol>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>7</number-of-claims>
    <exemplary-claim>7</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>6</number-of-drawing-sheets>
      <number-of-figures>15</number-of-figures>
      <image-key data-format="questel">US6182266</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Self-auditing protection method for sorted arrays</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>KING C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>3756404</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US3756404</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>MIYAZAWA TAKASHI</text>
          <document-id>
            <country>US</country>
            <doc-number>4448526</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4448526</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>BISH JOHN E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5235585</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5235585</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>SHINNO ATSUSHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5319627</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5319627</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>WELLS STEVEN E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5577194</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5577194</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Lucent Technologies, Inc.</orgname>
            <address>
              <address-1>Murray Hill, NJ, US</address-1>
              <city>Murray Hill</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>LUCENT TECHNOLOGIES</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Clutter, Sherwin J.</name>
            <address>
              <address-1>Aurora, IL, US</address-1>
              <city>Aurora</city>
              <state>IL</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Simak, David F.</name>
            <address>
              <address-1>Wheaton, IL, US</address-1>
              <city>Wheaton</city>
              <state>IL</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Moise, Emmanuel L.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      An error detection system for an array of data elements is disclosed.
      <br/>
      In this system, each data element in the array includes first and second error detection fields.
      <br/>
      As the system traverses the array, a detecting mechanism sequentially compares the first error detection field with the second error detection field for each data element in order to determine whether the data element is corrupt.
      <br/>
      The detecting mechanism also compares the first error detection field of adjacent data elements in order to identify duplicates.
      <br/>
      If an invalid element (i.e. corrupt or a duplicate) is detected, the system then removes or deletes the element from the array.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      This invention relates to the detection of invalid data elements stored in an array.
      <br/>
      More specifically, this invention pertains to a self-auditing protection method for a sorted array in which corrupt and/or duplicate data elements are detected and deleted during traversal of the sorted array.
    </p>
    <p num="2">
      In order to maximize efficiency and minimize delays associated with information retrieval, data elements within an array are typically "sorted" or arranged in numerical or alphabetical order.
      <br/>
      Many computer applications and operating systems include a built-in sorting program such as Quicksort, published in 1962 by C.A.R. Hoare, or computer sorting routines such as: (1) bubble sort; (2) insertion sort; (3) merge sort; (4) selection sort; and (5) shell sort.
      <br/>
      However, if the sorting process is prematurely terminated, before each data element has been moved to its appropriate array position, data elements may be duplicated or corrupted.
    </p>
    <p num="3">
      There are two existing techniques in the prior art which attempt to solve the above-identified problem.
      <br/>
      The first technique uses cyclic redundancy (check) code ("CRC") in conjunction with data elements in an array.
      <br/>
      In short, CRC auditing involves the calculation of a CRC value based upon a formula which uses the data contained in each array element as variables.
      <br/>
      The result of that calculation, the CRC value, is then appended onto the end of each data element.
      <br/>
      Various calculation methods can be used to generate the CRC value; however, the CRC calculation method is generally chosen to optimize error detection capability.
      <br/>
      In order to check for an error in the data element, the calculation is performed again and compared with the stored answer, the CRC value.
      <br/>
      If the two calculations are different, an error is detected.
    </p>
    <p num="4">
      For large data elements, generating the CRC value is time consuming and for small data elements, the CRC algorithm is susceptible to erroneous detection of duplicates.
      <br/>
      Further, either of these problems can be aggravated depending on the selected CRC algorithm.
    </p>
    <p num="5">
      Another technique involves the use of doubly-linked lists.
      <br/>
      Doubly-linked lists provide a way to manage data that is not stored sequentially in a computer.
      <br/>
      In essence, a doubly-linked list contains three parts, the data itself, a first number (ie. pointer) which identifies the location of the previous item on the list, and a second number (i.e. pointer)which identifies the location of the next item on the list.
      <br/>
      However, the use of linked lists requires a relatively complex resource allocation scheme and a complex auditing mechanism.
      <br/>
      In addition, the recovery of broken linkages (i.e. when the pointer does not properly identify the location of the next or previous item on the list) is time-consuming and requires complex data analysis to recover all possible breakages and resource losses.
      <br/>
      Furthermore, the process which is traversing the doubly-linked list cannot proceed if errors are encountered.
    </p>
    <p num="6">
      In many data intensive applications sorting techniques requiring the use of CRCs or doubly-linked lists are unacceptable.
      <br/>
      A new system for detecting corrupt data elements stored in a computer as an array of data elements is necessary.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="7">An object of the present invention is to provide a method and system of detecting and deleting invalid data elements contained within an array, including data elements that are duplicates as well as those that are corrupt, in which each traversal of the sorted array detects and discards the invalid data elements.</p>
    <p num="8">
      The invention takes the form of an error detection system for an array of data elements in which each data element has a first error detection field and a second error detection field.
      <br/>
      The first and second error detection fields are both assigned the same number which is unique and different from the numbers assigned to the error detection fields of the remaining data elements.
      <br/>
      The array of data elements is stored in a storing mechanism such as memory.
      <br/>
      As the error detection system traverses the array of data elements, a detecting mechanism sequentially compares the first error detection field with the second error detection field for each data element in order to determine whether the data element is corrupt.
      <br/>
      If the contents of the first error detection field does not equal the contents of the second error detection field, the data element is corrupt, otherwise, the data element is valid.
      <br/>
      A detecting mechanism also compares the first error detection field of one of the data elements with the first error detection field of another of the data elements.
      <br/>
      If the first error fi detection field of said one of the data elements equals the first error detection field of said another of the data elements, said another of the data elements is a duplicate of said one of the data elements.
      <br/>
      In any event, if a corrupt or duplicate data element is detected, a removing mechanism then removes or deletes the invalid element from the array.
    </p>
    <p num="9">These as well as other novel advantages, details, embodiments, features and objects of the present invention will be apparent to those skilled in the art from the following detailed description of the invention, the attached claims and accompanying drawings, listed hereinbelow, which are useful in explaining the invention.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="10">
      In the text which follows and in the drawings, wherein similar reference numerals denote similar elements throughout the several views thereof, the present invention is explained with reference to illustrative embodiments in which:
      <br/>
      FIGS. 1A, 2A, 3A and 4A depict the normal contents of data elements in an array;
      <br/>
      FIG. 1B depicts the contents of data elements in an array after an interruption of the data element insertion process;
      <br/>
      FIG. 2B shows the contents of data elements in an array after an interruption of the data element copying process;
      <br/>
      FIG. 3B illustrates the contents of data elements in an array after an interruption of the data element sorting process;
      <br/>
      FIG. 4B depicts the contents of data elements in an array wherein the deletion process was interrupted;
      <br/>
      FIG. 5 illustrates the proposed structural modification to existing data elements in the preferred embodiment of the present invention;
      <br/>
      FIG. 6 illustrates how the preferred embodiment of the present invention detects element copy failures;
      <br/>
      FIG. 7 illustrates how the preferred embodiment of the present invention detects erroneous duplicative elements within the array.
      <br/>
      FIG. 8 is a flow chart illustrating the preferred method by which processes using the present invention traverse the sorted array;
      <br/>
      FIG. 9 is a flow chart depicting the preferred method by which processes using the present invention insert data elements into the sorted array;
      <br/>
      FIG. 10 is a flow chart illustrating the preferred method by which processes using the present invention delete data elements from the sorted array;
      <br/>
      FIG. 11 depicts a schematic of a suitable hardware configuration for the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="11">
      For a better understanding of the present invention, reference may be had to the following detailed description taken in conjunction with the appended claims and accompanying drawings.
      <br/>
      In essence, the present invention enables any process which uses an array to check for corruption of array data elements and unintentional duplication of array data elements.
      <br/>
      Corruption of array data elements is determined by comparing the two error detection fields (i.e. Cookie1 and Cookie2) within each data element.
      <br/>
      Duplication of a data element is determined by comparing the Cookie1 error detection field of the data element to the Cookie1 error detection field of another data element.
    </p>
    <p num="12">
      As illustrated in FIG. 1, a sorted array is a data structure containing sorted groups of data, such as numbers and/or characters.
      <br/>
      The groups of data are commonly known as data elements (20, 30, 40, 50).
      <br/>
      Each data element includes related data items which are stored individually as fields (22, 24, 26, 32, 34, 36, 42, 44, 46, 52, 54, 56).
      <br/>
      Each field (e.g. 22) is generally associated with the other fields (24, 26) within the same data element (20).
      <br/>
      For example, a data element (20) may represent a person's fall name.
      <br/>
      In this example, one field (22) in the data element (20) would represent the person's first name, another field (24) would represent the person's middle name, and the last field (26) would represent the person's last name.
      <br/>
      Thus, in this example, the sorted array would contain data elements that identify the names of a number of different people.
      <br/>
      Within each data element, the three fields identify the person's first name, middle name, and last name.
      <br/>
      As can a be easily understood, many different types of information can be stored in data elements and fields to within stored arrays of various sizes.
    </p>
    <p num="13">
      When sorted arrays are created by computer programs, the arrays are normally allocated a fixed amount of amount of memory in which to store data.
      <br/>
      This allocated memory is broken down into two portions, an IN-USE portion and a FREE portion.
      <br/>
      The IN-USE portion is the memory currently being used to store valid data in the sorted array.
      <br/>
      In contrast, the FREE portion is the memory allocated to the sorted array that is not currently being used.
      <br/>
      Thus, for a computer manipulating a sorted array, the IN-USE portion contains valid data, while the FREE portion is the memory that is available for use.
    </p>
    <p num="14">
      As data is added to the sorted array, a block of memory from the FREE portion will be "transferred" to the IN-USE portion.
      <br/>
      The "transfer" of allocated memory blocks between the two memory portions is accomplished by manipulating a control element.
      <br/>
      A control element is used to identify the boundary or boundaries between the FREE and IN-USE portions.
      <br/>
      Normally, the control element includes an index which "points" to a valid data element (20, 30, 40, 50) in the sorted array.
      <br/>
      Because data elements (20, 30, 40, 50) are stored sequentially in memory, the index can be incremented or decremented respectively to traverse the entire sorted array.
    </p>
    <p num="15">
      When new data is added to the sorted array, the array will create a new data element to contain the newly entered data.
      <br/>
      Before the new data is added to the sorted array, an unused portion of memory must be moved from the FREE to IN-USE portion by adjusting the control element.
      <br/>
      Once a memory location is transferred to the IN-USE portion, the new data element will be "inserted" into the sorted array.
      <br/>
      Usually, the sorted array will be re-sorted to accommodate the insertion of the new data element.
      <br/>
      From the point in time when the memory is transferred from the FREE portion to the IN-USE portion until the sorted array has been re-sorted, an interruption in the insertion/sorting process can result in one of three possible errors.
    </p>
    <p num="16">
      FIGS. 1A and 1B depict the first possible error.
      <br/>
      The data elements (20, 30, 40, 50) and their contents (i.e. Data-22, Data-24, Data-26, Data-32, etc.) in the sorted array are shown before insertion in FIG. 1A, and also after the insertion process has been interrupted in FIG. 1B. As can be seen in FIG. 1A, the order of the data elements (20,30,40,50) is sorted in ascending numerical order.
      <br/>
      When an interruption occurs during the insertion process, the newly added data element (100) will contain corrupt data (102, 104, 106).
    </p>
    <p num="17">
      FIGS. 2A and 2B depict the second possible error.
      <br/>
      The data elements (20, 30, 40, 50, 60) and their contents (i.e. Data-22, Data-24, Data-26, Data-32, etc.) in the sorted array are shown before an interruption of the data element copying process (FIG. 2A), and also after the copying process has been interrupted (FIG. 2B).
      <br/>
      An interruption during the copying process can cause corruption of a data element (200).
      <br/>
      The interruption can also cause an unintentional duplication of data elements (not shown) or of fields within data elements (56, 206).
      <br/>
      As shown in FIG. 2B, data element 206 is corrupt and is a partial duplicate of data element 56.
    </p>
    <p num="18">
      FIGS. 3A and 3B depict the third possible error.
      <br/>
      When an interruption occurs after the copying process has finished (FIG. 3A), but before the resorting process is complete, a duplicate data element is erroneously created.
      <br/>
      As can be seen in FIG. 3B, data element (40) is an exact duplicate of data element (300).
    </p>
    <p num="19">
      Similarly, deletion of a data element from a sorted array requires both a resorting of the array as well as a reallocation of memory.
      <br/>
      When a data element is deleted, the memory used by the deleted data element must be moved from the IN-USE portion back to the FREE portion.
      <br/>
      In addition, the array usually must be resorted to adjust for the missing data element.
      <br/>
      From the point in time when the delete operation commences until the point where the boundary between the IN-USE and FREE portions of the array is updated to reflect the deletion, an interruption of the sorting/deletion process can also result in one of three possible errors:
    </p>
    <p num="20">
      The first possible error of this type is depicted in FIGS. 4A and 4B. FIG. 4A shows the data elements (20, 30, 40, 50, 60) in a stored array before any process has been performed.
      <br/>
      FIG. 4B shows the contents (e.g. Data-22, Data-24, Data-26, etc.) of data elements (20, 30, 40, 50, 60) in a sorted array when the deletion process is interrupted before the deletion process has commenced.
      <br/>
      For example, if data element (40) in FIG. 4A was to be deleted, and the deletion process was interrupted before the process started, data element (40) would not be deleted (See FIG. 4B).
      <br/>
      Consequently, data element (40) would still be present in the sorted array (See FIG. 4B), and the computer program would be under the erroneous assumption that data element (40) contained valid data, despite that fact data element (40) should have been deleted.
    </p>
    <p num="21">
      Because the deletion process also uses the copying function, copying errors can also occur during deletion.
      <br/>
      As previously discussed, FIG. 2B illustrates the contents (e.g. Data-22, Data-24, Data-26, etc.) of the data elements (20, 30, 40, 50) in a sorted array after an interruption of the data element copying process.
      <br/>
      Similarly, because the deletion function also uses a sorting process, sorting errors can also occur during deletion.
      <br/>
      Also a previously discussed, FIG. 3B shows the contents (e.g. Data-22, Data-24, Data-26, etc.) of data elements (20, 30, 40, 50) in an array after an interruption of the data sorting process.
    </p>
    <p num="22">
      In order to detect the above-identified error conditions, the audit mechanism of the present invention was developed.
      <br/>
      In particular, the audit mechanism of the present invention detects error conditions 1 through 3 of the insertion process and errors 2 and 3 of the deletion process.
      <br/>
      As illustrated in FIG. 5, this detection is accomplished by the addition of two "audit," or error detection, fields (502, 510) to each data element (e.g. 20) in an array.
      <br/>
      In the present invention, the error detection fields (502,510) are called Cookie1 and Cookie2; however, any other label could certainly be used.
      <br/>
      In the preferred embodiment, Cookie1 is located at the "top" of each data element (500) in field (502), and Cookie2 is located at the "bottom" of each data element (500) in field (510).
      <br/>
      In an alternate embodiment, the quantity and locations of the error detection fields (502, 510) may be changed (not shown), so long as one of the cookies corresponds to when a copy function is started and another cookie corresponds to when a copy function is completed.
    </p>
    <p num="23">
      In general, Cookie1 and Cookie2 (502, 510) represent the boundaries of memory locations associated with the fields (504, 506, 508) of each data element (500) in the sorted array.
      <br/>
      Thus, the data contained within in each individual data element (500) is stored between these two memory locations.
      <br/>
      As illustrated, data fields (504, 506, 508) are located between the two cookie fields (500, 510).
    </p>
    <p num="24">
      In addition to the two error detection fields (502, 510) located in each data element (500), the present invention also uses a global control variable called SysCookie.
      <br/>
      SysCookie is used to generate a unique value that is stored in the Cookie1 and Cookie2 fields (502, 510) for each given data element (500).
      <br/>
      The value generated by SysCookie that is stored in Cookie1 and Cookie2 (502, 510) is unique for each data element.
      <br/>
      In other words, no two valid data elements should have the same value stored in their respective Cookie I fields (502).
      <br/>
      So long as the contents of the Cookie1 and Cookie2 fields (502, 510) are equal for a given data element (500), the data element (500) contains valid data.
      <br/>
      If the Cookie1 and Cookie2 fields (502, 510) are not equal, the data element (500) is corrupt.
      <br/>
      Similarly, if the Cookie1 field (502) of two different data elements are equal, one of the data elements is a duplicate of the other data element, because each data element should have an unique (i.e. different) value in its Cookie1 field (502).
    </p>
    <p num="25">
      Any computer program capable of generating unique values can be used as SysCookie.
      <br/>
      In an alternate embodiment, a random number generating program could also be used as SysCookie.
      <br/>
      In any event, the range of numbers or values generated by SysCookie should be sufficiently large such that the probability of a given value appearing in more than one data element of the IN-USE portion of the array is statistically insignificant or otherwise significantly reduced.
      <br/>
      In the preferred embodiment, the value of SysCookie is incremented each time a data element (500) is inserted into the stored array.
      <br/>
      Although SysCookie is preferably incremented by a value of one, and any other incrementation value can certainly be used in an alternate embodiment.
      <br/>
      In any event, the same value that is generated by SysCookie is used in both the Cookie1 and Cookie2 fields (502, 510).
      <br/>
      According to the present invention, data element (500) is presumed to be valid and not corrupt, so long as the Cookie1 and Cookie2 fields (502, 510) contain the same value.
    </p>
    <p num="26">
      FIG. 8 shows a flow chart of the preferred method by which processes using the present invention traverses a sorted array.
      <br/>
      This traversal method detects and corrects the above-identified insertion and deletion error conditions that cause corruption and erroneous duplication of data elements.
    </p>
    <p num="27">
      The traversal method begins by establishing a variable N which corresponds to the control element index of the sorted array to be audited.
      <br/>
      The type and size of this variable is not restricted and can fluctuate with different types and sizes of indices for sorted arrays.
      <br/>
      Variable N is given the same value as the index pointing to the first element in the sorted array (S800).
      <br/>
      In other embodiments, variable N can be initially set to any location or data element in the array, thereby enabling a very long array of data elements to conduct self-audits in portions of the array without having to conduct an audit of the entire array.
    </p>
    <p num="28">
      After initializing variable N, the traversal process initiates a looping function which sequentially examines the entire portion of the sorted array to be audited.
      <br/>
      The looping function begins by determining whether the auditing process is at the end of the portion of the array to be audited this is accomplished by checking whether the value of variable N is greater than the value of the last element in the array (S802).
      <br/>
      If the value of variable N is greater than the value of the last data element, the traversal process is complete and the process terminates.
      <br/>
      This step (S802) is preferably performed first in order to ensure that the traversal process never wastes time auditing data in the FREE portion of memory.
      <br/>
      Thus, the auditing process is restricted to checking data in the IN-USE portion.
      <br/>
      In other embodiments, this step may be substituted by adding another field in the data element that contains a flag which would signal when the audit process is complete.
      <br/>
      This flag field would allow for multiple audits of the sorted array or allow an audit to begin in the middle of the array, but still audit the entire array.
    </p>
    <p num="29">
      If the value of variable N is not greater the last element in the sorted array, the traversal method determines whether the Nth data element's Cookie1 value is the same as (N+1)th data element's Cookie1 value (S804).
      <br/>
      This step determines whether adjacent data elements are duplicate (i.e. erroneous).
      <br/>
      In other embodiments, the Nth data element's Cookie1 value can be compared to any other data element's Cookie1 value, which may not necessarily by the (N+1)th data element.
    </p>
    <p num="30">
      FIG. 7 illustrates the detection of identical data elements that are adjacent.
      <br/>
      As previously mentioned, the erroneous duplication of data elements can be caused by interruptions in the sorting process during both the insertion and deletion of data elements.
      <br/>
      As illustrated in FIGS. 2 and 3, when a copying or resorting process is interrupted, data elements containing identical data are created in the sorted array.
      <br/>
      Because no two data elements within the same sorted array can have the same Cookie1 value, data elements (700, 710, 720) with matching Cookie1 values (702, 712) are duplicates.
      <br/>
      Since data element (700) is a duplicate of data element (710), one of the data elements (700, 710) must be deleted.
    </p>
    <p num="31">
      FIG. 6 illustrates the detection of a corrupt data element.
      <br/>
      As mentioned previously, data elements (e.g. 600) must contain matching Cookie1 (602) and Cookie2 (604) audit fields in order to be valid.
      <br/>
      If the two cookie fields (602, 604) do not match, a copying process was interrupted and the data is corrupt.
      <br/>
      In the example of FIG. 6, data element (600) is valid because the Cookie1 (602) value of 2 equals the Cookie2 (604) value of 2.
      <br/>
      Similarly, data element (620) is valid because the Cookie1 (622) value of 4 equals the Cookie2 (624) value of 4.
      <br/>
      In contrast, data element (610) is corrupt because the Cookie1 (612) value of 2 does not equal the Cookie2 (614) value of 4.
    </p>
    <p num="32">
      Thus, if the two cookie values do not match in step (S810), the Nth data element is corrupt.
      <br/>
      If corrupt, the Nth data element is deleted from the sorted array (S812).
      <br/>
      The value of variable N is then incremented to point to the next data element in the array and continue the traversing and/or auditing process (S814).
    </p>
    <p num="33">
      In situations, such as depicted in FIGS. 6 and 7, where the Cookie1 (602, 702) value of the Nth data element (600, 700) is equal to the Cookie1 (612, 712) value of the (N+1)th data element (610, 710) (S806), the (N+1)th data element (610, 710) is deleted (S808).
      <br/>
      This is due to the fact that the Nth data element (610, 710) is either corrupt (612) or a duplicate (712).
      <br/>
      After deletion (S808), the value of N is the incremented to point to the next data element (e.g. 620, 720) in the assorted array (S814).
    </p>
    <p num="34">As previously mentioned, the traversing and/or auditing process of the present invention will continue looping and checking for corrupt and duplicate data elements until the value of variable N has been incremented past the pointer to the last data element in the sorted array.</p>
    <p num="35">
      Because the self-auditing method of this invention uses the cookie fields for comparison purposes, special processes are used to insert and delete data elements.
      <br/>
      FIG. 9 shows a flow chart of the preferred method by which processes using the present invention insert data elements into the sorted array.
    </p>
    <p num="36">
      As can be seen in FIG. 9, the insertion method begins by establishing a variable N which is the same type and size of variable as the index to the sorted array.
      <br/>
      The type and size of this variable is not restricted and can fluctuate with different types and sizes of arrays.
    </p>
    <p num="37">
      Variable N is initially assigned the same value as the index to the last element in the sorted array (S900).
      <br/>
      In essence, this places the newly inserted data element at the end of the sorted array.
      <br/>
      After initializing variable N, the insertion process will begin a looping function which identifies an appropriate location in the sorted array for the new data element.
      <br/>
      This looping function begins by copying the Nth data element's data to the memory location of the (N+1)th data element (S902).
      <br/>
      The copying of the Nth data element's data will necessarily include the copying of cookie values, Cookie1 and Cookie2.
      <br/>
      If a slot for the new member is found, the insertion function will exit the looping function and continue with the insertion process (S904).
      <br/>
      However, if an appropriate slot is not found in the sorted array, the value of variable N will be decreased by one (S906) and the process will return to step (S902).
      <br/>
      Steps (S902, S904, S906) will continue copying the Nth data element's data to the (N+1)th data element until the appropriate slot is found for the new data element.
      <br/>
      In the preferred method, the looping function uses a bubble sort routine that determines the appropriate location is for the new data element.
      <br/>
      Although the bubble sort method is preferred, other sort routines can certainly be used.
    </p>
    <p num="38">
      Once the appropriate memory slot is found for the new data element and the looping function a is broken, the next step is to update the global control variable, SysCookie (S908), which is incremented to reflect the insertion of a new data element into the array.
      <br/>
      After SysCookie has been updated, the value of SysCookie will be copied to the new data element's Cookie1 field (S910).
      <br/>
      Because the previously mentioned looping function stopped with the new slot being pointed to by variable N, the new data element will then be copied to its new slot located at N (S912).
      <br/>
      After the new data element is copied, the value of SysCookie will also be copied to the new data element's Cookie2 field (S914).
    </p>
    <p num="39">
      After SysCookie has been copied to the two cookie values of the new data element, Cookie1 and Cookie2, the insertion process is complete.
      <br/>
      In other embodiments, the copying of cookie values may entail a looping function to copy multiple cookie values if there are more than two cookie audit fields in the data element.
    </p>
    <p num="40">
      As depicted in FIG. 10, the present invention also uses a special deletion process.
      <br/>
      More particularly, FIG. 10 shows a flow chart of the preferred method by which processes using the present invention deletes data elements from the sorted array.
    </p>
    <p num="41">
      The deletion method begins by establishing a variable N which is the same type and size of variable as the index to the sorted array.
      <br/>
      The type and size of this variable is not restricted and can fluctuate with different types of indexes and sizes of arrays.
      <br/>
      Variable N is assigned the same value as the index, or pointer, to the data element in the sorted array to be deleted (S 1000).
      <br/>
      In short, the deletion method uses a looping process to copy over the data element to be deleted.
      <br/>
      After variable N is initialized, the loop begins by copying the data of the (N+1)th data element to the Nth data element (S1002).
      <br/>
      The copying of data includes copying of both cookie values, Cookie1 and Cookie2.
    </p>
    <p num="42">
      After the (N+1)th data element is copied to the Nth data element, the next step is to determine if the variable N is at the last element in the sorted array (S1004).
      <br/>
      If variable N is not at the last element of the array, the value of N will be incremented (S 1006).
      <br/>
      After being incremented, the looping process will be begin again (S 1002) and continue until the process has reached the end of the array.
    </p>
    <p num="43">
      Once the end of the array is reached, the Cookie1 field of the (N+1)th element is invalidated (S1007).
      <br/>
      In other words, when the data element is moved from the IN-USE portion of the array to the FREE portion of the array, the data element's Cookie1 field is invalidated (S 1007).
      <br/>
      Thus, when a new element is added into the IN-USE portion of the array, it does not contain valid data until the new data is copied into it.
      <br/>
      Next, the value of variable N is decremented (S1008), because the sorted array contains one less data element.
      <br/>
      The continuous loop described in steps (S1002-S1006) shifts the data elements down by one which allows the last data element to be deleted by decreasing variable N (i.e. the array counter).
      <br/>
      After decrementing variable N, the deletion process is complete.
    </p>
    <p num="44">
      This invention may be implemented in a variety of hardware systems that use sorted arrays.
      <br/>
      For example, one such system is Lucent Technologies Inc.'s SN-CP processor of the GlobeView-2000.RTM. Switch. The SN-CP processor of the GlobeView-2000.RTM. Switch maintains a queue of maintenance requests.
      <br/>
      This maintenance queue is implemented as an array.
      <br/>
      Specific hardware maintenance concerns require this queue to be sorted on a priority basis causing the queue to inherit all of the possible errors associated with sorting data within an array.
      <br/>
      Any process running on the SN-CP processor of the GlobeView-2000 Switch has a potential for being terminated under fault conditions.
      <br/>
      The information in the maintenance queue is important enough that it is preserved over process terminations and is inherited by the restarted system process.
      <br/>
      The nature of maintenance requests is such that it is critical to system performance that an "invalid" maintenance request is not performed, thus a mechanism to guarantee the validity of data within the queue is required.
      <br/>
      In general, any microprocessor (1100), or other suitable device, capable of comparing cookie values and manipulating an array stored in memory (1102) can be used in conjunction with the method of the present invention.
      <br/>
      A schematic of a suitable hardware configuration is shown in FIG. 11.
    </p>
    <p num="45">
      In summary, the present invention uses and compares two error detection fields (i.e. Cookie1 and Cookie2) in each data element to check for and eliminate corrupt and duplicate data elements.
      <br/>
      In the preferred embodiment, the data elements of the array are stored in physical memory implemented as random access memory (RAM), however, any other type of memory could be used (e.g. magnetic tape, magneto-optical media, other electromagnetic media such as a computer hard drive, etc.) In this invention, a sorted array conducts a self-audit by using traversal, insertion and deletion processes.
      <br/>
      By requiring each data element to have matching numbers in both of its error detection fields and by requiring each data element to use a unique number in its error detection fields, the traversal, insertion and deletion processes can detect and correct errors that occur when a process is interrupted.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7.</claim-text>
      <claim-text>A method of auditing an array of data elements, each of said data elements having a first error detection field and a second error detection field, said method of auditing comprising the steps of: establishing an index which points to one of said data elements in said array; comparing the first error detection field of said one of said data elements to the second error detection field of said one of said data elements; deleting said one of said data elements from the array if the first error detection field of said one of said data elements does not equal the second error detection field of said one of said data elements; incrementing the index to another of said data elements if the first error detection field of said one of said data elements equals the second error detection field of said one of said data elements; comparing the first error detection field of said one of said data elements to the first error detection field of said another of said data elements;</claim-text>
      <claim-text>and deleting said another of said data elements from the array if the first error detection field of said one of said data elements equals said the first error detection field of said another of said data elements.</claim-text>
      <claim-text>1. An error detection system for a sorted array of data elements comprising:</claim-text>
      <claim-text>means for storing said sorted array of said data elements; means for determining whether one of said data elements is an invalid element, said determining means identifying said invalid element during a traversal of said sorted array;</claim-text>
      <claim-text>and means for removing said invalid element from said sorted array of said data elements after said invalid element is detected.</claim-text>
      <claim-text>2. The error detection system of claim 1 wherein said means for determining and said means for removing is a microprocessor.</claim-text>
      <claim-text>3. The error detection system of claim 1 wherein said means for storing is random access memory.</claim-text>
      <claim-text>4. The error detection system of claim 1 wherein each of said data elements includes a first error detection field and a second error detection field, whereby said means for determining compares the first error detection field of one of said data elements with the second error detection field of said one of said data elements in order to determine whether said one of said data elements is corrupt, and said means for determining compares the first error detection field of said one of said data elements with the first error detection field of another of said data elements in order to determine whether said another of said data elements is a duplicate of said one of said data elements.</claim-text>
      <claim-text>5. A method of auditing an array of data elements, each of said data elements having a first error detection field and a second error detection field, said method of auditing comprising the steps of: comparing the first error detection field of one of said data elements to the second error detection field of said one of said data elements;</claim-text>
      <claim-text>and processing said one of said data elements from the array if the first error detection field of said one of said data elements does not equal the second error detection field of said one of said data elements.</claim-text>
      <claim-text>6. The method of auditing of claim 5 further comprising the steps of: comparing the first error detection field of said one of said data elements to the first error detection field of another of said data elements;</claim-text>
      <claim-text>and deleting said another of said data elements from the array if the first error detection field of said one of said data elements equals said the first error detection field of said another of said data elements.</claim-text>
    </claim>
  </claims>
</questel-patent-document>