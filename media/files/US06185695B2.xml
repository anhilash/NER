<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185695B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185695</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185695</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="22016622" extended-family-id="3890102">
      <document-id>
        <country>US</country>
        <doc-number>09058406</doc-number>
        <kind>A</kind>
        <date>19980409</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09058406</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>4022985</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>5840698</doc-number>
        <kind>A</kind>
        <date>19980409</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09058406</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  15/177       20060101AFI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>15</main-group>
        <subgroup>177</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F  11/14        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>14</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>714004110</text>
        <class>714</class>
        <subclass>004110</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>709221000</text>
        <class>709</class>
        <subclass>221000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>709226000</text>
        <class>709</class>
        <subclass>226000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>709229000</text>
        <class>709</class>
        <subclass>229000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>714015000</text>
        <class>714</class>
        <subclass>015000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>714E11134</text>
        <class>714</class>
        <subclass>E11134</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-011/14A8C</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>011</main-group>
        <subgroup>14A8C</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/2097</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>2097</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20150306</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/2025</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>2025</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20150306</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/2028</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>2028</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20150306</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/2041</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>2041</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20150306</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/2046</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>2046</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20150306</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>25</number-of-claims>
    <exemplary-claim>8</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>8</number-of-drawing-sheets>
      <number-of-figures>10</number-of-figures>
      <image-key data-format="questel">US6185695</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and apparatus for transparent server failover for highly available objects</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>MAJOR DREW, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5157663</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5157663</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>DEVARAKONDA MURTHY V, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5566297</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5566297</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>KASHIMOTO SHUJI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5666479</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5666479</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>STIFFLER JACK J</text>
          <document-id>
            <country>US</country>
            <doc-number>5737514</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5737514</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>BHANOT PRADEEP, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5796934</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5796934</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>NELSON MICHAEL N</text>
          <document-id>
            <country>US</country>
            <doc-number>5819019</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5819019</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>GLENN II FLETCHER M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5852724</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5852724</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>HIRAYAMA HIDEAKI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5907673</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5907673</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>STIFFLER JACK J</text>
          <document-id>
            <country>US</country>
            <doc-number>5958070</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5958070</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>ATTANASIO CLEMENT RICHARD, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5668943</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5668943</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>KAPOOR SANDHYA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5682534</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5682534</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>SUN MICROSYSTEMS INC</text>
          <document-id>
            <country>EP</country>
            <doc-number>0817024</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-817024</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Thomas Becker,"Transparent Service Reconfiguration After Node Failure," Configurable Distributed Systems, pp. 212-223, 1992.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Chin et al, "Transparency in a Replicated Network File System,"EUROMICRO-96, Beyond 2000: Hardware and Software Desing Strategies; Proceedings of the 22nd EUROMICRO Conference, pp. 285-291, 1995.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Sun Microsystems, Inc.</orgname>
            <address>
              <address-1>Palo Alto, CA, US</address-1>
              <city>Palo Alto</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>SUN MICROSYSTEMS</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Murphy, Declan J.</name>
            <address>
              <address-1>San Francisco, CA, US</address-1>
              <city>San Francisco</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Talluri, Madhusudhan</name>
            <address>
              <address-1>Fremont, CA, US</address-1>
              <city>Fremont</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Matena, Vladimir</name>
            <address>
              <address-1>Redwood City, CA, US</address-1>
              <city>Redwood City</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Khalidi, Yousef A.</name>
            <address>
              <address-1>Cupertino, CA, US</address-1>
              <city>Cupertino</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="5">
          <addressbook lang="en">
            <name>Bernabeu-Auban, Jose M.</name>
            <address>
              <address-1>Valencia, ES</address-1>
              <city>Valencia</city>
              <country>ES</country>
            </address>
          </addressbook>
          <nationality>
            <country>ES</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="6">
          <addressbook lang="en">
            <name>Tucker, Andrew G.</name>
            <address>
              <address-1>Menlo Park, CA, US</address-1>
              <city>Menlo Park</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Park &amp; Vaughan</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Beausoliel, Jr., Robert W.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      One embodiment of the present invention provides a method and an apparatus that facilitates transparent failovers from a primary copy of an object on a first server to a secondary copy of the object on a second server when the first server fails, or otherwise becomes unresponsive.
      <br/>
      The method includes detecting the failure of the first server; selecting the second server; and reconfiguring the second server to act as a new primary server for the object.
      <br/>
      Additionally, the method includes transparently retrying uncompleted invocations to the object to the second server, without requiring explicit retry commands from a client application program.
      <br/>
      A variation on this embodiment further includes winding up active invocations to the object before reconfiguring the second server to act as the new primary server.
      <br/>
      This winding up process may include causing invocations to unresponsive nodes to unblock and complete.
      <br/>
      Another variation includes blocking new invocations to the object after detecting the failure of the first server, and unblocking these new invocations after reconfiguring the second server to act as the new primary server.
      <br/>
      Hence, the present invention can greatly simplify programming of client application programs for highly available systems.
      <br/>
      It also makes it possible to use a client application program written for a nonhighly available system in a highly available system.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND</heading>
    <p num="1">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="2">The present invention relates generally to distributed object operating systems, and more particularly to a system and method that supports transparent failover from a primary server to a secondary server during accesses to a remote object.</p>
    <p num="3">2. Related Art</p>
    <p num="4">
      As computer networks are increasingly used to link computer systems together, distributed operating systems have been developed to control interactions between computer systems across a computer network.
      <br/>
      Some distributed operating systems allow client computer systems to access resources on server computer systems.
      <br/>
      For example, a client computer system may be able to access information contained in a database on a server computer system.
      <br/>
      When the server fails, it is desirable for the distributed operating system to automatically recover from this failure.
      <br/>
      Distributed computer systems with distributed operating systems possessing an ability to recover from such server failures are referred to as "highly available systems." Data objects stored on such highly available systems are referred to as "highly available data objects."
    </p>
    <p num="5">
      For a highly available system to function properly, the highly available system must be able to detect a server failure and to reconfigure itself so accesses to objects on the failed server are redirected to backup copies on other servers.
      <br/>
      This process of switching over to a backup copy on another server is referred to as a "failover."
    </p>
    <p num="6">
      Existing client-server systems typically rely on the client application program to explicitly detect and recover from server failures.
      <br/>
      For example, a client application program typically includes code that explicitly specifies timeout and retry procedures.
      <br/>
      This additional code makes client application programming more complex and tedious.
      <br/>
      It also makes client application programs particularly hard to test and debug due to the difficulty in systematically reproducing the myriad of possible asynchronous interactions between client and server computing systems.
      <br/>
      Furthermore, each client application program must provide such failover code for every access to a highly available object from a server.
    </p>
    <p num="7">
      Therefore, what is needed is a distributed-object operating system that recovers from server failures in a manner transparent to client application programs.
      <br/>
      Such a distributed system will allow client application programs to be written without the burden of providing and testing failure detection and retry code.
    </p>
    <heading>SUMMARY</heading>
    <p num="8">
      One embodiment of the present invention provides a method and an apparatus that facilitates transparent failovers from a primary copy of an object on a first server to a secondary copy of the object on a second server when the first server fails, or otherwise becomes unresponsive.
      <br/>
      The method includes detecting the failure of the first server; selecting the second server; and reconfiguring the second server to act as a new primary server for the object.
      <br/>
      Additionally, the method includes transparently retrying uncompleted invocations to the object to the second server, without explicit retry commands from a client application program.
      <br/>
      A variation on this embodiment further includes winding up active invocations to the object before reconfiguring the second server to act as the new primary server.
      <br/>
      This winding up process can include causing invocations to unresponsive nodes to unblock and complete.
      <br/>
      Another variation further includes blocking new invocations to the object after detecting the failure of the first server, and unblocking these new invocations after reconfiguring the second server to act as the new primary server.
      <br/>
      Hence, the present invention can greatly simplify programming of client application programs for highly available systems.
      <br/>
      It also makes it possible to use a client application program written for a nonhighly available system in a highly available system.
    </p>
    <p num="9">
      Still other embodiments of the present invention will become readily apparent to those skilled in the art from the following detailed description, wherein is shown and described only the embodiments for the invention by way of illustration of the best modes contemplated for carrying out the invention.
      <br/>
      As will be realized, the invention is capable of other and different embodiments and several of its details are capable of modifications in various obvious respects, all without departing from the spirit and scope of the present invention.
      <br/>
      Accordingly, the drawings and detailed description are to be regarded as illustrative in nature and not as restrictive.
    </p>
    <heading>DESCRIPTION OF THE FIGURES</heading>
    <p num="10">
      FIG. 1 is a diagram illustrating a distributed computing system including a plurality of nodes 102, 106, 110 and 114, which can functions as either client and/or server systems in accordance with an embodiment of the present invention.
      <br/>
      FIG. 2A illustrates prior art client-server interactions involved in an invocation to an object 206 in a non-highly available system.
      <br/>
      FIG. 2B illustrates client-server interactions involved in an invocation to a highly available object 206 on a highly available server 211 in accordance with an embodiment of the present invention.
      <br/>
      FIG. 3 illustrates various system layers involved in communications between client 200, primary server 212 and secondary server 213 in accordance with an embodiment of the present invention.
      <br/>
      FIG. 4 illustrates some of the data structures involved in invocations to remote objects in accordance with an embodiment of the present invention.
      <br/>
      FIG. 5 illustrates how replica manager 500 keeps track of primary and secondary servers for various services in accordance with an embodiment of the present invention.
      <br/>
      FIG. 6 is a flow chart illustrating some of the operations involved in creating an object in accordance with an embodiment of the present invention.
      <br/>
      FIG. 7 is a flow chart illustrating some of the operations involved in creating an object on a secondary server in accordance with an embodiment of the present invention.
      <br/>
      FIG. 8 is a flow chart illustrating some of the operations involved in invoking a highly available object in accordance with an embodiment of the present invention.
      <br/>
      FIG. 9 is a flow chart illustrating some of the operations involved in performing a failover for an object from a primary to a secondary server in accordance with an embodiment of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE INVENTION</heading>
    <p num="11">Related Applications</p>
    <p num="12">
      This application is related to the following commonly-assigned U.S. patent applications: Ser.
      <br/>
      No. 08/829,156 to Matena, et al., filed Mar. 31, 1997, pending; Ser.
      <br/>
      No. 08/884,978 to Murphy, et al., filed Jun. 30, 1997, pending; Ser.
      <br/>
      No. 08/879,150 to Tucker, et al., filed Jun. 19, 1997, pending; and Ser.
      <br/>
      No. 08/879,151 to Tucker, et al., filed Jun. 19, 1997, pending; the disclosures of which are incorporated herein by reference for all purposes as set forth in full.
    </p>
    <p num="13">Definitions</p>
    <p num="14">Failover--The process of switching from a primary copy of an object on a first server to secondary copy of the object on a second server when the first server fails.</p>
    <p num="15">Failure of a Server--a condition that occurs when a server fails to respond to a request from a client in a timely manner.</p>
    <p num="16">Object--any data object, or more narrowly an object defined within an object-oriented programming environment.</p>
    <p num="17">Replica Manager--a process or mechanism that keep track of the various primary and secondary copies of an object on various servers.</p>
    <p num="18">Retrying Transparently--retrying an invocation to an object without explicit retrying by the client application program.</p>
    <p num="19">Transparent Failover--A failover that occurs automatically, without explicit failure detection and retry commands from a client application program.</p>
    <p num="20">
      Winding up Invocations to an Object--waiting for any active invocations to the object to complete.
      <br/>
      This may additionally include tearing down data structures associated with invocations to the object.
    </p>
    <p num="21">Description of Distributed System</p>
    <p num="22">
      FIG. 1 is a diagram illustrating a distributed computing system including a plurality of nodes 102, 106, 110 and 114, which can function as either client systems and/or server systems in accordance with an embodiment of the present invention.
      <br/>
      The system illustrated in FIG. 1 includes network 100, which is coupled to nodes 102, 102, 106, 110 and 114.
      <br/>
      Network 100 generally refers to any type of wire or wireless link between computers, including, but not limited to, a local area network, a wide area network, or a combination of networks.
      <br/>
      Nodes 102, 106, 110 and 114 use network 100 to communicate with each other.
      <br/>
      Each of nodes 104, 106, 110 ad 114 represent independent client/server computer systems, wherein each node can function as a client and/or a server computer system.
      <br/>
      A client computer system is associated with a node that invokes an object.
      <br/>
      A server computer system is associated with a node that stores the object's methods.
      <br/>
      In certain cases, the client and server for an object exist on the same node.
      <br/>
      In other cases, the client and server will exist on distinct nodes.
    </p>
    <p num="23">
      FIG. 1 includes storage units 118 and 120.
      <br/>
      Nodes 102 and 104 are coupled to storage unit 118.
      <br/>
      Nodes 110 and 114 are coupled to storage unit 120.
      <br/>
      Storage units 118 and 120 include non-volatile storage for data from nodes 102, 106, 110 and 114.
    </p>
    <p num="24">
      Each node 102, 106, 110 and 116 has one or more domains.
      <br/>
      A domain is defined to be a process with its own address space.
      <br/>
      A domain can have multiple threads of execution, which can execute user or kernel application procedures.
      <br/>
      A kernel domain is associated with the operating system and a user domain is associated with a process other than the operating system.
      <br/>
      User domains typically execute one or more user application procedures.
      <br/>
      Each domain has one or more objects associated with it.
    </p>
    <p num="25">
      In one embodiment, the operating system is the Solaris MC operating system, which is a product of Sun Microsystems, Inc. of Palo Alto, Calif.
      <br/>
      The Solaris MC operating system is a UNIX-based operating system.
      <br/>
      Hence, in describing the present technology, UNIX terminology and concepts are frequently used.
      <br/>
      However, this usage is for purposes of illustration and is not to be construed as limiting the invention to this particular operating system.
    </p>
    <p num="26">
      Each thread can request the execution of an object (i.e., object's method).
      <br/>
      The location of the object is transparent to the thread.
      <br/>
      The object can reside in one of several locations.
      <br/>
      It can reside within the same domain as the requesting thread, in a different domain but within the same node as the requesting thread, or in the domain of a remote node.
    </p>
    <p num="27">
      A kernel domain has multiple threads that can execute kernel applications.
      <br/>
      Each kernel domain can have one or more kernel objects associated with it.
      <br/>
      A kernel object can be invoked by a thread within its domain or by a thread in a domain in another node.
    </p>
    <p num="28">
      The execution of a method for an object within the domain of the requesting application is treated as a local procedure call.
      <br/>
      The local procedure call is typically a function or subroutine call that transfers control from the application to the object's method, and eventually returns control to the application.
      <br/>
      The arguments associated with the object are passed through the local procedure call.
    </p>
    <p num="29">
      The execution of a method for an object that resides in a remote domain is treated as a remote procedure call.
      <br/>
      The remote procedure call is handled by the object request broker (ORB), which is a distributed mechanism for handling remote procedure calls.
      <br/>
      Thus, the ORB invokes methods for objects residing in different domains from the requesting application.
      <br/>
      These remote objects can be situated in the same node as the requesting application, or in a different node.
    </p>
    <p num="30">Description of Client-Server Interactions</p>
    <p num="31">
      FIG. 2A illustrates prior art client-server interactions involved in an invocation to an object 206 in a non-highly available system.
      <br/>
      In this embodiment, client 200 makes a reference to object 206 on server 202.
      <br/>
      Generally, this reference is in the form of an invocation of object 206.
    </p>
    <p num="32">
      In this embodiment, client 200 performs the invocation as follows.
      <br/>
      Client 200 makes an invocation 204 to object 206 on server 202.
      <br/>
      This generates a request 208 across network 100 to server 202.
      <br/>
      In response to request 208, server 202 calls a specified function on object 206.
      <br/>
      After this function call completes, server 202 returns a reply 210 across network 100 to client 200.
      <br/>
      The object invocation 204 is now complete.
    </p>
    <p num="33">
      FIG. 2B illustrates client-server interactions involved in an invocation to a highly available object 206 on a highly available server 211 in accordance with an embodiment of the present invention.
      <br/>
      Highly available server 211 includes a primary server 212 and a secondary server 213.
      <br/>
      Primary server 212 includes a primary copy of the highly available object, and secondary server 213 includes a secondary copy of the highly available object.
      <br/>
      Consistency is maintained between primary and secondary copies of the highly available object through communications across checkpointing interface 214.
    </p>
    <p num="34">
      The client-server interactions proceed in essentially the same way as in FIG. 2A, except that highly available server 211 continues to function even if primary server 212 becomes unresponsive or otherwise fails.
      <br/>
      First, client 200 makes an invocation 204 to the object.
      <br/>
      This causes a request 208 to be generated across network 100 to primary server 212.
      <br/>
      If primary server 212 for some reason becomes unresponsive, the reply 210 fails.
      <br/>
      This indicated by the cross on FIG. 2B.
    </p>
    <p num="35">
      When a failure occurs, the failure will eventually be detected by a system process called the replica manager 500, which is described in more detail with reference to FIG. 5 below.
      <br/>
      Replica manager 500 initiates a chain of events that cause software within client 200 to automatically retry the invocation to secondary server 213.
      <br/>
      This generates a retry request 218 to secondary server 213.
      <br/>
      In response to retry request 218, server 213 calls the specified function on the secondary copy of the object 216.
      <br/>
      After the function call completes, server 213 returns a reply 220 across network 100 to client 200.
      <br/>
      The object invocation 204 is now complete.
    </p>
    <p num="36">Description of System Layers</p>
    <p num="37">
      FIG. 3 illustrates various system layers involved in communications between client 200, primary server 212 and secondary server 213 in accordance with an embodiment of the present invention.
      <br/>
      On client system 200, invocation 204 to the object is handled by a proxy that forwards the reference to replica handler 302.
      <br/>
      A replica handler, such as replica handler 302, controls the basic mechanism of object invocation and argunent passing.
      <br/>
      A replica handler controls how an object invocation is implemented, how object references are transmitted between address spaces, how object references are released, and similar object runtime operations.
    </p>
    <p num="38">
      Replica handler 302 forwards the reference to hxdoor 308.
      <br/>
      In one embodiment, this reference passing is accomplished through a function call.
      <br/>
      Hxdoor 308 is an intermediate layer interposed between replica handler 302 and client xdoor 314.
      <br/>
      The data structures underlying hxdoor 308 are described in more detail below with reference to FIG. 4.
      <br/>
      Hxdoor 308 passes the reference to client xdoor 314.
    </p>
    <p num="39">
      Client xdoor 314 forwards the reference to transport mechanism 320, which forwards the reference in the form of a request across network 100 to transport mechanism 322 on primary server 212.
      <br/>
      Within primary server 212, this request propagates upwards in the reverse order through, server xdoor 316 and hxdoor 310 to replica handler 304.
      <br/>
      Finally, replica handler 304 applies the request to the primary copy of highly available object 206 so that the invocation is performed on highly available object 206.
      <br/>
      Next, a reply is sent back along to same path to client 200.
    </p>
    <p num="40">
      The state of a secondary copy 216 of the highly available object on secondary server 213 is then updated through checkpointing interface 214.
      <br/>
      This updating process is described in more detail in a related patent, entitled "Method and System for Achieving High Availability in Networked Computer Systems," by inventor(s), Matena, et al., having Ser.
      <br/>
      No. 08/829,156, which is referenced and incorporated by reference in the related application sections above.
      <br/>
      Note that secondary server 213 includes replica handler 306, hxdoor 312, server xdoor 318 and transport mechanism 324.
      <br/>
      In the illustrated embodiment, server xdoor 318 (which appears in dashed lines) is not created until a failover occurs.
      <br/>
      In this way, creation of server xdoor 318 is delayed until it is necessary.
    </p>
    <p num="41">Description of Data Structures</p>
    <p num="42">
      FIG. 4 illustrates some of the data structures involved in invocations to remote objects in accordance with an embodiment of the present invention.
      <br/>
      Objects that are accessible by remote nodes have a xdoor 470 identified by a global xdoor identifier 440 that is used to uniquely identify the object within a particular node.
      <br/>
      In addition, each node is uniquely represented by a node identifier 442 that uniquely identifies the node within the distributed system.
      <br/>
      The global xdoor identifier 440 is coupled with the node identifier 442 to produce an identifier that uniquely identifies the object within the distributed system.
    </p>
    <p num="43">
      An application references an object utilizing a local xdoor identifier or file descriptor.
      <br/>
      In order to execute a remote object invocation, the ORB references the object using the servers file descriptor for that object.
      <br/>
      Thus, the ORB maps the client's object reference (i.e., local xdoor identifier) into the server's local xdoor identifier.
      <br/>
      This mapping is performed utilizing a number of procedures and data structures that reside in both the user and kernel domains.
    </p>
    <p num="44">
      The ORB utilizes several mechanisms to perform this mapping.
      <br/>
      The ORB includes the following procedures: handler procedures, xdoor procedures, and gateway handler procedures.
      <br/>
      The xdoor procedures reside in both the user and kernel domains.
      <br/>
      A brief description of these mechanisms is provided below with reference to FIG. 4.
    </p>
    <p num="45">
      An object is referenced by a handler procedure 422.
      <br/>
      Replica handlers 302, 304 and 406 are example of such a handler.
      <br/>
      Handler procedure 422 controls the basic mechanism of object invocation and argument passing.
      <br/>
      Handler procedure 422 controls how an object invocation is implemented, how object references are transmitted between address spaces, how object references are released, and similar object runtime operations.
      <br/>
      For local object invocations, handler 422 executes a local procedure call to the object's method 450.
    </p>
    <p num="46">
      Handler table 422 points to bxdoor table 480.
      <br/>
      Hxdoor table 480 is used by a correspond hxdoor.
      <br/>
      As mentioned above, an hxdoor is an intermediate layer between a replica handler and a xdoor that provides a level of indirection to facilitate high availability.
      <br/>
      To a replica handler, the hxdoor appears to be a xdoor.
      <br/>
      To a xdoor the hxdoor appears to be a replica handler.
    </p>
    <p num="47">
      Hxdoor table 480 includes an hxdoor ID 486, a service ID 490, a number of invocations 492 and a flag 494.
      <br/>
      The hxdoor ID identifies the particular hxdoor.
      <br/>
      The service ID 490 identifies a particular service, wherein a service is defined to be a group of objects.
      <br/>
      The number of invocations 492 keeps track of the number of uncompleted invocations currently outstanding to the service.
      <br/>
      Finally, the flag 494 indicates whether the hxdoor is on a client, a primary server or a secondary server.
    </p>
    <p num="48">
      For remote user object invocations, an object is represented in its domain by a user-level xdoor 452.
      <br/>
      A user-level xdoor 452 consists of a local xdoor identifier 453, a pointer to an appropriate handler 456, a door identifier 458, and other information.
      <br/>
      In one embodiment of the present invention, the local xdoor identifier 453 is a file descriptor.
      <br/>
      The door identifier 458 corresponds to a door representing the object and it is stored in the kernel-level door table 432.
    </p>
    <p num="49">
      A kernel-level xdoor 470 is a kernel state entity that is used to represent an object throughout the distributed system.
      <br/>
      The kernel-level xdoor 470 possibly includes a global xdoor identifier 440, handler pointers 444 (including a server handler pointer 441 and a client handler pointer 443), and a door identifier 446.
      <br/>
      Global xdoor identifier 440 is used to uniquely identify the object within the distributed system.
      <br/>
      It includes a node identifier 442 and a local xdoor identifier 447 for referring to a xdoor within a node.
      <br/>
      Door identifier 446 is used to identify the corresponding door 462.
    </p>
    <p num="50">
      There are two types of xdoors: a client xdoor and a server xdoor.
      <br/>
      Only client xdoors include a node identifier, such as node identifier 442, and only server xdoors include server handlers, such as the server hander pointed to by server handler pointer 441.
    </p>
    <p num="51">
      A door is a kernel state entity.
      <br/>
      It exists only for intra-node remote user objects (i.e., an intra-node remote user object is an object that resides in a different domain within the same node as the requesting domain).
      <br/>
      A door is represented by a file descriptor.
      <br/>
      Each user domain has a user xdoor table that stores the file descriptors of those objects accessible by threads associated with the domain.
      <br/>
      A user domain references a remote object through a file descriptor, located in the domain's user xdoor table, which is mapped into the actual door.
      <br/>
      Doors do not reside in the address space of the user accessible domains, but rather in the kernel domain.
    </p>
    <p num="52">
      The use of a file descriptor to represent a door provides a secure mechanism to control the objects that a user can invoke.
      <br/>
      A file descriptor is a protected kernel state and as such cannot be forged by a user.
      <br/>
      The possession of a file descriptor indicates that an application has permissible access to an object.
      <br/>
      The domain that generates the object becomes a server for the object and its door.
      <br/>
      The server exports object references to those applications that it wishes to have access to the object.
      <br/>
      In this manner, there is a secure mechanism to selectively control the applications that can access the objects within the distributed system.
    </p>
    <p num="53">
      An object can have a number of file descriptors associated with it.
      <br/>
      These file descriptors can reside in the same domain as the object, or alternatively, in different domains having access to the object.
      <br/>
      Each client domain that references a remote object has one or more file descriptors representing the object.
      <br/>
      In essence, the file descriptor is a local identifier for the object within a particular user domain.
    </p>
    <p num="54">
      A kernel object is represented in the kernel domain by a kernel-level xdoor 470.
      <br/>
      A kernel object's xdoor 470 contains an additional field that includes a local xdoor identifier 447 representing the kernel object in the kernel domain.
      <br/>
      Typically, the local xdoor identifier 447 is a file descriptor 454.
    </p>
    <p num="55">
      A kernel-level file descriptor table 430 is used to store each file descriptor 454 existing within a node 402.
      <br/>
      The file descriptor table 430 is partitioned into segments 455.
      <br/>
      Each segment represents the file descriptors 454 associated with a particular domain.
      <br/>
      Each file descriptor entry 454 references a door stored in a kernel-level door table 432.
      <br/>
      A door 462 includes a door identifier 464, a process location pointer 466, and other information.
      <br/>
      The process location pointer 466 reflects an entry point to a procedure in the server's address space that is used to perform the invocation.
      <br/>
      In the case of an intra-node remote user object invocation, process location pointer 466 is used to access the server's xdoor procedures 428.
      <br/>
      In the case of an inter-node remote object invocation or a remote kernel object invocation, process location pointer 466 is used to access a gateway handler 468 associated with the object.
      <br/>
      Gateway handler 468 is used to facilitate the transport of the remote object invocation request to the corresponding node.
      <br/>
      Gateway handler 468 translates object invocations utilizing file descriptors 454 to a respective system-wide identifier.
    </p>
    <p num="56">Description of Replica Manager</p>
    <p num="57">
      FIG. 5 illustrates how replica manager 500 keeps track of primary and secondary servers for various services in accordance with an embodiment of the present invention.
      <br/>
      For each service, replica manager 500 keeps a record of which nodes in a distributed system function as primary servers, and which nodes function as secondary servers. (Recall that a service is a related collection of objects.) For example, in FIG. 5 replica manager 500 keeps track of services 502, 504, 506 and 508.
      <br/>
      The primary server for service 502 is node 106, and the secondary servers are nodes 110 and 114.
      <br/>
      The primary server for service 504 is node 110, and the secondary servers are nodes 106 and 114.
      <br/>
      The primary server for service 506 is node 102, and the secondary servers are nodes 110 and 114.
      <br/>
      The primary server for service 508 is node 106, and the secondary servers are nodes 102, 110 and 114.
    </p>
    <p num="58">In one embodiment of the present invention, replica manager 500 is distributed across multiple nodes of the network, so that replica manager 500 will continue to function even if one of the nodes on the network fails.</p>
    <p num="59">Description of Operations</p>
    <p num="60">
      FIGS. 6-9 illustrate a number of operations involved in facilitating high availability in accordance with an embodiment of the present invention.
      <br/>
      These operations include, object creation, object invocation, and failover.
      <br/>
      Each of these is described in more detail with reference to FIGS. 6-9 below.
    </p>
    <p num="61">Description of Object Creation</p>
    <p num="62">
      FIG. 6 is a flow chart illustrating some of the operations involved in creating an object in accordance with an embodiment of the present invention.
      <br/>
      This flow chart is divided into a left-hand column and a right-hand column.
      <br/>
      The left-hand column illustrates operations of primary server 212, and the right-hand column illustrates operations of client 200 (see FIG. 2B).
    </p>
    <p num="63">
      The system starts at state 600 and proceeds to state 602.
      <br/>
      In state 602, primary server 212 allocates the object.
      <br/>
      This entails allocating memory for data structures associated with the object.
      <br/>
      It also includes allocating a replica handler for the object, and specifying a service ID for the object.
      <br/>
      Recall that a service refers to a collection of related objects.
      <br/>
      Hence, a service ID is an identifier for a service.
      <br/>
      The system next proceeds to state 604.
      <br/>
      In state 604, the system passes a reference to the object.
      <br/>
      This can happen either as an input or an output of an invocation on some other object.
      <br/>
      The system next proceeds to state 606.
      <br/>
      In state 606, primary server 212 allocates an hxdoor, such as hxdoor 310 in FIG. 3.
      <br/>
      This hxdoor includes an hxdoor identifier (ID).
      <br/>
      The system next proceeds to state 608.
      <br/>
      In state 608, primary server 212 allocates a server xdoor, such as server xdoor 316 in FIG. 3.
      <br/>
      This server xdoor includes a server xdoor ID.
      <br/>
      The system next proceeds to state 610.
      <br/>
      Note that the preceding states, 606 and 608, are only executed the first time a reference is passed to the object.
      <br/>
      For subsequent references, the hxdoor 310 and server xdoor 316 structures already exist, and the system can simply skip over states 606 and 608.
      <br/>
      In state 610, primary server 212 marshals the hxdoor ID and the server xdoor ID, which entails packaging them into a message.
      <br/>
      The system next proceeds to state 612.
      <br/>
      In state 612, primary server 212 sends the message containing the object reference to client 200.
      <br/>
      The system next proceeds to state 614.
    </p>
    <p num="64">
      In state 614, client 200 receives the message containing the object reference.
      <br/>
      The system next proceeds to state 616.
      <br/>
      In state 616, client 200 unmarshals the hxdoor ID, which entails reading it from the message.
      <br/>
      The system next proceeds to state 618.
      <br/>
      In state 618, the system unmarshals the client xdoor, and if it is necessary, client 200 creates a new client xdoor, such as client xdoor 314 in FIG. 3.
      <br/>
      The system next proceeds to state 620.
      <br/>
      In state 620, if necessary, client 200 creates an hxdoor, such as hxdoor 308 in FIG. 3.
      <br/>
      The system next proceeds to state 622.
      <br/>
      In state 622, if they do not already exist, client 200 creates a replica handler, such as replica handler 203 in FIG. 3, and a proxy.
      <br/>
      The system next proceeds to state 614, which is an end state.
      <br/>
      At this point the object has been created, and data structures that facilitate invocations to the object have been created on both primary server 212 and client 200.
      <br/>
      In order to provide high availability, at least one secondary copy of the object must be created on a secondary server, such as secondary server 213 in FIG. 2B.
    </p>
    <p num="65">
      FIG. 7 is a flow chart illustrating some of the operations involved in creating an object on a secondary server in accordance with an embodiment of the present invention.
      <br/>
      The system starts at state 700 and proceeds to state 702.
      <br/>
      In state 702, at some time after primary server 212 allocates the object, primary server 212 initiates creation of the object on secondary server 213 by invoking the object on secondary server 213 (see FIG. 2B).
      <br/>
      This causes a reference to be passed from primary server 212 to secondary server 213 through checkpointing interface 214 (see FIG. 2B).
      <br/>
      The system next proceeds to state 704.
      <br/>
      In state 704, secondary server 213 creates a linkage for the object on secondary server 213.
      <br/>
      This linkage includes replica handler 306 and hxdoor 312 as is illustrated in FIG. 3.
      <br/>
      This linkage is created using the same process that is discussed above for creating analogous linkages for the object on client 200 with reference to FIG. 6, except that server xdoor 318 is not created initially, and will only be created when necessary during failover.
      <br/>
      The system next proceeds to state 706.
      <br/>
      In state 706, secondary server 213 invokes a checkpoint object within secondary server 213.
      <br/>
      This causes a secondary copy of the object to be allocated on secondary server 213.
      <br/>
      It also calls a function on hxdoor 312 and on replica handler 306 (from FIG. 3) informing them that they are associated with a secondary server for the object.
      <br/>
      The system next proceeds to state 708.
      <br/>
      In state 708, flags are set in hxdoor 312 and replica handler 306 to indicate that they are associated with the secondary copy of the object.
      <br/>
      The content of these flags are the only significant difference between the process for creating data structures on client 200, as is outlined in FIG. 6 above, and the process for creating data structures on secondary server 213.
      <br/>
      These flags allow the same mechanism to be used for both client data structure creation and secondary server data structure creation.
      <br/>
      When the invocation of the checkpoint object completes, the client xdoor is deleted on secondary server 213.
      <br/>
      As mentioned above, server xdoor 318 will not be created until necessary during failover.
      <br/>
      The system finally proceeds to state 710, which is an end state.
      <br/>
      The process of creating data structures on secondary server 213 is now complete.
      <br/>
      The process outlined in FIG. 7 may be repeated on other secondary servers to create additional secondary servers for the object, if such secondary servers are desired.
    </p>
    <p num="66">
      Note that this disclosure uses the terms "object" and "service" interchangeably.
      <br/>
      A service is defined to be a collection of related objects.
      <br/>
      Conceptually, a service is a generalization of an object, because if a service includes only one object, the service is essentially analogous to the object.
      <br/>
      In one embodiment, all of the above operations specified as being performed on an object are performed on a service.
    </p>
    <p num="67">Description of Object Invocation</p>
    <p num="68">
      FIG. 8 is a flow chart illustrating some of the operations involved in invoking a highly available object in accordance with an embodiment of the present invention.
      <br/>
      The system starts at state 800 and proceeds to state 802.
      <br/>
      In state 802, client 200 calls its local proxy with an invocation to the object.
      <br/>
      The system then proceeds to state 804.
      <br/>
      In state 804, the proxy on client 200 forwards the invocation to replica handler 302 on client 200.
      <br/>
      Note that forwarding an invocation can be accomplished by performing a function call.
      <br/>
      The system next proceeds to state 806.
      <br/>
      In state 806, replica handler 302 marshals (gathers together) arguments pertaining to the invocation.
      <br/>
      The system next proceeds to state 808.
      <br/>
      In state 808, replica handler 302 forwards the invocation to hxdoor 308.
      <br/>
      The system next proceeds to state 810.
      <br/>
      In state 810, hxdoor 308 increments an invocation count related to the object to indicate that an additional invocation to the object is in progress.
      <br/>
      Hxdoor 308 then forwards the invocation to client xdoor 314.
      <br/>
      The system next proceeds to state 812.
    </p>
    <p num="69">
      In state 812, client xdoor 314 forwards the invocation to server xdoor 316 on primary server 212 (see FIG. 3).
      <br/>
      This is accomplished by forwarding the invocation through transport mechanism 320 on client 200, across network 100, and then through transport mechanism 322 on primary server 212, and then finally into server xdoor 316 (see FIG. 3).
      <br/>
      The system then proceeds to state 814.
    </p>
    <p num="70">
      In state 814, server xdoor 316 forwards the invocation to replica handler 304 on primary server 212.
      <br/>
      The system next proceeds to state 816.
      <br/>
      In state 816, replica handler 304 calls the specified function on the primary copy of the object 206 on primary server 212.
      <br/>
      The system then proceeds to state 818.
    </p>
    <p num="71">
      In state 818, primary server 212 sends a reply to the invocation back down the same pathway, but in the reverse direction.
      <br/>
      This reply is forwarded in essentially the same manner as the invocation.
      <br/>
      Along the way, hxdoor 308 decrements its invocation count for the object to indicate that the invocation is not longer in progress.
      <br/>
      The system next proceeds to state 820, which is an end state.
    </p>
    <p num="72">Description of Failover</p>
    <p num="73">
      FIG. 9 is a flow chart illustrating some of the operations involved in performing a failover for an object from a primary server to a secondary server in accordance with an embodiment of the present invention.
      <br/>
      The system starts in state 900 and proceeds to state 902.
      <br/>
      In state 902, the system detects a failure of primary server 212 (see FIGS. 2 and 3).
      <br/>
      This failure can arise if primary server 212 ceases to function, or ceases to process client requests in a timely manner.
      <br/>
      In one embodiment of the present invention, this failure detection is performed by a replica manager, such as replica manager 500 described above with reference the FIG. 5.
      <br/>
      Next, the system proceeds to state 904.
      <br/>
      In state 904, replica manager 500 tells clients associated with primary server 212, that primary server 212 is no longer functioning properly.
      <br/>
      The system next proceeds to state 906.
    </p>
    <p num="74">
      In state 906, all hxdoors with in-progress invocations to primary server 212 wait for the in-progress invocations to complete.
      <br/>
      This includes forcing in-progress invocations to dead nodes to unblock and complete.
      <br/>
      When these in-progress invocations to dead nodes return, they typically return with an error code indicating the invocation did not complete.
      <br/>
      The hxdoors convert these error codes into another error code indicating the request should be retried by the proxy instead of returning an error to the client application program on client 200.
      <br/>
      In this way, the retry will take place automatically, and the client application program will not have to deal with any error conditions as a result of the failure of primary server 212.
      <br/>
      The system next proceeds to state 908.
    </p>
    <p num="75">
      In state 908, the hxdoors set a flag to indicate that new invocations to primary server 212 should be blocked until the failover is complete.
      <br/>
      This is done so that new invocations will not interfere with the failover process.
      <br/>
      The system then proceeds to state 910.
      <br/>
      In state 910, when the invocations to objects on primary server 212 complete, the associated client xdoors are discarded because they are configured for failed primary server 212.
      <br/>
      The system next proceeds to state 912.
    </p>
    <p num="76">
      In state 912, the system selects a secondary server to replace primary server 212.
      <br/>
      In one embodiment of the present invention, this secondary server is selected by replica manager 500 (see FIG. 5).
      <br/>
      The system next proceeds to state 914.
      <br/>
      In state 914, replica manager 500 tells all clients to connect to the new primary.
      <br/>
      The system then proceeds to state 916.
      <br/>
      In state 916, clients invoke the object on the new primary server.
      <br/>
      This includes passing a list of hxdoor identifiers that need to be reconnected to the new primary.
      <br/>
      Marshalling the reply triggers creation of server xdoors on the new primary server.
      <br/>
      The system then proceeds to state 918.
    </p>
    <p num="77">
      In state 918, a list of references to the objects specified by the hxdoor identifiers is returned to the clients.
      <br/>
      The system next proceeds to state 920.
      <br/>
      In state 920, when the reply is received, the clients use the normal unmarshalling mechanism to plug in the corresponding client xdoors.
      <br/>
      The system next proceeds to 922.
      <br/>
      In state 922, the system tells clients to unblock invocations to objects on failed primary server 212.
      <br/>
      This allows blocked invocations to proceed to the new primary server.
      <br/>
      The system then proceeds to state 914, which is an end state.
      <br/>
      At this point the failover is process is complete.
    </p>
    <p num="78">While the invention has been particularly shown and described with reference to embodiments thereof, those skilled in the art will understand that the foregoing and other changes in form and detail may be made therein without departing from the spirit and scope of the present invention.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8.</claim-text>
      <claim-text>A method for providing transparent failover from a first server to a second server for active invocations to an object, the first server acting as a primary server for invocations to the object, the method comprising: detecting a failure of the first server; blocking any new active invocations to the object after detecting the failure of the first server; winding up the active invocations to the object, including causing any active invocations to unresponsive nodes to unblock and complete; selecting the second server as a new primary server for the object; reconfiguring the second server to act as the new primary server for the object; unblocking the new active invocations to the object after reconfiguring the second server;</claim-text>
      <claim-text>and automatically retrying the active invocations which are incomplete to the object on the second server; wherein the object has a primary copy located within a first storage device associated with the first server, and a secondary copy located within a second storage device associated with the second server, wherein the first storage device is separate from the second storage device;</claim-text>
      <claim-text>and updating the secondary copy on the second server when the primary copy is updated on the first server.</claim-text>
      <claim-text>1. A method for providing transparent failover from a first server to a second server for active invocations to an object, the first server acting as a primary server for invocations to the object, the method comprising:</claim-text>
      <claim-text>winding up the active invocations to the object, including causing any active invocations to unresponsive nodes to unblock and complete; selecting the second server as a new primary server for the object upon a failure of the first server; reconfiguring the second server to act as the new primary server for the object; automatically retrying the active invocations which are incomplete to the object on the second server; wherein the object has a primary copy located within a first storage device associated with the first server, and a secondary copy located within a second storage device associated with the second server, wherein the first storage device is separate from the second storage device;</claim-text>
      <claim-text>and updating the secondary copy on the second server when the primary copy is updated on the first server.</claim-text>
      <claim-text>2. The method of claim 1, wherein the operations of selecting the second server and reconfiguring the second server are performed automatically.</claim-text>
      <claim-text>3. The method of claim 1, further comprising: blocking any new active invocations to the object after the failure of the first server;</claim-text>
      <claim-text>and unblocking the new active invocations to the object after reconfiguring the second server.</claim-text>
      <claim-text>4. The method of claim 1, further comprising detecting the failure of the first server.</claim-text>
      <claim-text>5. The method of claim 4, wherein the operation of detecting the failure is carried out by a system manager that is distributed across at least two of, the first server, the second server and a plurality of additional computer systems, so that the system manager is tolerant of server failures.</claim-text>
      <claim-text>6. The method of claim 1, further comprising notifying clients of the first server that the first server has failed.</claim-text>
      <claim-text>7. The method of claim 1, wherein the object includes a group of objects.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 8, wherein the operation of detecting the failure is carried out by a system manager that is distributed across at least two of, the first server, the second server and a plurality of additional computer systems, so that the system manager is tolerant of server failures.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of claim 8, further comprising notifying clients of the first server that the first server has failed.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 8, wherein the object includes a group of objects.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. An apparatus that provides a transparent failover from a first server to a second server for active invocations to an object, the first server acting as a primary server for invocations to the object, the apparatus comprising: the first server coupled to a network; a first storage device associated with the first server; the second server coupled to the network; a second storage device associated with the second server; a system manager residing on at least one node on the network, the system manager detecting a failure of the first server and selecting the second server to act as a new primary server for the object; a reconfiguration mechanism in communication with the system manager that reconfigures the second server to act as the new primary server for the object; a winding up mechanism that winds up active invocations to the object before reconfiguring the second server, including causing any active invocations to unresponsive nodes to unblock and complete; a retry mechanism in communication with the second server that automatically retries the active invocations which are incomplete to the object to the second server after the second server has been reconfigured; wherein the object has a primary copy located within the first storage device and a secondary copy located within the second storage device wherein the first storage device is separate from the second storage device;</claim-text>
      <claim-text>and an updating mechanism in communication with the first server and the second server that is configured to update the secondary copy on the second server when the primary copy is updated on the first server.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The apparatus of claim 12, wherein the system manager and the reconfiguration mechanism operate without requiring explicit retry commands from a client application program.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The apparatus of claim 12, further comprising a blocking mechanism that blocks new active invocations to the object when the failure of the first server is detected, and that unblocks the new active invocations to the object after the second server is reconfigured.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The apparatus of claim 12, wherein the object includes a group of objects.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The apparatus of claim 12, wherein the system manager is distributed across multiple nodes on the network so that the system manager is tolerant of node failures.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The apparatus of claim 12, wherein the system manager is configured to notify clients of the first server that the first server has failed.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The apparatus of claim 12, wherein the system manager includes a selection mechanism to select the second server to act as the new primary server for the object.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. An apparatus that provides a transparent failover from a first server to a second server for active invocations to an object, the first server acting as a primary server for invocations to the object, the apparatus comprising: the first server coupled to a network; a first storage device associated with the first server; the second server coupled to the network; a second storage device associated with the second server; a system manager residing on at least one node on the network that detects a failure of the first server and selects the second server to act as a primary server for the object; a winding up mechanism that winds up active invocations to the object including causing any active invocations to unresponsive nodes to unblock and complete, before the second server is reconfigured to act as a new primary server for the object; a blocking mechanism that blocks new invocations to the object when the failure of the first server is detected, and that unblocks new invocations to the object after the second server is reconfigured; a reconfiguration mechanism in communication with the system manager that reconfigures the second server to act as the new primary server for the object; a retry mechanism in communication with the second server that automatically retries uncompleted invocations to the object after the second server has been reconfigured; wherein the object has a primary copy located within the first storage device and a secondary copy located within the second storage device, wherein the first storage device is separate from the second storage device;</claim-text>
      <claim-text>and an updating mechanism in communication with the first server and the second server that is configured to update the secondary copy on the second server when the primary copy is updated on the first server.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The apparatus of claim 19, wherein the system manager is distributed across multiple nodes on the network so that the system manager is tolerant to node failures.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The apparatus of claim 19, wherein the system manager is configured to notify clients of the first server that the first server has failed.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The apparatus of claim 19, wherein the system manager includes a selection mechanism to select the second server to act as a new primary server for the object.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The apparatus of claim 19, wherein the object includes a group of objects.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A program storage device storing instructions that when executed by a computer performs a method for providing transparent failover from a first server to a second server for active invocations to an object, the first server acting as a primary server for invocations to the object, the method comprising: winding up the active invocations to the object, including causing any active invocations to unresponsive nodes to unblock and complete; selecting the second server as a new primary server for the object upon a failure of the first server; reconfiguring the second server to act as the new primary server for the object; automatically retrying the active invocations which are incomplete to the object on the second server; wherein the object has a primary copy located within a first storage device associated with the first server and a secondary copy located within a second storage device associated with the second server, wherein the first storage device is separate from the second storage device;</claim-text>
      <claim-text>and updating the secondary copy on the second server when the primary copy is updated on the first server.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. A computer instruction signal embodied in a carrier wave carrying instructions that when executed by a computer perform a method for providing transparent failover from a first server to a second server for active invocations to an object, the first server acting as a primary server for invocations to the object, the method comprising: winding up the active invocations to the object, including causing any active invocations to unresponsive nodes to unblock and complete; selecting the second server as a new primary server for the object upon a failure of the first server; reconfiguring the second server to act as the new primary server for the object; automatically retrying the active invocations which are incomplete to the object on the second server; wherein the object has a primary copy located within a first storage device associated with the first server, and a secondary copy located within a second storage device associated with the second server, wherein the first storage device is separate from the second storage device;</claim-text>
      <claim-text>and updating the secondary copy on the second server when the primary copy is updated on the first server.</claim-text>
    </claim>
  </claims>
</questel-patent-document>