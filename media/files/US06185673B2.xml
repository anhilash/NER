<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185673B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185673</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185673</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22315629" extended-family-id="42113772">
      <document-id>
        <country>US</country>
        <doc-number>09107243</doc-number>
        <kind>A</kind>
        <date>19980630</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09107243</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43172116</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>10724398</doc-number>
        <kind>A</kind>
        <date>19980630</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09107243</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/345       20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>345</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   9/445       20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>445</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>712228000</text>
        <class>712</class>
        <subclass>228000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>712223000</text>
        <class>712</class>
        <subclass>223000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>712231000</text>
        <class>712</class>
        <subclass>231000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>712E09024</text>
        <class>712</class>
        <subclass>E09024</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>712E09039</text>
        <class>712</class>
        <subclass>E09039</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>717141000</text>
        <class>717</class>
        <subclass>141000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/30R2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30R2</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-009/345</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>345</subgroup>
      </classification-ecla>
      <classification-ecla sequence="3">
        <text>G06F-009/445V</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>445V</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30101</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30101</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/345</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>345</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/44589</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>44589</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>14</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>2</number-of-drawing-sheets>
      <number-of-figures>2</number-of-figures>
      <image-key data-format="questel">US6185673</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Apparatus and method for array bounds checking with a shadow register file</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>STEAD LAWRENCE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5384912</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5384912</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>AUSTIN TODD MICHAEL</text>
          <document-id>
            <country>US</country>
            <doc-number>5644709</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5644709</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Sun Microsystems, Inc.</orgname>
            <address>
              <address-1>Palo Alto, CA, US</address-1>
              <city>Palo Alto</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>SUN MICROSYSTEMS</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Dewan, Gautam</name>
            <address>
              <address-1>San Jose, CA, US</address-1>
              <city>San Jose</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Galliani, William S.</name>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <orgname>Pennie &amp; Edmonds LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Pan, Daniel H.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A circuit for processing source code with associated array bounds limitations includes an execution unit that generates a register value signal and an index number signal corresponding to an array value defined in a source code instruction.
      <br/>
      A primary register is connected to the execution unit.
      <br/>
      The primary register produces a base memory address signal in response to the register value signal.
      <br/>
      A shadow register is also connected to the execution unit.
      <br/>
      The shadow register produces an array bound value signal in response to the register value signal.
      <br/>
      An address computation circuit is connected to the execution unit and the primary register.
      <br/>
      The address computation circuit generates an effective memory address signal based upon the base memory address signal and the index number signal.
      <br/>
      An address comparison circuit generates an array bound error signal when an effective memory address associated with the effective memory address signal exceeds an array bound value associated with the array bound value signal.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BRIEF DESCRIPTION OF THE INVENTION</heading>
    <p num="1">
      This invention relates generally to the processing of secure computer code that has associated array bounds that limit memory accesses.
      <br/>
      More particularly, this invention relates to a hardware based technique for array bounds checking through the use of shadow registers.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      Secure computer code, such as JAVA, from SUN MICROSYSTEMS, INC., Mountain View, California, requires that all accesses to an array be checked to insure that the programmed code does not access prohibited memory spaces.
      <br/>
      An attempt to access a prohibited memory space must be trapped to insure computer security.
    </p>
    <p num="3">
      Array bounds checking of computer code can be appreciated with reference to an example associated with the JAVA programming language.
      <br/>
      Arrays are special types in JAVA.
      <br/>
      Arrays are used to keep similar information in the same place.
      <br/>
      Arrays hold a list of objects that can be referenced by indexing.
      <br/>
      For example, to create an array "a" of ten integers, the following code is used: "int a��=new int �10�".
      <br/>
      Individual variables in the array are referenced by a number, for example, a�0�, a�1�, through a�9�. Note that the subscripts go from zero, the first element in the array, to the size of the array minus one.
    </p>
    <p num="4">
      Now suppose that a subsequent source code instruction states: "a�12�=4".
      <br/>
      This instruction attempts to load the value "4" into the twelfth position of the array "a".
      <br/>
      When the foregoing code is processed by a JAVA compiler, the JAVA compiler will perform a run-time bounds check.
      <br/>
      This bounds check requires the execution of several instructions.
      <br/>
      This processing is computationally expensive, especially when the array is in a loop.
      <br/>
      When the JAVA compiler identifies the foregoing bounds error, it will generate a message and subsequently prohibit processing of the source code.
    </p>
    <p num="5">
      In view of the foregoing, it would be highly desirable to reduce the array bounds processing burden on a compiler by providing a hardware based technique for array bound checking.
      <br/>
      Such a technique should be easy to implement.
      <br/>
      Ideally, such a technique would be controllable through existing software instructions.
      <br/>
      Thus, the compiler would not be required to process a new class of instructions.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="6">
      The apparatus of the invention includes a circuit for processing source code with associated array bounds limitations.
      <br/>
      The apparatus includes an execution unit that generates a register value signal and an index number signal corresponding to an array value defined in a source code instruction.
      <br/>
      A primary register is connected to the execution unit.
      <br/>
      The primary register produces a base memory address signal in response to the register value signal.
      <br/>
      A shadow register is also connected to the execution unit.
      <br/>
      The shadow register produces an array bound value signal in response to the register value signal.
      <br/>
      An address computation circuit is connected to the execution unit and the primary register.
      <br/>
      The address computation circuit generates an effective memory address signal based upon the base memory address signal and the index number signal.
      <br/>
      An address comparison circuit generates an array bound error signal when an effective memory address associated with the effective memory address signal exceeds an array bound value associated with the array bound value signal.
    </p>
    <p num="7">
      The method of the invention includes the step of computing, with an array bounds check circuit, an effective memory address for an array value defined in a source code instruction.
      <br/>
      An array bound value is then read from a shadow register location defined in the source code instruction.
      <br/>
      A hardware error signal is then generated when the effective memory address exceeds the array bound value.
    </p>
    <p num="8">
      The invention reduces the array bounds processing burden on a compiler by providing a hardware based technique for array bounds checking.
      <br/>
      The technique of the invention can be implemented with well known hardware components.
      <br/>
      Advantageously, the disclosed technique can be implemented with existing software instructions.
      <br/>
      Consequently, the compiler is not required to process a new class of instructions.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="9">
      For a better understanding of the invention, reference should be made to the following detailed description taken in conjunction with the accompanying drawings, in which:
      <br/>
      FIG. 1 illustrates a computer constructed in accordance with an embodiment of the invention.
      <br/>
      FIG. 2 illustrates a processing circuit constructed in accordance with an embodiment of the invention.
      <br/>
      Like reference numerals refer to corresponding parts throughout the drawings.
    </p>
    <heading>DETAILED DESCRIPTION OF THE INVENTION</heading>
    <p num="10">
      FIG. 1 illustrates a computer 20 constructed in accordance with an embodiment of the invention.
      <br/>
      The computer includes a processing circuit 22.
      <br/>
      The processing circuit 22 includes standard execution units 24 and array bounds checking circuitry 26 in accordance with the invention.
      <br/>
      The processing circuit 22 may be a central processing unit of a computer, a silicon-based JAVA virtual machine, or the like.
      <br/>
      The processing circuit 22 is connected to a set of standard input/output devices 28 via a bus 30.
      <br/>
      By way of example, the standard input/output devices 28 include a keyboard, mouse, scanner, monitor, printer, etc.
      <br/>
      The processing circuit 22 is also connected to a memory 32 via the bus 30.
      <br/>
      The memory 32, which may be primary memory, secondary memory, or a combination of primary and secondary memory, stores source code 34 of a program to be executed.
      <br/>
      The source code 34 includes source code instructions that have array bounds limitations.
      <br/>
      The memory 32 also stores a compiler 36 for compiling the source code 34.
      <br/>
      As discussed below, the processing burden on the compiler is reduced by the processing performed by the array bounds check circuit 26.
    </p>
    <p num="11">
      The general processing interactions between a processing circuit 22, input/output devices 28, and a memory 32 are well known in the art.
      <br/>
      The present invention is directed toward the operation of the array bounds checking circuit 26 of the processing circuit 22.
    </p>
    <p num="12">
      FIG. 2 is a more detailed view of the processing circuit 22.
      <br/>
      Standard execution units 24 interact with an array bounds check circuit 26 constructed in accordance with an embodiment of the invention.
      <br/>
      In accordance with standard processing techniques, the execution units 24 generate a register value signal, which is applied to a primary register file 40, via signal line 43.
      <br/>
      As known in the art, a primary register file 40 is a bank of registers.
    </p>
    <p num="13">
      In accordance with the invention, the same signal is sent to a shadow register file 42.
      <br/>
      The shadow register file 42 includes a bank of register duplicating the bank of registers of the primary register file 40.
      <br/>
      That is, for each register in the primary register file 40, there is a corresponding register in the shadow register file 42.
      <br/>
      Each register in the shadow register file 42 stores a bounds value for a corresponding register in the primary register file 40.
    </p>
    <p num="14">
      The register value signal from the execution units corresponds to a register value assigned to an array variable.
      <br/>
      For example, the integer array "a" discussed above may be assigned to a register R3 of the primary register file 40.
      <br/>
      In accordance with the invention, the same register value signal is applied to a register R3 of the shadow register file 42.
    </p>
    <p num="15">
      The register value signal causes the primary register file 40 to generate a base memory address signal on line 44.
      <br/>
      The base memory address signal specifies the address in memory for the specified array variable.
      <br/>
      The base memory address signal is passed to an address computation circuit 46.
      <br/>
      The address computation circuit 46 also receives an index number signal from line 50 and an array element size signal from line 48.
      <br/>
      These signals are also generated by the execution units 24.
      <br/>
      The index number signal specifies the index number associated with the array element that was specified in a source code instruction.
      <br/>
      For example, for the statement "a�3�=8", the value eight is to be loaded into the fourth position of the array "a".
      <br/>
      Therefore, the index number signal in this case would be four (recall that the first position is specified by a�0�, therefore the fourth position is specified by a�3�).
      <br/>
      The array element size signal 48 is the size of each array element, for example, four bytes.
      <br/>
      This value is dependent upon the architecture of the processing circuit 22.
    </p>
    <p num="16">
      The address computation circuit 46 processes the array element size signal, the index number signal, and the base memory address signal to produce an effective memory address signal, which is routed onto line 52.
      <br/>
      The address computation circuit 52 calculates the effective memory address signal by adding a memory block product to the base memory address received form the primary register file 40.
      <br/>
      The memory block product is the product of the index number and the array element size.
      <br/>
      Relying upon the previous example where the index number was three (designating the fourth position) and the array element size was four bytes, the memory block product would be sixteen bytes, which is added to the base memory address.
      <br/>
      The resultant effective memory address represents the memory location for the array element specified in the source code instruction a�3�=8.
    </p>
    <p num="17">
      The effective memory address signal is routed to an address comparison circuit 56, which also receives an array bound value signal on line 54.
      <br/>
      As previously indicated, the array bound value signal represents the maximum array value for the array which was specified in the source code instruction.
      <br/>
      If the effective memory address signal exceeds the array bound value signal, then an array bound error signal is activated, for example, into a digital high state.
      <br/>
      The execution units 24 process this hardware error signal to generate an appropriate error message that is reported back to the individual attempting to execute the source code 34.
    </p>
    <p num="18">
      Observe that the primary register file 40 generates a base memory address signal on line 44, which may be immediately routed via line 60 to the execution units 24 for processing.
      <br/>
      This may be done if it is desirable to disable the bounds check operation.
      <br/>
      This processing may be implemented through the use of a bounds check register 62.
      <br/>
      The bounds check register 62 stores a bit for each register in the shadow register file 42.
      <br/>
      If a bounds value exists in a specified register of the shadow register file 42, then a bit corresponding to that specified register is activated (e.g., set to a digital high value).
      <br/>
      Therefore, if a bit in the bounds check register 62 is not activated (e.g., it is a digital low value), then a bound check operation need not be performed.
      <br/>
      The register value signal is applied to the bounds check register 62 over line 43.
      <br/>
      If the register value signal specifies a register in the shadow register file that does not have a bounds value within it, then the bounds check register 62 will produce an unactivated (e.g., digital low) bounds check register signal on line 64.
      <br/>
      This signal will advise the execution units 24 that they may immediately initiate processing of the base memory address signal from line 60.
      <br/>
      That is, the execution units need not wait for the processing of the address computation circuit 46 and the address comparison circuit 56, which produce the array bound error signal.
      <br/>
      Conversely, an activated (e.g., digital high) bounds check register signal online 64 advises the execution units 24 that processing cannot proceed until the array bound error signal is received.
    </p>
    <p num="19">
      The array bound values may be loaded into the shadow register file 42 using standard software instructions.
      <br/>
      For example, if a software programmer wishes to use address registers 1, 3, and 9 to access arrays that have bounds "b1", "b2", and "b3", the following instructions may be used:
    </p>
    <p num="20">
      store "b1""in BOUNDS REGISTER 1
      <br/>
      store "b2""in BOUNDS REGISTER 3
      <br/>
      store "b3""in BOUNDS REGISTER 9
      <br/>
      write a 1 in bit positions 1, 3, and 9 of BOUNDS CHECK REGISTER
    </p>
    <p num="21">
      Subsequently, all load store accesses that derive their addresses from primary register file registers 1, 3, and 9 will be automatically bounds checked against the bounds stored in the corresponding shadow registers.
      <br/>
      To disable bounds checking for primary memory register N, the programmer generates an instruction to write a "0" bit in position N of the bounds check register.
    </p>
    <p num="22">
      Those skilled in the art will recognize a number of benefits associated with the apparatus of the invention.
      <br/>
      Since there is a direct correspondence between each primary register and its shadow register, no conversion tables or other mechanisms are required to link a bound value to a variable.
      <br/>
      The technique of the invention can be implemented with existing source code instruction sets.
      <br/>
      That is, no new instructions (e.g., LOAD BOUND CHECK) are required, thus the invention does not require expensive new tools, such as new design tools, compilers, linkers, etc.
    </p>
    <p num="23">
      The invention reduces the array bounds processing burden on a compiler by providing a hardware based technique for array bounds checking.
      <br/>
      The technique of the invention can be implemented with well known hardware components.
    </p>
    <p num="24">
      The foregoing description, for purposes of explanation, used specific nomenclature to provide a thorough understanding of the invention.
      <br/>
      However, it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention.
      <br/>
      In other instances, well known circuits and devices are shown in block diagram form in order to avoid unnecessary distraction from the underlying invention.
      <br/>
      Thus, the foregoing descriptions of specific embodiments of the present invention are presented for purposes of illustration and description.
      <br/>
      They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, obviously many modifications and variations are possible in view of the above teachings.
      <br/>
      The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated.
      <br/>
      It is intended that the scope of the invention be defined by the following Claims and their equivalents.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A circuit for processing source code with associated array bounds limitations, comprising:</claim-text>
      <claim-text>an execution unit that generates a register value signal and an index number signal corresponding to an array value defined in a source code instruction; a primary register connected to said execution unit, said primary register producing a base memory address signal in response to said register value signal; a shadow register connected to said execution unit, said shadow register producing an array bound value signal in response to said register value signal; an address computation circuit connected to said execution unit and said primary register, said address computation circuit generating an effective memory address signal based upon said base memory address signal and said index number signal;</claim-text>
      <claim-text>and an address comparison circuit to generate an array bound error signal when an effective memory address associated with said effective memory address signal exceeds an array bound value associated with said array bound value signal.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The circuit of claim 1 wherein said execution unit generates an array element size signal and said address computation circuit multiplies said array element size signal by said index number signal to produce a memory block product signal, said address computation circuit adding said memory block product signal to said base memory address signal to yield said effective memory address signal.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The circuit of claim 2 further comprising a bound check register connected to said execution unit, said bound check register storing a bit value corresponding to said shadow register, said bit value specifying when said base memory address signal is processed by said execution unit prior to receiving said array bound error signal.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The circuit of claim 1 in combination with a system bus, a plurality of input/output devices, and a memory.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. A method of processing source code with associated array bounds limitations, said method comprising the steps of: computing, with an array bounds check circuit, an effective memory address for an array value defined in a source code instruction, said computing including accessing a base memory address stored in a primary register and multiplying an array element size value by an array index value to obtain a memory block product; reading an array bound value from a shadow register location defined in said source code instruction;</claim-text>
      <claim-text>and generating a hardware error signal when said effective memory address exceeds said array bound value.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 5 wherein said computing includes adding said memory block product to said base memory address to yield said effective memory address.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 5 further comprising loading array bounds values into said shadow register in response to software instructions.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 5 further comprising the step of processing said base memory address before said hardware error signal is generated.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 8 wherein said processing is performed in response to a bit value in a bound check register, said bit value in said bound check register corresponding to said shadow register location.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A method of processing computer instructions with associated array bounds limitations, comprising the steps of: accessing a base memory address; computing a memory block product from an array element size value and an array index value; adding said memory block product to said base memory address to yield an effective memory address; reading an array bound value;</claim-text>
      <claim-text>and generating an error signal when said effective memory address exceeds said array bound value.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 10 wherein said accessing includes accessing said base memory address in a primary register.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 11 further comprising the step of processing said base memory address before said error signal is generated.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 12 wherein said processing is performed in response to a bit value in a bound check register, said bit value in said bound check register corresponding to said shadow register location.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 10 further comprising the step of loading array bounds values into a shadow register in response to software instructions.</claim-text>
    </claim>
  </claims>
</questel-patent-document>