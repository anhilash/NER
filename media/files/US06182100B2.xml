<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182100B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182100</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182100</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22314068" extended-family-id="42108893">
      <document-id>
        <country>US</country>
        <doc-number>09106942</doc-number>
        <kind>A</kind>
        <date>19980630</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09106942</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165479</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>10694298</doc-number>
        <kind>A</kind>
        <date>19980630</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09106942</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   7/38        20060101A I20051110RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>38</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051110</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   7/483       20060101A I20070721RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>483</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20070721</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   7/556       20060101A N20070721RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>556</subgroup>
        <classification-value>N</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20070721</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>708277000</text>
        <class>708</class>
        <subclass>277000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>708495000</text>
        <class>708</class>
        <subclass>495000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>708512000</text>
        <class>708</class>
        <subclass>512000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-007/483</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>483</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-007/483</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>483</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-007/556</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>556</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="ICO"/>
        <classification-symbol>S06F-007/556</classification-symbol>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>8</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>3</number-of-drawing-sheets>
      <number-of-figures>3</number-of-figures>
      <image-key data-format="questel">US6182100</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and system for performing a logarithmic estimation within a data processing system</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>KMETZ GERALD L</text>
          <document-id>
            <country>US</country>
            <doc-number>4583180</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4583180</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>PICKETT LESTER C</text>
          <document-id>
            <country>US</country>
            <doc-number>5197024</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5197024</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>LARSON KEITH E</text>
          <document-id>
            <country>US</country>
            <doc-number>5365465</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5365465</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>TAKANO HIDETO</text>
          <document-id>
            <country>US</country>
            <doc-number>5524089</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5524089</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>SMITH ROGER A</text>
          <document-id>
            <country>US</country>
            <doc-number>5570310</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5570310</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>YOON JU YOUNG</text>
          <document-id>
            <country>US</country>
            <doc-number>5652584</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5652584</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Schmookler, Martin Stanley</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Salys, Casimer K.</name>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <orgname>Felsman, Bradley, Vaden, Gunter &amp; Dillon, LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Ngo, Chuong Dinh</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method for performing a logarithmic estimation on a positive floating-point number within a data processing system is disclosed.
      <br/>
      A floating-point number includes a sign bit, multiple exponent bits, and a mantissa having an implied one and multiple fraction bits.
      <br/>
      A fraction part of an estimate is obtained via a table lookup utilizing the fraction bits of the floating-point number as input.
      <br/>
      An integer part of the estimate is obtained by converting the exponent bits to an unbiased representation.
      <br/>
      The integer part is then concatenated with the fraction part to form an intermediate result.
      <br/>
      Subsequently, the intermediate result is normalized to yield a mantissa, and an exponent part is produced based on the normalization.
      <br/>
      Finally, the exponent part is combined with the mantissa to form a floating-point result.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>RELATED PATENT APPLICATION</heading>
    <p num="1">The present patent application is related to a copending application U.S. Ser. No. 09/106,944 filed on even date, entitled "METHOD AND SYSTEM FOR PERFORMING A POWER OF TWO ESTIMATION WITHIN A DATA-PROCESSING SYSTEM" (Attorney Docket No. AT9-98-063).</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Technical Field
    </p>
    <p num="3">
      The present invention relates to a method and system for data processing in general, and in particular to a method and system for performing a numerical estimation within a data processing system.
      <br/>
      Still more particularly, the present invention relates to a method and system for performing a logarithmic estimation within a data processing system.
    </p>
    <p num="4">2. Description of the Prior Art</p>
    <p num="5">
      A general purpose processor typically cannot perform a logarithmic function as efficiently as other mathematical operations such as additions, subtractions, and multiplications.
      <br/>
      A logarithmic function is likely to require many more processor cycles than a relatively processor cycle-consuming multiplication operation.
      <br/>
      The present disclosure provides a method for performing a logarithmic estimation, i.e., y=log2 x, within a general purpose processor, where both the argument x and the result y are represented in a floating-point format.
      <br/>
      Without loss of generality, the floating-point format used for the purpose of illustration is the IEEE 754 format.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="6">In view of the foregoing, it is therefore an object of the present invention to provide an improved method and system for data processing.</p>
    <p num="7">It is another object of the present invention to provide an improved method and system for performing a numerical estimation within a data processing system.</p>
    <p num="8">It is yet another object of the present invention to provide an improved method and system for performing a logarithmic estimation within a data processing system.</p>
    <p num="9">
      In accordance with a preferred embodiment of the present invention, a floating-point number includes a sign bit, multiple exponent bits, and a mantissa having an implied one and multiple fraction bits.
      <br/>
      A fraction part of an estimate is obtained via a table lookup utilizing the fraction bits of the floating-point number as input.
      <br/>
      An integer part of the estimate is obtained by converting the exponent bits to an unbiased representation.
      <br/>
      The integer part is then concatenated with the fraction part to form an intermediate result.
      <br/>
      Subsequently, the intermediate result is normalized to yield a mantissa, and an exponent part is produced based on the normalization.
      <br/>
      Finally, the exponent part is combined with the mantissa to form a floating-point result.
    </p>
    <p num="10">All objects, features, and advantages of the present invention will become apparent in the following detailed written description.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="11">
      The invention itself, as well as a preferred mode of use, further objects, and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:
      <br/>
      FIG. 1 is a high-level flow diagram illustrating a method for performing a logarithmic estimation within a data processing system, in accordance with a preferred embodiment of the present invention;
      <br/>
      FIG. 2 is an example illustrating a method for performing a logarithmic estimation within a data processing system, in accordance with a preferred embodiment of the present invention;
      <br/>
      FIG. 3 is a block diagram of a general purpose processor in which a preferred embodiment of the present invention may be incorporated.
    </p>
    <heading>DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT</heading>
    <p num="12">
      The present invention may be executed in a variety of data processing systems, including microprocessors and microcontrollers.
      <br/>
      For the purpose of illustration, a preferred embodiment of the present invention, as described below, may be implemented on a PowerPC (tm)  processor manufactured by International Business Machines Corporation of Armonk, N.Y.
    </p>
    <p num="13">A. Overview</p>
    <p num="14">
      As mentioned previously, one of the objectives of the present invention is to provide a fast implementation of a y=log2 x function within a general purpose floating-point processor, where x and y are 32-bit single precision floating-point numbers.
      <br/>
      According to the IEEE 754 format, a normalized floating-point number, such as x, is represented by three groups of bits, namely, a sign bit, exponent bits, and mantissa bits.
      <br/>
      The sign bit is the most significant bit of the floating-point number.
      <br/>
      The next eight less significant bits are the exponent bits, which represent a signed biased exponent of the floating-point number.
      <br/>
      An unbiased exponent can be computed by subtracting 127 from the biased exponent.
      <br/>
      The 23 least significant bits are the fraction bits; and the mantissa is computed by dividing these 23 bits with 223 and adding 1.0 to the quotient.
    </p>
    <p num="15">
      Excluding the sign bit, a floating-point number x can be considered as a product of two parts corresponding to the exponent and the mantissa, respectively.
      <br/>
      The part corresponding to the exponent of x has the value 2exp, where exp is the unbiased exponent.
      <br/>
      Thus, log2 x can be expressed by the sum of the logs of the above two parts (i.e., log2 2exp +log2 mantissa).
      <br/>
      The log2 2exp is merely the unbiased exponent, exp, itself, which is a signed integer.
      <br/>
      The log2 mantissa is a positive fraction part of the floating-point result y, which can be denoted as yF.
      <br/>
      Because 1 &lt;= mantissa&lt;2, therefore 0 &lt;= yF&lt;1, where yF=log2 mantissa.
      <br/>
      Thus, the floating-point result y can be obtained as follows:
      <br/>
      y=exp+log2 mantissa
    </p>
    <p num="16">where exp is the unbiased exponent of x, and mantissa is the mantissa of x.</p>
    <p num="17">
      If a graph of the log2 mantissa function is compared with a graph of a linear function (mantissa-1) within the range of 1 to 2 for the mantissa, it is observed that the results from the above two functions are identical at the endpoints, while the results from the log2 mantissa function is typically slightly greater than the results from the linear function between the endpoints.
      <br/>
      This relationship forms the basis for the present invention.
      <br/>
      Thus, if a logarithmic function with a low-precision estimation is needed, then the low-precision logarithmic function can be obtained simply by making small corrections to the linear function.
      <br/>
      On the other hand, if a logarithmic function with a higher precision estimation is required, the higher-precision logarithmic function can be obtained by means of a table lookup, sometimes in conjunction with point interpolation as is well-known to those skilled in the art.
    </p>
    <p num="18">
      Referring now to the drawings and in particular to FIG. 1, there is depicted a high-level flow diagram illustrating a method for performing a logarithmic estimation within a data processing system, in accordance with a preferred embodiment of the present invention.
      <br/>
      Starting at block 10, a floating-point number x, in the IEEE 754 format for example, is partitioned into a signed biased exponent part, expbias, and a fraction part, xF, as shown in block 11.
      <br/>
      An unbiased exponent, exp, is then obtained, such as by subtracting 127, from the biased exponent, as depicted in block 12.
      <br/>
      Next, an unnormalized mantissa is then obtained via a lookup table utilizing fraction part xF as the input, as illustrated in block 13.
      <br/>
      If the biased exponent part is negative, both the unbiased exponent and the unnormalized mantissa will be complemented, as depicted in block 14.
      <br/>
      The unbiased exponent is then concatenated with the unnormalized mantissa, with a binary point in between to form an immediate result, as shown in block 15.
      <br/>
      Subsequently, the immediate result is normalized by removing all leading zeros and the leading one, such as via left shifting, to obtain an normalized fraction part of the result y, and the exponent part of the result y is then generated by, for example, counting the number of leading digits shifted off and then subtracting that number from 8, as illustrated in block 16.
      <br/>
      At this point, the exponent part of the result y is unbiased.
      <br/>
      Finally, the floating-point result y is formed by combining the unbiased exponent part and the normalized faction part, as shown in block 17.
      <br/>
      A biased exponent can be obtained by adding 127 to the unbiased exponent.
    </p>
    <p num="19">
      With reference now to FIG. 2, there is depicted an example illustrating a method for performing a logarithmic estimation within a data processing system, in accordance with a preferred embodiment of the present invention.
      <br/>
      An input x for which the logarithmic value is desired, can be represented in a floating-point format, as follows:
      <br/>
      (-1)sign *2expbias -127 *mantissa
    </p>
    <p num="20">
      where sign is a sign bit, expbias is a signed biased exponent, and mantissa is equal to 1.fraction.
      <br/>
      Thus, if x equals 54 in decimal, x=(-1)0 *25 *1.10110000, or 0 1000 0100 1011 0000 in floating-point binary form, where 1000 0100 is the biased exponent and 1011 0000 is the fraction.
      <br/>
      An unbiased exponent can be obtained by subtracting 127 from the biased exponent, yielding 0000 0101.
      <br/>
      Because the unbiased exponent is positive, the sign bit of the result y equals 0.
      <br/>
      An unnormalized mantissa can be obtained by utilizing a table lookup (such as Table I shown below) with the fraction bits as the input.
      <br/>
      In this case, the last row of Table I is utilized.
      <br/>
      The unbiased exponent is then concatenated with the unnormalized mantissa, with a binary point in between, to form an intermediate result.
      <br/>
      The value of the intermediate result equals 0000 0101.1100 0000, with 0000 0101 as the unbiased exponent and 1100 0000 as the unnormalized mantissa.
    </p>
    <p num="21">
      The intermediate result is subsequently normalized in order to obtain the fraction part of the floating-point result y. The normalization can be performed by left shifting the intermediate result to remove all leading zeros and the leading one.
      <br/>
      The leading one is considered as the implied "1." The exponent part of the result y can be obtained either by subtracting the number of leading digits (i.e., the leading zeros and the leading one) shifted off from 8, or by subtracting 1 from the number of significant bits to the left of the binary point of the unnormalized mantissa.
      <br/>
      In this example, the shifting method is utilized to remove a total of six bits.
      <br/>
      Thus, the exponent of the result y should equal 8-6=2 or 0000 0010 in binary; and the fraction part becomes 0111 0000.
      <br/>
      After adding the bias 127 to the exponent, the biased exponent becomes 1000 0001.
      <br/>
      Finally, the result y can be obtained by combining the sign bit, the biased exponent, and the normalized fraction to yield 0 1000 0001 0111 0000 or 5.75 in decimal.
      <br/>
      The error of this estimated floating-point result y is 0.085% when compared with the precise result of 5.7549.
    </p>
    <p num="22">B. Implementation</p>
    <p num="23">
      Referring now to FIG. 3, there is depicted a block diagram of a general purpose processor in which a preferred embodiment of the present invention may be incorporated.
      <br/>
      Within a processor 30, a bus interface unit 32 is coupled to a data cache 33 and an instruction cache 34.
      <br/>
      Both data cache 33 and instruction cache 34 are high speed set-associative caches which enable processor 30 to achieve a relatively fast access time to a subset of data or instructions previously transferred from a main memory (not shown).
      <br/>
      Instruction cache 34 is further coupled to an instruction unit 33 which fetches instructions from instruction cache 34 during each execution cycle.
    </p>
    <p num="24">
      Processor 30 also includes at least three execution units, namely, an integer unit 35, a load/store unit 36, and a floating-point unit 37.
      <br/>
      Each of execution units 35-37 can execute one or more classes of instructions, and all execution units 35-37 can operate concurrently during each processor cycle.
      <br/>
      After execution of an instruction has terminated, execution units 35-37 store data results to a respective rename buffer, depending upon the instruction type.
      <br/>
      Then, any one of execution units 35-37 can signal a completion unit 20 that the instruction execution is finished.
      <br/>
      Finally, instructions are completed in program order by transferring result data from the respective rename buffer to a general purpose register 38 or a floating-point register 39, accordingly.
    </p>
    <p num="25">
      The present invention can be incorporated within the floating-point data flow of processor 30, such as the floating-point multiply-add function contained within floating-point unit 37.
      <br/>
      In addition, the steps described herein can be pipelined to enable a new instruction to begin at every cycle, as long as the new instruction is not delayed by a data dependency on a previous instruction.
    </p>
    <p num="26">A method for performing a logarithm estimation within processor 10 is implemented with the following steps, some of which can be done concurrently:</p>
    <p num="27">Step 1a: Obtain exp in an unbiased signed integer form by subtracting 127 from the biased exponent expbias of the floating-point input x. This step can be done by using an exponent adder often already available in floating-point unit 37 for use in performing other operations.</p>
    <heading>--        TABLE I</heading>
    <p num="28">
      --        x�1:5�      yF�1:12�
      <br/>
      --        00000, 11111          yF�1:6� = x�1:6�
      <br/>
      --        00001                 yF�1:6� = x�1:6� + 000001
      <br/>
      --        0001*, 1101*, 11100   yF�1:6� = x�1:6� + 000010
      <br/>
      --        0010*                 yF�1:6� = x�1:6� + 000011
      <br/>
      --        1100*                 yF�1:5� = 11010;
      <br/>
      --                              yF�6:12� = x�5:11�
      <br/>
      --        11101                 yF�1:6� = 111100;
      <br/>
      --                              yF�7:12� = x�6:11�
      <br/>
      --        11110                 yF�1:6� = 111101;
      <br/>
      --                              yF�7:12� = x�6:11�
      <br/>
      --        all other cases       yF�1:6� = x�1:6� + 000100
    </p>
    <p num="29">
      An "*" in the column for x�1:5� in Table I means either 0 or 1.
      <br/>
      Also, unless explicitly shown in Table I, yF�7:12�=x�7:12�.
    </p>
    <p num="30">Step 1b: Obtain a fraction yF via a table lookup, such as Table I, using the fraction bits of x as input.</p>
    <p num="31">Step 2: Concatenate exp, an integer, to the fraction yF to form an intermediate result y, i.e., yint =exp+yF�1:12�=exp.yF�1:12�.</p>
    <p num="32">Step 3: If exp is negative in a two's complement form, then the two's complement of yint is taken, using the means for complementing the intermediate result in floating-point addition when it is negative, and set the sign of the result y to 1.</p>
    <p num="33">
      Step 4: Normalize yint to get the most significant bit into the implied bit position.
      <br/>
      The number of significant bits in exp is determined by how many bits yint have been left-shifted.
      <br/>
      The number of shifted-off bits (including all leading zeros and a leading one) is then subtracted from 8.
    </p>
    <p num="34">Step 5: Obtain the biased exponent of the result y by adding 127 to the unbiased exponent, which can be done using the exponent adder normally utilized to adjust the exponent after normalization.</p>
    <p num="35">
      In sum, the value of floating-point result y can be obtained from: exp+yF�1:12�, where exp is an unbiased signed exponent of a floating-point input x, and yF�1:12� is a positive fraction that can be derived from a table using only x�1:12�. The remaining bits of input x are ignored.
      <br/>
      Note that, if x�1:12� are all O's and exp equals zero, then x�13:23� will be significant in a floating-point representation.
      <br/>
      Similarly, if x�1:12� are all 1's and exp equal -1, then x�13:23� will also be significant in the same floating-point representation.
      <br/>
      In either one of the above cases, a zero result will be returned.
    </p>
    <p num="36">
      As has been described, the present invention provides an improved method and system for performing a logarithmic estimation within a data processing system.
      <br/>
      Although a low-precision logarithmic estimation is described, it is well understood that higher-precision logarithmic estimation can easily be obtained with the same principle as disclosed.
      <br/>
      Despite its low-precision, the present implementation produces a monotonic result, which is desirable for most applications.
      <br/>
      Even with the low-precision implementation, if the fraction of input x equals zero, then a precise result will always be produced.
    </p>
    <p num="37">
      When the input value x is very close to one, then its logarithmic value is close to zero, and it is difficult to guarantee a relatively high precision.
      <br/>
      In the implementation described above, the result is guaranteed to have an absolute error of less than one part in 32.
      <br/>
      The relative error is guaranteed to be less than one part in eight, except when input x is within the range 7/8&lt;x&lt;11/8.
      <br/>
      Somewhat higher precision within the above range can be obtained by multiplying (x-1) by 1.44, which is the log2 e equivalent to 1/ln2.
      <br/>
      A binary multiplier 1.0111b equal to 1.4375 can be utilized to obtain a better result with minimum hardware.
    </p>
    <p num="38">
      Further, if an unbiased exponent, exp, is defined as exp=expbias -127, then the floating-point number will have a normal range of values when -126 &lt;= exp &lt;= +127.
      <br/>
      The IEEE 754 format also includes a range of values called the denormal range, where expbias =0 and the mantissa=0.fraction; however, the present disclosure will not explicitly deal with values in that range.
      <br/>
      For the logarithm function, input x is not restrained to a small range.
      <br/>
      In fact, input x can even be a denormal floating-point number, although such a case is not explicitly shown in the present disclosure.
    </p>
    <p num="39">While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for executing a floating-point instruction, said method comprising the steps of:</claim-text>
      <claim-text>storing a floating-point number within a memory of a data processing system having a processor, wherein said floating-point number includes a sign bit, a plurality of exponent bits, and a mantissa having an implied one and a plurality of fraction bits; in response to a floating-point instruction:</claim-text>
      <claim-text>- obtaining a fraction part of an estimate number via a table lookup utilizing said fraction bits of said floating-point number as input; - obtaining an integer part of said estimate number by converting said exponent bits to an unbiased representation; - concatenating said integer part with said fraction part to form an intermediate result; - normalizing said intermediate result to yield a mantissa, and producing an exponent part based on said normalizing step; - combining said exponent part and said mantissa to form a floating-point result;</claim-text>
      <claim-text>and storing said floating-point result in said memory.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method according to claim 1, wherein said method further includes a step of complementing said intermediate result if unbiased exponent of said floating-point number is negative.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method according to claim 1, wherein said normalizing step further includes a step of removing leading zeros and a leading one from said intermediate result.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method according to claim 3, wherein said method further includes a step of subtracting the number of leading zeros and said leading one in said removing step from 8.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. A processor capable of performing a logarithmic estimation on a floating-point number, wherein said floating-point number includes a sign bit, a plurality of exponent bits, and a mantissa having an implied one and a plurality of fraction bits, said processor comprising: means for generating a fraction part of an estimate number via a lookup table utilizing said fraction bits of said floating-point number as input; means for obtaining an integer part of said estimate number by converting said exponent bits to an unbiased representation; means for concatenating said integer part with said fraction part to form an intermediate result; means for normalizing said intermediate result to yield a mantissa, and producing an exponent part based on the normalization;</claim-text>
      <claim-text>and means for combining said exponent part and said mantissa to form a floating-point result.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The processor according to claim 5, wherein said processor further includes a means for complementing said intermediate result if said floating-point number is negative.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The processor according to claim 5, wherein said normalizing means further includes a means for removing leading zeros and a leading one from said intermediate result.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The processor according to claim 7, wherein said processor further includes a means for subtracting the number of leading zeros and said leading one in said removing step from 8.</claim-text>
    </claim>
  </claims>
</questel-patent-document>