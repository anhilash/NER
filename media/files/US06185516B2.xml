<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185516B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185516</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185516</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="27503222" extended-family-id="59034156">
      <document-id>
        <country>US</country>
        <doc-number>08946473</doc-number>
        <kind>A</kind>
        <date>19971007</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08946473</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43171829</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>94647397</doc-number>
        <kind>A</kind>
        <date>19971007</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08946473</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>38334195</doc-number>
        <kind>A</kind>
        <date>19950203</date>
        <priority-linkage-type>2</priority-linkage-type>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1995US-08383341</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="3">
        <country>US</country>
        <doc-number>38410095</doc-number>
        <kind>A</kind>
        <date>19950206</date>
        <priority-linkage-type>2</priority-linkage-type>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="3">
        <doc-number>1995US-08384100</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="4">
        <country>US</country>
        <doc-number>90608292</doc-number>
        <kind>A</kind>
        <date>19920629</date>
        <priority-linkage-type>2</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="4">
        <doc-number>1992US-07906082</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="5">
        <country>US</country>
        <doc-number>48943890</doc-number>
        <kind>A</kind>
        <date>19900306</date>
        <priority-linkage-type>2</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="5">
        <doc-number>1990US-07489438</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <term-of-grant>
      <disclaimer/>
    </term-of-grant>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  17/50        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>50</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>703002000</text>
        <class>703</class>
        <subclass>002000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>703014000</text>
        <class>703</class>
        <subclass>014000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>703015000</text>
        <class>703</class>
        <subclass>015000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>716103000</text>
        <class>716</class>
        <subclass>103000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>716106000</text>
        <class>716</class>
        <subclass>106000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-017/50C7</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>017</main-group>
        <subgroup>50C7</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/504</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>504</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>14</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>2</number-of-drawing-sheets>
      <number-of-figures>4</number-of-figures>
      <image-key data-format="questel">US6185516</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Automata-theoretic verification of systems</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>LOGSDON GARY L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4654780</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4654780</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>HAR EL ZVI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5163016</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5163016</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>PILLAGE LAWRENCE T, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5379231</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5379231</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>ALUR RAJEEV, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5483470</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5483470</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>FILKORN THOMAS</text>
          <document-id>
            <country>US</country>
            <doc-number>5491639</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5491639</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>CHENG KWANG-TING, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5513122</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5513122</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Soriano, T.; Concept of Descednt of a Grafcet Model Application to the Reduction of the Model in a Specific Context; Conference Proceedings of the International Conference on Systems, Man and Cybernetics, 1993-Systems Engineering in the Service of Human, Oct. 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Aziz, A.; Singhal, V.; Brayton, R.; Swamy, G. M.; Minimizing Interacting Finite State Machines: A Compositional Approach to Language Containment; Proceedings of the IEEE International Conference on Computer Design: VLSI in Computers and Processors, 1994; Oct. 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Kurshan, R.P.; McMillan, K.L.; Analysis of Digital Circuits Through Symbolic Reduction; IEEE Transactions on Computer-aided Design of Integrated Circuits and Systems; vol. 10, Issue, 11, pp. 1356-1371, Nov. 1991.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>Baumgartner, J.; Heyman, T.; An Overview and Application of Model Reduction Techniques in Formal Verification; IEEE International Performance, Computering and Communications, Feb. 1998; pp. 165-171.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>Soriano, T.; Concept of Descent of a Grafcet Model Application to the Reduction of the Model in a Specific Context; Proceedings of the International Conference on Systems, Man and Cybernetics, 1993, Oct. 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="6">
          <text>Aziz et al., Minimizing Interacting Finite State Machines: A Compositional Approach to Language Containment; Proceedings of the IEEE International Conference on Computer Design, Oct. 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="7">
          <text>Huang et al., "An ECFSM-Based Maximal Progress Protocol Verification", Proceedings of the TENCON '93 IEEE Regional Conference on Computer, Communications, Control and Power Engineering, vol. 1, pp. 527-530, Oct. 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="8">
          <text>Kurshan, R. P., "The Complexity of Verification", Proceedings 26th Annual ACM Symposium on the Theroy of Computing, pp. 365-371, May 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="9">
          <text>Clarke et al., "Formal Methods State of the Art and Future Directions", ACM Computing Surveys, vol. 28, Issue 4, pp. 626-643, Dec. 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="10">
          <text>Macii et al., "Formal Verification of Digital Systems by Automatic Reduction of Data Paths", IEEE Trans. on Computer-Aided Design if IC and Systems, vol. 16, Issue 10, pp. 1136-1156, Oct. 1997.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <continuation-in-part>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>38334195</doc-number>
              <kind>A</kind>
              <date>19950203</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>38410095</doc-number>
              <kind>A</kind>
              <date>19950206</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>90608292</doc-number>
              <kind>A</kind>
              <date>19920629</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>48943890</doc-number>
              <kind>A</kind>
              <date>19900306</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>5691925</doc-number>
              <kind>A</kind>
              <date>19971125</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>5740084</doc-number>
              <kind>A</kind>
              <date>19980414</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>5483470</doc-number>
              <kind>A</kind>
              <date>19960109</date>
            </document-id>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>5163016</doc-number>
              <kind>A</kind>
              <date>19921110</date>
            </document-id>
          </parent-doc>
        </relation>
      </continuation-in-part>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Lucent Technologies Inc.</orgname>
            <address>
              <address-1>Murray Hill, NJ, US</address-1>
              <city>Murray Hill</city>
              <state>NJ</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>LUCENT TECHNOLOGIES</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Hardin, Ronald H.</name>
            <address>
              <address-1>Pataskala, OH, US</address-1>
              <city>Pataskala</city>
              <state>OH</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Kurshan, Robert Paul</name>
            <address>
              <address-1>New York, NY, US</address-1>
              <city>New York</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>DiGiorgio, James</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Teska, Kevin J.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Verification systems which employ automata-theoretic formal verification use a model automaton made from a system process (203) representing the system and a task automaton (205) representing the task and use the model automaton to test (217) whether the language of the system process is contained in the language of the task automaton.
      <br/>
      An improved technique reduces the computational complexity of the language containment testing by producing a model (216) which represents a system which has been automatically localized with regard to a task.
      <br/>
      Another technique reduces the computational complexity of stepwise refinement (208).
      <br/>
      In stepwise refinement, the system automaton is refined a step at a time until it reaches the complexity of a practical implementation.
      <br/>
      The computational complexity of the stepwise refinement is reduced by a technique which permits language containment to be tested using a set of models made from process-automaton pairs rather than process-process pairs.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>CROSS-REFERENCE TO RELATED APPLICATIONS</heading>
    <p num="1">The present application is a continuation-in-part of R. H. Hardin and R. P. Kurshan "Deriving Tractable Subsystem from Model of Larger System," U.S. Ser. No. 08/383,341, filed Feb. 3, 1995, now U.S. Pat. No. 5,691,925 issued Nov. 25, 1997, and R. H. Hardin and R. P. Kurshan "Verification of Homomorphism between Two System Models," U.S. Ser. No. 08/384,100, filed Feb. 6, 1995, now U.S. Pat. No. 5,740,084 issued Apr. 14, 1998, which in turn are both continuations-in-part of Rajeev Alur, et al., "Timing Verification by Successive Approximation", U.S. Ser. No. 07/906,082, filed Jun. 29, 1992 now U.S. Pat. No. 5,483,470, issued Jan. 9, 1996, which in turn is a continuation-in-part of Zvi Har'El et al., "Analytical Development and Verification of Control-intensive Finite State Machines," U.S. Ser. No. 07/489,438, filed Mar. 6, 1990, U.S. Pat. No. 5,163,016, issued Nov. 10, 1992.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="3">The invention relates generally to determining whether a system will perform a given task correctly and more specifically to employing formal verification to make that determination.</p>
    <p num="4">2. Description of the Prior Art</p>
    <p num="5">
      A perennial problem in the design of large systems is verifying that the system will indeed behave in the manner intended by its designers.
      <br/>
      One approach has been simply to try out the system, either by building and testing the system itself or by building and testing a model of it.
      <br/>
      In recent years, this approach has taken the form of a computer simulation of the system.
      <br/>
      A computer program which is a model of the system is written, and the system is tested by executing the computer program.
      <br/>
      A fundamental problem with the approach of "trying out the system" is that the system's designers can only try out behavior which they anticipate.
      <br/>
      For any but the simplest systems, however, the designers cannot anticipate all of the behavior of the system, and it is of course always unanticipated behavior which causes difficulties.
    </p>
    <p num="6">
      As the limitations of simulation have become more apparent, interest has grown in the formal verification of system behavior.
      <br/>
      In formal verification, the designer provides a logical definition of the system's intended behavior and a logical definition of the implementation to a formal verification system.
      <br/>
      The formal verification system then determines whether the logical definition of the system's intended behavior implies the logical definition of the implementation.
      <br/>
      If it does, the implementation is faithful to the logical definition of the intended behavior.
    </p>
    <p num="7">
      A particularly useful kind of formal verification is automata-theoretic verification.
      <br/>
      In this type of formal verification, the system and the desired behavior are both modelled using a particular kind of finite state machine termed an automaton.
      <br/>
      A finite state machine consists of a set of states and a set of transitions between the states.
      <br/>
      A transition from one state to another takes place when a set of variables take on values which are required for the transition to occur.
      <br/>
      For example, an electrical circuit with a light bulb and a switch can be modelled as a finite state machine with two states light on and light off and a variable switch which has the value 0 when the switch is off and the value 1 when the switch is on.
      <br/>
      Transitions between the states take place when the value of switch changes.
      <br/>
      The initial state is light off; the finite state machine remains in the state until switch takes on the value 1.
      <br/>
      At that point, the finite state machine makes the transition to the light on state and remains in that state until switch takes on the value 0, whereupon the finite state machine makes the transition to the light off state.
    </p>
    <p num="8">
      One way of looking at the behavior of a finite state machine is to see it as responding to a sequence of values of the variables.
      <br/>
      For instance, the example finite state machine has only one variable, and that variable can have only two values, 0 and 1, so the example finite state machine will respond to any sequence of 0;0;1;0; and so forth.
      <br/>
      If there were two variables (for example, if the circuit had two switches), the finite state machine would respond to sequences of pairs of values, for example, 0,0; 0,1; and so forth.
    </p>
    <p num="9">
      An automaton is a finite state machine in which certain states are to be defined as final states.
      <br/>
      If an automaton is in one of the final states after it has received a sequence of values, the automaton is said to have accepted the sequence of values.
      <br/>
      In our example finite state machine, either of the two states is a final state, and the finite state machine is consequently an automaton which will accept any sequence of 0's and 1's.
    </p>
    <p num="10">
      In mathematical terms, the set of the sequences of values which an automaton accepts defines a language for the automaton.
      <br/>
      This is important for formal verification because when a system and a task are modelled as automata, the languages of the system and the task can be used to determine whether the system will perform the task.
      <br/>
      If the language defined by the automaton modelling the system is contained in the language defined by the automaton modelling the task, the system will perform the task.
      <br/>
      Otherwise, it will not.
    </p>
    <p num="11">
      The main problem with automata-theoretic verification is that the number of states and transitions in a system of finite state automata which represents a system of any size is so great that the state graphs which the programs that do automata-theoretic verification employ to represent the states of the system may exceed the storage capacity of the computer systems running the programs.
      <br/>
      Indeed, even if storage could be provided, the number of states is often so large that a computer system still would not be able to do the verification in a reasonable amount of time.
      <br/>
      This problem is termed the state-space explosion problem or more generally, the computational complexity problem.
    </p>
    <p num="12">
      The parents of the present patent application all disclose techniques for overcoming the computational complexity problem.
      <br/>
      One set of these techniques involves stepwise refinement of the system model from a simple model which can be verified to have desired properties to a model which has the complexity required for the actual implementation of the system and which can be verified to have inherited the desirable properties from the simple model.
      <br/>
      The techniques for stepwise refinement disclosed in the parent patent applications include the use of language homomorphisms to map behaviors of more detailed models into behaviors of less detailed models.
      <br/>
      As long as there is such a mapping, the behaviors of the more-detailed models preserve the properties of the behaviors of the less-detailed models.
    </p>
    <p num="13">
      Another set of the techniques involves reduction of the language containment test to a set of language containment tests which are together computationally less expensive than the original language containment test.
      <br/>
      The user of the verification system does a reduction by first decomposing the property that is being verified into local properties which, when taken together, imply the property being verified.
      <br/>
      The verification system verifies this implication.
      <br/>
      Then, the verification system "localizes" the system being verified with regard to each of the local properties.
      <br/>
      It does this by taking advantage of the fact that only a small part of the system being verified is concerned with the local property.
      <br/>
      Consequently, the rest of the system may be "abstracted away", and the verification need be done only on the part which is concerned with the local property.
      <br/>
      If the verification succeeds for all of the local properties, then the property has been verified for the entire system.
    </p>
    <p num="14">
      A more detailed discussion of the foregoing techniques for dealing with the computational complexity problem and an example may be found at columns 17 through 70 of "Verification of Homomorphism Between Two System Models," U.S. Pat. No. 5,740,084 issued Apr. 14, 1998, which is incorporated herein by reference.
      <br/>
      A description of a verification system which employs the stepwise refinement and reduction techniques described above may be found in Zvi Har'El et al., "Analytical Development and Verification of Control-intensive Finite State Machines," U.S. Pat. No. 5,163,016, issued Nov. 10, 1992. That patent is hereby incorporated into the present patent application by reference.
    </p>
    <p num="15">
      The use of stepwise refinement and reduction in the system of U.S. Pat. No. 5,136,016 represented a major step in dealing with the problem complexity.
      <br/>
      Automata-theoretic verification however remains an expensive undertaking in terms of both computation time and memory resources.
      <br/>
      It is an object of the present invention to provide improved techniques for stepwise refinement and reduction which further reduce the cost of automata-theoretic verification.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="16">The object of the present invention is attained by means of two techniques for reducing the size of the model automata used to test language containment and thereby reducing the computational complexity of the test.</p>
    <p num="17">
      The first technique reduces the size of the automaton by employing a directed dependency graph of the model automaton's variables to make a reduced model automaton which is the equivalent of the original automaton for the purposes of testing language containment.
      <br/>
      In a preferred embodiment, the technique is used to automatically produce a model automaton in which the system component of the model has been localized with regard to the task component so that only those portions of the system model which are relevant to the task specified by the task component are included in the model automaton.
    </p>
    <p num="18">
      The second technique is used in stepwise refinement.
      <br/>
      Stepwise refinement involves checking language containment with model automata made from processes between which there is a language homomorphism.
      <br/>
      Testing language containment with such model automata is computationally substantially more complex than testing language containment with model automata made from a process and an automaton.
      <br/>
      The technique avoids the necessity of making the model automaton from a pair of processes by transforming one of the processes into a sequence of automata and thereby permitting the language containment testing to be done on model automata made from a process and an automaton.
    </p>
    <p num="19">
      Other objects and advantages of the apparatus and methods disclosed herein will be apparent to those of ordinary skill in the art upon perusal of the following Drawing and Detailed Description, wherein:
      <br/>
      BRIEF DESCRIPTION OF THE DRAWING
      <br/>
      FIG. 1 is a diagram showing a homomorphism;
      <br/>
      FIG. 2 is a block diagram of a formal verification system;
      <br/>
      FIG. 3 is a detailed diagram of a model reducer employed in the system of FIG. 2; and
      <br/>
      FIG. 4 is a diagram of a directed graph of variable dependency.
      <br/>
      Reference numbers in the Drawing have two parts: the two least significant digits are the number of an item in a figure; the remaining digits are the number of the figure in which the item first appears. Thus, an item with the reference number 201 first appears in FIG. 2.
    </p>
    <heading>DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT</heading>
    <p num="20">
      The following Detailed Description will first describe the improved techniques for reduction and then the improved techniques for refinement.
      <br/>
      In both cases, a discussion of the theoretical basis of the techniques will be presented first; thereupon, a discussion of their implementation in a preferred embodiment will be presented.
    </p>
    <p num="21">Theory of Localization Reduction using Reduced Models</p>
    <p num="22">
      As pointed out above, automata-theoretic verification approaches verification as a language containment problem: if the language defined by the automaton modelling the system is contained in the language defined by the automaton modelling the task (property), the system will perform the task (i.e., have the property).
      <br/>
      The following discussion will first describe generally how it is determined whether one language is contained in another and will then describe the task decomposition and task localization techniques employed to make it computationally tractable to determine whether the language of a system automaton is contained in the language of a task automaton.
    </p>
    <p num="23">Determining Language Containment</p>
    <p num="24">
      The automata employed in the verification systems disclosed in the parents of the present application are  OMEGA -automata.
      <br/>
      Such automata accept sequences of infinite length.
      <br/>
      Because this is the case, they have acceptance structures which are different from those of automata which accept finite sequences (strings).
      <br/>
      An acceptance structure for an automaton defines the sequence of states of the automaton which accepts a word in the automaton's language.
      <br/>
      Because  OMEGA -automata accept sequences of infinite length, their acceptance structures are acceptance cycles of states instead of final states.
      <br/>
      An acceptance cycle of states for a given sequence of states is the cycle of states in which the given sequence remains.
      <br/>
      To check language containment with  OMEGA -automata, one determines whether all of the cycles of the finite state automaton representing the system are contained in the acceptance cycles of the finite state automaton representing the task.
      <br/>
      If they are, the system performs the task.
    </p>
    <p num="25">
      An efficient way of making that determination is to first make a complement task automaton whose language is the set complement of the language of the task automaton.
      <br/>
      Having done this, one makes an automaton which is the product of the system automaton and the complement task automaton and determines whether the language of that product automaton is the empty set.
      <br/>
      If that is the case, none of the cycles of the system automaton are contained in the complement task automaton, and consequently, all of the cycles of the system automaton must be contained in the acceptance cycles of the task automaton.
      <br/>
      In the following, the product automaton upon which the containment test is performed is termed the model automaton or simply the model.
    </p>
    <p num="26">
      One way of determining whether the language of the model is the empty set is based upon explicit state-space enumeration.
      <br/>
      This technique works as follows: all of the cycles in an automaton are captured by the set of strongly connected components of the directed graph representing the automaton. (In the graph, states are vertices and transitions are edges.
      <br/>
      The graph is directed because a given transition only goes in one direction.) A strongly connected component of a directed graph is a nonempty set of vertices maximal with respect to the property that any ordered pair of vertices from the set are connected by a directed path from the first to the second.
      <br/>
      Thus, to determine whether the language of the model is the empty set, one constructs the set of strongly connected components and determines whether it contains any cycles which are accepted by the automaton acceptance structure; if it does, there are cycles of the system automaton which are not contained in the acceptance cycles of the task automaton and the system does not perform the task.
      <br/>
      The cycles which are accepted by the automaton acceptance structure are termed the model automaton's error track, and as described below, the error track can be used to correct either the system or the model automaton.
    </p>
    <p num="27">Task Decomposition and Task Localization</p>
    <p num="28">
      The difficulty with the foregoing technique is that the directed graph representing the model may be still too large to be searched by a computer.
      <br/>
      This problem is dealt with in the verification system being described herein by task decomposition and task localization.
    </p>
    <p num="29">
      In task decomposition, the task to be verified is decomposed into local tasks such that the intersection of the languages of the local tasks is contained in the language of the entire task.
      <br/>
      When that is true, the system will perform the task if, for each of the local tasks, the language of the system is contained in the language of the local task.
      <br/>
      In the preferred embodiment, task decomposition is done by the person verifying the system.
      <br/>
      That person uses his knowledge of the system and the task to make the decomposition, and the verification system then verifies that the intersection of the languages of the local tasks is contained in the language of the entire task.
    </p>
    <p num="30">
      Task decomposition is used together with task localization.
      <br/>
      The models made using both task decomposition and task localization are made from a local task automaton and a localized system automaton.
      <br/>
      Each localized system automaton has been localized with respect to its local task automaton, that is, those portions of the system automaton which are not relevant to the local task automaton are abstracted away.
      <br/>
      This makes the computation of the language containment significantly less complex than when it is done with a model made from the system automaton and the task automaton.
      <br/>
      But the language containment test remains valid if each of the localized models pass the test, the language of each of the localized system automata is contained in the language of its corresponding local task automaton and the language of the entire system is contained in the language of the entire task.
      <br/>
      For a complete mathematical exposition of the foregoing, see columns 317 through 331 of "Verification of Homomorphism Between Two System Models," U.S. Pat. No. 5,740,084.
    </p>
    <p num="31">Finding Localized Models</p>
    <p num="32">
      As will be apparent from the foregoing, a major problem in automata-theoretic verification is finding a set of localized models for which computation is substantially less complex than for the model made from the entire system automaton and the entire task automaton but which nevertheless yield valid verification results.
      <br/>
      The present application presents a novel solution to that problem which automatically finds a relatively small localized model for each of the local task automata.
    </p>
    <p num="33">
      At the highest level, the technique works as follows: first, a localized model is made from the local task automaton and a reduced system automaton which has relatively few constraints.
      <br/>
      Beginning with that model, the following iteration is performed: the language containment test is done using the current localized model; if it passes, the iteration ceases: otherwise, an error is returned from the language containment test; that error is tested to determine whether it represents a real error in the system or is simply an artifact resulting from insufficient constraints in the localized model.
      <br/>
      In the former case, a real error has been found and the iteration terminates; in the latter case, the results of the test of the error are then used to make a new localized model with more constraints.
      <br/>
      The next iteration uses the new localized model as the current localized model and the iterations continue until a localized model is found that passes the containment test or a real error is found in the system automaton.
      <br/>
      The same iteration is repeated for each of the local tasks, and when a localized model which passes the containment test has been found for each of the local tasks, the containment of the language of the entire system automaton in the entire task automaton has been verified.
    </p>
    <p num="34">
      In a preferred embodiment, the localized models are found by first making a directed dependency graph for the model made from the local task automaton and the entire system automaton.
      <br/>
      The graph shows the dependencies between the local task and the entire system task.
      <br/>
      In a preferred embodiment, the states of the model and the transitions between the states are represented by variables, and the dependency graph shows dependency relations between these variables.
      <br/>
      Once the graph is made, it is used to make the model, with the beginning constraints being determined by the user of the verification system.
      <br/>
      If the user does not specify any constraints, the first model is made from the local automaton from the local task and the empty set (representing a localized system automaton which imposes no constraints on the model) or from a default first model supplied by the user.
      <br/>
      Continuing with the case of the empty set, the empty set is contained in any set, and consequently, the containment test on the localized model fails unless the task is trivially true.
    </p>
    <p num="35">
      In the preferred embodiment, when a containment test fails, the error track produced by the verification system contains a counter example, that is, a sequence of transitions in the language of the system automaton being tested which is not contained in the language of the task automaton being tested.
      <br/>
      Next, the verification system determines whether the counter example from the error track is contained in the language of the entire system automaton.
      <br/>
      If it is, the counter-example is a real error and the verification system has shown that the entire system does not perform the entire task.
      <br/>
      Otherwise, this containment check produces a second error track.
    </p>
    <p num="36">
      If the error track is not contained in the language of the entire system, then the error track was caused by the fact that the current localized model was not sufficiently constrained to pass the containment test and information from the second error track is used to determine the portion of the dependency graph from which the new localized model is to be made.
      <br/>
      The new localized model is then tested for language containment as described above, and the iterations continue until either the system automaton is demonstrated to contain an error or a localized model has been found for which the containment test succeeds.
      <br/>
      As may be seen from the foregoing, the limit for the localized model is one made using the entire system automaton.
    </p>
    <p num="37">
      For each local task automaton, a localized model is found in the manner just described, and if the containment test succeeds for all of the models, the verification system has verified that the entire system performs the entire task.
      <br/>
      A detailed mathematical exposition of the foregoing may be found in Section 8.4 of Appendix A at columns 351 through 356 of "Verification of Homomorphism Between Two System Models," U.S. Pat. No. 5,740,084. More specifically, the foregoing describes the follow(p,P) algorithm set forth in section 8.4.2 therein.
    </p>
    <p num="38">Implementation of Reduction: FIG. 2-4</p>
    <p num="39">The following discussion will provide an overview of a formal verification system which employs the localization techniques described above and will then provide details of an implementation of the techniques in that system.</p>
    <p num="40">A Formal Verification System: FIG. 2</p>
    <p num="41">
      In a preferred embodiment, the technique described above is implemented as a new component of a verification system of the type described in U.S. Pat. No. 5,163,016. FIG. 2 is a block diagram of such a verification system.
      <br/>
      Verification system 210 takes as its input a description 203 of the entire system to be verified and descriptions 205(0. . . n) of the entire task and local tasks for which it is to be verified.
      <br/>
      The user of the system makes the local tasks from the entire task by the task decomposition and verification techniques previously described.
    </p>
    <p num="42">
      In a preferred embodiment, descriptions 203 and 205 are written in a programming language which is explained in an appendix of U.S. Pat. No. 5,163,016. In the descriptions, the states of the automaton are defined by means of sets of values of state variables or stvars and the transitions are defined by means of sets of values of selection variables or selvars.
      <br/>
      When an automaton is in a state defined by a set of values of the state variables, a transition to another state occurs when the set of selection variables defined for the transition satisfies a set of tests defined for the transition.
      <br/>
      That set of values for the variables is termed the predicate of the transition.
      <br/>
      In most cases, the descriptions specify ranges of values for the state variables and selection variables.
    </p>
    <p num="43">
      For example, in the case of the light bulb automaton, the light on state of the light bulb automaton would be defined by a single state variable, called perhaps light13 state and a value 1 representing the light on state.
      <br/>
      The light off state would then be represented by the value 0 of that variable.
      <br/>
      The selection variable for the automaton is the variable switch, and the predicate for the transition from the light off state to the light on state is that the selection variable switch is equal to 1; similarly, the predicate for the transition from the light on state to the light off state is switch=0.
      <br/>
      Both the light_state state variable and the switch selection variable would be specified to have values in the range (0,1).
    </p>
    <p num="44">
      Another important aspect of these descriptions is that they define the acceptance structures of the automata in terms of recur edges and cycle sets or cysets.
      <br/>
      A recur edge is a transition which is crossed infinitely often by a sequence which is accepted by the automaton.
      <br/>
      A cycle set is a set of states which makes up an acceptance cycle for the automaton.
      <br/>
      The light bulb automaton will accept any infinite sequence of 0's and/or 1's, and consequently, all of the transitions in the automaton are recur edges and there is a cycle set including both states.
    </p>
    <p num="45">
      The descriptions of the system and task automata are input to a translator 207, which produces internal representations (IREPS) 208 of automata for the task and system.
      <br/>
      System automata in the following are represented by S and task automata by T. In a preferred embodiment, the internal representations are parse trees made from descriptions 203 and 205.
    </p>
    <p num="46">
      As described above, verification in system 201 is essentially a matter of determining whether the language of one  OMEGA -automaton is contained in another  OMEGA -automaton, and this in turn is done by examining the state of a model automaton made from the two automata whose language containment is to be verified.
      <br/>
      In system 201, the models are made by model maker 223, which receives parse trees of automata as inputs and provides parse trees of models made from the automata as outputs.
    </p>
    <p num="47">
      The containment testing on the models is done by language containment tester 217, which takes a model as an input and performs the language containment test on the model.
      <br/>
      If the containment test fails, language containment tester 217 produces an error track 219 which itself describes an automaton E. As shown by arrow 221, E can then be provided to model maker 223 together with another automaton to make a new model, which can then be tested by language containment tester 217 to determine whether the error is a real error or is an artifact of the choices made in decomposing a task.
    </p>
    <p num="48">
      Language containment tester 217 employs known techniques for testing language containment.
      <br/>
      In brief, language containment tester 217 receives the parse tree of the model being tested for language containment and makes a working representation of the model which permits the states which result from the operation of the model to be explored.
      <br/>
      The working representation implements a function which takes a global state of the model and a predicate for a transition and then produces the new global state that results from the application of the predicate to the old global state.
      <br/>
      The global state is represented by a set of values of the state variables and the predicate is represented by a set of values of the selection variables.
      <br/>
      The operation of this function is termed cranking in some of the following discussion.
    </p>
    <p num="49">
      Each predicate is marked to indicate whether it is a recur edge and each global state is marked to indicate whether it belongs to a cycle set.
      <br/>
      These marks are used to construct a result graph of sets of global states which contains none of the cycle sets of the model for which containment is being tested.
      <br/>
      If the result graph nevertheless contains a cycle, the language containment test has failed and the cycle is reported in the error track.
      <br/>
      One technique for making a result graph is to use a reached state table of the states; an example of such a technique is that described in U.S. Pat. No. 5,163,016. Another technique for making a result graph employs binary decision diagrams (BDD's), as described in K. L. McMillan Symbolic Model Checking, Kluwer, 1993.
    </p>
    <p num="50">Implementation of System Localization</p>
    <p num="51">
      The automatic system localization techniques described above are implemented in model reducer 216 of FIG. 201. Model reducer 216 takes a local task automaton TL 210 and a system automaton S as its inputs and produces two models therefrom: an optimistic model Mo 214 and a pessimistic model Mp.
      <br/>
      The optimistic system automaton Mo is a model made with an optimistic localization of system automaton S with regard to TL, while Mp is made with a pessimistic localization of that system automaton with regard to that local task.
      <br/>
      In the preferred embodiment, the user defines Mp via input 213.
      <br/>
      The user may simply define Mp as the model made with ML and S or may define a somewhat smaller model as Mp if he wishes to limit the amount of time spent checking language containment.
      <br/>
      In the preferred embodiment, the user may also define a first Mo via inputs 212 and 216; if the user does not, the system begins with a Mo that is guaranteed to fail the containment test.
    </p>
    <p num="52">Once Mo and Mp are defined, the iteration previously described begins.</p>
    <p num="53">
      Language containment tester 217 tests the current Mo for language containment and if any error track 219 results, provides the error track 219 to model maker 223 (arrow 221), which makes a model from the error track E and Mp.
      <br/>
      That model is then provided to tester 217 for containment testing.
      <br/>
      If the model passes, the error is real.
      <br/>
      If the model does not pass, error track 219 from the test against Mp is used to derive information 220 which is used in model reducer 216 to produce a new larger Mo.
      <br/>
      The iterations continue until a real error is found, until an Mo is found which passes the containment test or until Mo =Mp.
    </p>
    <p num="54">Details of Model Reducer 216: FIG. 3</p>
    <p num="55">
      Continuing with details of model reducer 216, in a preferred embodiment, model reducer 216 has four components: dependency graph maker 301, dependency graph 303, fence maker 305, and subgraph maker 307.
      <br/>
      Dependency graph maker 301 makes dependency graph 303 from the internal representation 208 of the model made from internal representations 208 of entire system automaton S 211 and local task automaton TL 210.
      <br/>
      As will be described in more detail below, fence maker 305 makes "fences" in dependency graph 303 which define subgraphs of dependency graph 303.
      <br/>
      Subgraph maker 307 makes and prunes the subgraphs defined by the fences and the pruned subgraphs in turn define a current Mo automaton and the Mp automaton.
    </p>
    <p num="56">Details of Dependency Graph 303</p>
    <p num="57">
      FIG. 4 shows dependency graph 303.
      <br/>
      Dependency graph 303 is a directed graph of dependency relationships between the variables (both stvars and selvars) of the model made from entire system automation S and local task automation TL.
      <br/>
      A first variable is dependent on a second variable if a value contained in the second variable is assigned to the first variable or if a value contained in the second variable determines whether a value is assigned to the first variable.
      <br/>
      Thus, in the light bulb automaton, the state variable light_state is dependent on the selection variable switch.
      <br/>
      There is a vertex 401(i) for each variable in the model, for each variable in system automaton S. Whenever a first variable is dependent on a second variable, there is an edge 405 from the second variable to the first variable.
      <br/>
      When graph 303 is constructed from the parse tree for the model, construction begins with the variables 401 of the model which come from task automaton TL.
      <br/>
      These variables are termed the "root variables" of graph 303.
      <br/>
      The graph then includes all-variables of the model S upon which the root variables 401 depend.
      <br/>
      The more edges there are between a given variable 403(j) of system automaton S and a root variable 401(i), the more remote the dependence of variable 401(i) on variable 403(j).
    </p>
    <p num="58">
      Because graph 303 is arranged as described above, it can be used to define a localized model Mo for a system automaton S which has been localized with respect to local task automation TL whose variables form the root of graph 303.
      <br/>
      First, if the variables of TL are all independent of a given variable of S, the given variable of S will simply not be one of the variables of model variables 403.
      <br/>
      Second, the more remote a given variable 403(j) is from a root variable 401(i) in graph 303, the more likely it is that the given variable 403(j) is not relevant to determining whether the language of system automaton S is contained in the language of local task automaton TL.
    </p>
    <p num="59">
      The preferred embodiment employs the foregoing properties of graph 303 to define Mo 's which are decreasingly localized with regard to TL until an Mo is found which passes the containment test or a real error is found.
      <br/>
      Conceptually, an Mo which is localized with regard to TL can be defined from graph 303 simply by drawing a line or "fence" (for example, line 407) across the graph such that all of the variables of TL are on one side of the line.
      <br/>
      The fence 407 defines a subgraph 411 consisting of the model variables 403 on the root side of fence 407 and that subgraph is used to define Mo defined by fence 407.
      <br/>
      If the check fails, fence 407 is moved away from root 401 to define a new subgraph, the new subgraph is used to define a new Mo, the language containment check is made on the Mo, and so forth.
    </p>
    <p num="60">
      In a preferred embodiment, fence 407 is defined by a list of state variables.
      <br/>
      The state variables on the list and those variables 403 in graph 303 which are further from root 401 than the state variables on the list are not part of the Mo defined by fence 407; all other variables 403 in graph 303 are.
      <br/>
      Fence 407 is defined and redefined in model reducer 216 by fence maker 305.
      <br/>
      In the preferred embodiment, the user of verification system 201 may provide fence maker 305 with a bound list of variables 216 and an unbound list of variables 212 to define an initial fence 407 for Mo as well as a list of variables which defines a fence for a pessimistic model Mp.
      <br/>
      The fence for pessimistic model Mp appears in FIG. 5 as fence 409.
      <br/>
      As will be explained in more detail in the following, fence maker 305 moves fence 407 in the preferred embodiment in response to an error track produced from the model made from the error track produced by the preceding model Mo is tested for containment.
      <br/>
      The former error track is used to produce variable lists 220, which are used to define the new position of fence 409.
    </p>
    <p num="61">Details of Subgraph Maker 307</p>
    <p num="62">
      Subgraph maker 307 makes the subgraphs representing Mo and Mp.
      <br/>
      There are three steps to making the subgraphs:
    </p>
    <p num="63">
      determining the subgraph defined by the relevant fence;
      <br/>
      "freeing" variables in the free list which defines the fence; and
      <br/>
      resizing variables in the subgraph.
    </p>
    <p num="64">
      The first step forms a new variable dependency subgraph by first removing every edge which enters a vertex in the free list whose variable is not of type integer.
      <br/>
      Integer variables are those which do not have defined ranges in system description 203 or task descriptions 205.
      <br/>
      The subgraph then consists only of those vertices for which there is still a directed path from the vertex to one of the task variables 401.
      <br/>
      The second step frees all variables in the free list for which a range of values has been defined in the original descriptions of the automata.
    </p>
    <p num="65">
      Freeing a variable in the present context means permitting the variable to take on any value in a range which was defined for it in the original descriptions of the automata.
      <br/>
      Because the variable has been freed, the states of the automaton defined by the subgraph will include any state reachable by any transition which includes one of the possible values of the variable.
      <br/>
      Freed variables consequently will not constrain the behavior of the automaton defined by the subgraph.
      <br/>
      As is apparent from the foregoing, integer variables cannot be freed because there is no limit to the range of values they can take.
    </p>
    <p num="66">
      The resizing step redefines the ranges of selection variables in the subgraph so that the range of a given selection variable includes all of the values which it may have anywhere in the subgraph.
      <br/>
      It is done like this:
    </p>
    <p num="67">
      1. for each variable x, check if
      <br/>
      a. every appearance of x is of the form:
    </p>
    <p num="68">
      - x=constant
      <br/>
      - or
      <br/>
      - x=constant
      <br/>
      - or
      <br/>
      - (x: constant_list)
      <br/>
      - and
      <br/>
      b. if x is the unique selvar of a proc A. then every appearance of `A:`
      <br/>
      - is of the form: (A: constant_list) and
      <br/>
      c. the union of the constants and constant_lists of a) and b) omits at least 2 elements in the range of x: so, this excludes -&gt;x,x&lt;5 and x+1=5, for example
    </p>
    <p num="69">
      2.
      <br/>
      Then, if a-c hold, and % is the 1st value in the range of x omitted redefine the range of x to be the union of c) and the value %: call that value new_range.
      <br/>
      If x is freed, then it can be assigned values is relative to new_range.
      <br/>
      Otherwise, x is not freed: in this case, suppose F is the (logical) expression to which x is assigned (ie, the assignment of x is equivalent to x:=F or x-&gt;F); then redefine the assignment of x as:
    </p>
    <p num="70">x:=F? (F: new_range) .vertline.%</p>
    <p num="71">(or x-&gt;F ?, accordingly).</p>
    <p num="72">This re-definition of the assignment of x is important on account of the reducing step.</p>
    <p num="73">The variables of the subgraph, resized as set forth above, then make up the automaton Mo or Mp defined by the subgraph.</p>
    <p num="74">Details of Moving the Fence</p>
    <p num="75">
      As indicated above, if Mo defined by a fence 407 is not constrained enough to pass the language inclusion test, the fence must be moved.
      <br/>
      Fence maker 305 does this in response to three variable lists 220, Vars_f, Vars_c, and Vars_r, returned from containment tester 217 as described above.
      <br/>
      The following discussion will first give details about how containment tester 217 computes these sets of variables and then give details about how the variables are used to calculate the new fence.
    </p>
    <p num="76">
      The variable lists 220 are produced by a routine in containment tester 215 that tests whether the language LE defined by the error track from the containment check for L(Mo) is contained in L(Mp).
      <br/>
      In the test, the error track defines an automaton E. E is treated as a process with state transitions enabled by `true` from its i-th (vector) state to its (i+1)-st (vector) state, for all I up to the length of E in the case of a finite E, i including the additional back-edge, in the case of a "Bad cycle" E. The routine performs the containment test by checking that each "next-state" of the automaton SXT which is the product of the automata Mp and TL matches the corresponding next-state of E (i.e., consider the state variables of E that also belong to SXT their respective values in E are checked for a match with those in SXT for each next-state of SXT and the (unique) next-state of E.) If there is no match, truncate that transition.
    </p>
    <p num="77">
      A state of SXTXE with every exiting transition thus truncated is called a lock-up.
      <br/>
      For each lock-up state V, for each selection valid at V, let v be the 1st state component of E which fails to have its next-state value match the next-state value of v in E, say v=v_i+1.
      <br/>
      If v=v_i is the current-state value of v (i.e., value of v in V), look at the variables which enable the transition v_i-&gt;v_i+1.
      <br/>
      Call these Vars(V).
      <br/>
      We compute Vars(V) during the crank, setting Vars(V)=0 at the end of crank, if it turns our that V is not a lock-up. Note that Vars(V) will consist only of variables of Mo (free or otherwise).
    </p>
    <p num="78">
      Vars(V) is computed like this: For each selection (in SXT at V, as we crank out the stvar's of SXT case RESOLVE), for each stvar v which is a component of E, check if the next-state matches the required next-state value in E. If yes, continue; if not, stop case RESOLVE for that selection, and add to Vars(V) some variables which collectively disable the transition from the current value of v to the required next value of v. If this particular set of variables is too hard to compute, get as close as practical (too many variables is ok; too few is not allowed); for example, all variables upon which v is dependent gives a list, when a finer list is impractical.
      <br/>
      Add these variables to Vars(V), and pick the next selvar (valid at V) to crank.
      <br/>
      Continue like this until all selvars are cranked.
      <br/>
      If for any selection, the required next-state match occurs, set Vars(V)=0, and set a flag to ensure that it stays=0 for the rest of the selvar cranks (but, continue to crank all selections from V, as there may be other states with next-state matches: we want them all).
    </p>
    <p num="79">There are 3 possible conclusions to the run of SXTXE:</p>
    <p num="80">
      Case 1: If E is a "finite" error track ("No transition", "Lockup", etc), we reach the last state of E in SXTXE, and reproduce the same error, or another error which results in the same finite error track, or an infinite error track consisting of a "Bad cycle" self-loop at the final state of E; or, E is an "infinite" error track ("Bad cycle") and we reach the end of E, and then can continue to cycle in the Post modern cycle of E, eventually reaching the same state of SXTXE twice AND the verification system reports the result in SXTXE as a "Bad cycle" (ie, not accepted by a cyset/recur in SXT).
      <br/>
      In either case, the result is a real error.
      <br/>
      Thus, as soon as this case applies (if at all), we stop.
    </p>
    <p num="81">
      Case 2: The conditions defining Case 1 fail, meaning that E is an artifact of the optimistic model Mo.
      <br/>
      This situation can arise for several reasons, which we separate into Case 2 and Case 3.
      <br/>
      One reason Case 1 may fail is that we fail to reach the end of the E track (for all possible init matches of E in S, and all possible selections along the path of E).
      <br/>
      In this case, let vars=+character pullout}Vars(V) (union over all lock-ups V) and let Vars_f be the elements of Vars which are in the active Mo (free-) list. Note: there is a possibility that Vars_f is empty. Set Vars_c=Vars_r=0.
    </p>
    <p num="82">
      Case 3: Suppose Cases 1 and 2 don't apply.
      <br/>
      In case E itself is infinite (ie, a Bad cycle track) and we reach the last state of E, with one or more additional transitions through the `Post mortem` loop of E, arriving finally twice to the same state of SXTXE, but the verification system reports the result in SXTXE as "Task performed", then look at the cyset check at the end of the run: each SCC (strongly connected component) must have been contained in some cyset of SXT. (This applies for each match of init's in S, and each branch in SXTXE which follows E, so there may be several.) Each such cyset must have involved stvar's which are NOT components of E. Let Vars_c be the set of all these.
      <br/>
      Furthermore, let Vars_r be the set of stvar's crossing recurs after the `Post Mortem` point of E. (These will be stvar's of S not in E. These stvar's arising from recurs are treated the same as the stvar's in Vars_c, defining the set Vars_r.
      <br/>
      If we don't ever arrive to the same state twice, for any init's match (although we've reached or passed the end of E), then we are in the same logical condition as Case 2, and we proceed analogously.
      <br/>
      In all these possibilities, we define Vars and Vars_f as in Case 2.
      <br/>
      Thus, in Case 3, we have Vars_f, Vars_c and Vars_r defined. (Note that Case 3 includes the possibility that some embeddings of E in SXT XE fall under Case 2; there may be several embeddings of E, defining respective Vars_c and Vars_r; the definitions of all the Vars_* accumulate over these respective embeddings.)
    </p>
    <p num="83">Computing the new Mo</p>
    <p num="84">
      We need to define a new (more pessimistic) optimistic model M0.
      <br/>
      The technique for doing so involves the use of disconnects: Let x be any variable.
      <br/>
      A variable d is a disconnect of x if every path in the dependency graph from d to x goes through a stvar not equal to d. A disconnect d of x is "minimal" if some path from d to x does not pass through another disconnect of x.
    </p>
    <p num="85">Compute a new Mo free list L' as follows from the previous Mo list L and Vars_f, Vars_c, Vars_r:</p>
    <p num="86">
      Case 1: Vars_f non-empty.
      <br/>
      For L' from L by removing from L each element of Vars_f, and add to L' each disconnect d of an element of Vars_f, unless d is in the root list of Mp. Since the pruning step will remove all non-minimal disconnects, they need not be added to L'.
      <br/>
      Case 2: Vars_f=0, Vars_c and/or Vars_r non-empty.
    </p>
    <p num="87">Let Vars_cc be the set of elements of Vars_c and Vars_r which are closest (in the dependency graph) to element of L. Set Vars_f to be the set of elements v of L for which there is a path in the dependency graph from an element of tt Vars_cc to v. Then apply case 1.</p>
    <p num="88">
      Case 3: Case 4: Vars_f=0, Vars_c=0, Vars_r=0.
      <br/>
      If Case 3: Vars is non-empty and there is a unique variable in L closest to Vars (in the dependency graph), or
      <br/>
      Case 4: there is more than one variable in L closest to Vars (if Vars=0, we consider all the variables of L to be closest to Vars).
      <br/>
      Set Var_f to be these, and apply Case 1.
    </p>
    <p num="89">In each case, this gives the new Mo list. (Note: as a fail-safe mechanism, we return an (internal) error and stop, if N&gt;number of variables in the Mp model, a logical impossibility.)</p>
    <p num="90">Using Minimal Flow to Determine Fence Location</p>
    <p num="91">
      One of the factors which determines the computational complexity of language containment done using the model is the number of values in the ranges of the variables of the model.
      <br/>
      One consideration in moving fence 407 is picking a new location for fence 407 which minimizes the number of these values.
      <br/>
      In a preferred embodiment, this is done by means of a minimal flow computation.
    </p>
    <p num="92">
      In a preferred embodiment, the fence is defined by a list of state variables.
      <br/>
      The variables which define the fence are free and the variables between the fence and the root are active, that is their values are determined by the values assigned to the free variables.
      <br/>
      When the fence is moved, the old free variables become active and the state variables defining the new fence location become active.
      <br/>
      In the preferred embodiment, the new location of the fence is determined as follows:
    </p>
    <p num="93">
      Starting with:
      <br/>
      the active variables, the old free fence on its boundary,
      <br/>
      and a set vars_f of old free fence variables to be made active,
    </p>
    <p num="94">
      Find:
      <br/>
      the new set of active variables, by finding its new free fence on its boundary.
      <br/>
      The new free fence will always have a minimal product of free selections given what stvars are active, and if the user provides a limit for the product with the --freesels=parameter, successive stvars will be activated until the limit is met.
    </p>
    <p num="95">So: given the old active vars and the free-fence vars to be made active: make the new vars active.</p>
    <p num="96">
      Now find successive stvar fences starting from the new active vars, and going outward through free variables.
      <br/>
      Label the stvar fences 1.2 . . . N. Set VCUT =N+1.
    </p>
    <p num="97">These are the forward stvar fences, selected by the set of variables to be made active.</p>
    <p num="98">Now label any other stvar fences encountered starting from all active variables (the backward fences) N+2. . . NN.</p>
    <p num="99">These labels are used to determine which stvars to favor including in the active set later.</p>
    <p num="100">If the --disconnect parameter is specified, advance the newly activated variables to the first stvar fence. (The directionality has been saved in the fence labels.)</p>
    <p num="101">
      The problem is converted into a minimal flow problem by
      <br/>
      1. saying we want to minimize the sum of logs of selections on the new free fence, instead of the product of free selections;
      <br/>
      2. dividing each variable into an input invariable and an output ovariable with a single channel between them having capacity equal to the log of the number of free selections for the variable;
      <br/>
      3. joining each ovariable to foreign ivariables it depends on with an infinite capacity channel.
    </p>
    <p num="102">The active variables are an infinite source of flow to the variables they depend on (so the old free fence is fed by an infinite source), and each stvar ovariable has an infinite-capacity channel to an infinite sink.</p>
    <p num="103">
      Thus the flow will be limited by the capacity of certain ivariable-to-ovariable channels internal to original variables.
      <br/>
      These limiting variables form the new free fence.
    </p>
    <p num="104">
      The computation of flow given this graph (source, channels, sink) is done with the usual maximal flow algorithm (see Wagner, "Principles of Operations Research", Appendix I, "Advanced Topics in Network Algorithms", Prentice Hall, 1975, p.953-958).
      <br/>
      It proceeds as follows:
      <br/>
      zero all flows, and all nodes marked Sink-side except the source marked Source-side.
    </p>
    <p num="105">Look at a source-side node; if any channel to a sink-side node has a flow that's less than capacity, mark the channel Plus, and mark the far node Source-side: if any channel from a sink-side node has a flow that's nonzero, mark the channel Minus, and mark the far node Source-side.</p>
    <p num="106">If the sink is finally marked Source-side, then there's a path from source to sink marked with Plus and Minus's, along which flow can be improved.</p>
    <p num="107">
      Find this path (we use bfs), and how much it can be improved.
      <br/>
      This is the minimal remaining capacity on Plus channels and the minimal existing flow in Minus channels along the path.
    </p>
    <p num="108">Increase (Plus) and decrease (Minus) the flow along this path, and start over with the new flow.</p>
    <p num="109">When there's no path to the sink, the flow is maximal.</p>
    <p num="110">When finding the path, paths from stvars to sink are favored, so the flow stays as close to the source as possible. (There may be other distant flows giving the same capacity.)</p>
    <p num="111">Given the maximal flow, the new free fence is given by the variables whose ivariable-to-ovariable channel limits the flow.</p>
    <p num="112">
      Complication: how to find which variables limit the flow:
      <br/>
      1.
      <br/>
      For each variable with capacity i-o flow, increase the capacity of the channel and look for a flow-improving source-to-sink path.
      <br/>
      If the path is found, the variable limits the flow, and hence is on the new free fence.
      <br/>
      Restore its original capacity if so.
      <br/>
      2. If not, leave the capacity increased for the variable.
      <br/>
      3. After all the limiting variables have been found, restore all the capacities to the original values.
    </p>
    <p num="113">
      The order in which variables are checked determines whether near or far variables wind up on the free fence, given a tie. (For example, a linear chain of equal-capacity variables; any one of them limits the flow after all the capacities on the others are increased.
      <br/>
      The parameter --maxvars says pick the most distant variable (i.e., increase the capacities on the near ones first in this test).
    </p>
    <p num="114">If an undesired variable winds up on the free fence, give its i-o channel infinite capacity and recompute the flow.</p>
    <p num="115">Undesired variables are: stvars, or any selvar that's tied to an active stvar within a selection predicate.</p>
    <p num="116">Limiting the flow, --freesels=</p>
    <p num="117">If the resulting flow exceeds the limit specified in --freesels, the network is changed by shutting down the stvar-to-sink channels on selected stvars. (This will eventually drop the maximal flow and thus move the discovered new free fence outward.) One stvar is shut down per iteration, as follows.</p>
    <p num="118">First, if there's a stvar in the maximal flow, shut it down.</p>
    <p num="119">
      If not, pick the largest-flow stvar with label less than VCUT.
      <br/>
      This will be in the forward direction, defined by the original variables-to-be-activated.
    </p>
    <p num="120">If there are none, pick the lowest-label (i.e., nearest) stvar in the backward set, with label greater than VCUT.</p>
    <p num="121">Having shut a stvar-to-sink channel down, increase VCUT, so the directionality is gradually lost from the problem as the solution grows.</p>
    <p num="122">The --slowdisconnect=M Parameter</p>
    <p num="123">
      The flow computation is iterated M times whether the number of free selections resulting is big or small; this advances the fence past M stvars on the average, is the idea, rather than just advancing past the first stvar fence all at once.
      <br/>
      If the width of the first stvar fence is less than M, M is reset to the actual fence width.
      <br/>
      The option can be used as well as --disconnect, which then performs both actions.
    </p>
    <p num="124">Stepwise Refinement and Homomorphism Verification</p>
    <p num="125">
      As pointed out in the Description of the Prior Art, another important technique for dealing with the computational complexity problem is stepwise refinement.
      <br/>
      In stepwise refinement, a simple system is refined in a series of steps.
      <br/>
      Each of the steps produces a refined system which is more complex than the system or task it was refined from (the abstract) system or task, and eventually, the refined system has the complexity required for an actual implementation.
      <br/>
      At each step, it is possible to verify that the refined system produced by the step is a correct refinement of the abstract system it was refined from.
      <br/>
      If the refinement is correct, the refined system inherits desired properties from the abstract system.
    </p>
    <p num="126">
      Refinement is typically used as follows: as indicated above, the design of a system begins with a simple model of the system and a simple model of the task it is to perform and the performance of the task by the system is verified for these models.
      <br/>
      Then the system model is refined, and the verification system verifies that the refinement has inherited the properties required to perform the task.
      <br/>
      Refinement continues until a refined system model is obtained from which the actual implementation may be made.
    </p>
    <p num="127">
      In the verification system of U.S. Pat. No. 5,163,016, language containment is used to verify the correctness of a refined system vis-a-vis its abstract system.
      <br/>
      The use of language containment is, however, complicated by the fact that the automaton representing a refined system has more variables than that of the abstract system, and consequently, the language of the automaton representing the refined system is often not related to the language of an automaton representing the abstract system it was refined from.
      <br/>
      However, even when the former language is not related to the later language, the refinement can be verified if there is a homomorphism from the boolean algebra defined by the abstract system automaton's variables to the boolean algebra defined by the refined system automaton's variables.
      <br/>
      In the following, the mathematics of homomorphism will be explained in more detail, and thereupon it will be shown how homomorphism may be used to verify refinements.
      <br/>
      A precise mathematical discussion of what follows may be found in Sections 8.5-8.11 of Chapter 8 of Appendix A at columns 355 through 408 of "Verification of Homomorphism Between two System Models," U.S. Pat. No. 5,740,084.
    </p>
    <p num="128">Homomorphisms: FIG. 1</p>
    <p num="129">
      As previously stated, each transition from one state of an automaton to another has a predicate which specifies tests which the selection variables must satisfy if the transition to which the predicate belongs is to occur.
      <br/>
      The predicate can be encoded as a bit string, with each of the bits in the bit string representing the result of a test specified in the predicate.
      <br/>
      In the following, what the bit string encodes is termed an event.
      <br/>
      More precisely, an event is a global assignment of the output variables of the automaton.
      <br/>
      The output variables are in turn the variables which appear in the predicates of the automaton's transitions.
    </p>
    <p num="130">
      The bit string encodings of all of the events in the automaton further define a Boolean algebra for the automaton.
      <br/>
      A first Boolean algebra is the image of a Boolean algebra homomorphism of a second Boolean algebra if there is a mapping  PHI  between the events of the first automaton and disjunctions of events of the second automaton such that for the operations of Boolean addition, multiplication, and negation, when an operation is performed on events of the first automaton to produce a result event, the mapping of the result event to the events of the second automaton yields a mapped result event in that automaton, and when the same events of the first automaton are each mapped to events in the second automaton and the operation is performed there, the result event in the second automaton is the same as the mapped result event.
      <br/>
      When the foregoing is applied to refinement, the Boolean algebra homomorphism is from the Boolean algebra of the abstract automaton to the Boolean algebra of the refined automaton.
    </p>
    <p num="131">
      It will be apparent from the foregoing that the Boolean algebra of an automaton is closely related to its language, and as might be expected from this fact, where there is Boolean algebra homomorphism  PHI  from the events of a first automaton to the events of a second automaton, there is also a language homomorphism  PHI  from the language of the second automaton to the language of the first automaton, or in the refinement context, from the language of the refined automaton to the language of the abstract automaton.
      <br/>
      Moreover, for each language homomorphism, there is a unique Boolean algebra homomorphism, and vice-versa.
    </p>
    <p num="132">
      What all of this means can be seen in more concrete terms in FIG. 1.
      <br/>
      Abstract state 101 is a state in an abstract automaton which is to be refined; state 101 has three outgoing transitions; the event for transition 105 is event 1; the event for transition 109 is event 2; the third transition, pause 107, is a place holder for several sequential events in a refinement.
      <br/>
      Refined states 111(0 . . . 7) are the states in the refined automaton that correspond to state 101 of the abstract automaton.
      <br/>
      Transitions 112 (0 . . . 6) are the transitions between those states 111.
      <br/>
      There are four transitions 113, 115, 117, and 119 which correspond to transitions 105 and 109 respectively in state 101.
      <br/>
      As can be see from the figure, there is a homomorphic mapping  PHI  109 from the events of state 101 to the events of state 101 to the events of states 111, pause 107 maps onto the events of the transitions 112(0 . . . 6); event 1 105 maps onto event 1a and event 1b; and event 2 maps onto events 2a and event 2b.
      <br/>
      Presuming that there is such a mapping from each event of the automaton to which state 101 belongs to the events of the automaton to which states 111 belong, there in a Boolean algebra homomorphism  PHI  from the events of the automaton of state 101 to the events of the automaton of states 111 and a language homomorphism  PHI  from the language of the automaton of states 111 to the automaton of state 101.
    </p>
    <p num="133">0 0 (slashed zero) 1 Using Homomorphism to Verify Refinement</p>
    <p num="134">
      Language homomorphism may be used together with language containment to verify a refinement.
      <br/>
      If there is a boolean algebra homomorphism  PHI  between the abstract automaton and the refined automaton and the refined automaton, then the correctness of the refinement can be verified if we can determine whether the language homomorphism  PHI  of the language of the refined automaton is contained in the language of the abstract automaton.
      <br/>
      We cannot do that directly, but we can determine whether the language of the refined automaton is contained in the language of an automaton whose Boolean algebra is produced by means of the homomorphism  PHI  from the Boolean algebra of the abstract automaton.
    </p>
    <p num="135">
      This would appear to be straightforward enough, since, as previously described, one tests whether the language of a system automaton is contained in the language of a task automaton by making a model automaton out of the product of the system automaton and a third automaton whose language is the complement of the language of the task automaton and then uses the model to determine containment.
      <br/>
      The foregoing description is, however, an oversimplification.
      <br/>
      In automata-theoretic verification, the task is represented as an automaton, but the system is represented as a process, i.e., a finite state machine whose acceptance structure indicates what the finite state machine does not do.
      <br/>
      Since real systems are typically described in terms such as : "the system will never fail to deliver a message", the use of processes to represent systems is natural.
      <br/>
      Processes and automata are further related to each other as follows: for each deterministic automaton, a process may be constructed which accepts the language which is the complement of the automaton's language, and vice-versa.
      <br/>
      That relationship of course solves the difficulty: the model may be constructed by transforming the system process into an automaton and constructing the model from that automaton and the task automaton.
    </p>
    <p num="136">
      There remains, however, the problem that in stepwise refinement, refinements may be made of either the system process or the task automaton, and consequently, ways are needed for doing language containment with pairs of processes.
      <br/>
      If the techniques used for automaton-automaton pairs are simply applied to pairs of processes, the process whose language is the negation of the language of the abstract process is exponentially larger than the abstract process itself.
    </p>
    <p num="137">
      A prior-art approach to the problem applies what is termed lifting: lifting takes advantage of the fact that a process is equivalent to the product of a set of processes and that if each of the processes for which containment is being checked is treated as the product of a set of processes and each of the set of processes representing the refined process has a language homomorphism with one of the processes representing the abstract processes or with a product of several of those processes, the language containment check becomes a language containment check on pairs of processes.
      <br/>
      If the processes in the pairs being checked are small, the language containment check becomes possible even with the blow up in the size of the process described above.
    </p>
    <p num="138">The verification system described herein goes beyond lifting as follows:</p>
    <p num="139">
      First, a node-recurring transform is done of the processes in the set of abstract processes to make their acceptance structures easier to handle.
      <br/>
      In this transformation, states with incoming edges that are recur edges are split into two states, with all of the recur edges going to one of the two states.
      <br/>
      For details, see R. P. Kurshan, "Modelling Concurrent Processes", Symposium Applied Math. 31, pp. 45-57, 1985.
    </p>
    <p num="140">
      Next, the system takes advantage of the fact that the language of any deterministic process is equivalent to the intersection of the languages of a set of simple strongly deterministic automata.
      <br/>
      An automaton is strongly deterministic if it has a unique initial state and there is only one transition from a given state to another state for a given predicate of a transition from that state.
      <br/>
      An automaton is simple if there are either no cycle sets or no recur edges and, if there are cycle sets, they are pairwise disjoint.
      <br/>
      Thus, a simple decomposition of the language of the refined process can be done which makes it into an equivalent set of languages of simply strongly deterministic automata and the language containment test can now be done on automaton-process pairs as described above.
      <br/>
      Simple decomposition may similarly be done to obtain a set of languages of simple processes whose union is a language which is equivalent to the language of a deterministic automaton.
    </p>
    <p num="141">
      Of course, simple decomposition requires that strongly deterministic automata be made into simple automata.
      <br/>
      That is done in a preferred embodiment by taking advantage of the fact that after the node-recurring transform, recur edges and cycle sets are duals.
      <br/>
      A set of recur edges that is equivalent to a cycle set can be derived from each cycle set by making edges into recur edges when the edges connect two states such that one or both of the states do not belong to the cycle set.
      <br/>
      Thus, what is done in the simple decomposition is to produce the set of automata which correspond to the refined process such that each of the automata has only one of the cycle sets of the refined process and then make these automata into simple automata by replacing the cycle set with recur edges.
    </p>
    <p num="142">
      Verifying homomorphism requires verification of several different kinds of language inclusion.
      <br/>
      In general, what must be verified is that the language L1 produced by a language homomorphism  PHI  from the language of a first finite state machine is contained in the language L2 of a second finite state machine.
      <br/>
      There are several different kinds of first and second finite state machines.
    </p>
    <p num="143">First, when what is being verified is a homomorphic reduction, L1 is the language of a first refined process and L2 is the language of a second abstract process or the languages of a first refined automaton and a second abstract automaton respectively.</p>
    <p num="144">Second, when what is being verified is a task decomposition, we need a test where L1 is the intersection of languages of a set of automata and L2 is the language of an automaton.</p>
    <p num="145">
      Third, when what is verified is a system decomposition, we need a test where what is tested is the containment of the language of a process in the language of an automaton or vice-versa.
      <br/>
      Homomorphism of a refined process in the language of this, thus, in general, it is sufficient to provide algorithms for the following four cases:
      <br/>
      L1 =L(P) for a process P,  (Equation image '1' not included in text)
    </p>
    <p num="146">
      for automata A1, . . . Ak, and similaryl for L2, but with deterministic transition structures.
      <br/>
      Tests for these four cases are summarized in the following table.
      <br/>
      In the table,
    </p>
    <p num="147">
      PHI  is the Boolean algebra homomorphism whose support is the support of  PHI  and the superscritp - indicates an automaton or process which has been transformed as described above from the process or automaton to which the superscript is applied.
      <br/>
      Each Test in the table is a necessary and sufficient condition for  PHI (L1)L2 in each respectively case. cxty following a verification algorithm indicates an expression which for the complexity of the verification algorithm.
    </p>
    <p num="148">
      --
      <br/>
      --       L1  L2  L2 = L(Q) for L'-process Q with MQ
      <br/>
      --  deterministic.
      <br/>
      --   (Equation image '2' not included in text)
      <br/>
      -- L1 = L(P) for L-process P
      <br/>
      --   (Equation image '3' not included in text)
      <br/>
      --   (Equation image '4' not included in text)
      <br/>
      --   (Equation image '5' not included in text)
      <br/>
      --   (Equation image '6' not included in text)
      <br/>
      --   (Equation image '7' not included in text)
    </p>
    <p num="149">Implementation of Homomorphism Verification</p>
    <p num="150">
      In the preferred embodiment, a refinement of an automaton or process is specified by concatenating a file with a description 203 or 205 of an abstract automaton or process (the abstractfile) to file 203 or 205 with a description of the refined automaton or process (the refinementfile).
      <br/>
      The abstract file further contains hom declarations which specify homomorphic mappings between variables in the refinement file and variables in the abstract file.
      <br/>
      Each hom declaration specifies a variable from the abstract file and a function involving variables from the refinement file and thereby specifies the mapping.
    </p>
    <p num="151">How the verification is done depends on whether the language containment test for the verification tests inclusion of the language of a process in the language of an automaton, the language of a process in the language of a process, or the language of an automaton in the language of an automaton.</p>
    <p num="152">Homomorphism Verification with a Process-Automaton Pair</p>
    <p num="153">
      This case employs the algorithm in the upper right-hand quadrant of the table of algorithms in the preceding section.
      <br/>
      The algorithm corresponds to an ordinary run of verification system 201 on the file made by concatenating the abstract file to the refinement file, except that the variables in the abstract file have the assignments specified in the horn declarations.
      <br/>
      An error is returned at run time if such an assignment is illegal.
      <br/>
      If the variable in the horn declaration to which the expression is being assigned is a state variable, then the legality of the assignment is checked at the end of "crank" (ie, as a next-state), otherwise it is checked at the time of the assignment (ie, as a current-state).
    </p>
    <p num="154">If a process of the abstract automaton process refers to a variable which is declared in the refined process but not in the abstract automaton, then a parse-time warning is given and the value of that variable is taken from the file containing the refined process specification.</p>
    <p num="155">Homomorphism Verification with a Process-Process Pair</p>
    <p num="156">
      This case employs the algorithm set forth in the upper left hand quadrant of the table of algorithms.
      <br/>
      It is thus necessary to first construct the simple decomposition of the abstract process by doing the node-recurring transform described above, then constructing processes with single cycle sets, and finally converting the cycle sets to sets of recur edges as described above.
    </p>
    <p num="157">If there are no recur or cyset declarations in the abstract file, run in the usual fashion, except that there is no need to look for cycles.</p>
    <p num="158">
      Else, for the first run, if there are recur declarations, set a plus bit at the end of each global state, as follows: With the packing of the initial states, plus gets set to 0.
      <br/>
      In the global state transition
    </p>
    <p num="159">(STATE, plus) --&gt; (NEXT_STATE,plus')</p>
    <p num="160">if STATE --&gt; NEXT_STATE crosses a recur edge in the abstract file, (a global state transition of the form v1, v2, . . . , vk --&gt; w1, w2, . . . ,wk where for some j, there is a recur edge vj --&gt; wj or recur * --&gt; wj or recur vj --&gt; * in the abstract file, set plus=1, else set plus=0.</p>
    <p num="161">
      Also, disregard all the cyset declarations in the abstract file and use the recur edges in the abstract file only to define the updating of plus.
      <br/>
      Create a cyset mask (a mask which permits the rapid location of cycle sets in the reached state table) for plus=0.
    </p>
    <p num="162">
      If originally, there were no cysets in the abstract file, the first run is sufficient.
      <br/>
      Otherwise, if there are no recurs but there are cysets, the cysets are split so that no two cysets overlap.
      <br/>
      This is done by putting a first mark between the cysets of different processes and then using a second mark to split the cysets so that no 2 cysets overlap-cyset +1,2}, +3}, +1,4}, +3,5} for a process becomes +1,2}, +3} * +1,4}, +3,5} Then N=number of strings of cysets between X's (N=2 here). (If there are no recur edges in the abstract file but there are cysets, we don't do the first iteration, and start our work with the second.) Packing the plus bit applies only to the first iteration.
    </p>
    <p num="163">
      Runs for i=1. . . N are each as follows: disregard all recur edges in the abstract file; ignore the cyset declarations in that file with regard to their usual interpretation.
      <br/>
      Treat each global state transition V --&gt; W as you would a recur edge UNLESS both V, Ware in the same set of i=th cyset string X . . 1 . . X . . 2 . . X . . 3 . . X . . . Note: if V=v1, v2, . . . ,vk and W=w1, w2, . . . , wk and vj, wj are in the same set of the i-th cyset string Xvj,wj, . . . ,X then we say "V and Ware in the same set of the i-th cyset" (Cysets/recur edges of the refinement file are treated normally, and are separated from this description.)
    </p>
    <p num="164">Error report: we print out before we start:</p>
    <p num="165">Hom check: 1or 0 recur checks; N cyset checks.</p>
    <p num="166">
      As we proceed through the i=0. . . N loop, print out:
      <br/>
      Recur check passed.
    </p>
    <p num="167">Cyset check 1 passed.</p>
    <p num="168">
      Cyset check 2 passed.
      <br/>
      . . .
    </p>
    <p num="169">Cyset check N passed.</p>
    <p num="170">If the recur edge check (i=0) fails, just print:</p>
    <p num="171">Recur check failed:</p>
    <p num="172">
      and report the errors.
      <br/>
      If the i-th cyset check fails, print out:
    </p>
    <p num="173">Cyset check i failed:</p>
    <p num="174">proc .X.Y.Z:</p>
    <p num="175">cyset +states}, +states},. . .</p>
    <p num="176">
      and again report the errors.
      <br/>
      The foregoing can be optimized by limiting the testing of predicates in the refinement to those with values which are valid at the associated states of the abstract process.
      <br/>
      These checks need only be done for the first iteration.
      <br/>
      In each run (for i&gt;0), the graph (and hence the representation of reached states) will be the same.
      <br/>
      The representation of reached states may be, for example, a reached state table (RST) or a binary decision diagram (BDD).
      <br/>
      The only differences will be the order of the search, and which edges are recur edges.
      <br/>
      We thus reuse the representation of the reached states for each subsequent run by clearing those fields of the representation having to do with cycle detection which are set during the search or are dependent upon the order of the search.
      <br/>
      If there is no hom declaration in the abstract file, there will be a compilation error.
    </p>
    <p num="177">Homomorphism Verification with an Automaton-Automaton Pair</p>
    <p num="178">
      This is an implementation of the algorithm of the lower right-hand quadrant of the algorithm table.
      <br/>
      As indicated there, we make several iterations, indexed over i=1. . . N.
    </p>
    <p num="179">If there are no recur or cyset declarations in the refinement file, return and stop: the refinement file defines empty an empty language and the homomorphisms are verified.</p>
    <p num="180">
      Else if there are recur declarations in the refinement file, set the plus bit at the end of each global state, as follows: With the packing or the initial states, plus gets packed with value 0.
      <br/>
      In the global state transition.
      <br/>
      (STATE,plus) --&gt; (NEXT_STATE,plus)
    </p>
    <p num="181">
      If STATE --&gt; NEXT_STATE crosses an active (see below) recur edge of the refinement file, set plus=1, else set plus 0.
      <br/>
      Then create in effect, a cyset for plus=0 by creating a cyset mask for plus=0 Pre-process the cyset declarations in the refinement file as described for the process-process case.
    </p>
    <p num="182">
      When this is done, make runs for i=1. . . N where i cycles over a succession of definitions of which recur edges and cysets are active.
      <br/>
      Treat each global state transition V --&gt; W as recur edge UNLESS both V, W are in the same set of some "active" cyset declaration. (Cyset/recur edges of the abstract file are treated normally, and are separate from this description.)
    </p>
    <p num="183">
      Definition of active recur/cyset declaration: let T1,T2, . . . ,Tn be those processes or tasks defined at the root of the refinement file (ie, top level processes) which have at least 1 cyset or recur declaration (including all sub-processes, sub-sub-processes, etc.).
      <br/>
      For each Tj, let Rj be all the recur edge declarations of Tj, and let Zj1r, Zj2, . . . be the list of cyset declarations in Tj (after splitting the cysets).
      <br/>
      An active assignment consists of a selection, for each j=1. . . n, of one of Rj, Zj1, Zj2. . . and so forth in the list (*) to be active.
      <br/>
      For the definition of run i=1. . . N, i cycles over all such active assignments.
      <br/>
      If mj is the number of elements in the (*), then N=m1*m2* . . . *mn.
    </p>
    <p num="184">Error report: we print out before we start:</p>
    <p num="185">Hom check: n automata in domain</p>
    <p num="186">As we proceed through the i=1. . . N loop, print out:</p>
    <p num="187">Check i out of N passed.</p>
    <p num="188">If the i-th check fails, print:</p>
    <p num="189">Check i failed.</p>
    <p num="190">for each j=1. . . n print out:</p>
    <p num="191">Automaton Tj:</p>
    <p num="192">followed by the active Rj/Zjk for that run and report the errors.</p>
    <heading>CONCLUSION</heading>
    <p num="193">
      The foregoing Detailed Description has disclosed to those skilled in the art of formal verification how to make and use formal verification systems which employ the novel techniques for reducing the computational complexity of model automata disclosed herein.
      <br/>
      The Detailed Description has further disclosed the best mode presently known to the inventors of implementing their techniques.
      <br/>
      It will be immediately apparent to those skilled in the art of formal verification that many other implementations of the techniques can be made which employ the principles disclosed herein and that the techniques can be used not only in formal verification, but in any context where there is a need to reduce the computational complexity of language containment testing.
      <br/>
      For example, the localization techniques described herein could be used in any system which wanted to employ language containment to determine whether a design performs a task.
    </p>
    <p num="194">All of the above being the case, the foregoing Detailed Description is to be understood as being in every respect illustrative and exemplary, but not restrictive, and the scope of the invention disclosed herein is not to be determined from the Detailed Description, but rather from the claims as interpreted according to the full breadth permitted by the law.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>Improved design testing apparatus for making a determination whether a design performs a task, the design testing apparatus being of the type which includes means for making the determination by testing a model automaton including variables and the improvement comprising:</claim-text>
      <claim-text>a processor operable to create a directed graph of dependency relations of the variables;</claim-text>
      <claim-text>and means for using the directed graph to make a reduced version of the model automaton,</claim-text>
      <claim-text>- wherein said means for using the directed graph comprises means for reducing the size of the directed graph to form a reduced version of the directed graph, - wherein said means for reducing comprises means for resizing variables having a value upon which the performance of the reduced version of the model automaton does not depend, the design testing apparatus making the determination by testing the reduced version of the model automaton.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. Improved design testing apparatus for making a determination whether a design performs a task, the design testing apparatus being of the type which includes means for making the determination by testing a model automaton including variables and the improvement comprising: a processor operable to create a directed graph of dependency relations of the variables; means for using the directed graph to make a reduced version of the model automaton, wherein said means for using the directed graph comprises means for reducing the size of the directed graph to form a reduced version of the directed graph;</claim-text>
      <claim-text>and means for freeing a set of variables each said freed variable thereby being treated as a primary input for said reduced model automaton.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The improved design testing apparatus of claim 2 further comprising: means for revising said set of freed variables if said task is performable by said reduced version of the model automaton.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A method for testing a design to determine whether the design defines a task, the method comprising: constructing a model automaton, the model automaton being of the type that includes variables; creating a directed graph of dependency relations of the variables; using the directed graph to make a reduced version of the model automaton, - wherein said step of using comprises the step of reducing the size of the directed graph to form a reduced version of the directed graph,</claim-text>
      <claim-text>-  wherein said step of reducing comprises the step of resizing variables having a value upon which the reduced version of the model automaton does not depend;</claim-text>
      <claim-text>and determining whether the design defines the task using the reduced version of the model automaton.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. A method for testing a design to determine whether the design defines a task, the method comprising: constructing a model automaton, the model automaton being of the type that includes variables; creating a directed graph of dependency relations of the variables; using the directed graph to make a reduced version of the model automaton, wherein said step of using comprises the step of reducing the size of the directed graph to form a reduced version of the directed graph; freeing a set of variables, each said freed variable thereby being treated as a primary input for said reduced model automaton;</claim-text>
      <claim-text>and determining whether the design defines the task using the reduced version of the model automaton.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 5 further comprising the step of: revising said set of freed variables of said task performable by said reduced version of the model automaton.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. A method used in design verification apparatus for verifying that a first process is a valid refinement of a second process, the design verifications apparatus being of the type which tests whether a process's language is contained in an automaton's language, there being a language homomorphism between the language of the first process and the language of the second process and the method comprising the steps performed in the design verification apparatus of: making a set of simple strongly deterministic automata which have languages such that the intersections of the languages is equivalent to the language of the second process;</claim-text>
      <claim-text>and testing whether the language of the first process is contained in the language of each of the simple strongly deterministic automata, wherein the testing step determines whether the first process is a valid refinement of the second process.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A design testing apparatus for determining whether a design performs a task, the design testing apparatus including means for testing a model automaton having variables, the apparatus comprising: a processor operable to create a directed graph of dependency relations of the variables;</claim-text>
      <claim-text>and a reducer for using the directed graph to make a reduced version of the model automaton, the reduced version of the model automaton being localized with respect to the task, wherein the apparatus determines whether the reduced version of the model automaton performs the task.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. Improved design testing apparatus for making a determination whether a design performs a task, the design testing apparatus being of the type which includes means for making the determination by testing a model including variables and the improvement comprising: a processor operable to create a directed graph of dependency relations of the variables; means for using the directed graph to make a reduced version of the model, wherein said means for using the directed graph includes means for reducing the size of the directed graph to form a reduced version of the directed graph, wherein said means for reducing includes means for resizing variables having a value upon which the performance of the reduced version of the model does not depend, wherein the apparatus determines whether the reduced version of the model performs the task.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. Improved design testing apparatus for making a determination whether a design performs a task, the design testing apparatus being of the type which includes means for making the determination by testing a model including variables and the improvement comprising: a processor operable to create a directed graph of dependency relations of the variables; means for using the directed graph to make a reduced version of the model, wherein said means for using the directed graph includes means for reducing the size of the directed graph to form a reduced version of the directed graph, wherein said means for reducing comprises means for freeing a set of variables each said freed variable thereby being treated as a primary input for said reduced model, wherein the apparatus determines whether the reduced version of the model performs the task.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The improved design testing apparatus of claim 10 further comprising means for revising said set of freed variables if said task is performable by said reduced version of the model.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A method for testing a model of a design to determine whether the design defines a task, the model being of the type that includes variables, the method comprising: creating a directed graph of dependency relations of the variables; using the directed graph to make a reduced version of the model, wherein said means for using the directed graph includes means for reducing the size of the directed graph to form a reduced version of the directed graph, wherein said means for reducing includes means for resizing variables having a value upon which the performance of the reduced version of the model does not depend;</claim-text>
      <claim-text>and determining whether the reduced version of the model performs the task.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. A method for testing a model of a design to determine whether the design defines a task, the model being of the type that includes variables, the method comprising: creating a directed graph of dependency relations of the variables; using the directed graph to make a reduced version of the model, wherein said means for using the directed graph includes means for reducing the size of the directed graph to form a reduced version of the directed graph; freeing a set of variables, each said freed variable thereby being treated as a primary input for said reduced model;</claim-text>
      <claim-text>and determining whether the reduced version of the model performs the task.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 13 further comprising the step of: revising said set of freed bariables of said task performable by said reduced version of the model.</claim-text>
    </claim>
  </claims>
</questel-patent-document>