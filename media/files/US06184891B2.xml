<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06184891B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06184891</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6184891</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="21951974" extended-family-id="42112808">
      <document-id>
        <country>US</country>
        <doc-number>09047958</doc-number>
        <kind>A</kind>
        <date>19980325</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09047958</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43170758</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>4795898</doc-number>
        <kind>A</kind>
        <date>19980325</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09047958</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06T  15/50        20110101A I20120414RMEP</text>
        <ipc-version-indicator>
          <date>20110101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>15</main-group>
        <subgroup>50</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20120414</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06T  15/10        20110101A I20120414RMEP</text>
        <ipc-version-indicator>
          <date>20110101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>15</main-group>
        <subgroup>10</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20120414</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>345426000</text>
        <class>345</class>
        <subclass>426000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>345589000</text>
        <class>345</class>
        <subclass>589000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>345629000</text>
        <class>345</class>
        <subclass>629000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06T-015/50</text>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>15</main-group>
        <subgroup>50</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06T-015/10</text>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>15</main-group>
        <subgroup>10</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06T-015/50</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>15</main-group>
        <subgroup>50</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06T-015/10</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>T</subclass>
        <main-group>15</main-group>
        <subgroup>10</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>19</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>5</number-of-drawing-sheets>
      <number-of-figures>8</number-of-figures>
      <image-key data-format="questel">US6184891</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Fog simulation for partially transparent objects</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>SONY CORP</text>
          <document-id>
            <country>JP</country>
            <doc-number>H0721407</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP07021407</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="2">
          <text>SUN MICROSYSTEMS INC</text>
          <document-id>
            <country>GB</country>
            <doc-number>2207585</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>GB2207585</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="3">
          <text>INFORMATIX INC, et al</text>
          <document-id>
            <country>WO</country>
            <doc-number>9710570</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>WO9710570</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>"Layered Representations for Vision and Video"; Adelson, E.H., Dept. of Brain &amp; Cognitive Science, MIT; Proceedings IEEE workshop on Representation of Visual Scenes, 1995; ISBN:0-8186-7122-X, Jun. 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>"Particle Systems", Computer Graphics, Principles and Practice, 2nd Ed., James D. Foley, Andries van Dam, Steven K. Feiner, and John F. Hughes, Addison-Wesley Publishing Co., Nov. 1991, pp. 1031-1034.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>"Fog", Open GL Programming Guide, the Official Guide to Learning Open GL, Release 1, Jackie Neider, Tom Davis, and Mason Woo, Addison-Wesley Publishing Co., 1993, pp. 216-223.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>"Compositing Digital Images", Computer Graphics, vol. 18, No. 3, Thomas Porter and Tom Duff, ACM, 1984, pp. 253-259.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Microsoft Corporation</orgname>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>MICROSOFT</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Blinn, James F.</name>
            <address>
              <address-1>Bellevue, WA, US</address-1>
              <city>Bellevue</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Klarquist Sparkman Campbell Leigh &amp; Whinston, LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Zimmerman, Mark</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method for simulating fog in 3D graphics rendering applications correctly computes fogged pixel colors even in graphics scenes where two surfaces overlap and the frontmost surface is partially transparent.
      <br/>
      The method computes the fog for each surface according to the following formula: &amp;fnof;F atop A, where &amp;fnof; is the amount of fog, F is the color of the fog, and A is the color of the pixel being fogged.
      <br/>
      Each fogged surface can be rendered independently to a separate image layer, called a fogged image layer.
      <br/>
      The graphics rendering system can then simulate the motion of a fogged image layer by moving the fogged layer in an (x,y) plane without re-computing the fogged pixels, or by moving the fogged layer in the z-direction and independently re-computing the moving fogged layer with a new value for the amount of fog applied to the image layer.
      <br/>
      The method applies to scenes where there are several fogged layers and to scenes that simulate fire and glow with pixels that are totally transparent but have non-zero color values.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The invention relates to a technique used in three-dimensional (3D) graphics rendering to simulate fog.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      In 3D graphics rendering, fog simulation is a rendering technique that can be used to simulate atmospheric effects such as haze, fog and smog.
      <br/>
      Fog is a general term that encompasses a variety of atmospheric effects such as haze, mist, smoke or pollution.
      <br/>
      Some computer-generated images tend to appear unrealistically sharp and well defined.
      <br/>
      Fog can make a computer-generated image more natural by making objects fade into the distance.
      <br/>
      When fog is simulated in a graphics scene, the objects gnat are farther from the viewpoint start to fade into the color of the fog.
    </p>
    <p num="3">
      In conventional graphics rendering architectures, like OpenGL, the author of a graphics scene can control the density of the fog as well as the fog color.
      <br/>
      The density of the fog is controlled by a parameter called the fog blend factor or fog dissolve factor, f. The fog color is typically represented as a vector value such as F=�Fred, Fgreen, Fblue, 1�. The color F is expressed in conventional vector algebraic notation, including four components: red, green, blue and alpha.
      <br/>
      Alpha is the opacity of the pixel, and typically ranges from 0 (totally transparent) to 1 (totally opaque).
      <br/>
      Note that the alpha value of the fog is set to 1, which means that the fog is simulated as being totally opaque.
      <br/>
      The extent to which an object appears to fade into the fog depends on the fog factor, and specifically, how much fog exists between the viewpoint and the object.
      <br/>
      Both the fog color and the fog factor are terms in a fog model used to compute the value of a fogged pixel given the color and opacity of an input pixel, such as A=�Ared, Agreen, Ablue, A ALPHA  �.
    </p>
    <p num="4">
      The fog factor, .function., represents an amount of fog.
      <br/>
      One way to describe the amount of fog at a given location in a graphics scene is to define it as the fog influence between the viewpoint of the graphics scene and the depth of an object relative to the viewpoint.
      <br/>
      More specifically, the fog factor is typically calculated as a function of z, the depth of an object from the viewpoint.
      <br/>
      For example one expression for .function. is:
      <br/>
      .function.=1-e- TAU ZA ,
    </p>
    <p num="5">
      where  TAU  is the optical depth and ZA is the depth of the object from the viewpoint.
      <br/>
      The value of .function. can be computed by a variety of other functions in the OpenGL graphics programming language from Silicon Graphics, and the Direct3D graphics programming interface from Microsoft.
      <br/>
      It is important to note that the notation for the dissolve factor is slightly different in some graphics programming languages.
      <br/>
      For example, in OpenGL, the value of .function. in the above equation actually corresponds to (1-.function.) in OpenGL rotation.
    </p>
    <p num="6">
      FIG. 1 is a block diagram illustrating how fog is typically applied to pixels in a conventional 3D graphics rendering pipeline.
      <br/>
      The rasterizer 20 is a stage in the graphics rendering pipeline where a geometric primitive used to model the surface of an object is converted into pixel values.
      <br/>
      In a geometric processing stage, the objects in a scene are clipped to a view volume and geometrically transformed to a view space, corresponding to a display screen.
      <br/>
      The rasterizer 20 takes the transformed geometric primitives (e.g., polygons) as input and computes the color of each pixel within the polygon.
      <br/>
      Typically, conventional rasterizers interpolate color values at a polygon's vertices to compute the color values at a pixel location within the polygon.
      <br/>
      The fog applicator 22 then modifies the color values of a pixel by applying an amount of fog of a predetermined color to interpolated color values.
      <br/>
      The blend unit 24 is responsible for blending pixels from the rasterizer and fog applicator with pixel values at corresponding pixel locations in the frame buffer 26.
      <br/>
      The frame buffer is memory that stores an array of pixel values corresponding to the picture elements in a display device.
      <br/>
      When the graphics rendering pipeline completes the rendering of a graphics scene, the frame buffer has an array of pixels representing an output image for display on a display screen.
    </p>
    <p num="7">
      During rendering, the rasterizer 20 processes a stream of geometric primitives from the objects in a graphics scene.
      <br/>
      In some cases, geometric primitives can overlap the same pixel location.
      <br/>
      For example, a graphical object representing a foreground object can have polygons that occlude polygons of a background object.
      <br/>
      Graphics rendering systems employ a method called hidden surface removal to determine which surfaces are actually visible in a scene.
      <br/>
      One technique for hidden surface removal is to rasterize unsorted polygons into pixels with depth values.
      <br/>
      The blend unit 24 then determines whether an input pixel generated by the rasterizer occludes a previously generated pixel in the frame buffer at the same pixel location.
      <br/>
      If it does, the blend unit 24 replaces the pixel in the frame buffer with the new pixel.
      <br/>
      If it does not, the blend unit 24 discards the new pixel.
      <br/>
      An alternative technique is to sort the polygons in depth order and rasterize them in front to back order.
    </p>
    <p num="8">
      The process of computing pixel values in the frame buffer gets more complicated for partially transparent pixels since it is often necessary to combine the frontmost opaque pixel with partially transparent pixels in front of it.
      <br/>
      In some architectures that support partially transparent pixels, the blend unit 24 includes logic to combine partially transparent pixel values (sometimes called pixel fragments) at a pixel location into a final output pixel.
      <br/>
      Some architectures also rasterize geometric primitives at a subpixel resolution and then blend the pixel values of the subpixels in the neighborhood of each pixel location to compute final pixel values at each pixel location.
    </p>
    <p num="9">
      As illustrated in FIG. 1, the fog applicator 22 receives input pixels from the rasterizer and modifies them to simulate fog.
      <br/>
      The manner in which the fog applicator modifies a pixel (or pixel fragment) to simulate fog depends on the fog model or models implemented in it.
    </p>
    <p num="10">
      The conventional model for fogging a pixel A by the amount .function. of fog color F is:
      <br/>
      .function.F+(1-.function.)A,
    </p>
    <p num="11">where A is the color of the pixel being fogged.</p>
    <p num="12">
      The conventional formula for fog simulation will generate the wrong pixel color if two fogged surfaces overlap on the screen and the frontmost surface is partially transparent.
      <br/>
      A fogged surface refers to a rendering of the surface of a 3D object into pixel values where the pixel values are modified due to the influence of fog on the object's surface.
    </p>
    <p num="13">
      There are two primary cases where a surface is partially transparent: 1) some of the geometric primitives ( e.g., polygons) used to model the surface of an object may only partially cover a pixel location in screen space; and 2) some of the geometric primitives used to model the surface of an object may be translucent.
      <br/>
      In both cases, the pixels generated by the rasterizer might have an opacity value (alpha) indicating that the pixel is not opaque.
    </p>
    <p num="14">
      The best way to illustrate the problem with the conventional approach in these cases is to consider an example.
      <br/>
      FIG. 2 is a diagram illustrating how the conventional fog model produces incorrect results when the two fogged pixels are combined.
      <br/>
      FIG. 2 shows series of magnified square regions representing pixels A and B. The pixels are the points at the center of each square, and the square regions are at  +- 1/2 pixel spacing from the pixels.
      <br/>
      Pixels A and B each have a partially covered region (hatched regions 40 and 42) and transparent regions (white areas 44 and 46.
      <br/>
      Assume in this example that pixel A is closer to the viewpoint than B (ZA &lt;ZB).
    </p>
    <p num="15">The fog is represented as a scattering of dots (e.g., 48) of color F and an amount .function.(z) corresponding to the fog between the viewpoint and the depth value (z) of the pixel.</p>
    <p num="16">
      Using the conventional formula, the fogged pixels A and B (50, 52) appear as shown in FIG. 2.
      <br/>
      When the two fogged pixels are composited, the result looks like the square region 54.
      <br/>
      The result of the compositing operation gives the wrong result because a portion of the fog is counted twice.
      <br/>
      In FIG. 2, this problem is illustrated in the upper left region 56 of the square 54, where the fog appears denser because a portion of the fog at this region is counted twice.
      <br/>
      If A and B are composited over a fog background, the final pixel at this location will not be correct because the pixel will have too much fog color.
      <br/>
      If A and B are composited over another object (e.g., opaque pixel C), the final image will not be correct at this location because the object will receive too much fog color.
    </p>
    <p num="17">In view of this problem with the conventional fog model, there is a need for an improved fog model that accurately simulates fog when applied to scenes with partially transparent objects.</p>
    <p num="18">
      A number of special effects can be achieved by blending or modifying pixel values using image operators.
      <br/>
      See Porter and Duff, Compositing Digital Images, Computer Graphics, Vol. 18, No. 3, at 253-259, July 1984.
      <br/>
      In this paper, Porter and Duff defined a series of image operators that can be used to combine pixels to compute a composite image.
      <br/>
      The image operators in this paper are summarized in the following table, which describes how images A and B can be combined in terms of the fractions of A and B present in the final, composite image:
    </p>
    <p num="19">
      --
      <br/>
      -- operation                 AF  BF
      <br/>
      -- clear                     0       0
      <br/>
      -- A                         1       0
      <br/>
      -- B                         0       1
      <br/>
      -- A over B                  1       1 - A ALPHA
      <br/>
      -- B over A                  1 - A ALPHA   1
      <br/>
      -- A in B                    B ALPHA   0
      <br/>
      -- B in A                    0       A ALPHA
      <br/>
      -- A out B                   1 - A ALPHA   0
      <br/>
      -- B out A                   0       1 - A ALPHA
      <br/>
      -- A atop B                  B ALPHA   1 - A ALPHA
      <br/>
      -- B atop A                  1 - B ALPHA   A ALPHA
      <br/>
      -- A xor B                   1 - B ALPHA   1 - A ALPHA
      <br/>
      -- A plus B                  1       1
    </p>
    <p num="20">
      AF and BF represent the fractions of the respective input images that are present in the final, composite image.
      <br/>
      As Porter and Duff describe, the color component of pixels in the composite image can be expressed as:
      <br/>
      A ALPHA  AF AC +B ALPHA  BF BC,
    </p>
    <p num="21">where AC and BC are the color components of image A and image B (AC =�Ared, Agreen, Ablue � and BC =�Bred, Bgreen, Bblue �).</p>
    <p num="22">The Porter and Duff operators also include "unary" operators performed on a single image:</p>
    <p num="23">
      darken (A,  PHI )=( PHI Ar,  PHI Ab,  PHI Ag,  ALPHA A); and
      <br/>
      dissolve (A,  DELTA )=( DELTA Ar,  DELTA Ab,  DELTA Ag,  DELTA  ALPHA A).
    </p>
    <p num="24">
      The "over" operator can be used to combine partially transparent pixels into an output pixel.
      <br/>
      However, the use of the over operator does not solve the problem associated with fog applied to partially transparent objects.
      <br/>
      Porter and Duff do not address the problem of simulating fog, and more specifically, the problem of simulating fog of partially transparent objects.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="25">
      The invention provides an improved method and fog simulator logic for accurately simulated fog for partially transparent objects that overlap other objects in graphics scenes.
      <br/>
      In contrast to conventional fog simulation, the fog simulation method uses the "atop" operator to fog pixels as follows: .function.F atop A;
      <br/>
      where .function. is the amount of fog, F is the fog color, and A is the color of the pixel being fogged.
      <br/>
      The logic for simulating fog can be expressed as:
      <br/>
      .function.A ALPHA  F+(1-.function.)A;
    </p>
    <p num="26">where A ALPHA  is the alpha value for pixel A.</p>
    <p num="27">
      Unlike the conventional method for simulating fog, this method will obtain the correct result even when a partially transparent object is in front of a background object.
      <br/>
      The foreground object may be partially transparent because it has translucent portions or as a result of anti-aliasing computations.
    </p>
    <p num="28">
      In a graphics rendering system, this fog method is applied after computing the color of the pixel being fogged.
      <br/>
      The fogged pixel can then be composited with another pixel at the same location.
      <br/>
      This method applies particularly well to a layered graphics rendering pipeline where geometry in a graphics scene is rendered to separate image layers called sprites.
      <br/>
      A fogged image layer can be stored and re-used as long as the object rendered to the image layer moves in an (x,y) plane.
      <br/>
      If an object moves in the z direction, then it can be re-rendered independently and fogged using a new amount of fog representing the fog between the viewpoint and the object.
    </p>
    <p num="29">
      Additional features and advantages of the invention will become more apparent from the following detailed description and the accompanying drawings.
      <br/>
      BRIEF DESCRIPTION OF THE DRAWINGS
      <br/>
      FIG. 1 is a block diagram illustrating how fog is typically applied to pixels in a conventional 3D graphics rendering pipeline.
      <br/>
      FIG. 2 is a diagram of two partially covered pixels illustrating the problem of the conventional fog simulation formula in combining partially transparent pixels.
      <br/>
      FIG. 3 is a diagram graphically illustrating logic used to apply fog to pixels using, an improved fog model that accurately simulates fog for partially transparent surfaces that overlap other fogged surfaces.
      <br/>
      FIG. 4 is a diagram illustrating how the fog logic shown in FIG. 3 solves the problem that occurs when a partially transparent surface overlaps another surface.
      <br/>
      FIG. 5 illustrates an example of a scene with two overlapping objects A and B and the surrounding fog represented in fog layers.
      <br/>
      FIG. 6 illustrates an example of a scene with several overlapping objects and fog to illustrate how the atop operator can be used to independently compute fog for object layers.
      <br/>
      FIG. 7 is a block diagram illustrating an example of a computing environment in which a software rendering system can be implemented.
      <br/>
      FIG. 8 is a block diagram illustrating an implementation of a layered graphics rendering system.
    </p>
    <heading>DETAILED DESCRIPTION</heading>
    <p num="30">Introduction</p>
    <p num="31">
      As introduced in the background section, the conventional technique for simulating fog generates an incorrect result when two partially transparent surfaces overlap on the screen.
      <br/>
      A more accurate approach for simulated fog can be expressed by the following formula for fogging a pixel A by the amount .function. of fog color F:
      <br/>
      .function.F atop A.tbd..function.A ALPHA  F+(1-.function.)A,
    </p>
    <p num="32">where A is the color of the pixel being fogged.</p>
    <p num="33">
      This fog model differs from the conventional model in that it reduces fog color applied to the pixel by the degree to which the pixel is partially transparent, or in other words, by the pixel's alpha value, A ALPHA .
      <br/>
      One significant advantage of this approach is that it enables partially transparent surfaces to be fogged independently and then composited to compute an image that accurately simulates fog.
    </p>
    <p num="34">
      The "atop" operator refers to an image,e compositing operator described in Porter and Duff.
      <br/>
      The atop operator gives the portion of the first term .function.F that overlaps the second term A, in union with the portion of the second term A outside of the first term.
      <br/>
      Imagine the first term as a table cloth and the second term as a table.
      <br/>
      The expression table cloth atop table includes table cloth where it is on top of the table, and the table; otherwise, the area beyond the edge of the table is out of the picture.
      <br/>
      Thus, if A is partially transparent, it only receives fog on its non-transparent portion.
      <br/>
      The color values of the pixel A are expressed as:
      <br/>
      A=�Ared, Agreen, Ablue, A ALPHA  �.
    </p>
    <p num="35">
      The alpha of the pixel defines the extent to which it is partially transparent, and is typically a number between 0 and 1, inclusive (or 0 to 255 in an 8 bit binary number).
      <br/>
      The alpha can represent the translucency of the pixel or the extent to which an opaque pixel is covered by a polygon as a result of antialiasing computations.
    </p>
    <p num="36">
      The color values of the fog F are expressed as:
      <br/>
      F=�Fred, Fgreen, Fblue, 1�.
    </p>
    <p num="37">
      The amount of fog .function. is the amount of fog in front of the pixel A (between the viewpoint and the depth of the pixel, z).
      <br/>
      The value of .function. in this notation ranges from 0 at the viewpoint to 1 at a point infinitely far from the viewpoint.
    </p>
    <p num="38">
      It is important to emphasize that some graphics rendering systems use a slightly different notation for the amount of fog.
      <br/>
      In OpenGL, for example, the amount of fog between the viewpoint and a pixel location on the surface of a polygon is (1-.function.), instead of .function. as used above.
    </p>
    <p num="39">The Fog Simulator</p>
    <p num="40">
      The approach for simulating fog summarized above can be incorporated into 3D graphics rendering systems implemented in software, hardware or a combination of both.
      <br/>
      Regardless of the implementation details of the rendering pipeline, the pixel processing operations for simulating fog based on the fog model above is substantially the same in both hardware and software platforms.
      <br/>
      FIG. 3 is a diagram graphically illustrating the logic used to apply fog to pixels based on the formula described in the introduction section.
    </p>
    <p num="41">
      In FIG. 3, the mathematical operators of the fog model are functional units in the fog logic.
      <br/>
      Note that there arc many ways to express the fog model using different operators that achieve the same result.
      <br/>
      The logic shown in FIG. 3 is just one example to show how fog can be applied to a pixel using the atop operator.
    </p>
    <p num="42">
      The fog logic in this example includes three multipliers 100, 102 and 104 and an adder 106.
      <br/>
      The first multiplier 100 multiplies the fog amount .function. and the alpha of the pixel generated by the rasterizer.
      <br/>
      The second multiplier 102 takes this intermediate result (.function.A ALPHA ) and multiplies it by the fog colors.
      <br/>
      The second multiplier is a vector multiplier that multiplies the color components of F by the scalar quantity (.function.A ALPHA ).
    </p>
    <p num="43">
      The third multiplier 104 is also a vector multiplier that multiplies the color values of A by the scalar quantity (1-.function.) to generate another intermediate result.
      <br/>
      The adder 106 is a vector adder that combines the scaled color values from the vector multipliers 102 and 104.
      <br/>
      The result is a fogged pixel, fogged A.
    </p>
    <p num="44">
      The fogged pixel can be composited with fogged pixels from other surfaces at the same pixel location and produce the correct result even if the other surfaces are partially transparent at the pixel location.
      <br/>
      Specifically, fogged pixels from different surfaces can be combined in back-to-front order using the over operator.
      <br/>
      A description of how to combine fogged pixels for more complex geometry is explained further below.
    </p>
    <p num="45">
      The logic for simulating fog solves the problem associated with fogging partially transparent surfaces that overlap other fogged surfaces.
      <br/>
      To illustrate this point, it is helpful to consider an example showing how the logic computes a fogged pixel using the fog logic shown in FIG. 3.
      <br/>
      FIG. 4 is a diagram illustrating how the fog logic shown in FIG. 3 solves the problem that occurs when a partially transparent surface overlaps another surface.
      <br/>
      FIG. 4 is similar to FIG. 2 described in the background section in that it shows a series of diagrams of the same pixels A and B. However, it differs in that the surfaces A and B are fogged using the atop operator, instead of the conventional fog expression.
    </p>
    <p num="46">
      As in FIG. 2, region A and region B have opaque portions 40 and 42, and transparent portions 44 and 46.
      <br/>
      Each of these regions can represent either a partially covered opaque pixel (such as a pixel fragment produced as a result of antialiasing) or a translucent pixel (from a translucent surface that allows light reflected from a background surface to pass through).
      <br/>
      A translucent pixel is represented geometrically as partially covered region where the size of the covered region is proportional to the alpha of the pixel.
    </p>
    <p num="47">
      The second row depicts regions A and B (regions 120 and 122) fogged using the atop operator to apply an amount of fog of color F to regions A and B. The amount of fog is the portion of fog between the viewpoint and each surface.
      <br/>
      For example, the amount of fog applied to region A is the fog between the viewpoint and A, and the amount of fog applied to region B is the fog between the viewpoint and B. When the fogged pixels are combined using the over operator, the composite pixel has the correct amount of fog, as shown by the region 130 in FIG. 4.
      <br/>
      Note that the upper left corner of the region 130 does not improperly contribute to the color of the region.
    </p>
    <p num="48">Complex Geometry</p>
    <p num="49">
      The method for simulating fog described above can be used in complex scenes with several layers of objects and fog.
      <br/>
      To illustrate the problem, it is helpful to consider an example showing how fog enclosing objects in a graphics scene can be modeled with fog layers.
      <br/>
      FIG. 5 illustrates an example of a scene with two objects A and B (150 and 152) and the surrounding fog between the viewpoint and the objects represented in fog layers (154-158).
      <br/>
      Object B at least partially covers Object B, and both objects have partially transparent regions.
    </p>
    <p num="50">
      Each of the fog layers 154-148 have a fog color F, and an amount of fog representing a portion of fog in 3D space.
      <br/>
      The background fog layer 154 has a fog amount of 1 since it extends from object A to infinity.
      <br/>
      Fog layer 156 has an amount of fog g, representing the amount of fog between objects A and B. Finally, fog layer 158 has an amount of fog h, representing the amount of fog between object B and the viewpoint.
      <br/>
      The amount of fog between the viewpoint and object A is .function..
    </p>
    <p num="51">
      Consider that the amount of fog, .function. is defined as follows:
      <br/>
      .function.=1-e- TAU ZA  =1-e- TAU (ZB +ZA-B ) =1-e- TAU ZB e- TAU ZA-B  1-.function.=e- TAU ZA =e- TAU (zB +ZA-B ) =e- TAU ZB  e- TAU ZA-B  =(1-h)(1-g)
    </p>
    <p num="52">
      The fog layers and objects can be rendered independently and composited into image layers to compute a final output image.
      <br/>
      Consider a scene with only object A in front of an opaque fog background (layer 154) of color F. An expression for an image layer representing a rendering of the fogged object A superimposed on the opaque fog background is:
    </p>
    <p num="53">(Fog layer of amount .function. and color F) over (A over F)=.function.F over (A over F).</p>
    <p num="54">
      Since the over operator is associative, this expression can be rewritten as:
      <br/>
      (.function.F over A) over F.
    </p>
    <p num="55">
      One problem with using the over operator in this manner is that the fogged image layer will have non-zero alpha values across the entire layer.
      <br/>
      Specifically, for values of A ALPHA  ranging from 0 to 1, the fogged image layer will have alpha values ranging from .function. to 1.
      <br/>
      Since the fog layers occupy the entire screen, the fogged image layer will occupy the entire screen also and have non-transparent alpha values at every pixel location.
      <br/>
      One way to avoid having non-zero alpha values at every pixel location in the screen is to set the alpha values of the fogged image layer to zero at every location where the object A is totally transparent, or in other words, where A ALPHA  =0.
    </p>
    <p num="56">
      Another way to avoid this problem is to use the atop operator to compute the fogged pixel layer as set forth in the new fog model above:
      <br/>
      Fogged A=.function.A ALPHA  F+(1-.function.)A.
    </p>
    <p num="57">
      Before proceeding to the larger problem of complex scenes, it is useful to examine how the conventional and new fog models compare.
      <br/>
      Recall that the two fogged image calculations are:
      <br/>
      .function.F+(1-.function.)A
      <br/>
      .function.A ALPHA F+( 1-.function.)A
    </p>
    <p num="58">
      These fog models both give the same (correct) result when composited over F. These are just special cases of:
      <br/>
      KF+(1-.function.)A
    </p>
    <p num="59">which, when composited over the final background F gives  (Equation image '1' not included in text)</p>
    <p num="60">
      Since the K terms cancel, any value for K will satisfy this expression when an object is composited over an opaque fog background.
      <br/>
      This observation can be expressed as the following identity:
    </p>
    <p num="61">
      if F ALPHA  =1
      <br/>
      then (KF+B) over F=B over F  (1)
    </p>
    <p num="62">
      Scenes with more than one object and layer of fog such as shown in FIG. 5 present a more complex problem.
      <br/>
      Representing fog as image layers, a layered graphics rendering system can compute the final image by using the over operator to combine image layers representing the objects and fog layers.
      <br/>
      For example, the final image can be represented as:
      <br/>
      (hF over B over gF over A ) over F.
    </p>
    <p num="63">To arrive at this expression, one can start by compositing the front four layers:  (Equation image '2' not included in text)</p>
    <p num="64">
      The fog factor g can be eliminated by substituting an expression for g in terms of .function..
      <br/>
      hF over B over gF over A=(.function.-(.function.-h)B ALPHA )F+(1-h)B+(1-B  ALPHA )(1-.function.)A
    </p>
    <p num="65">
      This result is then composited over the opaque fog background.
      <br/>
      Because of identity (1), the step of compositing this result over an opaque background (F ALPHA ) can be written as:
      <br/>
      (hF over B over gF over A) over F=((1-h)B+(1-B ALPHA )(1-.function.)A) over F.
    </p>
    <p num="66">
      It would be advantageous to find a new fog model of the form:
      <br/>
      (B foggedby h) over (A foggedby .function.) over F;
    </p>
    <p num="67">
      where the "foggedby" operator is an image operator used to simulate the fog in between the view point and an object.
      <br/>
      The new method for simulating fog described above can be substituted for the "foggedby" operator as follows:
      <br/>
      (hF atop B) over (.function.F atop A) over F.
    </p>
    <p num="68">
      This approach has a number of advantages.
      <br/>
      First, objects like A that are partially occluded by other objects (e.g., B ) are fogged using a fog layer having a fog amount .function., the fog amount from the viewpoint all the way to A. Thus, the fog can be computed for A independently of B. In other words, the fog can be computed for A, without regard to whether another object overlapping A is present in the scene.
      <br/>
      Second, the fogged objects A and B can be rendered to separate image layers and composited later to construct an output image.
      <br/>
      As a result, the graphics rendering system can approximate motion of fogged objects in x and y dimensions (in a plane at the same depth from the viewpoint) without re-rendering the fogged layers.
      <br/>
      In addition, the rendering system can simulate the motion of an object in the z-direction (depth from the viewpoint) by rasterizing the layer that moves in the z-direction independently with new values for the amount of fog between the object and the viewpoint.
    </p>
    <p num="69">
      The expression for simulating fog on two objects A and B can be extended to an arbitrary number of layers of fogged objects.
      <br/>
      FIG. 6 extends the example in FIG. 5 by adding another object C (170) with a fog layer 172 of amount j in front of C. Part o.function. the scene, P (174), from FIG. 5 can be treated as a single image layer since these portions of the scene are composited into a layer as explained above.
      <br/>
      The object C and the portion P are in front of an opaque fog background 154.
    </p>
    <p num="70">The new fog layer jF and object C can be overlaid on the combined layer P using the over operator as follows:  (Equation image '3' not included in text)</p>
    <p num="71">In a general stack of objects, each object pixel A, B, C etc. will be multiplied by terms of the form (1-C ALPHA ) for all of the objects in front of it, and by all the terms of form (1-j) for each fog layer in front of it.</p>
    <p num="72">The atop operator can also be used to combine layers of objects and fog as follows:  (Equation image '4' not included in text)</p>
    <p num="73">
      The methods using the over and the atop operator differ because they use a different amount of fog for each layer.
      <br/>
      In the first method, the over operator builds up net pixel color using individual fog slice amounts j, h, and g by the nested products:
      <br/>
      jF+(1-j)C+(1-j)(1-C ALPHA )+(1-h)B+(1-h)(1-B ALPHA )+(1-g)A}}.
    </p>
    <p num="74">In the second method, the atop operator builds the net pixel color using total fog depth amounts j, k, m. These total fog amounts can be defined in terms of the slice amounts as:  (Equation image '5' not included in text)</p>
    <p num="75">
      The net product generated by the atop operator is then:
      <br/>
      jC ALPHA  F+(1-j)C+(1-C ALPHA )+(1-k)B+(1-B ALPHA )+(1-m)A}}
    </p>
    <p num="76">
      The use of the over and atop operators as described above to compute net pixel color from several layers of fog and objects obtains the same result, but the atop operator has some advantages.
      <br/>
      First, it is more convenient to use the atop operator because it uses the total amount of fog from the viewpoint to the object.
      <br/>
      The total amount of fog is easier to compute and facilitates independent rendering of each fogged object, e.g., A, B, and C. In addition, the use of total fog amounts, instead of amounts of slabs or slices of fog, is necessary in cases where the expression for the fog amount is such that the following identity no longer holds:
      <br/>
      (1-.function.)=(1-h)(1-g).
    </p>
    <p num="77">For example, this expression is true for the following definitions of .function., g, and h:</p>
    <p num="78">
      .function.=1-e- TAU ZA
      <br/>
      g=1-e- TAU (ZA -ZB )
      <br/>
      h=1-e- TAU ZB
    </p>
    <p num="79">
      However, the identity might not be true for other fog expressions.
      <br/>
      Thus, the new model for simulating fog, which uses the total amount of fog from the viewpoint to the object, is a more accurate and more general model for a variety of expressions for the fog amount.
    </p>
    <p num="80">Fire and Glow</p>
    <p num="81">
      The new fog model using the atop operation is also accurate when used in conjunction with glowing objects.
      <br/>
      Glowing objects such as fire add brightness to a pixel but do not affect its opacity, alpha.
      <br/>
      A glowing object can be simulated with glow pixels that have a zero alpha component and non-zero color components.
      <br/>
      The simple `over` operator with A ALPHA  =0 then becomes:  (Equation image '6' not included in text)
    </p>
    <p num="82">
      One design issue that results from adding glow pixels in this manner is that the resulting color values must fall within a range of the allowable color values in the graphics rendering system.
      <br/>
      For example, in some systems, this range might be from 0 to 1 (or 0 to 255 for 8 bit color values).
      <br/>
      To address this issue, the rendering system clamps the color values such that they are limited to the predetermined range.
      <br/>
      The discussion below, describing how the fog model applies to glowing objects, explains how to use clamping.
    </p>
    <p num="83">
      The expression for simulating a fogged, glowing object is:
      <br/>
      (.function.A ALPHA  F+(1-.function.)A) over F
    </p>
    <p num="84">
      It might appear that having A ALPHA = 0 would give the wrong result because it removes the contribution of fog in front of the object A. However, the fog model does generate the correct result because of the identity:
      <br/>
      if F ALPHA  =1
      <br/>
      then (KF+B) over F=B over F
    </p>
    <p num="85">
      The fogged, glowing sprite has no fog color in it.
      <br/>
      For A ALPHA  =0, the first term of the fog model is zero such that:
      <br/>
      (.function.A ALPHA  F+(1-.function.)A)=(1-.function.)A
    </p>
    <p num="86">
      When placed over the background color F, the proper amount of .function. shows through to account for the fog color in front of A, i.e. .function.F, as well as the amount of fog peeking through the fogged A, (1-.function.)F. That is,
      <br/>
      .function.F over A over F=(.function.F atop A) over F
    </p>
    <p num="87">independently of any value for A ALPHA .</p>
    <p num="88">
      To demonstrate that the new fog model does not result in any errors due to clamping, consider an example of two pixels, each with one representative color component:
      <br/>
      C.tbd.�Cc C ALPHA  �; D.tbd.�Dc D ALPHA  �
    </p>
    <p num="89">
      The expression for computing C over D on one of the color component and the alpha component can be written as:
      <br/>
      C over D=�clamp(Cc +(1-C ALPHA )Dc)C ALPHA  +(1-C ALPHA )D ALPHA  �
    </p>
    <p num="90">
      It is not necessary to clamp the alpha channel because it will always result in a value from 0 to 1, inclusive, if the original alpha values are in that range.
      <br/>
      A series of over operations should ideally be carried out using an extended range such that clamping can be deferred to the last possible operation.
      <br/>
      One technique using this approach is demonstrated in the first example below.
    </p>
    <p num="91">Consider the three following cases for simulating glowing objects in fog using A=�Ac 0�, F=�Fc 1�:</p>
    <p num="92">1) `over` evaluated front to back: (.function.F over A) over F. This can be evaluated as:  (Equation image '7' not included in text)</p>
    <p num="93">The clamping operation can be avoided since its argument can never be greater than one.  (Equation image '8' not included in text)</p>
    <p num="94">This approach loses a minimal amount of information since the earlier clamp operation is unnecessary.</p>
    <p num="95">2) `over` evaluated back to front: .function.F over(A over F)  (Equation image '9' not included in text)</p>
    <p num="96">Note that the clamp is necessary here because the argument to the clamp operation can be greater than 1.  (Equation image '10' not included in text)</p>
    <p num="97">This approach yields a different and arguably incorrect answer.</p>
    <p num="98">3) `atop` evaluated as: (.function.F atop A)over F  (Equation image '11' not included in text)</p>
    <p num="99">The clamp is not necessary here because the argument of the clamp operation cannot be greater than 1.  (Equation image '12' not included in text)</p>
    <p num="100">This approach yields the correct result.</p>
    <p num="101">Graphics Rendering Systems</p>
    <p num="102">
      FIG. 7 and the following discussion are intended to provide a brief, general description of a suitable computing environment in which a software rendering system or the front end of special purpose graphics rendering hardware can be implemented.
      <br/>
      The methods for simulating fog can be incorporated into rendering systems designed for commercially available graphics programming environments such as the OpenGL programming language from Silicon Graphics Corp. or Direct3D from Microsoft Corp.
    </p>
    <p num="103">
      In software rendering systems, the stages of the graphics rendering pipeline, including traversing the scene database (display traversal), transforming objects to the view space, and rasterizing objects (hidden surface removal, scan conversion, pixel blending, antialiasing, shading, fog, and texture mapping) are performed by software modules executing on a computer.
      <br/>
      Generally, these modules include routines, programs, components, data structures, etc. that perform particular tasks or implement particular abstract data types.
      <br/>
      The software that implements the rasterizer (including a fog applicator as detailed above) can be executed in a variety of computer system configurations, including multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.
      <br/>
      The software for simulating fog can be implemented in a series of computer-executable instructions in the rasterizer.
      <br/>
      Main memory or video memory on a display controller can be used to store intermediate pixel values.
    </p>
    <p num="104">
      The graphics rendering system may be executed in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network.
      <br/>
      In a distributed computing environment, program modules may be located in both local and remote memory storage devices.
    </p>
    <p num="105">
      FIG. 7 shows an example of a computer system for implementing a software rendering system.
      <br/>
      The computer system includes a conventional computer 220, including a processing unit 221, a system memory 222, and a system bus 223 that couples various system components including the system memory to the processing unit 221.
      <br/>
      The system bus may comprise any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of conventional bus architectures such as PCI, VESA, Microchannel, ISA and EISA, to name a few.
      <br/>
      The system memory includes read only memory (ROM) 224 and random access memory (RAM) 225. A basic input/output system 226 (BIOS), containing the basic routines that help to transfer information between elements within the personal computer 220, such as during start-up, is stored in ROM 224.
      <br/>
      The personal computer 220 further includes a hard disk drive 227, a magnetic disk drive 228, e.g., to read from or write to a removable disk 229, and an optical disk drive 230, e.g., for reading a CD-ROM disk 231 or to read from or write to other optical media.
      <br/>
      The hard disk drive 227, magnetic disk drive 228, and optical disk drive 230 are connected to the system bus 223 by a hard disk drive interface 232, a magnetic disk drive interface 233, and an optical drive interface 234, respectively.
      <br/>
      The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, etc. for the personal computer 220.
      <br/>
      Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD, other types of media which are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, and the like, may also be used in this computing environment.
    </p>
    <p num="106">
      A number of program modules may be stored in the drives and RAM 225, including an operating system 235, one or more application programs 236, other program modules 237, and program data 238.
      <br/>
      A user may enter commands and information into the personal computer 220 through a keyboard 240 and pointing device, such as a mouse 242.
      <br/>
      Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like.
      <br/>
      These and other input devices are often connected to the processing unit 221 through a serial port interface 246 that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB).
      <br/>
      A monitor 247 or other type of display device is also connected to the system bus 223 via an interface, such as a video adapter 248.
      <br/>
      In addition to the monitor, personal computers typically include other peripheral output devices (not shown), such as speakers and printers.
    </p>
    <p num="107">
      The personal computer 220 may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer 249.
      <br/>
      The remote computer 249 may be a server, a router, a peer device or other common network node, and typically includes many or all of the elements described relative to the personal computer 220, although only a memory storage device 250 has been illustrated in FIG. 7.
      <br/>
      The logical connections depicted in FIG. 7 include a local area network (LAN) 251 and a wide area network (WAN) 252. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.
    </p>
    <p num="108">
      When used in a LAN networking environment, the personal computer 220 is connected to the local network 251 through a network interface or adapter 253.
      <br/>
      When used in a WAN networking environment, the personal computer 220 typically includes a modem 254 or other means for establishing communications over the wide area network 252, such as the Internet.
      <br/>
      The modem 254, which may be internal or external, is connected to the system bus 223 via the serial port interface 246.
      <br/>
      In a networked environment, program modules depicted relative to the personal computer 220, or portions of them, may be stored in the remote memory storage device.
      <br/>
      The network connections shown are just examples and other means of establishing a communications link between the computers may be used.
    </p>
    <p num="109">Implementation of the Layered Graphics Rendering Pipeline</p>
    <p num="110">
      As described above, the new fog model is particularly useful in a real time, layered graphics rendering pipeline where fogged objects can be rendered independently to fog layers and then composited to form an output image.
      <br/>
      One implementation of a layered graphics rendering pipeline is described in co-pending U.S. patent application Ser.
      <br/>
      No. 08/671,412 by Nathan P. Myhrvold, James T. Kajiya, Jerome E. Lengycl, and Russell Schick, entitled Method and System for Generating Images Using Gsprites, filed on Jun. 27, 1996, which is hereby incorporated by reference.
      <br/>
      This particular rendering system can independently render objects or parts of objects in a scene to separate image layers called sprites.
      <br/>
      For convenience, we describe the details of the architecture here.
      <br/>
      It should be noted that conventional rendering architectures can be adapted to emulate a layered graphics pipeline by rendering objects to separate layers and then using the pixel fill capacity of the rasterizer to composite intermediate pixel values in the image layers.
    </p>
    <p num="111">
      FIG. 8 is a block diagram illustrating one possible implementation of a layered graphics rendering system 330.
      <br/>
      This implementation is designed to communicate with a host computer (such as the computer in FIG. 7) through a bus 332.
      <br/>
      The architecture of the layered graphics system can also be designed such that the microprocessor of the host PC is used in place of the DSP 334.
    </p>
    <p num="112">
      This particular implementation includes a DSP 334, tiler 336, shared memory 338, gsprite engine 340, compositing buffer 342, and digital-to-analog converter (DAC) 344. The bus 332 transfers rendering commands and data (polygons and rendering attributes) between the host and the DSP 334.
      <br/>
      In response to rendering commands from the host, the rendering system renders independent scene elements to sprites, combines the sprites into display images, and transfers the display images to a display device through the DAC 344.
      <br/>
      The independent scene elements are typically contiguous objects (e.g., a robot in a game) or parts of an object (e.g., the robot's arm).
    </p>
    <p num="113">
      The shared memory 338 stores image processing commands and sprites in a specific sprite format called a gsprite (generalized sprite).
      <br/>
      In this implementation, the shared memory is used to store gsprite and texture data, DSP code and data, and buffers used to transfer data between processing subsystems.
      <br/>
      The shared memory 316 shown here comprises 4 Mbytes of RAM, and is implemented using two 8-bit Ram bus channels.
    </p>
    <p num="114">
      The DSP 334 is responsible for performing front end geometry processing, and sprite management.
      <br/>
      Specifically, the DSP performs front end geometry and lighting calculations used for 3-D graphics.
      <br/>
      This includes model and viewing transformations, clipping, and lighting.
      <br/>
      The DSP also performs sprite management including 1) computing sprite transforms, 2) sorting geometry assigned to a sprite among 32 * 32 sample chunks; 3) tracking sprite motion through characteristic points on the object model rendered to a sprite; 4) computing affine warps to approximate changes in position and lighting of previous renderings; 5) computing the error of a warped image approximation; 6) and regulating rendering resources by dynamically adjusting quality parameters of image layers.
      <br/>
      It is important to note that the functions of the preprocessor can also be implemented on the host processor, instead of using both the host processor and DSP.
    </p>
    <p num="115">
      The architecture of the rendering system shown in FIG. 8 is relatively independent of the specific DSP.
      <br/>
      However, the DSP should preferably have significant floating point performance.
      <br/>
      Suitable DSPs include the MSP-1 from Samsung Semiconductor and TriMedia from Phillips Semiconductor.
      <br/>
      These specific DSPs are two examples of DSPs that provide sufficient floating point performance.
      <br/>
      The host processor can used in place of the DSP and interface directly with the tiler 336 through the bus 332.
    </p>
    <p num="116">
      The rendering system 330 shown in FIG. 8 manages image data in three different units: gsprites, chunks, and blocks.
      <br/>
      The system serially renders image layers in 32 * 32 sample chunks.
      <br/>
      To prepare an object for rendering to a sprite, the DSP divides a sprite into chunks and sorts geometry assigned to the sprite among the chunks.
      <br/>
      The DSP also computes a gsprite display list that lists the gsprites for an output image.
      <br/>
      This display list includes pointers to gsprites, and more specifically, to gsprite data structures called header blocks.
      <br/>
      The gsprite header block stores a number of attributes of a gsprite including gsprite width, height, and an affine transform defined in terms of a screen space parallelogram (it may be preferable to use a rectangle to reduce anisotropy of sprite samples).
      <br/>
      The gsprite header block also includes a list of its member chunks.
      <br/>
      This list is in the form of pointers to chunk control blocks.
    </p>
    <p num="117">
      The DSP 334 sets up the gsprite header blocks and stores them in shared memory 316.
      <br/>
      The gsprite header block includes a header for storing various attributes of the gsprite and for keeping track of where related image data is stored in the shared memory.
      <br/>
      The data structure includes fields to store the size of the gsprite, to represent the edge equations for the screen edges of the gsprite, to maintain 2-D transform data, and other image attributes.
    </p>
    <p num="118">
      Chunk control blocks include per chunk and per block parameters.
      <br/>
      The per chunk parameters include compression parameters, pixel format, and whether the pixel data resides in memory managed in Memory Allocation Units (MAU) in linear memory.
      <br/>
      An MAU is a piece of shared memory used to allocate chunk memory.
      <br/>
      MAU managed memory includes a list of MAUs (124 bytes for example), each MAU having a pointer to the next MAU.
      <br/>
      In one specific implementation for example, the chunk control blocks are stored in sequential MAUs for each gsprite.
    </p>
    <p num="119">
      The per block parameters include the number of MAUs the block spans, and a block pointer pointing to the first byte of pixel data for the block.
      <br/>
      The specific block format is an 8 * 8 * 4 array of pixels that encode 32 bit pixels (8 bits for RGB and Alpha).
    </p>
    <p num="120">
      The tiler 336 performs scan-conversion, shading, texturing, hidden-surface removal, anti-aliasing, translucency, shadowing, and blending for multi-pass rendering.
      <br/>
      Preferably the tiler is implemented as a VLSI chip along with the gsprite engine 340.
      <br/>
      The tiler rasterizes polygons one chunk at a time in a serial fashion to compute pixel fragments.
      <br/>
      The pixel fragments include translucent and partially covered pixels.
      <br/>
      In cases where a primitive partially covers a pixel location modeled as 4 * 4 array of sub-pixel regions, the tiler computes the pixel coverage and stores it in a mask which indicates which sub-pixel regions are covered.
      <br/>
      The tiler performs hidden surface removal using a z-buffer approach on pixels.
      <br/>
      It saves the frontmost opaque pixel and any translucent or partially covered pixels in front of the opaque pixel.
    </p>
    <p num="121">
      The tiler has a double buffered rasterization buffer so that it can compute sprite samples in one buffer, while resolving pixel fragments for samples in the second buffer.
      <br/>
      The rasterization buffer includes two 32 * 32 color buffers for double buffering color values of fully covered opaque pixels in the current chunk, a depth buffer for storing depth values for the pixels in the color buffer, and a fragment buffer for storing color, depth, and coverage masks for partially transparent pixels.
      <br/>
      The tiler composites the fragments and fully covered pixel at pixel locations within a chunk to compute a rendered gsprite chunk, a 32 * 32 chunk of pixels in a sprite image layer.
      <br/>
      The tiler stores the resulting rendered gsprite chunks in the shared memory.
    </p>
    <p num="122">
      The tiler has fog logic used to modify color values calculated by the scan conversion engine (rasterizer) within the tiler.
      <br/>
      The scan conversion engine scans primitives (e.g., triangles) and interpolates attributes at vertices to generate pixel coverage and interpolated color values.
      <br/>
      The scan conversion engine also computes the fog factor .function. for each pixel.
      <br/>
      The pixel values and associated fog factor .function. generated by the scan conversion engine are stored in a queue for further processing.
      <br/>
      A fog applicator implements a fog model as described above to apply fog (of amount .function. and color F) to each calculated pixel.
      <br/>
      The output of the fog applicator is transferred to a pixel input processor, which performs depth compare and blending operations to determine how the incoming pixel values should be stored in the rasterization buffer.
      <br/>
      Once all the primitives in a chunk are rasterized, a pixel output processor resolves the pixel fragments for pixels in the chunk.
    </p>
    <p num="123">
      The process of resolving pixel fragments includes taking a depth sorted list of fragments for each pixel location in a chunk and compositing them along with the front-most opaque pixel at the pixel location.
      <br/>
      The pixel output processor sorts the fragments and then uses the opacity and coverage mask to compute the contribution of each fragment to the final pixel color of the output pixel in the sprite.
      <br/>
      The resolved pixels have RGB color and alpha components.
    </p>
    <p num="124">
      The gsprite engine 340 operates at video rates to address the gsprite chunk data and perform the necessary image processing for general affine transformations (which include scaling, translation with subpixel accuracy, rotation, reflection and shearing).
      <br/>
      The gsprite engine can be implemented on the same or a different chip from the tiler 336.
      <br/>
      If on a separate chip, it interfaces with a memory interface unit in the tiler to access the gsprite data structures in shared memory.
    </p>
    <p num="125">
      The gsprite engine 340 includes a video timing generator which controls video display refresh, and generates the timing signals necessary to control gsprite accesses.
      <br/>
      To display each frame, the gsprite engine 340 traverses the gsprite display data structures to determine which sprites need to be read for any given 32-scanline band.
      <br/>
      For each gsprite in a band, the gsprite engine reads the header block, clips the sprite to the current display band, and places the sprite in the sprite queue for rasterization.
      <br/>
      The gsprite engine scans each sprite based on the specified affine transform in the gsprite header and generates read requests.
      <br/>
      To hide the latency of sprite accesses, the gsprite engine utilizes a caching scheme that pre-fetches and caches sprite blocks in a cache memory before a rasterizer computes transformed sprite samples using the cached data.
    </p>
    <p num="126">
      A simple rasterizer in the gsprite engine scans each sprite based on the specified affine transform in the gsprite header and calculates the filter parameters for each pixel.
      <br/>
      The gsprite engine uses a filter to map color and alpha data at sample locations in gsprite space to screen space.
      <br/>
      Specifically, it applies either a 2 * 2 or 4 by 4 filter kernel to compute pixel values (color or both color and alpha) at pixel locations in screen space.
    </p>
    <p num="127">
      The gsprite engine has a compositing buffer control for controlling the operation of a compositing buffer.
      <br/>
      The compositing buffer control passes transformed sprite samples and instructions on how to combine samples from different layers.
      <br/>
      The compositing buffer control monitors a ready line from the compositing buffer 342 to ensure that the gsprite engine 340 does not overrun the compositing buffer 342.
    </p>
    <p num="128">
      Gsprite chunk data is processed a number of scan lines at a time for display.
      <br/>
      In one implementation, chunk data is processed 32 scan lines at a time.
      <br/>
      This implementation of the compositing buffer (342) includes two 32 scan line color buffers which are toggled between display and compositing activities.
      <br/>
      The compositing buffer also includes a 32 scan line alpha buffer which is used to accumulate alpha for each pixel.
      <br/>
      This particular compositing buffer has compositing logic that implements the over image operator.
      <br/>
      The compositing logic receives transformed sprite samples, and combines them with the accumulated color values using the alpha values from the alpha buffers.
    </p>
    <p num="129">
      The DAC 344 includes a R G B video DAC and corresponding video port 346, to video editing devices.
      <br/>
      Individual components can be used to implement the functionality of the DAC.
      <br/>
      The DAC 344 implements the basic functions that are common to most RAMDACs on the market today.
      <br/>
      The DAC includes logic for reading and writing internal control registers, and for pipelining the video control signals.
      <br/>
      The DAC includes pixel data routing logic that controls the routing of pixel data from the compositing buffers.
      <br/>
      In the normal operating mode, this data is passed at pixel rates to Color LUTs for each of the three channels.
      <br/>
      The DAC also has a clock generator that generates the video clock.
      <br/>
      These clocks are generated by two phase locked clock generators to eliminate synchronization drift.
    </p>
    <p num="130">Using the Fog Model on Sprites</p>
    <p num="131">
      While the fog model described above applies to a variety of rendering architectures, it is particularly useful in rendering architectures where objects can be rendered to separate image layers or "sprites." In such systems, the new fog model has implications in two parts of the rendering pipeline: 1) in the tiler, where it is used to generate fogged pixels in a sprite using the atop operator; and 2) in the sprite compositor, where it facilitates compositing of sprites representing fogged objects using the over operator.
      <br/>
      In the layered architecture described above, the tiler performs the first computation, and the gsprite engine controls the second computation in conjunction with the compositing buffers, which combine sprites using the over operator.
    </p>
    <p num="132">Generating Sprites</p>
    <p num="133">To generate fogged sprite pixels, a rendering system applies fog of color F and an amount corresponding to the fog influence from the viewpoint to the surface being rendered.</p>
    <p num="134">
      Given the parameters:
      <br/>
      fog amount=.function.
      <br/>
      fog color=F=�Fc 1�
      <br/>
      polygon color=A=�Ac A ALPHA  �
    </p>
    <p num="135">The fogged sprite color should be:  (Equation image '13' not included in text)</p>
    <p num="136">
      The components within the tiler for making this computation are explained further above.
      <br/>
      In summary, the fog applicator implements logic to perform this calculation using the fog color F, pixel color and alpha A, and fog amount .function..
    </p>
    <p num="137">Compositing Operations on Fog Sprites</p>
    <p num="138">
      In a layered graphics pipeline, the rasterizer can apply fog to each object independently as it renders the object to a sprite layer.
      <br/>
      The compositing buffer can then be used to composite fogged object layers and the opaque fog background layer.
    </p>
    <p num="139">
      Given two objects embedded in fog, the expression for fogging the scene can be factored into a series fogged image layers combined with the over operator:
      <br/>
      (hF atop B) over (.function.F atop A) over F
    </p>
    <p num="140">
      Each fogged surface can be placed in a separate sprite:
      <br/>
      sprite 1=hF atop B
      <br/>
      sprite 2=.function.F atop A
      <br/>
      sprite 3=F
    </p>
    <p num="141">
      Each of the objects can move in (x,y) directions in the scene without re-rendering.
      <br/>
      If an object moves in the z direction, this object can be rendered independently to a new sprite layer, without re-rendering the other fogged objects in separate sprites.
      <br/>
      The non-changing (or imperceptibly changing) sprites can retain their original color values for more than one frame in an animation sequence.
      <br/>
      To compute each output image, the rendering system can composite the separate layers, including both re-used and/or re-rendered fog layers, using the over image operator.
    </p>
    <p num="142">Conclusion</p>
    <p num="143">
      While the invention is explained with reference to a specific rendering architecture, it is important to emphasize that it can be employed in a variety of graphics rendering architectures, whether they implement a frame buffer or a chunking architecture as described above.
      <br/>
      The fog model applies to a layered graphics pipeline and more conventional rendering pipeline where all geometry is rendered to a single output image, rather than independent layers.
      <br/>
      The precise logic or software instructions used to implement the fog model can vary as well.
    </p>
    <p num="144">
      In view of the many possible embodiments to which the principles of my invention may be applied, it should be recognized that the illustrated embodiment is only an example of the invention and should not be taken as a limitation on the scope of the invention.
      <br/>
      Rather, the scope of the invention is defined by the following claims.
      <br/>
      I therefore claim as my invention all that comes within the scope and spirit of these claims.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>In a graphics rendering system for generating an output image from a 3D graphics scene having a viewpoint and graphical object models, a method for simulating fog in the 3D graphics scene, the method comprising:</claim-text>
      <claim-text>for a pixel having a color A and being rasterized for an object in the 3D graphics scene, computing an amount of fog .function. of color F between the viewpoint and the object, wherein A comprises color components and an opacity component; applying the amount of fog .function. between the viewpoint and the object to the pixel using at least F and A in an atop image operator, wherein applying the amount of fog comprises the following (a)-(c)</claim-text>
      <claim-text>- (a) multiplying each of the color and opacity components of the pixel by a factor (1-.function.) to compute a first intermediate result, where .function. is a dissolve factor representing an amount of fog between the viewpoint in the scene and pixel depth of the pixel; - (b) multiplying color components of a fog color value F by the opacity component of the pixel, and by the dissolve factor .function. to compute a second intermediate result;</claim-text>
      <claim-text>and - (c) adding the first and second intermediate results to compute a fogged pixel;</claim-text>
      <claim-text>and repeating the above for additional pixels rasterized for the object to compute an image simulating the object in fog.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1 further including repeating the method for a second object and compositing the pixels resulting from applying fog using an atop operator to each of the objects to compute an image simulating the objects in fog.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 2 including separately computing fogged image layers representing fogged pixels of the objects using an atop operator;</claim-text>
      <claim-text>and compositing the fogged image layers computed using an atop operator, said compositing using an over image operator to compute a composite image.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method claim 1 wherein the method computes each fogged pixel according to the following expression, .function.F atop A; where .function. is the amount of fog, F is fog color, and A is a color of the pixel being fogged.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 1 including computing fogged image layers for objects in the graphics scene using an atop image operator to compute each of the fogged image layers;</claim-text>
      <claim-text>and combining each of the fogged image layers into an output image using an over image operator to combine the fogged image layers.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 1 including independently computing fogged image layers for objects in the graphics scene;</claim-text>
      <claim-text>and approximating motion of a moving object in the scene in an (x,y) plane relative to a viewpoint of the scene by moving a fogged image layer representing the moving object in the (x,y) plane.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 1 wherein the object is a glowing object, having pixels with zero alpha components and non-zero color components, and wherein fog is applied to the glowing object according to the following formula:</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8.</claim-text>
      <claim-text>The method of claim 1 wherein at least two fogged pixels from different objects at a pixel location are combined according to the following formula, wherein the pixels have colors A and B: where A and B are pixel color values from the different objects and the pixel of color B is in front of the pixel of color A relative to the viewpoint, h is an amount of fog from the viewpoint to the pixel of color B, and .function. is an amount of fog from the viewpoint to the pixel of color A.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 8 wherein more than two pixels from different objects at a pixel location are fogged according to an expression (xF atop X) where X are color values of an object and x is an amount of fog from the viewpoint to pixel X;</claim-text>
      <claim-text>and wherein the fogged pixels are combined using the over operator.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A computer-readable medium having computer executable instructions for performing the method of claim 1.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. In a graphics rendering system for generating an output image from a 3D graphics scene having a viewpoint and graphical object models, a method for simulating fog in the 3D graphics scene, the method comprising: for a pixel having a color A and being rasterized for an object in the 3D graphics scene, computing an amount of fog .function. of color F between the viewpoint and the object, wherein A comprises an opacity component; applying the amount of fog .function. between the viewpoint and the object to the pixel using at least F and A in an atop image operator; repeating the above for additional pixels rasterized for the object to compute an image simulating the object in fog; simulating motion of a moving object in the scene in a z-direction relative to the viewpoint of the scene by rendering the moving object, including fogging the pixels of the moving object with a new fog amount, to compute a fogged image layer representing the moving object;</claim-text>
      <claim-text>and re-using a previously computed fogged image layer by compositing the fogged image layer representing the moving object with the previously computed fogged layer to compute an output image.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. In a graphics rendering system for generating an output image from a 3D graphics scene, a fog simulator for applying fog of color F to a pixel comprising a color component A, wherein A comprises an opacity value, the fog simulator comprising: an amount of fog calculator for calculating an amount of fog .function. between the viewpoint and an object;</claim-text>
      <claim-text>and a fog applier using A, F and .function. in an atop image operator to apply the amount of fog .function. of color F to the pixel comprising a color A, wherein A comprises an opacity value;</claim-text>
      <claim-text>wherein the atop image operator comprises: - a first multiplier for multiplying the amount of fog .function. and opacity of the pixel to compute .function.A ALPHA  ; - a second multiplier for multiplying .function.A ALPHA  and a fog color F to compute .function.A ALPHA  F; - a third multiplier for multiplying (1-.function.) and pixel color A to compute (1-.function.)A;</claim-text>
      <claim-text>and - an adder for adding the results of the second and third multipliers to compute a fogged pixel via the atop image operator.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The fog simulator of claim 12 further including: a rasterizer for computing pixel color, opacity and depth values for pixel locations in a view space from geometric primitives in the object, for computing the amount of fog .function., and for communicating the pixel color and opacity values and the amount of fog .function. to the fog applier.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The fog simulator of claim 12 further including an over image operator in communication with the adder for compositing the fogged pixel computed by the adder via the atop image operator with a pixel generated from a different object.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A graphics rendering system including a fog mode for applying fog to objects rendered as pixels to simulate fog, the graphics rendering system comprising: a rasterizer for computing pixel color, opacity and depth values for pixel locations in a view space from geometric primitives in the objects, and for computing an amount of fog .function. between a viewpoint and an object surface of one of the objects being rendered; a fog applicator for applying the amount of fog of a predetermined color to rasterized pixels from the rasterizer using an atop image operator to yield a plurality of fogged pixels from different objects, wherein the fogged pixels are fogged using an atop image operator;</claim-text>
      <claim-text>and a compositor for compositing the plurality of fogged pixels from different objects together to compute a composite pixel value, wherein the plurality of fogged pixels are fogged using an atop image operator;</claim-text>
      <claim-text>wherein the fog is of a color F; rasterized pixels from the rasterizer each comprise color components A, the color components A each comprising an opacity component;</claim-text>
      <claim-text>and the fog applicator is operable for applying the amount of fog of a predetermined color to rasterized pixels from the rasterizer by using at least the following (a)-(c) for a pixel being fogged: - (a) multiplying the color components A, including the opacity component, of the pixel being fogged by a factor (1-.function.) to compute a first intermediate result, where .function. is a dissolve factor representing an amount of fog between the viewpoint in the scene and pixel depth of the pixel being fogged; - (b) multiplying color components of a fog color value F by the opacity component of the pixel being fogged, and by the dissolve factor .function. to compute a second intermediate result;</claim-text>
      <claim-text>and - (c) adding the first and second intermediate results to compute a fogged pixel, wherein the fogged pixel is a fogged version of the pixel being fogged.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The rendering system of claim 15 wherein the rasterizer and fog applicator are operable to compute fogged image layers independently;</claim-text>
      <claim-text>and wherein the compositor is operable to combine independently rendered fogged image layers to form an output image for display.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. In a graphics rendering system for generating an output image from a 3D graphics scene having a viewpoint and graphical object models, a method for simulating fog in the 3D graphics scene, the method comprising: for a pixel being fogged and rasterized for an object in the 3D graphics scene, wherein the pixel being fogged has color components and an opacity component, computing an amount of fog .function. of color F between the viewpoint and the object; applying the amount of fog .function. between the viewpoint and the object to the pixel being fogged using an atop image operator by performing at least the following (a) (b) and (c): - (a) multiplying the color components and the opacity component of the pixel being fogged by a factor (1-.function.) to compute a first intermediate result, where .function. is a dissolve factor representing an amount of fog between the viewpoint in the scene and pixel depth of the pixel being fogged; - (b) multiplying color components of a fog color value F by the opacity component of the pixel being fogged, and by the dissolve factor .function. to compute a second intermediate result;</claim-text>
      <claim-text>and - (c) adding the first and second intermediate results to compute a fogged pixel, wherein the fogged pixel is a fogged version of the pixel being fogged;</claim-text>
      <claim-text>and - repeating the above steps for additional pixels rasterized for the object to compute an image simulating the object in fog.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method of claim 17 wherein the object is a first object and the pixel being fogged is a first pixel being fogged, the method further comprising: for a second pixel being fogged and rasterized for a second object in the 3D graphics scene, wherein the second pixel being fogged has color components and an opacity component, computing an amount of fog .function. of color F between the viewpoint and the second object, wherein the second object overlaps the first from the viewpoint; applying the amount of fog .function. between the viewpoint and the second object to the second pixel being fogged using an atop image operator by performing at least (a) (b) and (c);</claim-text>
      <claim-text>and combining the first fogged pixel and the second fogged pixel to compute a composite fogged pixel, wherein the composite fogged pixel is a fogged version of a pixel representing an overlap between the first object and the second object.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. A computer-readable medium having computer executable instructions for performing the following in a graphics rendering system for generating an output image from a 3D graphics scene having a viewpoint and graphical object models to simulate fog in the 3D graphics scene: for a pixel being fogged and rasterized for an object in the 3D graphics scene, wherein the pixel being fogged has color components and an opacity component, computing an amount of fog .function. of color F between the viewpoint and the object; applying the amount of fog .function. between the viewpoint and the object to the pixel being fogged using an atop image operator by performing at least the following (a) (b) and (c): - (a) multiplying the color components and the opacity component of the pixel being fogged by a factor (1-.function.) to compute a first intermediate result, where .function. is a dissolve factor representing an amount of fog between the viewpoint in the scene and pixel depth of the pixel being fogged; - (b) multiplying color components of a fog color value F by the opacity component of the pixel being fogged, and by the dissolve factor .function. to compute a second intermediate result;</claim-text>
      <claim-text>and - (c) adding the first and second intermediate results to compute a fogged pixel, wherein the fogged pixel is a fogged version of the pixel being fogged;</claim-text>
      <claim-text>and repeating the above for additional pixels rasterized for the object to compute an image simulating the object in fog.</claim-text>
    </claim>
  </claims>
</questel-patent-document>