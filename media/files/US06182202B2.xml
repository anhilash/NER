<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182202B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182202</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182202</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="25505467" extended-family-id="42109051">
      <document-id>
        <country>US</country>
        <doc-number>08962134</doc-number>
        <kind>A</kind>
        <date>19971031</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08962134</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165695</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>96213497</doc-number>
        <kind>A</kind>
        <date>19971031</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08962134</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/355       20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>355</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>711212000</text>
        <class>711</class>
        <subclass>212000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>711214000</text>
        <class>711</class>
        <subclass>214000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>711220000</text>
        <class>711</class>
        <subclass>220000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>712210000</text>
        <class>712</class>
        <subclass>210000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>712E09030</text>
        <class>712</class>
        <subclass>E09030</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>712E09042</text>
        <class>712</class>
        <subclass>E09042</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/355</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>355</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-009/30T4</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30T4</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/355</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>355</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3016</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3016</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>68</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>6</number-of-drawing-sheets>
      <number-of-figures>6</number-of-figures>
      <image-key data-format="questel">US6182202</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Generating computer instructions having operand offset length fields for defining the length of variable length operand offsets</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>BALOGH E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>3735355</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US3735355</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>HASTINGS THOMAS N, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4241397</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4241397</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>HOUSEMAN DAVID L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4466057</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4466057</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>KURAKAZU KEIICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4825355</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4825355</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>KAGIMASA TOYOHIKO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4868740</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4868740</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>WATANABE MASAYA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5038280</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5038280</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>NOGUCHI KOUKI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5117488</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5117488</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>KASHIMA MASAHIKO</text>
          <document-id>
            <country>US</country>
            <doc-number>5179676</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5179676</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>FU BEATRICE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5293592</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5293592</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>MC68020 32-bit Microprocessor User's Manual 1985, pp. B-70 and B-87.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>i486 Microprocessor Programmer's Reference Manual 1989 pp. 26-1 to 26-7.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Brumm, Penn. "80486 Programming," Windcrest 1991 p 181-186.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>"Java Virtual Machine Instruction Set," pp. 337 and 338, The JAVA(TM) Virtual Machine Specification.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Oracle Corporation</orgname>
            <address>
              <address-1>Redwood Shores, CA, US</address-1>
              <city>Redwood Shores</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>ORACLE</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Muthukkaruppan, Kannan</name>
            <address>
              <address-1>Foster City, CA, US</address-1>
              <city>Foster City</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Hickman Palermo Troung &amp; Becker LLP</orgname>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>Brandt, Carl L.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Kim, Kenneth S.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A method and apparatus for storing a variable length operand offset in a computer instruction is provided.
      <br/>
      An operand base is stored in a computer instruction.
      <br/>
      Also stored in the computer instruction is a variable length operand offset that is associated with the operand base.
      <br/>
      In addition, an operand offset length is stored within the computer instruction that defines the length of the variable length operand offset.
      <br/>
      Storing an operand offset length with each variable length operand offset in a computer instruction provides for the reduction of unused space.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates to computer instructions, and more specifically to the storing of operand addresses in a computer instruction.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      Computer languages generally include instructions that contain an op-code and one or more operand addresses.
      <br/>
      The op-code typically represents a mathematical or logical operation that is to be performed by the instruction (e.g., MOV (move), ADD, STORE and SUB (subtract)).
      <br/>
      The operands represent a quantity or function that the mathematical or logical operation is to be performed on.
      <br/>
      For example, a computer instruction of MOV A, B contains the op-code MOV operating on the operands located at memory addresses A and B.
    </p>
    <p num="3">
      Commonly, a computer language allows operand addresses to be specified using either a direct addressing mode or an indirect addressing mode.
      <br/>
      In a direct addressing mode, the address specified in the computer instruction is the actual machine address at which is stored the data to be used for the operand.
      <br/>
      Conversely, in an indirect addressing mode, the address specified in the computer instruction is an address at which is stored an address that specifies the memory location that contains the data that is to be used for the operand.
    </p>
    <p num="4">
      For example, assume that A represents address location 100 in memory and B represents address location 102 in memory.
      <br/>
      The instruction MOV A,B uses direct addressing and causes the value stored in address 102 to be moved to address 100.
      <br/>
      As a further example, assume memory location 102 has a value of 200 stored in it and the instruction MOV A,�B� is executed.
      <br/>
      The instruction MOV A,�B� uses indirect addressing for the second operand (noted in this example by the brackets � � surrounding B) and direct addressing for the first operand (noted in this example by the lack of brackets surrounding A).
      <br/>
      Thus, the execution of this instruction causes the value stored at memory location 200 to be moved to memory location 100.
    </p>
    <p num="5">
      In typical database systems, users store, update and retrieve information by submitting commands, or, more generally, statements, to a database application.
      <br/>
      To be correctly processed, the statements must comply with a database language that is supported by the particular database system.
      <br/>
      For example, a database application may be configured to support the processing of database queries according to the Oracle-based Programming Language using Structured Query Language (PL/SQL).
    </p>
    <p num="6">
      Blocks of PL/SQL code (e.g., procedures, functions and packages) can be stored in a compiled format within a database.
      <br/>
      These compiled PL/SQL blocks can provide several advantages to a database system, such as increased security, increased performance and a reduction in memory requirements.
      <br/>
      For example, increased security can be provided by granting access to a schema object, such as a table, only through a particular stored procedure.
      <br/>
      Performance can be increased in a client-server environment since storing procedures within the database can reduce network traffic.
      <br/>
      Performance may also be increased as the stored procedures are already in a compiled format, and, thus, recompilation is unnecessary.
    </p>
    <p num="7">
      In addition, memory requirements can be reduced as only a single copy of a stored procedure needs to be stored in a shared area of memory which can be accessed by multiple users.
      <br/>
      A stored procedure can remain in a shared area of memory throughout a series of invocations by multiple users/applications, thereby avoiding the need to repeatedly retrieve the procedure from disk for each invocation.
    </p>
    <p num="8">
      In a compiled format, the PL/SQL code blocks specify a series of instructions for a virtual machine.
      <br/>
      The code blocks can be interpreted by a PL/SQL engine in order to execute the instructions contained in the code blocks.
      <br/>
      These instructions may contain operand addresses that are comprised of an operand address base pointer, sometimes referred to herein as an "operand base," (e.g., contents of a particular register, a stack frame pointer, etc.), and one or more operand address offsets (sometimes referred to herein as "operand offsets" or "offsets".) For example, in the instruction ADD REG+A,5, the address stored in register REG is the operand address base pointer and A is an operand address offset.
      <br/>
      Thus, executing this instruction adds 5 to the value stored at the memory address X+A where X is the address stored in register REG.
      <br/>
      If register REG stores the address 100 and A has a value of 3, executing the instruction ADD REG+A,5 adds 5 to the value stored in memory location 103.
    </p>
    <p num="9">
      As a further example, consider the instruction MOVC FP+A, DL�4��8�. In this example, the first operand address in the instruction is comprised of an operand address base pointer represented by frame pointer register FP and an operand address offset represented by the variable A. As shown by the lack of brackets, the operand address offset A is specified in the direct addressing mode.
      <br/>
      Conversely, the second operand address in the instruction is comprised of an operand address base pointer represented by a register DL and two operand address offsets represented by �4� and �8�. As indicated by the brackets, the two operand address offsets �4� and �8� are each specified in the indirect addressing mode.
      <br/>
      The second operand address is computed as follows:
    </p>
    <p num="10">
      1) the value stored in register DL is added to 4 to produce a first address;
      <br/>
      2) the value stored in memory at the first address is added to 8 to produce a second address;
      <br/>
      3) the second operand address is the value stored in memory at the second address.
    </p>
    <p num="11">
      Typically, instruction formats allocate a fixed amount of space for each operand address offset.
      <br/>
      The fixed amount of space is determined by the largest possible value for an operand address offset.
    </p>
    <p num="12">
      For example, FIG. 1 illustrates an instruction 100 in which a typical fixed storage technique is used to allocate a fixed number of bytes (4) for each operand offset.
      <br/>
      As depicted in FIG. 1, instruction 100 is comprised of an op-code 102, operand bases 104 and 116, operand offsets 138, 140 and 142, and control codes 114, 126 and 136.
      <br/>
      Control codes 114, 126 and 136 are associated with operand offsets 138, 140 and 142 respectively, and are used to indicate whether a particular operand offset is applied in a direct or indirect addressing mode.
      <br/>
      In addition, the control codes 114, 126 and 136 are used to indicate whether another operand offset is associated with a particular operand base.
      <br/>
      Thus, as depicted in FIG. 1, using this fixed storage technique, instruction 100 can be represented using 18 bytes.
    </p>
    <p num="13">
      However, a drawback associated with allocating a fixed amount of space for each operand offset is that compiled PL/SQL blocks are larger than necessary since many operand offsets require less than the fixed amount of allocated space (this is evident in instruction 100 as operand offset bytes 106, 108, 110, 118, 120, 122, 128, 130 and 132 are all set to zero).
      <br/>
      Because the compiled PL/SQL blocks are larger than necessary, a fewer number of blocks can be simultaneously resident in the shared memory area allocated for stored PL/SQL blocks.
      <br/>
      This problem is exacerbated as the shared memory area becomes fragmented, i.e. one or more PL/SQL blocks might have to be removed from the shared area to make room for another PL/SQL block even though the total amount of free (though not contiguous) space available in the shared area is large enough to hold the newly required PL/SQL block.
      <br/>
      This results in a greater number of retrievals of compiled PL/SQL blocks from disk, and a resultant degradation in database performance.
    </p>
    <p num="14">
      Another detrimental side effect associated with allocating a fixed amount of space for each operand offset is a reduction in the scalability of the system.
      <br/>
      Scalability is a measure of the number of concurrent applications that can be resident in memory and executing with satisfactory performance on a system at one time.
      <br/>
      As the compiled PL/SQL blocks are larger, less of them can be resident in memory at the same time.
      <br/>
      This results in a reduction in the number of applications that can execute concurrently, since the compiled PL/SQL blocks that are required for the applications wanting to execute may not be able to reside in memory simultaneously.
    </p>
    <p num="15">
      Another drawback associated with allocating a fixed amount of space for each operand offset is that additional, unnecessary processing is performed on unused memory bytes of an operand offset.
      <br/>
      Stored operand offsets are typically processed by a PL/SQL engine on a byte by byte basis, in order to generate a corresponding integer value of the operand offset in a "native" (i.e., machine dependent) format that is expected by the machine on which the PL/SQL engine is executing.
      <br/>
      For example, integers in an PL/SQL virtual machine ("VM") instruction might be stored with the most significant byte first, whereas in a corresponding native instruction integers might be stored in the opposite manner (i.e., with the least significant byte first).
      <br/>
      In this case, the PL/SQL engine would multiply each byte (of an integer) by an appropriate power of two, and sum the results to produce the same integer for the native instruction format.
      <br/>
      This can require unnecessary processing if the PL/SQL engine must assume that each operand offset requires a fixed number of bytes (e.g., 4).
      <br/>
      If an operand offset only requires one non-zero byte, the PL/SQL engine performs three unnecessary multiplications.
    </p>
    <p num="16">
      Even if the native and PL/SQL VM integer formats are the same, the PL/SQL engine may have to copy the VM formatted operand offsets that are stored at locations that are not byte aligned (as required by the native instruction format) to a new location that is properly byte aligned.
      <br/>
      Unnecessary copying of unused operand offset bytes is performed if the PL/SQL engine must assume that each operand offset is of a fixed size.
    </p>
    <p num="17">
      One approach to reducing the wasted space problem is to provide multiple instructions for each op-code (e.g., MOV1, MOV2, MOV3 for the op-code MOV) which accommodate different fixed size operands.
      <br/>
      By using the instruction (op-code) that uses the smallest fixed size operand offsets large enough to hold the required offset values, the amount of wasted space in an instruction can be reduced.
      <br/>
      For example, a MOV1 instruction can comprise the op-code MOV1 and two operand offsets that are each one byte in size, and a MOV2 instruction can comprise the op-code MOV2 and two operand offsets that are each two bytes in size.
    </p>
    <p num="18">
      By using the MOV1 instruction whenever the operand offsets require only one byte each and the MOV2 instruction whenever the operand offsets require two bytes each, the wasted space problem can be reduced.
      <br/>
      However, a drawback with this approach is that it significantly increases the number of instructions that must be supported by a particular system.
      <br/>
      For example, if a MOV instruction can have two operand offsets, each comprising up to four bytes in size, the system that is executing the instructions must support 42 or sixteen different MOV instructions if it is to support all possible combinations of operand offset sizes.
      <br/>
      Therefore, this approach may be viable for a RISC like language like JAVA.
      <br/>
      However, for a database language such as PL/SQL, the number of instructions would quickly become overwhelmingly large as database instructions tend to be longer and more complex and therefore would require many more instruction permutations.
    </p>
    <p num="19">Based on the foregoing, it is desirable to provide a mechanism for reducing the amount of unused space in fields of an instruction that store operand address offsets without having to increase the number of instructions that must be supported by a particular system.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="20">
      A method and apparatus for storing a variable length operand offset in a computer instruction is provided.
      <br/>
      According to one aspect of the invention, an operand base is stored in a computer instruction.
      <br/>
      Also stored in the computer instruction is a variable length operand offset that is associated with the operand base.
      <br/>
      In addition, an operand offset length is stored within the computer instruction that defines the length of the variable length operand offset.
    </p>
    <p num="21">According to another aspect of the invention, a control code is stored in the computer instruction and is used to indicate whether an associated variable length operand offset is to be applied with a direct or indirect addressing node.</p>
    <p num="22">According to another aspect of the invention, the operand base and operand offset length are stored in a single byte within the computer instruction.</p>
    <p num="23">According to another aspect of the invention, the operand offset length and the control code are stored in a single byte within the computer instruction.</p>
    <p num="24">According to another aspect of the invention, the operand base, the operand offset length and the control code are stored in a single byte within the computer instruction.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="25">
      The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:
      <br/>
      FIG. 1 is a block diagram depicting how instructions with fixed size operand offsets may conventionally be stored in computer instructions;
      <br/>
      FIG. 2 is a block diagram of a computer system upon which an embodiment of the invention may be implemented;
      <br/>
      FIG. 3 is a block diagram depicting the storing of operand offset lengths in computer instructions according to an embodiment of the invention;
      <br/>
      FIG. 4 is a block diagram depicting the storing of an operand offset length and control code within a single byte in computer instructions according to an embodiment of the invention;
      <br/>
      FIG. 5 is a block diagram depicting the storing an operand offset length, control code and operand base within a single byte in computer instructions according to an embodiment of the invention; and
      <br/>
      FIG. 6 is a block diagram depicting the storing of an operand offset length and operand base within a single byte and an operand offset length and control code within a single byte in computer instructions according to an embodiment of the invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="26">
      A method and apparatus for storing variable length operand offsets in a computer instruction is described.
      <br/>
      In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention.
      <br/>
      It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details.
      <br/>
      In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.
    </p>
    <heading>HARDWARE OVERVIEW</heading>
    <p num="27">
      FIG. 2 is a block diagram that illustrates a computer system 200 upon which an embodiment of the invention may be implemented.
      <br/>
      Computer system 200 includes a bus 202 or other communication mechanism for communicating information, and a processor 204 coupled with bus 202 for processing information.
      <br/>
      Computer system 200 also includes a main memory 206, such as a random access memory (RAM) or other dynamic storage device, coupled to bus 202 for storing information and instructions to be executed by processor 204.
      <br/>
      Main memory 206 also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor 204.
      <br/>
      Computer system 200 further includes a read only memory (ROM) 208 or other static storage device coupled to bus 202 for storing static information and instructions for processor 204.
      <br/>
      A storage device 210, such as a magnetic disk or optical disk, is provided and coupled to bus 202 for storing information and instructions.
    </p>
    <p num="28">
      Computer system 200 may be coupled via bus 202 to a display 212, such as a cathode ray tube (CRT), for displaying information to a computer user.
      <br/>
      An input device 214, including alphanumeric and other keys, is coupled to bus 202 for communicating information and command selections to processor 204.
      <br/>
      Another type of user input device is cursor control 216, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor 204 and for controlling cursor movement on display 212.
      <br/>
      This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.
    </p>
    <p num="29">
      The invention is related to the use of computer system 200 for storing variable length operand offsets in a computer instruction.
      <br/>
      According to one embodiment of the invention, the storing of variable length operand offsets in a computer instruction is provided by computer system 200 in response to processor 204 executing one or more sequences of one or more instructions contained in main memory 206.
      <br/>
      Such instructions may be read into main memory 206 from another computer-readable medium, such as storage device 210.
      <br/>
      Execution of the sequences of instructions contained in main memory 206 causes processor 204 to perform the process steps described herein.
      <br/>
      In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention.
      <br/>
      Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.
    </p>
    <p num="30">
      The term "computer-readable medium" as used herein refers to any medium that participates in providing instructions to processor 204 for execution.
      <br/>
      Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media.
      <br/>
      Non-volatile media includes, for example, optical or magnetic disks, such as storage device 210.
      <br/>
      Volatile media includes dynamic memory, such as main memory 206.
      <br/>
      Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus 202.
      <br/>
      Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.
    </p>
    <p num="31">Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punch-cards, paper-tape, any other physical medium with patterns of holes, a RAM, a PROM, an EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.</p>
    <p num="32">
      Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor 204 for execution.
      <br/>
      For example, the instructions may initially be carried on a magnetic disk of a remote computer.
      <br/>
      The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem.
      <br/>
      A modem local to computer system 200 can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal.
      <br/>
      An infra-red detector coupled to bus 202 can receive the data carried in the infra-red signal and place the data on bus 202.
      <br/>
      Bus 202 carries the data to main memory 206, from which processor 204 retrieves and executes the instructions.
      <br/>
      The instructions received by main memory 206 may optionally be stored on storage device 210 either before or after execution by processor 204.
    </p>
    <p num="33">
      Computer system 200 also includes a communication interface 218 coupled to bus 202.
      <br/>
      Communication interface 218 provides a two-way data communication coupling to a network link 220 that is connected to a local network 222.
      <br/>
      For example, communication interface 218 may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line.
      <br/>
      As another example, communication interface 218 may be a local area network (LAN) card to provide a data communication connection to a compatible LAN.
      <br/>
      Wireless links may also be implemented.
      <br/>
      In any such implementation, communication interface 218 sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.
    </p>
    <p num="34">
      Network link 220 typically provides data communication through one or more networks to other data devices.
      <br/>
      For example, network link 220 may provide a connection through local network 222 to a host computer 224 or to data equipment operated by an Internet Service Provider (ISP) 226. ISP 226 in turn provides data communication services through the world wide packet data communication network now commonly referred to as the "Internet" 228.
      <br/>
      Local network 222 and Internet 228 both use electrical, electromagnetic or optical signals that carry digital data streams.
      <br/>
      The signals through the various networks and the signals on network link 220 and through communication interface 218, which carry the digital data to and from computer system 200, are exemplary forms of carrier waves transporting the information.
    </p>
    <p num="35">
      Computer system 200 can send messages and receive data, including program code, through the network(s), network link 220 and communication interface 218.
      <br/>
      In the Internet example, a server 230 might transmit a requested code for an application program through Internet 228, ISP 226, local network 222 and communication interface 218.
      <br/>
      In accordance with the invention, one such downloaded application provides for the storing of variable length operand offsets in a computer instruction as described herein.
    </p>
    <p num="36">
      The received code may be executed by processor 204 as it is received, and/or stored in storage device 210, or other non-volatile storage for later execution.
      <br/>
      In this manner, computer system 200 may obtain application code in the form of a carrier wave.
    </p>
    <heading>STORING AN OPERAND OFFSET LENGTH</heading>
    <p num="37">
      One approach to reducing the amount of unused space in an instruction without increasing the actual number of instructions (op-codes), is to store the length of each operand offset within the instruction.
      <br/>
      By storing an associated operand offset length with each operand offset, the amount of wasted space is reduced as unused operand offset bytes no longer need to be stored within the instruction.
      <br/>
      Reducing the amount of unused space has the advantage of decreasing the size of the compiled PL/SQL blocks.
      <br/>
      Decreasing the size of the compiled PL/SQL blocks increases the number of compiled PL/SQL blocks that can be simultaneously resident in shared memory.
      <br/>
      By increasing the number of compiled PL/SQL blocks that are simultaneously resident in shared memory, the scalability of the system is increased as more resources are available to support a greater number of applications executing concurrently.
    </p>
    <p num="38">
      An additional benefit associated with reducing the amount of wasted space is that for certain systems, decreasing the size of the compiled PL/SQL blocks can reduce fragmentation problems.
      <br/>
      The fragmentation problem may be reduced as the smaller PL/SQL blocks may be able to fit within an available contiguous memory space that could not accommodate corresponding larger compiled PL/SQL blocks that use fixed size operand offsets.
    </p>
    <p num="39">
      Another benefit associated with storing the length of each operand offset in the associated instruction is that additional, unnecessary processing of unused operand offset bytes is significantly reduced.
      <br/>
      By storing the length of each operand offset, unused operand offset bytes can be eliminated, and, thus the PL/SQL engine is not required to access and process unused operand offsets bytes.
    </p>
    <p num="40">
      FIG. 3 depicts the storing of operand offset lengths in an instruction according to one embodiment of the invention.
      <br/>
      As depicted, the instruction MOVC FP+A, DL�4��8�, which was described above, is stored as instruction 300.
      <br/>
      Instruction 300 is comprised of an op-code byte 302, operand base bytes 304 and 312, operand offset bytes 308, 316 and 322, control code bytes 310, 318 and 324, and operand offset length bytes 306, 314 and 320.
    </p>
    <p num="41">
      Control code bytes 310, 318 and 324 are associated with operand offset bytes 308, 316 and 322 respectively and are used to indicate whether a particular operand offset is applied in a direct or indirect addressing mode.
      <br/>
      In addition, the control code bytes 310, 318 and 324 are used to indicate whether the associated operand offset is the last operand offset associated with a particular operand base, since a variable number of operand offsets may be associated with each operand base.
      <br/>
      Because there are only four possible control code states (e.g. direct/more offsets, direct/no more offsets, indirect/more offsets and indirect/no more offsets) in certain embodiments, the control code values are represented using only two of the eight bits contained in control code bytes 310, 318 and 324.
    </p>
    <p num="42">
      Operand offset length bytes 306, 314 and 320 are associated with operand offset bytes 308, 316 and 322 respectively.
      <br/>
      The value of each operand offset length byte indicates the number of bytes that are required to store the value of its associated operand offset.
      <br/>
      For example, for instruction 300, the operand offset length L1 in byte operand offset length 306 has a value of one since its associated operand offset in operand offset byte 308 can be represented by a single byte.
      <br/>
      This is true because, in this example, operand offset A in operand offset byte 308 has an integer value of 10, which as shown by bits 326, can be represented in one byte (i.e., 8 bits).
      <br/>
      If, on the other hand, the operand offset in operand offset byte 308 was equal to the integer value 1024, the operand offset length L1 in operand offset length byte 306 would have a value of two, since the integer value 1024 requires two bytes to be represented (i.e., 000000100 000000002 =102410).
    </p>
    <p num="43">
      The operand offset length associated with an operand offset must be interpreted before the operand offset can be operated on.
      <br/>
      Therefore, in certain embodiments, each operand offset length is stored to the left of its associated operand offset to cause the operand offset length to be interpreted first.
    </p>
    <p num="44">
      Using operand offset lengths, operand offsets can be of variable length.
      <br/>
      Because operand offsets can be of variable length, operand offsets can be stored in instruction 300 without any unused bytes.
      <br/>
      Using a separate byte to store each operand offset length results in shorter instructions than instructions using fixed 4-byte operand offsets when the average operand offset value requires less than three bytes.
      <br/>
      For example, by eliminating the need to store unused operand offset bytes (e.g.,bytes 106, 108, 110, 118, 120, 122, 128, 130 and 132 of FIG. 1), instruction 300 can be represented using 12 bytes.
      <br/>
      This is in contrast to the 18 bytes that were previously needed for instruction 100 of FIG. 1.
    </p>
    <heading>INTEGRATING OPERAND OFFSET LENGTHS WITH CONTROL CODES</heading>
    <p num="45">
      As previously indicated above, in certain configurations, the control codes can be represented using only two bits.
      <br/>
      In addition, when operand offsets are limited to values that can be represented by four bytes, the value of the operand offset lengths can be represent using two bits.
      <br/>
      For example, a one byte operand offset can be represented by the two bit configuration "00", a two byte operand offset can be represented by the two bit configuration "01", a three byte operand offset can be represented by the two bit configuration "10", and a four byte operand offset can be represented by the two bit configuration "11".
      <br/>
      Therefore, because the length of an operand can be indicated using only two bits and the control codes require only two bits, an operand offset length/control code pair of four bits can be stored in a single byte (i.e. 8 bits).
      <br/>
      By storing operand offset length/control code pairs in a single byte, the size of a particular instruction can be further reduced.
    </p>
    <p num="46">
      FIG. 4 depicts the storing of operand offset length/control code pairs in a single byte according to one embodiment of the invention.
      <br/>
      As depicted, instruction 400 is comprised of an op-code 402, operand bases 404 and 410, operand offsets 408, 414 and 418, and operand offset length/control code pairs 406, 412 and 416.
      <br/>
      The operand offset length/control code pairs 406, 412 and 416 are respectively associated with operand offsets 408, 414 and 418.
      <br/>
      Although operand offset lengths and control codes are combined within a single byte, they perform the same functions as previously described above.
      <br/>
      To take advantage of storing an associated operand offset length with each operand offset, the operand offset length/control code pairs are stored to the left of each associated operand offset in order to cause each operand offset length to be interpreted before its associated operand offset is processed.
    </p>
    <p num="47">
      By combining operand offset lengths and control codes that are associated with the same operand offset, the unused bits in both the operand offset lengths and the control codes can be reduced.
      <br/>
      Storing operand offset lengths and control codes together in a single byte results in shorter instructions than instructions using fixed 4-byte operand offsets when the average operand offset value requires less than four bytes.
      <br/>
      For example, by eliminating the need to store unused operand offset length and control code bits, instruction 400 can be represented using 9 bytes, as opposed to 12 bytes for corresponding instruction 300 (FIG. 3).
      <br/>
      This further reduction in instruction size provides for a further decrease in the size of compiled PL/SQL blocks.
      <br/>
      This in turn helps to further increase scalability and decrease fragmentation problems within a computer system.
    </p>
    <p num="48">INTEGRATING AN OPERAND OFFSET LENGTHS/CONTROL CODES PAIR WITH AN OPERAND BASE</p>
    <p num="49">
      In certain cases, the operand bases can be represented in fewer than eight bits.
      <br/>
      For example, if a system provides for 16 distinct registers that can be used as an operand base, an operand base can be represented using four bits.
      <br/>
      Therefore, by using 16 distinct operand bases, an operand base (represented by four bits) and a operand offset length/control code pair (also represented by a total of four bits) can be stored in a single byte of 8 bits.
      <br/>
      By storing an operand base and an operand offset length/control code pair in a single byte, the size of a particular instruction is further reduced.
    </p>
    <p num="50">
      FIG. 500 depicts the storing of an operand base and an operand offset length/control code pair in a single byte according to one embodiment of the invention.
      <br/>
      As depicted, instruction 500 is comprised of an op-code 502, operand offsets 506, 510 and 514, an operand offset length/control code pair 512 and two operand base/operand offset length/control code triplet bytes 504 and 508.
      <br/>
      The offset length/control code pair contained in operand base/operand offset length/control code triplet byte 504 is associated with operand offset 506 and the offset length/control code pair contained in operand base/operand offset length/control code triplet byte 508 is associated with operand offset 510.
      <br/>
      The offset length/control code pair 512 is associated with operand offset byte 514.
    </p>
    <p num="51">
      By combining operand bases with operand offset length/control code pairs in a single byte, the unused bits formerly in the operand base bytes and operand offset length/control code bytes are eliminated.
      <br/>
      By eliminating unused bits for the operand bases and the operand offset length/control code pairs, instruction 500 can be represented using 7 bytes.
      <br/>
      This further reduction in instruction size provides for a further decrease in the size of compiled PL/SQL blocks leads to a further increase in scalability and a further decrease in fragmentation problems in a computer system.
    </p>
    <heading>OTHER STORING MECHANISMS</heading>
    <p num="52">
      Although the previous examples describe several embodiments for storing operand offset lengths to reduce the amount of unused space, still other similar storing embodiments exist.
      <br/>
      For example, FIG. 6 illustrates the storing of operand base/operand offset length pairs in addition to the storing of operand offset length/control pairs to reduce the amount of unused space according to one embodiment.
      <br/>
      As depicted, instruction 600 is comprised of an op-code 602, operand offsets 606, 612 and 616, operand offset length/control code pair 614, operand base/operand offset length 604 and 610 and control codes 608 and 618.
    </p>
    <p num="53">
      By combining the operand bases with operand offset lengths in bytes 604 and 610 and an operand offset length with a control code in byte 614, the unused bits in instruction 600 are reduced.
      <br/>
      Thus, by reducing the unused bits instruction 600 can be represented using 9 bytes.
    </p>
    <heading>IDENTIFYING THE SIGN OF AN OPERAND OFFSET</heading>
    <p num="54">
      As previously indicated, in certain configurations, an operand offset length/control code pair can be represented together in a single byte using less than the 8 available bits (i.e. 1 or more unused bits).
      <br/>
      Therefore, in certain embodiments of the invention, an operand offset sign (i.e. a single bit) is stored within an unused bit of the single bytes that contain operand offset length/control code pairs.
      <br/>
      By storing an operand sign with an operand offset length/control code pair, the range of values that can be represented by the associated operand offset is doubled.
    </p>
    <p num="55">
      For example, conventionally a one byte operand offset represents values in the range of -127 to +127 (i.e. 1 bit of the 8 available bits is used for the operand offset sign).
      <br/>
      However, by storing an operand offset sign with each operand offset length/control code pair, all 8 bits are available and therefore a single byte operand offset can represent values in the range -255 to +255.
    </p>
    <p num="56">
      By extending a single byte operand offset to represent values in the range of -255 to +255, the size of the instruction can be reduced for certain operand offset values.
      <br/>
      For example, to store an operand offset value of +200 in an instruction in which single byte operand offsets can only represent values in the range of -127 to +127, a minimum of 2 bytes is required to store the operand offset value of +200.
      <br/>
      However, if a single byte operand offset can represent values in the range of -255 to +255, a single byte can be used to store the operand offset value of +200.
      <br/>
      Therefore, as illustrated in this example, by storing an operand offset sign with the operand offset length/control code pairs, the instruction size can be reduced for certain operand offset values.
    </p>
    <heading>UNUSED SPACE REDUCTION</heading>
    <p num="57">
      From FIG. 1, where 18 bytes were used to represent instruction 100, to FIG. 5, where 7 bytes were used to represent the same instruction, certain embodiments of the invention produced an 11 byte decrease in instruction size.
      <br/>
      Therefore, by storing an associated operand offset length with each operand offset, the amount of wasted space is decreased, thus reducing the size of the compiled PL/SQL blocks.
      <br/>
      This decrease allows a greater number of compiled PL/SQL blocks to be simultaneously resident in shared memory, thereby increasing the scalability of the system.
      <br/>
      This reduction in compiled PL/SQL block size can also reduce fragmentation problems on certain systems.
      <br/>
      Additionally, storing the length of each operand offset in the associated instruction reduces unnecessary processing of unused operand offset bytes as the PL/SQL engine is not required to access or process unused operand offsets bytes.
    </p>
    <p num="58">
      It should be noted that although the examples have depicted operands with having at most two operand offsets associated with a particular operand base, the described storing mechanisms also reduce the amount of unused space in instructions that have operands that contain more than two operand offsets.
      <br/>
      Thus, the previous examples have contained a particular number of operand offsets for use of explanation only and not as a limitation on the embodiments of the invention as each operand may have a variable number of associated operand offsets.
    </p>
    <p num="59">
      In the foregoing specification, the invention has been described with reference to specific embodiments thereof.
      <br/>
      It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention.
      <br/>
      For example, although the illustrated embodiments discuss interpreted computer instructions, the invention is equally applicable to native machine instructions.
      <br/>
      In this context, the advantages provided by the invention would include a reduction in the size of executables or other compiled units of code (such as libraries).
      <br/>
      The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for generating computer instructions having a variable length operand offset, the method comprising the computer implemented steps of:</claim-text>
      <claim-text>for each computer instruction that includes one or more variable length operand offsets, generating one or more operand bases for the computer instruction;</claim-text>
      <claim-text>and performing the following steps for each variable length operand offset of said one or more variable length operand offsets in said computer instruction,</claim-text>
      <claim-text>- generating the variable length operand offset for the computer instruction, wherein the variable length operand offset is associated with an operand base; - generating an operand offset length for the computer instruction, wherein the operand offset length is a value that equals the number of bytes used to store the variable length operand offset;</claim-text>
      <claim-text>and - generating the computer instruction to include said operand base, said operand offset length, and said variable length operand offset, wherein said computer instruction has an order and wherein said operand offset length precedes said variable length operand offset in said order; - wherein each computer instruction includes a first field and a second field; - wherein said second field is used to store variable length operand offsets;</claim-text>
      <claim-text>and - wherein said first field is used to only store operand offset lengths that are values that equal the number of bytes used to store the variable length operand offset.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein: the step of generating the variable length operand offset for the computer instruction includes the step of generating multiple variable length operand offsets for the computer instruction;</claim-text>
      <claim-text>and the step of generating the operand offset length for the computer instruction includes the step of generating multiple operand offset lengths for the computer instruction.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 1, further comprising the step of generating a control code for the computer instruction, wherein the control code indicates whether the variable length operand offset is to be applied with a direct or indirect addressing mode.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 2, further comprising the step of generating multiple control codes for the computer instruction, wherein each of the multiple control codes indicates whether a respective one of the variable length operand offsets is to be applied with a direct or indirect addressing mode.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 1, further comprising the step of generating a control code for the computer instruction, wherein the control code indicates whether the variable length operand offset represents a last offset value for the computer instruction that is associated with the operand base.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 1, wherein the step of generating the operand base for the computer instruction includes the step of generating a value identifying a register.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 1, further comprising the step of generating the operand base and operand offset length in a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 3, further comprising the step of generating the operand base, the operand offset length and the control code in a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 3, further comprising the step of generating the operand offset length and the control code in a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of claim 1, wherein the step of generating the operand base for the computer instruction includes the step of generating four bits, wherein the four bits represent the operand base for the computer instruction.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 1, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating two bits, wherein the two bits represent the length of the variable length operand offset for the computer instruction.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 3, wherein the step of generating the control code for the computer instruction includes the step of generating two bits, wherein the two bits represent the control code for the computer instruction.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 1, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating a direct variable length operand offset, wherein the direct variable length operand offset represents an offset that is to be applied in a direct addressing mode.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 1, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating an indirect variable length operand offset, wherein the indirect variable length operand offset represents an offset that is to be applied in an indirect addressing mode.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method of claim 1, further comprising the steps of: generating the operand offset length in a first location associated with the computer instruction;</claim-text>
      <claim-text>and generating the variable length operand offset in a second location associated with the computer instruction, wherein the first location is processed before the second location when the computer instruction is interpreted or executed.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 15, further comprising the step of generating the operand base in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method of claim 3, further comprising the steps of: generating the operand offset length in a first location associated with the computer instruction;</claim-text>
      <claim-text>and generating the variable length operand offset in a second location associated with the computer instruction, wherein the first location is processed before the second location when the computer instruction is interpreted or executed.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method of claim 17, further comprising the step of generating the operand base in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method of claim 18, further comprising the step of generating the control code in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The method of claim 1, wherein: the step of generating the operand base for the computer instruction includes the step of generating the operand base for an interpreted computer instruction; the step of generating the variable length operand offset for the computer instruction includes the step of generating the variable length operand offset for the interpreted computer instruction;</claim-text>
      <claim-text>and the step of generating the operand offset length for the computer instruction includes the step of generating the operand offset length for the interpreted computer instruction.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The method of claim 3, further comprising the step of generating the operand offset length, the control code and an operand offset sign in a single byte within the computer instruction, wherein the operand offset sign indicates whether the variable length operand offset represents a positive or negative offset value.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The method of claim 1, wherein the step of generating said operand offset length includes the steps of: determining a minimum number of bytes required to represent said variable length operand offset without any leading zeros;</claim-text>
      <claim-text>and generating said operand offset length to equal said minimum number of bytes required to represent said variable length operand offset without any leading zeros.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. A computer-readable medium carrying one or more sequences of instructions for generating computer instructions having a variable length operand offset, wherein execution of the one or more sequences of instructions by one or more processors causes the one or more processors to perform the steps of: for each computer instruction that includes one or more variable length operand offsets, generating one or more operand bases for the computer instruction;</claim-text>
      <claim-text>and performing the following steps for each variable length operand offset of said one or more variable length operand offsets in said computer instruction, - generating the variable length operand offset for the computer instruction, wherein the variable length operand offset is associated with an operand base; - generating an operand offset length for the computer instruction, wherein the operand offset length is a value that equals the number of bytes used to store the variable length operand offset;</claim-text>
      <claim-text>and - generating the computer instruction to include said operand base, said operand offset length, and said variable length operand offset, wherein said computer instruction has an order and wherein said operand offset length precedes said variable length operand offset in said order; - wherein each computer instruction includes a first field and a second field; - wherein said second field is used to store variable length operand offsets;</claim-text>
      <claim-text>and - wherein said first field is used to only store operand offset lengths that are values that equal the number of bytes used to store the variable length operand offset.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The computer-readable medium of claim 23, wherein: the step of generating the variable length operand offset for the computer instruction includes the step of generating multiple variable length operand offsets for the computer instruction;</claim-text>
      <claim-text>and the step of generating the operand offset length for the computer instruction includes the step of generating multiple operand offset lengths for the computer instruction.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The computer-readable medium of claim 23, wherein the computer-readable medium further comprises instructions for performing the step of generating a control code for the computer instruction, wherein the control code indicates whether the variable length operand offset is to be applied with a direct or indirect addressing mode.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The computer-readable medium of claim 24, wherein the computer-readable medium further comprises instructions for performing the step of generating multiple control codes for the computer instruction, wherein each of the multiple control codes indicates whether a respective one of the variable length operand offsets is to be applied with a direct or indirect addressing mode.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The computer-readable medium of claim 23, wherein the computer-readable medium further comprises instructions for performing the step of generating a control code for the computer instruction, wherein the control code indicates whether the variable length operand offset represents a last offset value for the computer instruction that is associated with the operand base.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The computer-readable medium of claim 23, wherein the step of generating the operand base for the computer instruction includes the step of generating a value identifying a register.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The computer-readable medium of claim 23, wherein the computer-readable medium further comprises instructions for performing the step of generating the operand base and operand offset length in a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. The computer-readable medium of claim 25, wherein the computer-readable medium further comprises instructions for performing the step of generating the operand base, the operand offset length and the control code in a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="31">
      <claim-text>31. The computer-readable medium of claim 25, wherein the computer-readable medium further comprises instructions for performing the step of generating the operand offset length and the control code in a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="32">
      <claim-text>32. The computer-readable medium of claim 23, wherein the step of generating the operand base for the computer instruction includes the step of generating four bits, wherein the four bits represent the operand base for the computer instruction.</claim-text>
    </claim>
    <claim num="33">
      <claim-text>33. The computer-readable medium of claim 23, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating two bits, wherein the two bits represent the length of the variable length operand offset for the computer instruction.</claim-text>
    </claim>
    <claim num="34">
      <claim-text>34. The computer-readable medium of claim 25, wherein the step of generating the control code for the computer instruction includes the step of generating two bits, wherein the two bits represent the control code for the computer instruction.</claim-text>
    </claim>
    <claim num="35">
      <claim-text>35. The computer-readable medium of claim 23, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating a direct variable length operand offset, wherein the direct variable length operand offset represents an offset that is to be applied in a direct addressing mode.</claim-text>
    </claim>
    <claim num="36">
      <claim-text>36. The computer-readable medium of claim 23, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating an indirect variable length operand offset, wherein the indirect variable length operand offset represents an offset that is to be applied in an indirect addressing mode.</claim-text>
    </claim>
    <claim num="37">
      <claim-text>37. The computer-readable medium of claim 23, wherein the computer-readable medium further comprises instructions for performing the steps of: generating the operand offset length in a first location associated with the computer instruction;</claim-text>
      <claim-text>and generating the variable length operand offset in a second location associated with the computer instruction, wherein the first location is processed before the second location when the computer instruction is interpreted or executed.</claim-text>
    </claim>
    <claim num="38">
      <claim-text>38. The computer-readable medium of claim 37, wherein the computer-readable medium further comprises instructions for performing the step of generating the operand base in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="39">
      <claim-text>39. The computer-readable medium of claim 25, wherein the computer-readable medium further comprises instructions for performing the steps of: generating the operand offset length in a first location associated with the computer instruction;</claim-text>
      <claim-text>and generating the variable length operand offset in a second location associated with the computer instruction, wherein the first location is processed before the second location when the computer instruction is interpreted or executed.</claim-text>
    </claim>
    <claim num="40">
      <claim-text>40. The computer-readable medium of claim 39, wherein the computer-readable medium further comprises instructions for performing the step of generating the operand base in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="41">
      <claim-text>41. The computer-readable medium of claim 40, wherein the computer-readable medium further comprises instructions for performing the step of generating the control code in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="42">
      <claim-text>42. The computer-readable medium of claim 23, wherein: the step of generating the operand base for the computer instruction includes the step of generating the operand base for an interpreted computer instruction; the step of generating the variable length operand offset for the computer instruction includes the step of generating the variable length operand offset for the interpreted computer instruction;</claim-text>
      <claim-text>and the step of generating the operand offset length for the computer instruction includes the step of generating the operand offset length for the interpreted computer instruction.</claim-text>
    </claim>
    <claim num="43">
      <claim-text>43. The computer-readable medium of claim 25, wherein the computer-readable medium further comprises instructions for performing the step of generating the operand offset length, the control code and an operand offset sign in a single byte within the computer instruction, wherein the operand offset sign indicates whether the variable length operand offset represents a positive or negative offset value.</claim-text>
    </claim>
    <claim num="44">
      <claim-text>44. The computer-readable medium of claim 23, wherein the step of generating said operand offset length includes the steps of: determining a minimum number of bytes required to represent said variable length operand offset without any leading zeros;</claim-text>
      <claim-text>and generating said operand offset length to equal said minimum number of bytes required to represent said variable length operand offset without any leading zeros.</claim-text>
    </claim>
    <claim num="45">
      <claim-text>45. A computer system for generating computer instructions having a variable length operand offset, the computer system comprising: a memory; one or more processors coupled to the memory;</claim-text>
      <claim-text>and a set of instructions contained in the memory, the set of instructions including instructions which when executed by the one or more processors, cause the one or more processors to perform the steps of: - for each computer instruction that includes one or more variable length operand offsets, - generating one or more operand bases for the computer instruction;</claim-text>
      <claim-text>and - performing the following steps for each variable length operand offset of said one or more variable length operand offsets in said computer instruction, - generating the variable length operand offset for the computer instruction, wherein the variable length operand offset is associated with an operand base; - generating an operand offset length for the computer instruction, wherein the operand offset length is a value that equals the number of bytes used to store the variable length operand offset;</claim-text>
      <claim-text>and - generating the computer instruction to include said operand base, said operand offset length, and said variable length operand offset, wherein said computer instruction has an order and wherein said operand offset length precedes said variable length operand offset in said order; - wherein each computer instruction includes a first field and a second field; - wherein said second field is used to store variable length operand offsets;</claim-text>
      <claim-text>and - wherein said first field is used to only store operand offset lengths that are values that equal the number of bytes used to store the variable length operand offset.</claim-text>
    </claim>
    <claim num="46">
      <claim-text>46. The computer system of claim 45, wherein: the step of generating the variable length operand offset for the computer instruction includes the step of generating multiple variable length operand offsets for the computer instruction;</claim-text>
      <claim-text>and the step of generating the operand offset length for the computer instruction includes the step of generating multiple operand offset lengths for the computer instruction.</claim-text>
    </claim>
    <claim num="47">
      <claim-text>47. The computer system of claim 45, wherein the set of instructions further comprises instructions for performing the step of generating a control code for the computer instruction, wherein the control code indicates whether the variable length operand offset is to be applied with a direct or indirect addressing mode.</claim-text>
    </claim>
    <claim num="48">
      <claim-text>48. The computer system of claim 46, wherein the set of instructions further comprises instructions for performing the step of generating multiple control codes for the computer instruction, wherein each of the multiple control codes indicates whether a respective one of the variable length operand offsets is to be applied with a direct or indirect addressing mode.</claim-text>
    </claim>
    <claim num="49">
      <claim-text>49. The computer system of claim 45, wherein the set of instructions further comprises instructions for performing the step of generating a control code for the computer instruction, wherein the control code indicates whether the variable length operand offset represents a last offset value for the computer instruction that is associated with the operand base.</claim-text>
    </claim>
    <claim num="50">
      <claim-text>50. The computer system of claim 45, wherein the step of generating the operand base for the computer instruction includes the step of generating a value identifying a register.</claim-text>
    </claim>
    <claim num="51">
      <claim-text>51. The computer system of claim 45, wherein the set of instructions further comprises instructions for performing the step of generating the operand base and operand offset length for a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="52">
      <claim-text>52. The computer system of claim 47, wherein the set of instructions further comprises instructions for performing the step of generating the operand base, the operand offset length and the control code for a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="53">
      <claim-text>53. The computer system of claim 47, wherein the set of instructions further comprises instructions for performing the step of generating the operand offset length and the control code in a single byte within the computer instruction.</claim-text>
    </claim>
    <claim num="54">
      <claim-text>54. The computer system of claim 45, wherein the step of generating the operand base for the computer instruction includes the step of generating four bits, wherein the four bits represent the operand base for the computer instruction.</claim-text>
    </claim>
    <claim num="55">
      <claim-text>55. The computer system of claim 45, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating two bits, wherein the two bits represent the length of the variable length operand offset for the computer instruction.</claim-text>
    </claim>
    <claim num="56">
      <claim-text>56. The computer system of claim 47, wherein the step of generating the control code for the computer instruction includes the step of generating two bits, wherein the two bits represent the control code for the computer instruction.</claim-text>
    </claim>
    <claim num="57">
      <claim-text>57. The computer system of claim 45, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating a direct variable length operand offset, wherein the direct variable length operand offset represents an offset that is to be applied in a direct addressing mode.</claim-text>
    </claim>
    <claim num="58">
      <claim-text>58. The computer system of claim 45, wherein the step of generating the variable length operand offset for the computer instruction includes the step of generating an indirect variable length operand offset, wherein the indirect variable length operand offset represents an offset that is to be applied in an indirect addressing mode.</claim-text>
    </claim>
    <claim num="59">
      <claim-text>59. The computer system of claim 45, wherein the set of instructions further comprises instructions for performing the steps of: generating the operand offset length in a first location associated with the computer instruction;</claim-text>
      <claim-text>and generating the variable length operand offset in a second location associated with the computer instruction, wherein the first location is processed before the second location when the computer instruction is interpreted or executed.</claim-text>
    </claim>
    <claim num="60">
      <claim-text>60. The computer system of claim 59, wherein the set of instructions further comprises instructions for performing the step of generating the operand base in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="61">
      <claim-text>61. The computer system of claim 47, wherein the set of instructions further comprises instructions for performing the steps of: generating the operand offset length in a first location associated with the computer instruction;</claim-text>
      <claim-text>and generating the variable length operand offset in a second location associated with the computer instruction, wherein the first location is processed before the second location when the computer instruction is interpreted or executed.</claim-text>
    </claim>
    <claim num="62">
      <claim-text>62. The computer system of claim 61, wherein the set of instructions further comprises instructions for performing the step of generating the operand base in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="63">
      <claim-text>63. The computer system of claim 62, wherein the set of instructions further comprises instructions for performing the step of generating the control code in the first location associated with the computer instruction.</claim-text>
    </claim>
    <claim num="64">
      <claim-text>64. The computer system of claim 45, wherein: the step of generating the operand base for the computer instruction includes the step of generating the operand base for a interpreted computer instruction; the step of generating the variable length operand offset for the computer instruction includes the step of generating the variable length operand offset for the interpreted computer instruction;</claim-text>
      <claim-text>and the step of generating the operand offset length for the computer instruction includes the step of generating the operand offset length for the interpreted computer instruction.</claim-text>
    </claim>
    <claim num="65">
      <claim-text>65. The computer system of claim 47, wherein the set of instructions further comprises instructions for performing the step of generating the operand offset length, the control code and an operand offset sign in a single byte within the computer instruction, wherein the operand offset sign indicates whether the variable length operand offset represents a positive or negative offset value.</claim-text>
    </claim>
    <claim num="66">
      <claim-text>66. The computer system of claim 45, wherein the step of generating said operand offset length includes the steps of: determining a minimum number of bytes required to represent said variable length operand offset without any leading zeros;</claim-text>
      <claim-text>and generating said operand offset length to equal said minimum number of bytes required to represent said variable length operand offset without any leading zeros.</claim-text>
    </claim>
    <claim num="67">
      <claim-text>67. A computer-readable medium having stored thereon one or more sequences of instructions, wherein the one or more sequences of instructions include one or more instructions having: an operand base; one or more variable length operand offsets that are associated with the operand base;</claim-text>
      <claim-text>and one or more operand offset lengths, wherein each operand offset length is associated with a variable length operand offset and has a value that equals the number of bytes used to store the variable length operand offset; wherein said one or more instructions have an order and wherein each operand offset length precedes its associated variable length operand offset in said order; wherein said one or more instructions include one or more first fields and one or more second fields; wherein said one or more second fields are used to store variable length operand offsets; wherein said one or more first fields are used to only store operand offset lengths that are values that equal the number of bytes used to store the associated variable length operand offset;</claim-text>
      <claim-text>and wherein the operand offset length stored in said one or more first fields may be inspected during execution of said one or more instructions to determine how many bytes are used to store said variable length operand offsets.</claim-text>
    </claim>
    <claim num="68">
      <claim-text>68. A method for generating computer instructions having a variable length operand offset, the method comprising the computer implemented steps of: for each computer instruction that includes one or more variable length operand offsets, generating one or more operand bases for the computer instruction;</claim-text>
      <claim-text>and performing the following steps for each variable length operand offset of said one or more variable length operand offsets in said computer instruction, - generating the variable length operand offset for the computer instruction, wherein the variable length operand offset is associated with an operand base; - determining a minimum number of bytes required to represent said variable length operand offset without any leading zeros; - generating an operand offset length, wherein for all operand offset length values the operand offset length equals the minimum number of bytes required to represent said variable length operand offset without any leading zeros;</claim-text>
      <claim-text>and - generating the computer instruction to include said operand base, said operand offset length, and said variable length operand offset; - wherein the computer instruction includes a first field and a second field; - wherein said second field is used to store variable length operand offsets;</claim-text>
      <claim-text>and - wherein said first field is used to only store operand offset lengths that are values that equal the minimum number of bytes required to represent said variable length operand offset without any leading zeros.</claim-text>
    </claim>
  </claims>
</questel-patent-document>