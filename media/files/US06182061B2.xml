<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182061B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182061</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182061</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="27306426" extended-family-id="21071106">
      <document-id>
        <country>US</country>
        <doc-number>09057520</doc-number>
        <kind>A</kind>
        <date>19980409</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09057520</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>21607429</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>5752098</doc-number>
        <kind>A</kind>
        <date>19980409</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09057520</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>JP</country>
        <doc-number>33918597</doc-number>
        <kind>A</kind>
        <date>19971209</date>
        <priority-linkage-type>T</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997JP-0339185</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="3">
        <country>JP</country>
        <doc-number>9038497</doc-number>
        <kind>A</kind>
        <date>19970409</date>
        <priority-linkage-type>T</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="3">
        <doc-number>1997JP-0090384</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  17/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F  17/18        20060101AFI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>18</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>707737000</text>
        <class>707</class>
        <subclass>737000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>707764000</text>
        <class>707</class>
        <subclass>764000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>707769000</text>
        <class>707</class>
        <subclass>769000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>707813000</text>
        <class>707</class>
        <subclass>813000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>707966000</text>
        <class>707</class>
        <subclass>966000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>707999002</text>
        <class>707</class>
        <subclass>999002</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>707999003</text>
        <class>707</class>
        <subclass>999003</subclass>
      </further-classification>
      <further-classification sequence="7">
        <text>707E17032</text>
        <class>707</class>
        <subclass>E17032</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-017/30489</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30489</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/966</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>966</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99932</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99932</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99933</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99933</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>18</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>23</number-of-drawing-sheets>
      <number-of-figures>34</number-of-figures>
      <image-key data-format="questel">US6182061</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method for executing aggregate queries, and computer system</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>SHARMA ANOOP, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5511190</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5511190</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>DALAL KETAN</text>
          <document-id>
            <country>US</country>
            <doc-number>5537589</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5537589</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>DALAL KETAN</text>
          <document-id>
            <country>US</country>
            <doc-number>5781896</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5781896</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>AGRAWAL RAKESH, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5832475</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5832475</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>CHEN YONG MIN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5852821</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5852821</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>GRAUNKE GARY, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5852826</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5852826</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>COCHRANE ROBERTA JO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5963936</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5963936</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Matsuzawa, Hirofumi</name>
            <address>
              <address-1>Sagamihara, JP</address-1>
              <city>Sagamihara</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Fukuda, Takeshi</name>
            <address>
              <address-1>Machida, JP</address-1>
              <city>Machida</city>
              <country>JP</country>
            </address>
          </addressbook>
          <nationality>
            <country>JP</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Drumheller, Ronald L.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Alam, Hosain T.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      To provide a method for performing a plurality of aggregations in parallel and at a high speed, in a computer system so constructed that each of a plurality of processors connected across a network can use a memory area for itself and a part of the database for itself that includes data categorized into one or a plurality of groups, a method comprising the steps of: (a) ensuring space for storing results of M aggregate queries of the N aggregate queries (M is an integer equal to or less than N) in the memory area for itself in each processor; (b) executing all of the M aggregate queries for the part of the database for itself in each processor; (c) transmitting the results of the M aggregate queries executed by each processor to another processor for counting up and calculating of a final result for counting up; and (d) repeating the steps (a) to (c) until execution of the N aggregate queries is completed by each processor.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="2">
      The present invention relates to a method for processing aggregate queries on a parallel computer system, that are required for a database processing, such as Data Mining.
      <br/>
      The aggregate query or aggregation includes a query of aggregation for each group in the database.
    </p>
    <p num="3">2. Related Art</p>
    <p num="4">
      The aggregation used in a field, such as Data Mining, is a process for calculating the total value, or the maximum value, or the minimum value, or the average value of one attribute relative to a certain relation in the database every group, like "group-by" in the structured query language, SQL, to the relational database.
      <br/>
      The group is defined as records whose another attribute has the same value or the same value set, or a value that is inside a predetermined range.
      <br/>
      This aggregation is recently indispensable to a decision support system, such as OLAP (On Line Analytical Processing) (for details, see "Beyond Decision Support," E. F. Codd, S. B. Codd and C. T. Salley, Computerworld, 27(30), Jul. 1993) and Data Mining.
    </p>
    <p num="5">
      An example aggregation will now be explained.
      <br/>
      Table 1 shows the relation stored in a database.
      <br/>
      In Table 1, product numbers, customer numbers and sales are entered in that separate columns, and each time the sale occurs, a tuple is filled.
      <br/>
      Assume a calculation for counting the sales for each product number in this relation.
      <br/>
      For this calculation, a group is formed for each product number, and the total is calculated for each group.
      <br/>
      This is one example of the above described aggregation.
      <br/>
      When the aggregation is executed, the results shown in Table 2 are obtained.
    </p>
    <p num="6">
      -- TABLE 1
      <br/>
      -- product -             customer - sold
      <br/>
      -- G1                        C1          3
      <br/>
      -- G1                        C2          10
      <br/>
      -- G2                        C2          5
      <br/>
      -- G2                        C3          10
      <br/>
      -- G3                        C4          2
    </p>
    <p num="7">
      --                TABLE 2
      <br/>
      --                product - sold
      <br/>
      --                G1        13
      <br/>
      --                G2        15
      <br/>
      --                G3        2
    </p>
    <p num="8">
      Algorithms for parallel processing for one aggregation have been studied, and these algorithms will now be described.
      <br/>
      It should be noted that, for each algorithm, the entire relation in a database is divided equally for each processor.
    </p>
    <p num="9">1. 2P Algorithm</p>
    <p num="10">Since this algorithm is performed in two phases, it is called 2P.</p>
    <p num="11">(1) As a first phase, each processor (also called a node) performs an aggregation for a corresponding disk drive (some part of a database is stored thereon).</p>
    <p num="12">(2) As a second phase, the results of the respective processors are collected by a totaling processor to obtain the final result.</p>
    <p num="13">This method is also described in Japanese Unexamined Patent Publication No. Hei 5-2610. In this publication, an aggregation for only one group is performed, and no consideration is given for aggregation for a plurality of groups, such as in Data Mining described above.</p>
    <p num="14">2. Rep Algorithm</p>
    <p num="15">The repartition algorithm is performed according to the following algorithm (FIG. 1).</p>
    <p num="16">
      (1) First, it is determined for which group each node performs the aggregation (step 110).
      <br/>
      In the example in Table 1, it is determined that a node 1 will handle product number G1 and a node 2 will handle product number G2.
    </p>
    <p num="17">
      (2) Then, each node reads part of data from a corresponding disk drive (a database is stored therein).
      <br/>
      If the read part is data for a group for which another node is to perform aggregation, the read part is transmitted to the responsible node (step 120).
      <br/>
      In the example in Table 1, if Table 1 is present on the disk drive for node 1, when node 1 reads the third tuple in Table 1 it will transmit the data in the third tuple to node 2.
    </p>
    <p num="18">(3) Finally, each node performs aggregation for the group to be aggregated in that node, including the data transmitted by the other nodes (step 130).</p>
    <p num="19">
      It is different which algorithm is faster depending on the conditions.
      <br/>
      FIG. 2 shows an estimate of the period of time required for the performance of one aggregation using each algorithm.
      <br/>
      The estimate in FIG. 2 was obtained with an IBM SP2 having 16 nodes (SP2 is a trademark of International Business Machines Corp.), and indicates the relationship existing between the number of groups and the response time.
      <br/>
      In this system, when the number of groups is smaller than 2 * 105, the 2P algorithm provides faster processing.
      <br/>
      When the number of groups is greater, the Rep algorithm provides faster processing.
      <br/>
      An algorithm for dynamically switching the 2P algorithm and the Rep algorithm has been proposed (for example, see "Adaptive Parallel Aggregation Algorithms," Ambuj Shatdal and Jeffrey F. Naughton, in Proceedings Of The ACM SIGMOD Conference On The Management of Data, pp. 104-114, May 1995).
    </p>
    <p num="20">
      Another method is a method that involves the broadcasting of all the records in a database (see "Parallel Algorithms For The Execution Of Relational Database Operations," Dine Bitton, Haran Boral, David J. DeWitt and W. Kevin Wilkinson, ACM Trans. on Database Systems, 8(3):324-353, Sep. 1983).
      <br/>
      Such an algorithm (hereinafter called a BC algorithm), however, is impractical when a network for connecting processors is slow.
    </p>
    <p num="21">The BC algorithm will be generally explained below.</p>
    <p num="22">3. BC algorithm</p>
    <p num="23">
      (1) It is determined for which group in all the groups, each node performs the aggregation.
      <br/>
      This is the same as for the Rep algorithm.
    </p>
    <p num="24">(2) Each node broadcasts all the data on its disk drive to all the other nodes.</p>
    <p num="25">(3) Each node performs an aggregation for responsible groups relative to the broadcast data (including data on the disk drive of that node).</p>
    <p num="26">
      The algorithms with which one aggregation is performed in parallel have been explained.
      <br/>
      When one processor is used to perform a plurality of aggregations, a method has been employed for increasing the speed for the entire processing that is performed by adjusting the order of the calculations or by employing the correlation of calculations (see, for example, "On The Computation Of Multidimensional Aggregates," Sameet Agrawal, Rakesh Agrawl, Prasad M. Deshpande, Ashish Gupta, Jeffrey F. Naughton, Raghu Ramakrishnan and Sunita Sarawagi, In proceedings of the 22nd VLDB Conference, Sep. 1996).
      <br/>
      However, a method for simultaneously processing a plurality of aggregations by using a parallel computer has not been proposed.
    </p>
    <p num="27">
      A process for performing a plurality of aggregations in parallel can not always be performed at a high speed by repeating the above described method multiple times.
      <br/>
      It is, therefore, one object of the present invention to provide a method for performing a plurality of aggregations in parallel and at a high speed.
    </p>
    <p num="28">
      A plurality of aggregations must be performed for OLAP and for Data Mining, which are technical cores for a decision support system on which interest has recently been focused.
      <br/>
      For example, a Data Cube operator for performing a plurality of aggregations, relative to the analysis of data having a multiple-dimensional attribute, has been proposed (for example, see "Data Cube: A Relational
    </p>
    <p num="29">
      Aggregation Operator Generalizing Group-by, Cross-by and Sub-by, and Sub-totals," Jim Gray, Adam Bosworth, Andrew Layman and Hamid Pirahesh, Technical Report, Microsoft, November 1995).
      <br/>
      An application of Data Mining automatically finds the relationship between the attributes by using the results obtained by a plurality of aggregations and then prepares a graphical display (for example, see "Data Mining Optimized Association Rules For Numeric Attributes," Takeshi Fukuda, Yasuhiko Morimoto, Shinichi Morishita and Takeshi Tokuyama, in Proceedings Of The Fifteenth ACM SIGACT-SIGMOD-SIGART Symposium On Principles Of Database Systems, pp. 182-191, June 1996, and "Data Mining Using Two-Dimensional Optimized Association Rules: Scheme, Algorithm And Visualization," Takeshi Fukuda, Yasuhiko Morimoto, Shinichi Morishita and Takeshi Tokuyama, in Proceedings Of The ACM SIGMOD Conference On Management Of Data, pp. 13-23, June 1996).
      <br/>
      In these techniques, the interactive operations are required and the response time is an important element.
      <br/>
      To reduce the response time, the advance performance of aggregation is considered as one method.
      <br/>
      Thus, it is another object of the present invention to increase the speed for the execution of OLAP and Data Mining by performing a plurality of aggregations in parallel and at a high speed.
    </p>
    <p num="30">It is an additional object of the present invention to switch methods for executing a plurality of aggregations, depending on hardware conditions and on the properties of a plurality of aggregations, so that under various conditions the plurality of aggregations can be executed at a higher speed than by using the same method constantly.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="31">
      The most important technical matters for achieving the above objects are the number of accesses and the period of time required to access to a disk drive.
      <br/>
      At present, the access speed for a disk drive is slower than the transmission speed for communication between processors in a parallel processor system.
      <br/>
      A reduction in the access to a disk device greatly affects the achievement of the objects of the present invention.
      <br/>
      A specific method for reducing the number of accesses to the disk device will now be described.
    </p>
    <p num="32">
      A first aggregation execution method according to the present invention comprises the steps of: (a) ensuring space for storing results of M aggregate queries of N aggregate queries (M is an integer equal to or less than N) in a memory area for that processor in each processor; (b) executing the M aggregate queries together for the part of database for itself in each processor; (c) transmitting the results of the M aggregate queries executed by each processor to a processor for counting up in each processor, and calculating a final result in the processor for counting up; and (d) iterating the steps (a) to (c) until execution of the N aggregate queries is completed.
      <br/>
      A computer system for performing the aggregation execution method of the present invention is so designed that a plurality of processors connected by a network can use its memory area (memory area for itself) and its part of database (a part of database for itself or a partial database), which include data that can be divided into one or a plurality of groups.
      <br/>
      The memory may be prepared separately for each node, or memory connected to a network may be divided into several memory areas that are employed by individual processors.
      <br/>
      The same configuration can be applied for a disk.
    </p>
    <p num="33">
      The first aggregation execution method is provided based on the 2P algorithm described in the description of the background.
      <br/>
      According to this method, the calculation speed of the previously employed IBM SP2 is increased when the number of the resultant groups is relatively small.
    </p>
    <p num="34">
      The step (b) includes the steps of: (b1) in each processor, reading a part of a partial database into a work space of the memory area for itself, wherein the partial database is a part of the database for itself; (b2) in each processor, executing the M aggregate queries for results of calculations that were performed at previous steps and stored in the memory area for itself and the read part of the partial database; and (b3) iterating the steps (b1) and (b2) until execution of the M aggregate queries is completed for all of the database.
      <br/>
      At step (b2), M aggregate queries can be performed only for the read part of the partial database, and then the sum of the current results and the previously obtained results can be calculated.
      <br/>
      This method, however, reduces the processing speed.
    </p>
    <p num="35">
      M can be an integer equal to N or smaller, and can be selected regardless of other conditions.
      <br/>
      However, if M is determined from an amount of space which can be acquired into the memory area for storage of the results of the calculation of the aggregation, the number of steps (step (d)) to be repeated is smaller, and the processing speed can be increased.
    </p>
    <p num="36">
      A second aggregation execution method according to the present invention comprises the steps of: (a) in each processor, ensuring space for storing results of Q aggregate queries to be executed in that processor of P aggregate queries in the memory area for itself; (b) executing the Q aggregate queries for data in the entire database in each processor by iterating a step of reading a part of the partial database into the memory area for itself in each processor and a step of broadcasting the read part of the partial database via the network in each processor; and (c) iterating the steps (a) and (b) until execution of the P aggregate queries is completed.
      <br/>
      A computer system for the second aggregation execution method is the same as that for the first aggregation execution method.
    </p>
    <p num="37">
      The second aggregation execution method is provided based on the BC algorithm.
      <br/>
      With this method, when the number of groups is larger than that for the first aggregation execution method, the calculation speed is increased.
    </p>
    <p num="38">
      The step (a) in the second aggregation execution method can comprise the steps of: (a1) checking whether space in which a result of an execution of one aggregate query is stored is present in the memory area for one processor; (a2) acquiring the space for the result of the execution of the one aggregate query when the space is present; (a3) when the space is not present, checking whether the space in which the result of the execution of the one aggregate query is stored is present in the memory area for another processor; and (a4) acquiring the space for the result of the execution of the one aggregate query when the space is present in the another processor; and wherein, when the space is not present in the memory area for the another processor, the one aggregate query is executed in a succeeding iteration process.
      <br/>
      Even when a case occurs where no space is present for a certain aggregation, the aggregation can be performed by dividing it into several parts.
    </p>
    <p num="39">As well as M, Q can be determined from an amount of space which can be acquired into the memory area for storage of the results of the calculation of the aggregation.</p>
    <p num="40">
      The step (b) in the second aggregation execution method can comprise the steps of: (b1) in each processor, reading a part of the partial database to a work space of the memory area for itself; (b2) broadcasting the read part of the partial database via the network; (b3) executing the Q aggregate queries for results of calculations that were performed at previous steps and stored in the memory area for itself and the read part of the partial database and data transmitted from other processors; and (b4) iterating the steps (b1) to (b3) until each processor completes execution of the Q aggregate queries for all data in the database.
      <br/>
      At step (b3), the execution of the Q aggregations may be executed for the read part of the partial database and data that are received from another processor and then the obtained result and the previously obtained results may be added.
      <br/>
      This method, however, reduces the processing speed.
    </p>
    <p num="41">
      The third aggregation execution method in the present invention comprises the steps of: (a) determining T aggregate queries to be executed of S aggregate queries; (b) determining which processor aggregates each group of each of the T aggregate queries, wherein each group is to be aggregated when the T aggregate queries are executed; (c) in each processor, reading out a part of the partial database into the memory area for itself, and transmitting data associated with a group to be aggregated in another processor of an aggregate query in the read data to the another processor via the network with the aggregate query's ID, and executing the aggregate queries for data associated with groups to be aggregated in that processor of the T aggregate queries; (d) iterating the step (c) until each processor completes the execution of the T aggregate queries for all data associated with groups to be aggregated in that processor of the T aggregate queries; and (e) iterating the steps (a) to (d) until the execution of the S aggregate queries is completed.
      <br/>
      A computer method for the third aggregation execution method is the same as that for the first aggregation execution.
    </p>
    <p num="42">
      The third aggregation execution method is provided based on the Rep algorithm.
      <br/>
      When the number of groups is relatively larger than the number in which the second aggregation execution method should be used, speed of the third method becomes faster.
    </p>
    <p num="43">
      The step (c) in the third aggregation execution method comprises the steps of: (c1) in each processor, reading a part of the partial database into a work area in the memory area for itself; (c2) in each processor, determining which processor needs each portion of read data, transmitting the portion with an ID of an aggregate query associated with the portion to the needing processor via the network; and (c3) in each processor, executing the T aggregate queries for data associated with groups to be aggregated in that processor in the read data and data transmitted from other processors and results of calculations which were performed at the previous steps and stored in the memory area for itself.
      <br/>
      The transmission via the network may be performed with the execution of the T aggregate queries, simultaneously.
    </p>
    <p num="44">A method for determining the T aggregate queries and a method for determining how processor is assigned to each of groups of the aggregate queries in the third aggregation execution method depend on the memory space which is used by each processor.</p>
    <p num="45">
      Among the first to third aggregation execution method, the optimal algorithm differs depending on the conditions.
      <br/>
      When the optimal algorithm is selected by employing a parameter of the computer system, which may include the number of processors, the size of the database and the network communication speed, and a parameter, concerning the property of an aggregation operation, that includes the memory capacity for storing the results of aggregations, and then the plurality of aggregations are executed by the selected algorithm, a user can rapidly obtain results for the plurality of aggregations, usually.
      <br/>
      Note the selection from the three methods is one example.
      <br/>
      It may be selected from a group of methods which include the three methods or from any subset of the three methods.
    </p>
    <p num="46">
      The above described methods can be provided by a program or by using a special apparatus.
      <br/>
      For one having ordinary skill in the art who understands the following explanation, it would be easy to modify the implementation of the present invention as described a above.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="47">
      FIG. 1 is a flowchart showing the processing for the Rep algorithm.
      <br/>
      FIG. 2 is a graph showing the relationship between the number of groups and the response time for the 2P algorithm, the Rep algorithm and the BC algorithm.
      <br/>
      FIG. 3 is a diagram showing an example arrangement of a computer system employed for the present invention.
      <br/>
      FIG. 4 is a diagram showing another example arrangement of the computer system employed for the present invention.
      <br/>
      FIG. 5 is a diagram showing an additional example arrangement of the computer system employed for the present invention.
      <br/>
      FIG. 6 is a flowchart showing the processing for the 2Pm algorithm.
      <br/>
      FIG. 7 is a diagram showing the contents of a database of a processor element 1.
      <br/>
      FIG. 8 is a diagram showing the contents of a database of a processor element 2.
      <br/>
      FIG. 9 is a diagram showing the contents of a database of a processor element 3.
      <br/>
      FIG. 10 is a diagram showing the contents of a database of a processor element 4.
      <br/>
      FIG. 11 is a diagram illustrating the intermediate results held by the memory of the processor element 1 that is executing the second step in the 2Pm algorithm for the database in FIG. 7.
      <br/>
      FIG. 12 is a diagram illustrating the results held by the memory of the processor element 1 that has executed the second step of the 2Pm algorithm for the database in FIG. 7.
      <br/>
      FIG. 13 is a diagram illustrating the results held by the memory of the processor element 2 that has executed the second step of the 2Pm algorithm for the database in FIG. 8.
      <br/>
      FIG. 14 is a diagram illustrating the results held by the memory of the processor element 3 that has executed the second step of the 2Pm algorithm for the database in FIG. 9.
      <br/>
      FIG. 15 is a diagram illustrating the results held by the memory of the processor element 4 that has executed the second step of the 2Pm algorithm for the database in FIG. 10.
      <br/>
      FIG. 16 is a diagram illustrating the results held by the memory of the processor element 1 that has executed the totaling process of the 2Pm algorithm.
      <br/>
      FIG. 17 is a diagram illustrating the results held by the memory of the processor element 2 that has executed the totaling process of the 2Pm algorithm.
      <br/>
      FIG. 18 is a diagram illustrating the results held by the memory of the processor element 3 that has executed the totaling process of the 2Pm algorithm.
      <br/>
      FIG. 19 is a diagram illustrating the results held by the memory of the processor element 4 that has executed the totaling process of the 2Pm algorithm.
      <br/>
      FIG. 20 is a flowchart showing the processing for the BCm algorithm.
      <br/>
      FIG. 21 is a flowchart for determining which processor element executes which aggregate query by using the BCm algorithm.
      <br/>
      FIG. 22 is a diagram showing the results held by the memory of the processor element 2 that has executed the BCm algorithm for the databases in FIGS. 7 to 10.
      <br/>
      FIG. 23 is a diagram showing the results held by the memories of the processor elements 1, 3 and 4 that have executed the BCm algorithm.
      <br/>
      FIG. 24 is a processing flow of the Repm algorithm.
      <br/>
      FIG. 25 is a drawing showing the intermediate state where the processor element 3 executes the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 26 is a drawing showing the intermediate state where the processor element 3 executes the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 27 is a drawing showing the intermediate state where the processor element 3 executes the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 28 is a drawing showing the intermediate state where the processor element 3 executes the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 29 is a drawing showing data associated with the query 1 and the destination processor element of the data transmitted from each processor element when executing the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 30 is a drawing showing data associated with the query 1 and the source processor element of the data received in each processor element when executing the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 31 is a drawing showing data associated with the query 2 and the destination processor element of the data transmitted form each processor element when executing the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 32 is a drawing showing data associated with the query 2 and the source processor element of the data received in each processor element when executing the query 1 and 2 by the Repm algorithm.
      <br/>
      FIG. 33 is a flowchart for selecting an optimal algorithm from the 2Pm, BCm and Repm algorithms.
      <br/>
      FIG. 34 is a graph indicating positions at which the optimal algorithm is changed when an IBM SP2 having 16 nodes executes aggregate queries.
    </p>
    <heading>DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
    <p num="48">
      First, the hardware arrangement of a computer system employed for the present invention will be described.
      <br/>
      FIG. 3 is a diagram showing one example of the hardware arrangement.
      <br/>
      A processor element PE1 (3a), a processor element PE2 (3b) and a processor element PEn (3c) are connected via a network 1.
      <br/>
      The number of processor elements is not necessarily limited to three, as in FIG. 3, and it is only necessary that more than one processor element be provided.
      <br/>
      In general, n processor elements are assumed to be provided.
      <br/>
      A memory 5a and a disk drive 7a are connected to the processor element PE1 (3a), a memory 5b and a disk drive 7b are connected to the processor element PE2 (3b), and a memory 5c and a disk drive 7c are connected to the processor element PEn (3c).
      <br/>
      One part of a database is stored in each disk drive.
      <br/>
      The network 1 is employed for communication among the processor elements, which can exchange data at high speed across the network 1.
    </p>
    <p num="49">
      The arrangement in FIG. 3 is merely an example, and another example arrangement shown in FIG. 4 may be employed wherein memories are not directly connected to respective processor elements, and memories 9 and 10 are connected to a network 1.
      <br/>
      In this arrangement, the memory 9 can be divided into an area 9a for the processor element PE1 and an area 9b for the processor element PE2.
      <br/>
      In addition to the areas for the respective processor elements, an area used in common by the processor elements may be provided in the memory 9.
      <br/>
      Like the memory 10 that is used only for the processor element PEn, separate memories for individual processor elements can be connected to the network 1.
      <br/>
      The processor elements 3a, 3b and 3c read data from the disk drives 7a, 7b and 7c, and write the data, via the network 1, to work areas in their memory areas 9a, 9b and 10.
    </p>
    <p num="50">
      As an additional arrangement shown in FIG. 5, while processor elements and memories are connected in the same manner as shown in FIG. 3, disk drives are connected to a network 1.
      <br/>
      A disk drive 11 includes data 11a for a processor element PE1 and data 11b for a processor element PE2.
      <br/>
      The disk drive 11 can include common data, in addition to the data for the processor elements PE1 and PE2.
      <br/>
      Data for a processor element PEn is stored in a disk drive 13.
      <br/>
      As in the arrangement shown in FIG. 5, a disk drive for each processor element can be separately connected to the network 1.
      <br/>
      The data on the disk drives are read, via the network 1, by the processor elements 3a, 3b and 3c, and are fetched in the work areas of memories 5a, 5b and 5c.
    </p>
    <p num="51">
      A combination of some of the arrangements in FIGS. 3, 4 and 5 can be employed.
      <br/>
      For example, several processor elements can be arranged as shown in FIG. 3, and the other processor elements can be arranged as shown in FIG. 4 or FIG. 5.
      <br/>
      An arrangement other than those in FIGS. 3, 4 and 5 can also be employed.
      <br/>
      In short, the memories and the disk drives need not necessarily be used in common by the processors.
    </p>
    <p num="52">
      The processing on the above described arrangement will now be described.
      <br/>
      The following processing partially includes the process for the entire system.
      <br/>
      One of the processor elements may be assigned for the performance of that process, or a dedicated processor for performing that process may be prepared.
    </p>
    <p num="53">1. 2Pm algorithm (FIG. 6)</p>
    <p num="54">
      Since this algorithm is provided based on the 2P algorithm described in the background explanation, and is an algorithm that is expanded in order to perform a plurality of aggregations in parallel, it is called the 2Pm algorithm.
      <br/>
      To perform a plurality of aggregations, the processing speed is increased by reducing the number of accesses to the disk drive to the minimum.
      <br/>
      It should be noted that a total of N aggregate queries are to be executed.
    </p>
    <p num="55">
      (1) First, a space for storing the results of the execution of M aggregate queries is obtained in a memory area for each processor element (step 210).
      <br/>
      M is so determined that it falls in a range within which the results of the aggregations can be stored in a memory area for each processor element.
      <br/>
      Since the execution of more aggregations at one time allows the disk access to be shared, the processing speed is increased.
      <br/>
      In addition, the processing can be performed at a higher speed when all of the processor elements that execute this algorithm perform the same M aggregate queries.
      <br/>
      This is because a totaling process, which will be described later, is required, and if a different number of aggregate queries were performed for each processor element, a part of the results that could not be counted (or totaled) would remain in the memory, and the termination of the execution in another processor element would have to be waited for.
      <br/>
      Therefore, if the number of aggregate queries is selected from the viewpoint that the processor elements that will execute this algorithm will perform the same number of aggregate queries at the same time, this is effective for fast processing.
      <br/>
      Although the space for storing the results of the aggregations must be determined before the aggregations are performed, the size required for the results can be obtained by performing a trial calculation for a small amount of data.
      <br/>
      This process is not heavy burden.
    </p>
    <p num="56">Pseudo code at step 210 are shown below.</p>
    <p num="57">
      -- TABLE 3
      <br/>
      -- // variables
      <br/>
      -- N         : number of node
      <br/>
      -- mem       : size of memory
      <br/>
      -- MEM       : variable ( 0  &lt;=  MEM  &lt;=  mem )
      <br/>
      -- q         : query
      <br/>
      -- NL        : list of queries
      <br/>
      -- tmpNL     : list of queries - for subsequent processing
      <br/>
      -- ML        : list of queries - for this processing
      <br/>
      -- // initialization
      <br/>
      -- NL = + q_1, q_2, . . . , q_i, . . . , q_Q } - list of Q queries.
      <br/>
      -- mem = getMaxMemSize( )  - Acquiring memory size.
      <br/>
      --      - Each node adjusts the size to the
      <br/>
      --      - minimum size in all nodes in cooperation.
      <br/>
      --      - Each node executes the following steps.
      <br/>
      -- while NL  not equal to  NIL and tmpNL  not equal to  NIL do  - NIL : null list
      <br/>
      --      begin
      <br/>
      --      MEM = mem ;
      <br/>
      --      tmpNL = NIL ;
      <br/>
      --      ML = NIL ;
      <br/>
      --      while NL  not equal to  NIL do - Execute until NL becomes null.
      <br/>
      --       begin
      <br/>
      --        q = pop( NL ); - Acquiring the head of pop( ) list.
      <br/>
      --      if ( MEM &gt; .vertline.q.vertline. ) then - Check whether the memory for
      <br/>
      --  the
      <br/>
      --                           - query q is ensured.
      <br/>
      --      begin                - .vertline.q.vertline. is a memory size used by
      <br/>
      --  the
      <br/>
      --                           - query q.
      <br/>
      --      append( ML, q ) ;    - Add q to ML.
      <br/>
      --      MEM = MEM - .vertline.q.vertline. ; - Subtract .vertline.q.vertline.
      <br/>
      --  from residual capacity
      <br/>
      --                           - of the memory.
      <br/>
      --      end
      <br/>
      --    else
      <br/>
      --       begin
      <br/>
      --       append( tmpNL, q ) ;
      <br/>
      --                           - Add query q to the unprocessed list.
      <br/>
      --       end
      <br/>
      --      end
      <br/>
      --      - Execute queries in ML.
      <br/>
      --      - Execute queries in tmpNL in the subsequent processing.
      <br/>
      --      while ML  not equal to  NIL do - Execute until ML becomes NIL.
      <br/>
      --       begin
      <br/>
      --        q = pop( ML ) ; - Acquire the head query from ML.
      <br/>
      --        allocate ( q ) ; - Allocate memory area for query q.
      <br/>
      --       end
      <br/>
      --      2Pm( ) ;             - For queries in the list ML, execute
      <br/>
      --                           - 2Pm algorithm.
      <br/>
      --      copy( NL, tmpNL ) ;  - Copy tmpNL to NL.
      <br/>
      -- end
    </p>
    <p num="58">
      (2) M aggregate queries are performed for part of the database for each processor element (step 220).
      <br/>
      More specifically, in this process, first, data to be processed at this time in part of the database for each processor element are read to a work space in the memory area of the processor element.
      <br/>
      M aggregate queries are executed for the previously obtained results (not present at the first step), which are stored in the memory area, and data that is currently to be processed, which are read from the part of the database for that processor element.
      <br/>
      These two steps are repeated until the aggregation is performed for the entire part of the data-base.
      <br/>
      A specific example will be described later.
      <br/>
      Since with a conventional method only one aggregation is performed for data that are read once, when this conventional method is applied for the execution of M aggregate queries, data must be read M times.
      <br/>
      On the other hand, according to the present invention, since M aggregate queries are executed for data that are read once, the period of time required for disk accesses is reduced to 1/M.
    </p>
    <p num="59">
      (3) The result obtained by execution of M aggregate queries is transmitted to a totaling processor element (also called a totaling node), which then calculates the final result (step 230).
      <br/>
      One or a plurality of totaling processor elements may be provided.
      <br/>
      When, for example, M processor elements perform this algorithm, each processor may serve as a processor element for counting the result of one aggregation to obtain the final result.
      <br/>
      When the number of processor elements is smaller than M, each processor element may count the results obtained by execution of a plurality of aggregate queries, or only one processor element may count all the results obtained by execution of M aggregate queries.
      <br/>
      It should be determined in advance which processor element counts the results of which aggregate queries.
    </p>
    <p num="60">
      As another totaling method, individual groups in the results obtained by the execution of aggregations, are assigned for processor elements, which in turn count the results.
      <br/>
      For example, processor element 1 counts groups 1 and 2, relative to aggregation 1; and processor element 2 counts groups 3 and 4, relative to aggregation 1, and groups 1 and 2, relative to aggregation 2.
    </p>
    <p num="61">
      (4) When the final result for the execution of M aggregate queries is acquired, a check is performed to determine whether or not the execution of N aggregate queries is completed (step 240).
      <br/>
      When not all the N aggregate queries has been executed, program control returns to step 210 and the above described process is repeated.
      <br/>
      In this case, normally, the process is repeated by using an M that differs from the previous M. When the N aggregate queries have been executed, the process is thereafter terminated.
    </p>
    <p num="62">
      An execution example will now be explained referring to FIGS. 7 through 10.
      <br/>
      The relation stored on a disk drive for the processor element 1 is shown in FIG. 7; the relation stored on a disk drive for the processor element 2 is shown in FIG. 8; the relation stored on a disk drive for the processor element 3 is shown in FIG. 9; and the relation stored on a disk drive for the processor element 4 is shown in FIG. 10. Four processor elements are present in a computer system.
      <br/>
      The columns in tables represent, from the left, month, day, week, location, shop number, product number and the amount of sold.
      <br/>
      The tuples in the tables are filled in when a sale occurs.
    </p>
    <p num="63">Assume that a query (query 1) for adding the amount sold by the month, a query (query 2) for adding the amount of sold by day of the week, a query (query 3) for adding the amount of sold by location, a query (query 4) for adding the amount of sold by product number, and a query (query 5) for adding the amount of sold by location and week are to be performed at one time.</p>
    <p num="64">
      The processor element 1 reads the data in the first tuple in FIG. 7 from the disk drive to the work space in the memory.
      <br/>
      To perform the query 1, the columns for the month and the amount of sold are referred to.
      <br/>
      Month "Apr" and the amount of sold "3" are stored as a result of the query 1.
      <br/>
      Then, to perform query 2, the columns for the week and the amount of sold are referred to, and day of the week "Sun" and the amount of sold "3" are stored as a result of the query 2.
      <br/>
      The columns for the location and the amount of sold are then referred to in order to perform query 3, and location "Kyuushuu" and the amount of sold "3" are stored as a result of the query 3.
      <br/>
      After that the columns for the product number and the amount of sold are referred to in order to execute query 4, and product number 2 and the amount of sold "3" are entered as a result of the query 4.
      <br/>
      Then, the columns for the location, the week and the amount of sold are referred to in order to execute query 5, and the location "Kyuushuu," the day of week "Sun" and the amount of sold "3" are entered as a result of the query 5.
    </p>
    <p num="65">
      Then, the processor element 1 reads data in the second tuple in FIG. 7 from the disk drive to the work space in the memory.
      <br/>
      The columns for the month and the amount of sold are referred to in order to perform the query 1.
      <br/>
      Since the read data for the month differs from the previously stored result for the month obtained by the first execution of the query 1, the month "Aug" and the amount of sold "4" are added to the result the performed by the query 1.
      <br/>
      Then, the columns for the week and the amount of sold are referred to in order to perform the query 2.
      <br/>
      Since the read data for the week is the same as the data for the week previously obtained by the query 2, the amount of sold "4" is added to the result in the week "Sun" obtained by the query 2, then enters "17".
      <br/>
      The columns for the location and the amount of sold are referred to in order to perform the query 3.
      <br/>
      Since the data for the location that is read differs from the previously stored result for the location obtained by the query 3, the location "Hokkaido" and the amount of sold "4" are added to the result obtained by the query 3.
      <br/>
      After that the columns for the product number and the amount of sold are referred to in order to perform the query 4.
      <br/>
      Since the data for the product number that is read differs from the previously stored product number obtained by the query 4, the product number "1" and the amount of sold "4" are added to the result obtained by the query 4.
      <br/>
      Then the columns for the location, the week and the amount of sold are referred to in order to perform the query 5.
      <br/>
      Since the read data for the location and the day differ from the previously stored data for the location and the day obtained by the query 5, the location "Hokkaido" and the day "4" are added to the result obtained by the query 5.
    </p>
    <p num="66">
      Following this, the processor element 1 reads data in the third tuple in FIG. 7 from the disk drive to the work space in the memory.
      <br/>
      The columns f or the month and the amount of sold are referred to in order to perform the query 1.
      <br/>
      Since the read data for the month differs from the result for the month previously obtained by the query 1, the month "Jun" and the amount of sold "2" are added to the result obtained by the query 1.
      <br/>
      Then, the columns for the week and the amount of sold are ref erred to in order to perform the query 2.
      <br/>
      Since the read data for the week differs from data for the day previously obtained by the query 2, the week "Mon" and the amount of sold "2" are entered.
      <br/>
      The columns for the location and the amount of sold are referred to in order to perform the query 3.
      <br/>
      Since the read data for the location is the same as the data for the location obtained by the query 3, the location "Hokkaido" and the amount of sold "6," which is obtained by adding "2" to the amount of sold "4," are entered.
      <br/>
      After this the columns for the product number and the amount of sold are referred to in order to perform the query 4.
      <br/>
      Since the read data for the product number is the same as the product number obtained by the query 4, "2" is added to the amount of sold "4," and the product number "1" and the amount of sold "6" are entered.
      <br/>
      Then the columns for the location, the week and the amount of sold are referred to in order to perform the query 5.
      <br/>
      Since the read data for the location and the week differ from the data for the location and the day previously obtained by the query 5, the location "Hokkaido," the week "Mon," and the amount of sold "2" are entered.
    </p>
    <p num="67">
      In this process, the results shown in FIG. 11 are stored in the memory of the processor element 1.
      <br/>
      When this process is repeated for the related data shown in the Table in FIG. 7 that is stored on the disk drive of the processor element 1, the results shown in FIG. 12 are stored in the memory of the processor element 1.
    </p>
    <p num="68">The same processing is performed by the processor element 2, the processor element 3 and the processor element 4, and the results obtained by queries 1 through 5 relative to the relation in FIGS. 8, 9 and 10 that are stored on the respective disk drives are represented as shown in FIGS. 13, 14 and 15, respectively.</p>
    <p num="69">
      When all the calculations have been performed, the final results for the aggregate queries 1 through 5 can be obtained.
      <br/>
      In this embodiment, a total calculation method is employed whereby a specified processor element calculates the total for a specific group in the aggregate queries 1 through 5.
      <br/>
      More specifically, the processor element 1 counts the total for groups of the months "Jan" and "Feb" in the query 1, groups of the weeks "Mon" and "Tue" in the query 2, a group of the location "Hokkaido" in the query 3, a group of the product number "1" in the query 4 and a group associated with the location "Hokkaido" in the set of the location and the week in the query 5.
      <br/>
      The processor element 2 counts the total for groups of the months "Mar" and "Apr" in the query 1, groups of the weeks "Wed" and "Thu" in the query 2, a group of the location "Kanto" in the query 3, a group of the product number "2" in the query 4 and a group associated with the location "Kanto" in the set of the location and the week in the query 5.
    </p>
    <p num="70">
      The processor element 3 counts the total for groups of the months "May" and "Jun" in the query 1, groups of the weeks "Fri" and "Sat" in the query 2, a group of the location "Kansai" in the query 3, a group of the product number "1" in the query 4 and a group associated with the location "Kansai" in the set of the location and the week in the query 5.
      <br/>
      The processor element 4 counts the total for groups of the months "Jul" and "Aug" in the query 1, a group of the week "Sun" in the query 2, a group of the location "Kyuushuu" in the query 3 and a group associated with the location "Kyuushuu" in the set of the location and the week in the query 5.
    </p>
    <p num="71">
      Therefore, the individual processor elements must transmit, to totaling nodes, data for groups held by the individual processor elements, except for data for groups that are counted by itself.
      <br/>
      The result counted by the processor element 1 is shown in FIG. 16; the result counted by the processor element 2 is shown in FIG. 17; the result counted by the processor element 3 is shown in FIG. 18; and the result counted by the processor element 4 is shown in FIG. 19.
    </p>
    <p num="72">2. BCm algorithm (FIG. 20)</p>
    <p num="73">
      This algorithm, which is based on the BC algorithm described in the background, is expanded for the parallel processing of a plurality of aggregations, so that hereinafter it is called the BCm algorithm.
      <br/>
      To execute a plurality of aggregations, the BCm algorithm also provides fast processing by reducing disk drive accesses to the minimum.
      <br/>
      In this case, a total of P aggregate queries are to be performed.
    </p>
    <p num="74">
      (1) First, space is acquired in a memory area for storing results that a processor element will obtain by the execution of Q aggregate queries (step 310).
      <br/>
      As well as the M explained for the 2Pm algorithm, the number Q of the queries is determined so that it falls within the range of the capacity of the memory area for each processor element.
      <br/>
      Since the access to the disk drive is shared when as many aggregate queries as possible are performed at one time, the processing speed is increased.
      <br/>
      The execution of Q aggregate queries may be performed differently by individual processor elements, or may be performed the same so that the resultant groups for the aggregations are sorted for processor elements.
    </p>
    <p num="75">
      Example processing for assigning an aggregation for each processor element is shown in FIG. 21. First, an unexecuted aggregation is selected (step 410), and one of the processor elements is selected (step 420).
      <br/>
      Then, a check is performed to determine whether or not there is space available in the memory of the selected processor element to store the result of the selected aggregation (step 430).
      <br/>
      When space is available in the memory area of the processor element, the selected aggregation is assigned to the selected processor element (step 440).
      <br/>
      If no space is available in the memory of the selected processor element, the memory for another processor element is examined (step 450).
      <br/>
      When all of the processor elements are examined and no space is found for storing the results of the query (step 460), the aggregation is performed separately (step 470). "The separate processing" means the aggregation is performed at the subsequent processing since the process is repeated at step 350 in FIG. 20, or it is divided into several groups for execution.
    </p>
    <p num="76">
      In the above manner, the other aggregations are assigned to the processor elements.
      <br/>
      Since, when insufficient space is available in the memories of all the processor elements, the assignment process is performed again using the iterative process at step 350 in FIG. 20, and since, when the assignment process has been performed for all the unexecuted aggregation queries (step 480), the assigned aggregate queries are executed, the processing is suspended (step 490).
    </p>
    <p num="77">
      The above process for assigning the aggregate queries for the processor elements is only an example, and another method can be used to perform the assignment.
      <br/>
      It is possible for a user to intentionally assign a specific aggregate query to a specific processor element.
      <br/>
      As previously described, while the same aggregate query can be executed by the individual processor elements, a group of aggregation can be changed for an individual processor element.
      <br/>
      In this case, since the aggregation is the same type of operation but has a different group, it can be assigned to a processor element as a different aggregation using the process in FIG. 21. For this case, another assignment algorithm can be prepared.
    </p>
    <p num="78">More detailed pseudo code for the processing in FIG. 21 is shown below.</p>
    <p num="79">
      -- TABLE 4
      <br/>
      -- // variables
      <br/>
      -- N       : number of node
      <br/>
      -- m_i     : memory size for each node ( 1  &lt;=  i  &lt;=  N )
      <br/>
      -- q       : query
      <br/>
      -- q_i     : query ( 1  &lt;=  i  &lt;=  Q )
      <br/>
      -- QL      : list of queries to be aggregated
      <br/>
      --            - a list of aggregate queries to be executed
      <br/>
      -- tmpQL   : list of queries  - for the subsequent processing
      <br/>
      -- ML      : list of queries  - for the current processing
      <br/>
      -- // initialization
      <br/>
      -- QL = + q_1, q_2, . . . , q_i, . . . , q_Q } - list of Q queries.
      <br/>
      -- while QL  not equal to  NIL and tmpQL  not equal to  NIL do  - NIL : null list
      <br/>
      --      begin
      <br/>
      -- for i=0 to N do
      <br/>
      --      begin
      <br/>
      --        m_j = getMaxMemSize( j ) ;
      <br/>
      --                      - Get memory size of each node.
      <br/>
      --      end
      <br/>
      --      tmpQL = NIL ;
      <br/>
      --      ML = NIL ;
      <br/>
      -- while QL  not equal to  NIL do  - Execute until QL become null.
      <br/>
      --      begin
      <br/>
      --        q = pop( QL );
      <br/>
      --           - pop( ) means "acquire the head of the list."
      <br/>
      --        for j=1 to N do
      <br/>
      --         begin
      <br/>
      --         if ( m_j &gt; .vertline.q.vertline. ) then - Check whether space of
      <br/>
      --  the
      <br/>
      --                            - memory for q can be acquired.
      <br/>
      --          begin    - .vertline.q.vertline. means memory size for query q.
      <br/>
      --           append( ML, q ) ; - Add q to ML.
      <br/>
      --             m_j = m_j - .vertline.q.vertline. ;
      <br/>
      --                - Subtract .vertline.q.vertline. from the residual memory
      <br/>
      --  size.
      <br/>
      --             break ;        - Exit for routine.
      <br/>
      --         end
      <br/>
      --        end
      <br/>
      --        if (there is no space for q) then
      <br/>
      --        begin
      <br/>
      --         append( tmpQL, q ) ;
      <br/>
      --                - Add the query q to the unexecuted list.
      <br/>
      --         end
      <br/>
      --        end
      <br/>
      --        - Execute aggregate queries in ML.
      <br/>
      --        - Execute queries in tmpQL in the subsequent processing.
      <br/>
      --        while ML  not equal to  NIL do - Execute until ML becomes NIL.
      <br/>
      --        begin
      <br/>
      --           q = pop( ML ) ; - acquire a query at the head of ML.
      <br/>
      --             allocate ( q ) ; - Allocate memory space for query q.
      <br/>
      --        end
      <br/>
      --        BCm( ) ;  - Execute BCm algorithm for queries in ML list.
      <br/>
      --        copy( QL, tmpQL ) ;  - Copy tmpQL to QL.
      <br/>
      -- end
    </p>
    <p num="80">
      (2) Referring back to FIG. 20, from the individually owned part of the database, data to be currently processed are read and broadcast through a network (step 320).
      <br/>
      Because of the broadcast, the same data is transmitted to all the processor elements.
      <br/>
      It is not always necessary to determine which data is required for which processor element.
      <br/>
      According to the previously explained Rep algorithm and Repm algorithm described below, for which group each processor element performs aggregation is determined, and data is transmitted to a processor element that requires it.
      <br/>
      According to this algorithm, however, such a determination is not performed because not all the processor elements execute the same aggregation.
      <br/>
      If it is understood in advance that there is data that will not be employed by any processor element, transmission of that data can be eliminated.
    </p>
    <p num="81">(3) Q aggregate queries are executed for data read by an individual processor element and data received from another processor element, and results previously obtained by the aggregations (not present at first) (step 330).</p>
    <p num="82">
      (4) Processes (2) (step 320) and (3) (step 330) are repeated until execution of the Q aggregate queries is completed for all data in the database (step 340).
      <br/>
      If the sizes of the databases for the individual processor elements vary, although the processing of data in the owned part of the database has been completed, data may be transmitted from another processor element, or although data may not be transmitted from another processor element, the owned part of the database will not yet have been processed.
      <br/>
      In this case, at step 330, Q aggregate queries are executed for unprocessed data included in the individually owned part of the database or for data transmitted by the other processor elements and the results previously obtained by the aggregations.
    </p>
    <p num="83">
      (5) When Q aggregate queries have been executed for the data in all the databases, it is performed to check whether or not P aggregate queries have been executed (step 350).
      <br/>
      If not, the procedure at step 310 and the following steps are performed for another aggregate queries.
      <br/>
      If P aggregate queries have been executed, the processing is terminated (step 360).
    </p>
    <p num="84">
      According to the BCm algorithm, since only an individually owned disk drive is accessed, even though the processor element that executes specific aggregate queries performs an operation for all the data, the cost of accessing the disk drive is reduced.
      <br/>
      In addition, since accessing the disk drive is shared by a plurality of aggregate queries, the total cost is reduced.
    </p>
    <p num="85">
      The above processing will specifically be explained referring to FIGS. 7 to 10. Assume that the processor element 1 performs the query 1 previously mentioned, the processor element 2 performs queries 2 and 3, the processor element 3 performs the query 4, and the processor element 4 performs the query 5.
      <br/>
      The processing performed by the processor element 2 will now be described.
      <br/>
      In this explanation, one tuple of data is read, but a desired number of tuples of data can be read.
    </p>
    <p num="86">
      The processor element 2 reads the first tuple in FIG. 8 to the work space in the memory, and transmits that data to all the processor elements via the network.
      <br/>
      Since the other processor elements also read data (the first tuple in each database) and transmit them to all the rest of the processor elements, data in the first tuples in FIGS. 7 to 10 are stored in the work space in the memory of the processor element 2.
      <br/>
      The processor element 2 then executes the previously mentioned queries 2 and 3, which are a query (query 2) for adding the amount of sold each week and a query (query 3) for adding the amount of sold at each location.
    </p>
    <p num="87">
      When the processor element 2 begins the query 2 for the data present in the work space of the memory, the week "Sat" and the amount of sold "7," the week "Wed" and the amount of sold "15," and the week "Sun" and the amount of sold "3" are acquired.
      <br/>
      When the processor element 2 executes the query 3, the location "Kyuushuu" and the amount of sold "10,"the location "Kansai" and the amount of sold "6" and the location "Hokkaido" and the amount of sold "9" are acquired.
    </p>
    <p num="88">
      Following this, the processor element 2 reads the second tuple in FIG. 8 to the work space in the memory, and transmits that data to all the processor elements via the network.
      <br/>
      Since the other processor elements also read data (the second tuple in each database) and transmit them to all the rest of the processor elements, the data in the second tuples in FIGS. 7 to 10 are stored in the work space in the memory of the processor element 2.
    </p>
    <p num="89">
      When the processor element 2 begins the query 2 for the data present in the work space of the memory and the currently obtained result, the week "Sat" and the amount of sold "16," the week "Wed" and the amount of sold "15," the week "Sun" and the amount of sold "7," the week "Tue" and the amount of sold "8," and the week "Thu" and the amount of sold "1" are acquired.
      <br/>
      Similarly, when the processor element 2 executes the query 3, the location "Kyuushuu" and the amount of sold "11," the location "Kansai" and the amount of sold "6," the location "Hokkaido" and the amount of sold "21," and the location "Kanto" and the amount of sold "9" are acquired.
    </p>
    <p num="90">
      Then, the processor element 2 reads the third tuple in FIG. 8 to the work space in the memory, and transmits that data to the rest of the processor elements via the network.
      <br/>
      Since the other processor elements also read data (the third tuple in each database) and transmit them to all the rest of the processor elements, data in the third tuples in FIGS. 7 to 10 are stored in the work space in the memory of the processor element 2.
    </p>
    <p num="91">
      When the processor element 2 begins the query 2 for the data present in the work space of the memory and the currently obtained result, the week "Sat" and the amount of sold "16," the week "Wed" and the amount of sold "15," the week "Sun" and the amount of sold "15," the week "Tue" and the amount of sold "8," the week "Thu" and the amount of sold "9," and the week "Mon" and the amount of sold "4" are acquired.
      <br/>
      Similarly, when the processor element 2 executes the query 3, the location "Kyuushuu" and the amount of sold "11," the location "Kansai" and the amount of sold "6," the location "Hokkaido" and the amount of sold "31," and the location "Kanto" and the amount of sold "19" are acquired.
    </p>
    <p num="92">
      When the processor element 2 has executed the queries 2 and 3 for all the data in FIGS. 7 to 10 by repeating the above described process, data shown in FIG. 22 are stored in the memory of the processor element 2.
      <br/>
      The final results obtained by the processor elements 1, 3 and 4 are shown in FIG. 23.
    </p>
    <p num="93">3. Repm algorithm (FIG. 24)</p>
    <p num="94">
      Because this algorithm is based on the Rep algorithm which is described in the background art and is expanded to perform a plurality of aggregate queries in parallel, it is called Repm algorithm.
      <br/>
      By minimizing the disk access when executing the plurality of aggregations, performance in the whole system is enhanced.
      <br/>
      In this case, S aggregate queries are executed.
    </p>
    <p num="95">
      (1) First, it is determined which queries are executed in the S aggregate queries (step 510).
      <br/>
      At this time, T aggregate queries are executed.
      <br/>
      In the following explanation, each processor element executes the same queries, but executes difference groups in the same queries.
      <br/>
      However, it is not necessary that each processor element executes the same queries.
      <br/>
      In addition, this step has to be performed referring to available memory capacity in the whole system.
      <br/>
      However, it is not necessary to refer to only the available memory capacity.
      <br/>
      It is possible that a user specifies the queries within the available memory capacity.
      <br/>
      One example for implementing this step is shown in the following pseudo code.
    </p>
    <p num="96">
      -- TABLE 5
      <br/>
      -- Input:    number of aggregate queries: s
      <br/>
      --           estimated size of the result of each aggregate query
      <br/>
      --                    : n(1), n(2), . . . n(s)
      <br/>
      --           size of the main memory in the whole system: M
      <br/>
      -- output:   Output is aggregate queries which can be put in the memory.
      <br/>
      -- algorithm:
      <br/>
      -- R = + 1, 2, . . . s };
      <br/>
      --           - a group of unprocessed aggregate queries
      <br/>
      -- while R is not empty do
      <br/>
      --      m = M; - size of the residual memory space
      <br/>
      --      Q = empty; - Initialization of Q which stores the result
      <br/>
      --      while m &gt;= 0 or R is empty do
      <br/>
      --         x = an element in R; - Acquire an element in R
    </p>
    <p num="97">
      --         R = R - + x }; - Take away the element from R.
      <br/>
      --         Q = Q + + x }; - Add the element to Q
      <br/>
      --         m = m - n(x); - Subtract memory size of the execution
      <br/>
      --                       - result of the element from m.
      <br/>
      --      done;
      <br/>
      --      output (Q);
      <br/>
      --         - Output Q as a group of the aggregate queries which
      <br/>
      --         - can be put in the memory.
      <br/>
      -- done.
    </p>
    <p num="98">
      (2) In the next step, it is determined which processor element executes aggregations for which group of the aggregate queries.
      <br/>
      For example, if there are b, c, d and e groups associated with query A, the b, c, d and e are respectively assigned to processor elements 1, 2, 3 and 4.
      <br/>
      If there are f, g, h and i associated with query B, the f, g, h and i are respectively assigned to processor elements 1, 2, 3 and 4.
      <br/>
      This step can not be executed without knowledge about what groups exist in each aggregate queries.
      <br/>
      However, if execution is performed for sampling in a small way, the kinds of the groups can be grasped.
      <br/>
      In addition, there are a lot of variations of the method for assigning the groups.
      <br/>
      For example, it is possible that a hash function whose input is a group is prepared to assign a processor element according to the range of the hash value.
      <br/>
      It is also possible that a user assigns one processor element to one group, specifically.
    </p>
    <p num="99">
      The whole system should perform the above steps 510 and 520.
      <br/>
      Therefore, it is possible to assign this process to one specific processor element or to provide one control processor and to cause the control processor to execute the process.
    </p>
    <p num="100">
      (3) Then, each processor element reads out data to be processed from the owned part of the database (step 530).
      <br/>
      For example, one tuple is read out or a plurality of tuples in the database are read out.
    </p>
    <p num="101">
      (4) Each processor element selects necessary data for execution of the aggregate queries in the read data (step 540).
      <br/>
      For example, if one tuple in the database is read out, data about unnecessary attributes for the aggregate queries are read out.
      <br/>
      Therefore, the data about the unnecessary attributes are discarded in the whole system.
      <br/>
      In this case, data about unnecessary attribute for the T aggregate queries which are determined in the step 510 is discarded.
      <br/>
      Since, in the Rep algorithm described in the background art, the read data is used for only one aggregate query is used, one disk access is used in the Repm algorithm T times as efficiently as in the Rep algorithm.
    </p>
    <p num="102">
      (5) In the next step, each processor element transmits data to be aggregated in another processor element in the read data to another processor element with the aggregate query's ID, which is associated with the data to be aggregated in another processor element, via the network 1 (step 550).
      <br/>
      Since a necessary attribute in the data is determined by the executed aggregate query and a value of the attribute determines its group, a hash function for determining a destination processor element by using the attribute value as an input is prepared.
      <br/>
      This step is performed for each of the T aggregate queries.
      <br/>
      At this time, the ID of the aggregate query is attached to transmitted data so that the receiving processor element can judge for which aggregate query the data is transmitted.
    </p>
    <p num="103">
      (6) Each processor element executes the T aggregate queries for data associated with groups of the aggregate queries to be executed in the processor element (step 560).
      <br/>
      This step is executed for the results of the aggregations previously obtained and necessary data in the processor element of the read data and data transmitted from another processor elements.
    </p>
    <p num="104">
      (7) Then, until each processor element executes the T aggregate queries for all the data associated with groups of the aggregate queries to be executed (step 570).
      <br/>
      That is, it is repeated until the read data and received data become necessary part of the whole database.
    </p>
    <p num="105">
      (8) If this execution completes, the processing for the T aggregate queries completes.
      <br/>
      Therefore, next T aggregate queries (the number T may be different from current T.) will be executed by repeating the step 510 and the subsequent steps until the S aggregate queries are executed (step 580).
    </p>
    <p num="106">
      Execution example is described using FIG. 7 to 10. At this time, simultaneously executed aggregate queries are the query 1 (a query for totaling an amount of sold by month) and the query 2 (a query for totaling an amount of sold by day of the week).
      <br/>
      The number of the processor element is 4.
      <br/>
      The processor element 1 aggregates Jan and Feb groups of the query 1 and Mon and Tue groups of the query 2.
      <br/>
      The processor element 2 aggregates Mar and Apr groups of the query 1 and Wed and Thu groups of the query 2.
      <br/>
      The processor element 3 aggregates May and Jun groups of the query 1 and Fri and Sat groups of the query 2.
      <br/>
      The processor element 4 aggregates Jul and Aug groups of the query 1 and Sun group of the query 2.
    </p>
    <p num="107">
      The example processing of the processor element 3 is explained below.
      <br/>
      FIG. 25 shows the state where the processor element 3 read out the first tuple in the database for the processor element 3, which is shown in FIG. 9.
      <br/>
      In this example, one tuple is read out one time, but the number of the read tuple is arbitrary.
      <br/>
      In this example, the columns of "day" and "location" and "shop-" and "product-" are discarded because those columns are not necessary for the query 1 and 2 (See step 540).
      <br/>
      The columns of "month" and "week" and "sold" are necessary for the query 1 and 2.
      <br/>
      Then, month "Aug" and amount of sold "7" are transmitted to the responsible processor element 4 with the ID of the query 1 (See step 550).
      <br/>
      Because day of the week "Sat" and amount of sold "7" is for a group to be aggregated in the processor element 3, the processor element 3 aggregates the data.
      <br/>
      Here, the data is first data, therefore the data is merely recorded.
      <br/>
      If the processor element 1 and 2 and 4 read out and process the first tuple in those database, no data is transmitted to the processor element 3.
    </p>
    <p num="108">
      The state where the processor element 3 read out the second tuple in FIG. 9 is shown in FIG. 26. Unnecessary part in the tuple is already discarded.
      <br/>
      Month "Apr" and amount of sold "8" are transmitted to the processor element 2 with the ID of the query 1.
      <br/>
      In addition, day of the week "Tue" and amount of sold "8" are transmitted to the processor element 1 with the ID of the query 2.
      <br/>
      If the processor element 1 and 2 and 4 simultaneously read out and process the second tuple in the individual database, day the week "Sat" and amount of sold "9" are received from the processor element 4 with the ID of the query 2.
      <br/>
      Then, the processor element 3 obtains day of the week "Sat" and amount of sold "16" referring to the result of the first tuple.
    </p>
    <p num="109">
      The state where the processor element 3 read out the third tuple in FIG. 9 is shown in FIG. 27. Unnecessary part in the tuple is already discarded.
      <br/>
      Month "May" and amount of sold "8" are data to be aggregated by the processor element 3.
      <br/>
      Here, the processor element 3 records the Month "May" and amount of sold "8".
      <br/>
      Day of the week "Thu" and amount of sold "8" are transmitted to the processor element 2 with the ID of the query 2.
      <br/>
      If the processor element 1 and 2 and 4 simultaneously read out and process the third tuple in the individual database, the processor element 3 receives month "Jun" and amount of sold "2" with the ID of the query 1 from the processor element 1 and month "May" and amount of sold "2" with the ID of the query 1 from the processor element 2.
      <br/>
      The processor element 3 refers to the previously obtained results and obtains and stores the result of month "May" and amount of sold "10" and month "Jun" and amount of sold "2".
      <br/>
      This explanation shows data read by the processor element and data transmitted from another processor element are differently processed.
      <br/>
      However, this is only for convenience of the explanation, and both data can be processed without any discrimination.
    </p>
    <p num="110">
      The state where the processor element 3 read out the forth tuple in FIG. 9 is shown in FIG. 28. Because month "Mar" and amount of sold "8" are for a group to be aggregated in the processor element 2, the processor element 3 transmits the data to the processor element 2 with the ID of the query 1.
      <br/>
      In addition, because day of the week "Fri" and amount of sold "8" are for a group to be aggregated in the processor element 3, the data is only stored in this case.
      <br/>
      If the processor element 1 and 2 and 4 simultaneously read out and process the forth tuple in the individual database, month "May" and amount of sold "4" are received from the processor element 1 with the ID of the query 1, and day of the week "Fri" and amount of sold "4" are received from the processor element 1 with the ID of the query 2, and day of the week "Fri" and amount of sold "9" are received from the processor element 2 with the ID of the query 2, and month "Jun" and amount of sold "3" are received from the processor element 4 with the ID of the query 1, and day of the week "Sat" and amount of sold "3" are received from the processor element 4 with the ID of the query 2.
      <br/>
      Therefore, the processor element 3 obtains from those data month "May" and amount of sold "14" and month "Jun" and amount of sold "5" and day of the week "Fri" and amount of sold "21" and day of the week "Sat" and amount of sold "19".
    </p>
    <p num="111">
      By repeating these processing, the processor element 3 obtains part of the query 1 and query 2 in FIG. 18. Similarly, the processor element 1 obtains part of the query 1 and query 2 in FIG. 16. The processor element 2 obtains part of the query 1 and query 2 in FIG. 17. the processor element 4 obtains part of the query 1 and query 2 in FIG. 19. FIG. 29 shows the destination processor element (node) of the data when each processor element transmits to another processor element (node) with the ID of the query 1.
      <br/>
      Inversely, for the query 1, FIG. 30 shows the source processor element (node) of the data transmitted to each processor element from another processor element.
      <br/>
      In addition, FIG. 31 shows the destination processor element (node) of the data when each processor element transmits to another processor element (node) with the ID of the query 2.
      <br/>
      Inversely, for the query 2, FIG. 32 shows the source processor element (node) of the data transmitted to each processor element from another processor element.
    </p>
    <p num="112">
      The recapitulations below are for the algorithms that have been explained.
      <br/>
      Since according to the 2Pm algorithm the processor elements respectively execute aggregations for data stored on their disk drives, the processor elements must prepare a memory having the same size as the final results obtained by the aggregations.
      <br/>
      However, as the communication cost is low, the processing speed is faster than the other algorithms when the final results are small.
    </p>
    <p num="113">
      According to the BCm algorithm, since all of the processor elements can individually store the final results in their memories, access to a disk drive can be shared by a number of aggregate queries that is multiple times, the equivalent of the number of processors, of the number of aggregate queries that can be processed at one time by using the 2Pm algorithm.
      <br/>
      When the final result is too large to be stored in the memory in one processor element, the repetitive 2Pm algorithm process is required for the final result; however, by using the BCm algorithm, the final result can be stored in the memory and the performance of the BCm algorithm is required only once.
      <br/>
      In this case, the processing speed using the BCm algorithm is higher than that using the 2Pm algorithm.
    </p>
    <p num="114">If the memory size for storing the final result is very large, Repm algorithm may be advantageous because cost of the access to the disk device and totaling cost become large in algorithms other than the Repm algorithm.</p>
    <p num="115">
      Since the optimal algorithm is not always the same, it is preferable that an optimal algorithm be selected from among the Repm algorithm, the 2Pm algorithm and the BCm algorithm, and that a plurality of aggregate queries be executed by using the selected algorithm.
      <br/>
      Costs required for the execution of each algorithm are to be estimated.
      <br/>
      An explanation will now be given for a cost model.
    </p>
    <p num="116">First, costs that will occur are shown in Table 6.</p>
    <p num="117">
      -- TABLE 6
      <br/>
      -- Symbols            Contents              Values
      <br/>
      -- N                  No. of nodes          variable
      <br/>
      -- R                  Size of relation      5 G
      <br/>
      --                    (Byte)
      <br/>
      -- .vertline.R.vertline.  No. of tuples in R    10 million
      <br/>
      -- .vertline.Ri .vertline.
      <br/>
      No. of tuples on      .vertline.R.vertline./N
      <br/>
      --                    node i
      <br/>
      -- .vertline.Rp .vertline.
      <br/>
      No. of repartitioned
      <br/>
      --  max(.vertline.Ri.vertline.,1/S/Q)
      <br/>
      --                    tuples
      <br/>
      -- Q                  No. of aggregate      variable
      <br/>
      --                    queries
      <br/>
      -- T                  No. of scans of the   variable
      <br/>
      --                    source data
      <br/>
      -- A                  No. of aggregate      100
      <br/>
      --                    function per query
      <br/>
      -- S                  Grouping              variable
      <br/>
      --                    selectivity of a
      <br/>
      --                    query
      <br/>
      -- Sl            Phase 1 selectivity   min(SN, 1)
      <br/>
      --                    (for 2P)
      <br/>
      -- Sg            Phase 2 selectivity   min(1/N, S)
      <br/>
      --                    (for 2P)
      <br/>
      -- .vertline.G.vertline.  No. of result         .vertline.R.vertline.S
      <br/>
      --                    tuples
      <br/>
      -- p                  Projectivity          0.5
      <br/>
      -- .vertline.Gi .vertline.
      <br/>
      No. of result         .vertline.Ri
      <br/>
      --  .vertline.Sl
      <br/>
      --                    tuples on node i
      <br/>
      -- P                  Page size             4 KB
      <br/>
      -- M                  Size of hash table    50 MB
      <br/>
      -- mips               CPU speed             120 MIPS
      <br/>
      -- IO                 Time to read a page   0.8 ms
      <br/>
      -- tr            Time to read a        200/mips
      <br/>
      --                    tuple
      <br/>
      -- tw            Time to write a       200/mips
      <br/>
      --                    tuple
      <br/>
      -- th            Time to compute       200/mips
      <br/>
      --                    hash
      <br/>
      -- ta            Time to compute an    40/mips
      <br/>
      --                    aggregate
      <br/>
      -- tm            Time to send a page   0.1 ms
      <br/>
      -- tb            Time to broadcast a   (N-1)tm
      <br/>
      --                    page
    </p>
    <p num="118">
      Specific values in the right column are merely examples, and other values will be employed in another computer system.
      <br/>
      Symbols sandwiched between vertical lines indicate the values for those symbols, and symbols without vertical lines indicate the number of bytes used for those symbols.
    </p>
    <p num="119">
      An explanation will be now given for several symbols.
      <br/>
      Page size P is the size of data handled by a computer system.
      <br/>
      Projectivity p indicates a rate of columns in the relation that are employed.
      <br/>
      Selectivity of one aggregate query indicates a value obtained by dividing the number of groups by the number of data sets.
      <br/>
      In addition, there are cases where aggregate queries which use the same attribute differently process the attribute, such as counting the occurrence and totaling the value, and where, for example, a value which satisfies a predetermined condition is aggregated.
      <br/>
      Therefore, A is defined as the number of the different processes of the attribute.
      <br/>
      In the Data Mining, A becomes a large value, such as 100 in the Table 6.
    </p>
    <p num="120">Using the above background, the costs of the individual algorithms will be described.</p>
    <p num="121">1. 2Pm algorithm</p>
    <p num="122">(a) cost for reading from a database</p>
    <p num="123">
      - (Ri /P)*IO*T
      <br/>
      (b) cost for selecting necessary data
      <br/>
      - .vertline.Ri.vertline.*tr *T
      <br/>
      (c) cost for executing aggregate queries
      <br/>
      - .vertline.Ri.vertline.*(th +ta *A)*Q
      <br/>
      (d) cost for data that can not be processed by the first hashing
      <br/>
      - (Ri *p*Q-M/SI *T)/P*2*IO
      <br/>
      (e) cost for generating tuples to store results
      <br/>
      - .vertline.Gi.vertline.*tw *Q
      <br/>
      (f) transmission/reception cost
      <br/>
      - Gi /P*tm *Q
      <br/>
      (g) cost for calculating final results
      <br/>
      - .vertline.i.vertline.*(tr +ta *A)*Q
      <br/>
      (h) cost for generating tuples to store results (for the second phase)
      <br/>
      - .vertline.Gi.vertline.*Sg *tw *Q
      <br/>
      (i) cost for data that can not be processed by the first hashing (for the second phase)
      <br/>
      - (Gi *Q-M/Sg *T)/P*2*IO
      <br/>
      (j) cost for storing results on a disk drive
      <br/>
      - Gi *Sg /P*IO*Q
    </p>
    <p num="124">Total of these costs is of the 2Pm algorithm.</p>
    <p num="125">
      2. BCm algorithm
      <br/>
      (a) cost for reading data from database
      <br/>
      - (Ri /P)*IO*T
      <br/>
      (b) cost for broadcasting data
      <br/>
      - (Ri /P)*tb *T
      <br/>
      (c) cost of getting tuples from the communication buffer
      <br/>
      - .vertline.R.vertline.*tr *T
      <br/>
      (d) Aggregation cost
      <br/>
      - .vertline.Rp.vertline.*(tb +ta *A)*Q
      <br/>
      (e) cost for data that can not be processed by the first hashing
      <br/>
      - (Rp *p*Q-M/S*T) /P*2*IO
      <br/>
      (f) cost for generating tuples to store results
      <br/>
      - .vertline.Rp.vertline.*S*tw*Q
      <br/>
      (g) cost for storing results on a disk drive
      <br/>
      - Rp *S/P*p*IO*Q
    </p>
    <p num="126">The sum of these costs is the cost for the BCm algorithm.</p>
    <p num="127">
      3. Repm algorithm
      <br/>
      (a) cost for reading data from a database
      <br/>
      - (Ri /P)*IO*T
      <br/>
      (b) cost for selecting necessary data
      <br/>
      - .vertline.Ri.vertline.*tr *T
      <br/>
      (c) cost of hashing to find the destination and writing to communication buffer
      <br/>
      - Ri *(th +tw)*Q
      <br/>
      (d) cost for sending and receiving repartitioned data
      <br/>
      - .vertline.Rp.vertline./P*p*tm *Q
      <br/>
      (e) cost for aggregation
      <br/>
      - .vertline.Rp.vertline.*(tr +ta *A)*Q
      <br/>
      (f) cost for data that can not be processed by the first hashing
      <br/>
      - (Rp *p*Q-M/S*T)/P*2*IO
      <br/>
      (g) cost for generating result tuples
      <br/>
      - .vertline.Rp.vertline.*S*tw *Q
      <br/>
      (h) cost for storing results on a disk drive
      <br/>
      - Rp *S/P*p*IO*Q
    </p>
    <p num="128">The sum of these costs is for the Repm algorithm.</p>
    <p num="129">
      In this manner, the costs required for the individual algorithms can be acquired.
      <br/>
      An algorithm to be executed is determined by the following process (FIG. 33) in accordance with the acquired costs.
      <br/>
      First, parameters concerning hardware are input (step 610).
      <br/>
      The parameters concerning the hardware are determined by the hardware configuration, such as the number of processor elements, the size of a hash table, the time required for reading a page, the time required for reading a tuple, the time required for writing a tuple, the time required for hash calculation, the time required for page transmission, the time required for aggregation operation and the time required for broadcasting a page in the Table 6.
      <br/>
      Most of the parameters are not changed once the configuration of a computer is determined, but it is possible by calculation to change the number of the processor elements and the size of the hash table.
      <br/>
      The parameters concerning aggregate queries to be executed are input (step 620).
      <br/>
      In Table 6, almost all the parameters other than those for hardware are related to the aggregations.
      <br/>
      While the number of resultant tuples is not determined by only the aggregations, that value can be obtained by performing data sampling and estimating the number of groups.
      <br/>
      This process has been performed (see, for example, "Sampling-based Estimation Of The Number Of Distinct Values Of An Attribute," P. J. Haas, J. F. Naughton, S. Seshadri and L. Stockes, in Proceedings of the 21st VLDB Conference, pp. 311-322, 1995).
    </p>
    <p num="130">
      When parameters shown in Table 6 are input, the costs of the individual algorithms can be calculated in accordance with the previously described cost models (step 630).
      <br/>
      Then, the algorithm requiring the lowest cost of the three is determined (step 640).
      <br/>
      The aggregations can be performed at the highest speed by using the selected algorithm.
    </p>
    <p num="131">
      An explanation has been given for the computer system and the processing flow of the program that are required for implementing the present invention.
      <br/>
      It is possible to form a circuit for each step of the processing flow of the program processing or means for performing the individual steps by using a combination of a program and a circuit.
      <br/>
      The means for performing the individual steps are provided instead of the processor elements, and perform parallel processing across a high speed network.
      <br/>
      It is also possible to provide a controller for controlling the repetitive process and to provide management means for controlling the entire system.
    </p>
    <p num="132">
      The program for performing the above described processing can be distributed by using a storage medium, such as a floppy disk, a CD-ROM or an MO (Magneto-Optics) disk.
      <br/>
      In addition, the program can be distributed not only on a storage medium, but also by a wire or radio communication medium.
      <br/>
      In this case, for several steps in the above described processing, the program can be provided for a user, separately from a program run by using a storage medium or a communication medium.
    </p>
    <p num="133">
      FIG. 34 is a graph showing an optimal algorithm for each condition when an IBM SP2, which has a 16-node high performance switch, is employed.
      <br/>
      In this system, the 2Pm algorithm is optimal in region a, the BCm algorithm is optimal in region b, and the Rep algorithm is optimal in region c. The optimal algorithm can be selected in accordance with the number of queries and the number of groups for each query.
      <br/>
      It should be noted that instead of preparing the graph to select the optimal algorithm, the costs for the algorithms can be calculated by using the above cost model and can be compared with each other to select the optimal algorithm.
    </p>
    <p num="134">As described above, a method for performing a plurality of aggregations in parallel and at a high speed can be provided.</p>
    <p num="135">Since a plurality of aggregations can be performed in parallel and at a high speed by using the above described method, the speed for the execution of OLAP and Data Mining can be increased.</p>
    <p num="136">In addition, since a method for executing a plurality of aggregations can be switched to another based on hardware conditions and the properties of a plurality of aggregations, under various conditions a plurality of aggregations can be executed at a higher speed than normal by using the same method.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for executing N aggregate queries for a database in a computer system, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a part of said database for itself, said database including data which is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said method comprising the steps of:</claim-text>
      <claim-text>(a) ensuring space for storing results of M aggregate queries of said N aggregate queries (M being an integer less than N) in the memory area for itself in each said processor; (b) executing said M aggregate queries together for said part of said database for itself in each said processor in parallel; (c) transmitting the results of said M aggregate queries executed by each said processor to a processor for counting up and calculating a final result;</claim-text>
      <claim-text>and (d) iterating said steps (a) to (c) until execution of said N aggregate queries is completed.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method according to claim 1, wherein said step (b) includes the steps of: (b1) in each said processor, reading a part of a partial database into a work space of said memory area for itself, said partial database being said part of said database for itself; (b2) in each said processor, executing said M aggregate queries for results of calculations that were performed at previous steps and stored in the memory area for itself and the read part of said partial database;</claim-text>
      <claim-text>and (b3) iterating said steps (b1) and (b2) until execution of said M aggregate queries is completed for all of said database.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method according to claim 1, wherein M is determined from an amount of space which can be acquired in said memory area for itself for storage of results obtained by execution of aggregate queries.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A method for executing P aggregate queries for a database in a computer system, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data which is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said method comprising the steps of: (a) in each said processor, ensuring space for storing results of Q aggregate queries (Q being an integer less than P) to be executed in that processor of said P aggregate queries in the memory area for itself; (b) executing said Q aggregate queries for data in the entire database in each said processor by iterating a step of reading a part of said partial database into the memory area for itself in each said processor and a step of broadcasting said read part of said partial database via said network in each said processor;</claim-text>
      <claim-text>and (c) iterating said steps (a) and (b) until execution of said P aggregate queries is completed.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method according to claim 4, wherein said step (a) includes the steps of: (a1) checking whether space in which a result of an execution of one aggregate query is stored is present in the memory area for one processor; (a2) acquiring said space for said result of said execution of said one aggregate query when said space is present; (a3) when said space is not present, checking whether said space in which said result of said execution of said one aggregate query is stored is present in the memory area for another processor;</claim-text>
      <claim-text>and (a4) acquiring said space for said result of said execution of said one aggregate query when said space is present in said another processor;</claim-text>
      <claim-text>and</claim-text>
      <claim-text>wherein, when said space is not present in the memory area for said another processor, said one aggregate query is executed in a succeeding iteration process.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method according to claim 4, wherein Q is determined from an amount of space which can be acquired in said memory area for itself for storage for results obtained by execution of aggregate queries.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method according to claim 4, wherein said step (b) includes the steps of: (b1) in each said processor, reading a part of said partial database to a work space of said memory area for itself; (b2) broadcasting the read part of said partial database via said network; (b3) executing said Q aggregate queries for results of calculations that were performed at previous steps and stored in the memory area for itself and the read part of said partial database and data transmitted from other processors;</claim-text>
      <claim-text>and (b4) iterating said steps (b1) to (b3) until each said processor completes execution of said Q aggregate queries for all data in said database.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A method for executing S aggregate queries for a database in a computer system, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of a database for itself, said database including data which is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of the groups, said method comprising the steps of: (a) determining T aggregate queries to be executed of said S aggregate queries; (b) determining which processor aggregates each group of each of said T aggregate queries, wherein each said group is to be aggregated when said T aggregate queries are executed; (c) in each said processor, reading out a part of said partial database into said memory area for itself, and transmitting data associated with a group to be aggregated in another processor of an aggregate query in the read data to said another processor via said network with the aggregate query's ID, and executing said aggregate queries for data associated with groups to be aggregated in that processor of said T aggregate queries; (d) iterating said step (c) until each said processor completes the execution of said T aggregate queries for all data associated with groups to be aggregated in that processor of said T aggregate queries;</claim-text>
      <claim-text>and (e) iterating said steps (a) to (d) until the execution of said S aggregate queries is completed.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method according to the claim 8, wherein the step (c) includes the steps of: (c1) in each said processor, reading a part of said partial database into a work area in the memory area for itself; (c2) in each said processor, determining which processor needs each portion of read data, transmitting said portion with an ID of an aggregate query associated with said portion to the needing processor via said network;</claim-text>
      <claim-text>and (c3) in each said processor, executing said T aggregate queries for data associated with groups to be aggregated in that processor in the read data and data transmitted from other processors and results of calculations which were performed at the previous steps and stored in the memory area for itself.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A method for executing N aggregate queries for a database in a computer system, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data that is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said method comprising the steps of: determining which method in a plurality of aggregate query execution methods which includes first and second and third methods is the speediest by using parameters of said computer system that includes the number of said processors, the size of said database and a communication speed of said network, and parameters associated with properties of said aggregate queries that include the number of aggregate queries to be executed and a capacity of memory in which the results of said execution of said aggregate queries are stored, wherein said first method comprises the steps of:</claim-text>
      <claim-text>- (a) ensuring space for storing results of M aggregate queries of said N aggregate queries (M is an integer equal to or less than N) in the memory area for itself in each processor; - (b) executing said M aggregate queries together for said part of database for itself in each said processor; - (c) transmitting the results of said M aggregate queries executed by each processor to a processor for counting up in each said processor, and calculating a final result in said processor for counting up;</claim-text>
      <claim-text>and - (d) iterating said steps (a) to (c) until execution of said N aggregate queries is completed, wherein said second method comprises the steps of: - (e) in each said processor, ensuring space for storing results of Q aggregate queries to be executed in that processor of said N aggregate queries in the memory area for itself; - (f) executing said Q aggregate queries for data in the entire database in each said processor by iterating a step of reading a part of said partial database into the memory area for itself in each said processor and a step of broadcasting said read part of said partial database via said network in each said processor;</claim-text>
      <claim-text>and - (g) iterating said steps (e) and (f) until execution of said N aggregate queries is completed, wherein said third method comprising the steps of: - (h) determining T aggregate queries to be executed of said N aggregate queries; - (i) determining which processor aggregates each group of each of said T aggregate queries, wherein each said group is to be aggregated when said T aggregate queries are executed; - (j) in each said processor, reading out a part of said partial database into said memory area for itself, and transmitting data associated with a group to be aggregated in another processor of an aggregate query in the read data to said another processor via said network with the aggregate query's ID, and executing said aggregate queries for data associated with groups to be aggregated in that processor of said T aggregate queries; - (k) iterating said step (j) until each said processor completes the execution of said T aggregate queries for all data associated with groups to be aggregated in that processor of said T aggregate queries;</claim-text>
      <claim-text>and - (l) iterating said steps (h) to (k) until the execution of said N aggregate queries is completed;</claim-text>
      <claim-text>and executing said N aggregate queries by the determined method.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A computer system for executing N aggregate queries for a database, said computer system being so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a part of said database for itself, said database including data that is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, each said processor comprising: (a) a memory processor for ensuring space for storing results of M aggregate queries of said N aggregate queries (M being an integer less than N) in the memory area for itself; (b) a database processor for executing said M aggregate queries together for said part of said database for itself; (c) a transmitter for transmitting results obtained by said M aggregate queries to a processor for counting up;</claim-text>
      <claim-text>and</claim-text>
      <claim-text>wherein each said processor operates said memory processor and said database processor and said transmitter until the execution of the N aggregate queries is completed, and said processor for counting up receives and counts up execution results to be counted up in that processor from other processors.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A computer system for executing N aggregate queries for a database, said computer system being so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data that is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, each said processor comprising: (a) a memory processor for ensuring space for storing results of Q aggregate queries (Q being an integer less than N) to be executed in that processor of said N aggregate queries in the memory area for itself; (b) a database processor for executing said Q aggregate queries for data in the entire database by iterating a step of reading a part of said partial database into a work space in the memory area for itself and a step of broadcasting via said network the read part of said partial database;</claim-text>
      <claim-text>and wherein each said processor operates said memory processor and said database processor until execution of said P aggregate queries is completed.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. A computer system for executing S aggregate queries for a database, said computer system being so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data that is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said computer system comprising: a controller for determining T aggregate queries to be executed of said S aggregate queries and determining which processor aggregates each group of each of said T aggregate queries, wherein each said group is to be aggregated when said T aggregate queries are executed, each said processor comprising: - a database processor for reading out a part of said partial database into said memory area for itself, and transmitting data associated with a group to be aggregated in another processor of an aggregate query in the read data to said another processor via said network with the aggregate query's ID, and executing said aggregate queries for data associated with groups to be aggregated in that processor of said T aggregate queries, - wherein said database processor operates until each said processor completes the execution of said T aggregate queries for all data associated with groups to be aggregated in that processor of said T aggregate queries, and said controller and each said processor operate until the execution of said S aggregate queries is completed.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A computer system for executing N aggregate queries for a database, said computer system being so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data that is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said computer system comprising: a selector for determining which method in a plurality of aggregate query execution methods which includes first and second and third methods is the speediest by using parameters of said computer system that includes the number of said processors, the size of said database and a communication speed of said network, and parameters associated with properties of said aggregate queries that include the number of aggregate queries to be executed and a capacity of memory in which the results of said execution of said aggregate queries are stored, wherein said first method comprises the steps of: - (a) ensuring space for storing results of M aggregate queries of said N aggregate queries (M is an integer equal to or less than N) in the memory area for itself in each processor; - (b) executing said M aggregate queries together for said part of database for itself in each said processor; - (c) transmitting the results of said M aggregate queries executed by each processor to a processor for counting up in each said processor, and calculating a final result in said processor for counting up;</claim-text>
      <claim-text>and - (d) iterating said steps (a) to (c) until execution of said N aggregate queries is completed, wherein said second method comprises the steps of: - (e) in each said processor, ensuring space for storing results of Q aggregate queries to be executed in that processor of said N aggregate queries in the memory area for itself; - (f) executing said Q aggregate queries for data in the entire database in each said processor by iterating a step of reading a part of said partial database into the memory area for itself in each said processor and a step of broadcasting said read part of said partial database via said network in each said processor;</claim-text>
      <claim-text>and - (g) iterating said steps (e) and (f) until execution of said N aggregate queries is completed, wherein said third method comprising the steps of: - (h) determining T aggregate queries to be executed of said N aggregate queries; - (i) determining which processor aggregates each group of each of said T aggregate queries, wherein each said group is to be aggregated when said T aggregate queries are executed; - (j) in each said processor, reading out a part of said partial database into said memory area for itself, and transmitting data associated with a group to be aggregated in another processor of an aggregate query in the read data to said another processor via said network with the aggregate query's ID, and executing said aggregate queries for data associated with groups to be aggregated in that processor of said T aggregate queries; - (k) iterating said step (j) until each said processor completes the execution of said T aggregate queries for all data associated with groups to be aggregated in that processor of said T aggregate queries;</claim-text>
      <claim-text>and - (l) iterating said steps (h) to (k) until the execution of said N aggregate queries is completed;</claim-text>
      <claim-text>and - means for instructing each said processor to execute said N aggregate queries by the determined method.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A storage medium for storing a program for causing a computer system to execute N aggregate queries for a database, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a part of said database for itself, said database including data which is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said program comprising the steps of: (a) ensuring space for storing results of M aggregate queries of said N aggregate queries (M being an integer less than N) in the memory area for itself in each processor; (b) executing said M aggregate queries together for said part of database for itself in each said processor; (c) transmitting the results of said M aggregate queries executed by each processor to a processor for counting up in each said processor, and calculating a final result in said processor for counting up;</claim-text>
      <claim-text>and (d) iterating said steps (a) to (c) until execution of said N aggregate queries is completed.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. A storage medium for storing a program for causing a computer system to execute P aggregate queries for a database, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data which is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said program comprising the steps of: (a) in each said processor, ensuring space for storing results of Q aggregate queries (Q being an integer less than P) to be executed in that processor of said P aggregate queries in the memory area for itself; (b) executing said Q aggregate queries for data in the entire database in each said processor by iterating a step of reading a part of said partial database into the memory area for itself in each said processor and a step of broadcasting said read part of said partial database via said network in each said processor;</claim-text>
      <claim-text>and (c) iterating said steps (a) and (b) until execution of said P aggregate queries is completed.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. A storage medium for storing a program for causing a computer system to execute S aggregate queries for a database, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data which is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said program comprising the steps of: (a) determining T aggregate queries to be executed of said S aggregate queries; (b) determining which processor aggregates each group of each of said T aggregate queries, wherein each said group is to be aggregated when said T aggregate queries are executed; (c) in each said processor, reading out a part of said partial database into said memory area for itself, and transmitting data associated with a group to be aggregated in another processor of an aggregate query in the read data to said another processor via said network with the aggregate query's ID, and executing said aggregate queries for data associated with groups to be aggregated in that processor of said T aggregate queries; (d) iterating said step (c) until each said processor completes the execution of said T aggregate queries for all data associated with groups to be aggregated in that processor of said T aggregate queries;</claim-text>
      <claim-text>and (e) iterating said steps (a) to (d) until the execution of said S aggregate queries is completed.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. A storage medium for storing a program for causing a computer system to execute N aggregate queries for a database, wherein said computer system is so constructed that each of a plurality of processors connected by a network can use a memory area for itself and a partial database which is a part of said database for itself, said database including data which is categorized into a plurality of groups, said aggregate query including a query of an aggregation for each of said groups, said program comprising the steps of: determining which method in a plurality of aggregate query execution methods which includes first and second and third methods is the speediest by using parameters of said computer system that includes the number of said processors, the size of said database and a communication speed of said network, and parameters associated with properties of said aggregate queries that include the number of aggregate queries to be executed and a capacity of memory in which the results of said execution of said aggregate queries are stored, wherein said first method comprises the steps of: - (a) ensuring space for storing results of M aggregate queries of said N aggregate queries (M is an integer equal to or less than N) in the memory area for itself in each processor; - (b) executing said M aggregate queries together for said part of database for itself in each said processor; - (c) transmitting the results of said M aggregate queries executed by each processor to a processor for counting up in each said processor, and calculating a final result in said processor for counting up;</claim-text>
      <claim-text>and - (d) iterating said steps (a) to (c) until execution of said N aggregate queries is completed, wherein said second method comprises the steps of: - (e) in each said processor, ensuring space for storing results of Q aggregate queries to be executed in that processor of said N aggregate queries in the memory area for itself; - (f) executing said Q aggregate queries for data in the entire database in each said processor by iterating a step of reading a part of said partial database into the memory area for itself in each said processor and a step of broadcasting said read part of said partial database via said network in each said processor;</claim-text>
      <claim-text>and - (g) iterating said steps (e) and (f) until execution of said N aggregate queries is completed, wherein said third method comprising the steps of: - (h) determining T aggregate queries to be executed of said N aggregate queries; - (i) determining which processor aggregates each group of each of said T aggregate queries, wherein each said group is to be aggregated when said T aggregate queries are executed; - (j) in each said processor, reading out a part of said partial database into said memory area for itself, and transmitting data associated with a group to be aggregated in another processor of an aggregate query in the read data to said another processor via said network with the aggregate query's ID, and executing said aggregate queries for data associated with groups to be aggregated in that processor of said T aggregate queries; - (k) iterating said step (j) until each said processor completes the execution of said T aggregate queries for all data associated with groups to be aggregated in that processor of said T aggregate queries;</claim-text>
      <claim-text>and - (l) iterating said steps (h) to (k) until the execution of said N aggregate queries is completed;</claim-text>
      <claim-text>and - executing said N aggregate queries by the determined method.</claim-text>
    </claim>
  </claims>
</questel-patent-document>