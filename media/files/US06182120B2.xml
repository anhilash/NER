<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182120B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182120</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182120</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="8230039" extended-family-id="42108937">
      <document-id>
        <country>US</country>
        <doc-number>09152144</doc-number>
        <kind>A</kind>
        <date>19980911</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09152144</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165530</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="regional" sequence="1">
        <country>EP</country>
        <doc-number>97480067</doc-number>
        <kind>A</kind>
        <date>19970930</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997EP-0480067</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/48        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>48</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>709207000</text>
        <class>709</class>
        <subclass>207000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>709200000</text>
        <class>709</class>
        <subclass>200000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>709229000</text>
        <class>709</class>
        <subclass>229000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>709232000</text>
        <class>709</class>
        <subclass>232000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>709240000</text>
        <class>709</class>
        <subclass>240000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>710029000</text>
        <class>710</class>
        <subclass>029000</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>710040000</text>
        <class>710</class>
        <subclass>040000</subclass>
      </further-classification>
      <further-classification sequence="7">
        <text>710054000</text>
        <class>710</class>
        <subclass>054000</subclass>
      </further-classification>
      <further-classification sequence="8">
        <text>710060000</text>
        <class>710</class>
        <subclass>060000</subclass>
      </further-classification>
      <further-classification sequence="9">
        <text>710244000</text>
        <class>710</class>
        <subclass>244000</subclass>
      </further-classification>
      <further-classification sequence="10">
        <text>710263000</text>
        <class>710</class>
        <subclass>263000</subclass>
      </further-classification>
      <further-classification sequence="11">
        <text>718103000</text>
        <class>718</class>
        <subclass>103000</subclass>
      </further-classification>
      <further-classification sequence="12">
        <text>718107000</text>
        <class>718</class>
        <subclass>107000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/48C4S</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>48C4S</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/4881</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>4881</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>4</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>6</number-of-drawing-sheets>
      <number-of-figures>6</number-of-figures>
      <image-key data-format="questel">US6182120</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method and system for scheduling queued messages based on queue delay and queue priority</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>DUFOND PATRICK, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4084228</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4084228</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>FLETCHER MITCHELL S, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5012409</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5012409</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>BUNNELL MITCHELL</text>
          <document-id>
            <country>US</country>
            <doc-number>5469571</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5469571</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>SCHMITZ PATRICK L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5544318</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5544318</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>GINTER KARL L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5892900</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5892900</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>BRONTE JEFFREY S</text>
          <document-id>
            <country>US</country>
            <doc-number>6061709</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6061709</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Beaulieu, Cesca</name>
            <address>
              <address-1>Saint-Jeannet, FR</address-1>
              <city>Saint-Jeannet</city>
              <country>FR</country>
            </address>
          </addressbook>
          <nationality>
            <country>FR</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Dispensa, Jean-Claude</name>
            <address>
              <address-1>Saint-Jeannet, FR</address-1>
              <city>Saint-Jeannet</city>
              <country>FR</country>
            </address>
          </addressbook>
          <nationality>
            <country>FR</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>McConnell, Daniel E.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Rinehart, Mark H.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Queue processing mechanism in which queued messages are processed based on combination of queue delay and queue priority.
      <br/>
      A scheduler dequeues the highest priority non-empty Microcode Input Queue (MIQ) to serve the queued messages.
      <br/>
      If there is no critical queue, meaning that the maximum aging of one or more queues has not been reached, the critical state is not entered.
      <br/>
      A static weight for each queue is then tested to determine if there is still a message to be processed from the corresponding MIQ.
      <br/>
      Messages are dequeued from the same MIQ until the static weight is reached.
      <br/>
      The next MIQ is then served etc., until the queue of the lowest priority level is served.
      <br/>
      If the critical phase is entered, the status of the normal state is stored for later return and the MIQs in critical state are dequeued according to their critical weights.
      <br/>
      If other MIQs appear to be critical, they are served in the order of their critical priorities (or weights).
      <br/>
      The critical queues are dequeued sequentially according to their critical weight.
      <br/>
      If no critical MIQ is left, the scheduler exits from this critical state and loops back to the normal state that it previously exited.
      <br/>
      Normal state processing continues until the next critical state occurs.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates to data processing in a multitasking operating computer system and more particularly to a method and a system for controlling data transfer between a host data processing system and communication networks by processing queued messages according to a combination of time and weight criteria.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      Operating systems that use single tasking have existed on host data processing systems for many years.
      <br/>
      In such systems, the operating system executes computer programs, subroutines or tasks serially.
      <br/>
      Before beginning a new task, the previous one must be completed.
      <br/>
      The waiting delay may last for a certain period and the throughput of the operating system may be impacted.
      <br/>
      Thus, the system may break down.
    </p>
    <p num="3">
      This problem has led to the advent of the multitasking or multi thread operating systems in which each computer program or task is divided into a plurality of tasks or streams of execution.
      <br/>
      Furthermore, multitasking operating systems have also been extended to multiprocessor environments where tasks of the same or different programs can be executed in parallel on different computer processors.
      <br/>
      While such multitasking operating systems optimize the use of one or more processors, they do not permit the application program developer to adequately influence the scheduling of the task executions.
    </p>
    <p num="4">
      There are different mechanisms for processing the set of queues in which the tasks are queued.
      <br/>
      Such mechanisms are based on three main basic principles:
    </p>
    <p num="5">
      the principle based on priority: wherein a set of priorities is assigned to the different queues and the queue with highest priority is served as long as it is not empty.
      <br/>
      In such case, the queues with lower priorities might never be served because of the important traffic on higher priority queues;
      <br/>
      the principle based on a predefined processing sequence: wherein an order for processing of queues is defined according to a priority that is defined by repetition of a queue in the sequence.
      <br/>
      Whatever the status of the queues are, the sequence is executed (high priority is defined by a high number of occurrences of a given queue in the sequence); and
      <br/>
      the principle based on time: wherein each queue is assigned a processing time.
      <br/>
      The queue is to be processed when the corresponding processing time has elapsed.
      <br/>
      In this case, the queue priority is defined according to the value of the corresponding processing time (the higher the priority of the queue is, the lower the relevant processing time should be).
    </p>
    <p num="6">
      In any one of these mechanisms which are to some extent static, the queue evolution and aging are not taken into consideration.
      <br/>
      In order to cope with the data traffic and not to impact on the throughput of the queue processing, it is required to implement a mechanism that is based on criteria which may have static requirements but which may also evolve in real time so as to process within acceptable delays all the messages in the queues, even the ones with the lowest priorities.
    </p>
    <p num="7">
      In U.S. Pat. No. 5,630,128, a controlled scheduling of program threads in a multitasking operating system is disclosed.
      <br/>
      In this technique, a multitasking operating system permits application programs to influence a schedule of execution of programs to which are assigned priority levels and dispatch classes in which the threads reside.
      <br/>
      According to these parameters, the operating system queues the highest priority thread which is available for execution from each dispatch class onto a run list for execution by a processor.
      <br/>
      The highest priority thread on the run list is executed first.
      <br/>
      But in this kind of implementation, there is no guarantee that the lowest priority thread can be processed within an acceptable delay unless no higher priority thread remains on the run list.
    </p>
    <p num="8">
      In another U.S. Pat. No. 5,437,032, a task scheduler for a multiprocessor system, each containing one or more processors, concurrently execute tasks into which jobs as database queries are divided.
      <br/>
      Each job is assigned a weight in accordance with the external priority of the job.
      <br/>
      A desired level of concurrent task activity is defined for each of the jobs.
      <br/>
      The actual level of concurrent task activity for each of the jobs is also determined.
      <br/>
      The jobs are prioritized for execution of awaiting tasks in accordance with the discrepancy between the desired level of concurrent task activity and the actual level of concurrent task activity for each of the jobs.
      <br/>
      This technique is based on the definitions of desired and actual levels and does take into account the time constraint wherein a task or a set of tasks are to be executed within a certain delay.
    </p>
    <p num="9">
      In U.S. Pat. No. 5,247,671, scalable schedules for a serial communications controller in a data processing system is disclosed.
      <br/>
      In this document, the tasks are scheduled at different priority level so that time-critical tasks are performed quickly enough to prevent data loss.
      <br/>
      The notion of time-critical in this patent came directly from the notion of priority.
      <br/>
      Both notions are not independent, meaning that the tasks are arranged according to certain priority and in this arrangement, some or all the tasks might have time-critical values.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="10">It is therefore an object of the present invention to provide a method and a system for use in data processing in a computer system where the tasks or messages that are queued might have both an associated priority and a time-critical delay.</p>
    <p num="11">It is also an object of the invention to have an implementation wherein the prioritizing of queues and messages should not deteriorate the time responses of messages of the lowest priorities.</p>
    <p num="12">It is another object of the present invention to be applicable to any software managed system where the users share a single resource.</p>
    <p num="13">
      Accordingly, the queues are processed according to two criteria that are the static priority requirements of the queues and its acceptable aging.
      <br/>
      The queue processing is then based on a time and weight dependent mechanism.
    </p>
    <p num="14">
      Therefore, according to the present invention, a method for controlling data transfer between a host data processing system and communication networks by processing queued messages of a plurality of queues (MIQ) saved in a data store comprises the steps of:
      <br/>
      (a) dequeueing, in normal state, successively queued messages from a plurality of queues (MIQ) according to their queue priorities;
      <br/>
      (b) interrupting this normal state to enter a critical state, by dequeueing successively queued messages from a plurality of critical queues (MIQ) according to their queue priorities, the critical queues having aging times that exceed predetermined values (Delay.Maxi); and
      <br/>
      (c) returning to the previous normal state with its set of parameters to continue until the next critical state occurs or until the end of the scheduling cycle.
    </p>
    <p num="15">
      According to the present invention, a system is provided for controlling data transfer between a host data processing system and communication networks by processing queued messages of a plurality of queues (MIQ) saved in a data store, wherein each MIQ is associated with at least four registers:
      <br/>
      a first register for static weight (Stat.Ni) corresponding to the number of messages which may be pulled out from the queue, the first register being implemented in connection with a second register for current weight (Cur.Ni) corresponding to the number of messages left that are allowed to be dequeued from the queue, for processing queued messages in normal state; and
      <br/>
      a third register for maximum delay (Delay.Maxi) corresponding to the maximum waiting time of a non-empty MIQ to be dequeued, the third register being implemented in connection with a fourth register for dormant time (Dorm.i) corresponding to the elapsed time since the MIQ was last served, for processing queued messages in critical state when the fourth register exceeds the third register.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWING</heading>
    <p num="16">
      FIG. 1 shows a block diagram of the computer system in which a preferred embodiment of the present invention is implemented.
      <br/>
      FIG. 2 shows the major steps of the method according to the present invention.
      <br/>
      FIG. 3 shows in detail a flow chart illustrating the method according to the present invention in normal state.
      <br/>
      FIG. 4 shows in detail a flow chart illustrating the method according to the present invention in critical state.
      <br/>
      FIGS. 5A-5B illustrate an example of an application of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="17">
      The description corresponds to the case of an implementation within a telecommunication environment.
      <br/>
      This environment comprises a connectivity switch 1 and a set of communication adapters 10-1 and 11- 1 to 10-N and 11-N.
    </p>
    <p num="18">
      Each telecommunication adapter 10-1 and 11-1 includes a processor card 10-1 and a coupler card 11-1 connected to a plurality of networks through a 32-port bus 9.
      <br/>
      The processor card contains a microprocessor 12 for instance Intel 486, a data store 14 and two hardware circuits 16,18.
      <br/>
      The functionalities of both hardware circuits are to interface the data store 14 and to connect either the coupler or the switch.
      <br/>
      High performance processing bus (HPPB) 3,7 interconnects the switch 1 and the coupler 11-1 to the processor 10-1.
    </p>
    <p num="19">The microprocessor 12 also includes software composed of a multitasking operating system using a scheduler 13 and the tasks to be executed.</p>
    <p num="20">The processor 10-1 operates as follow:</p>
    <p num="21">
      Upon reception from the hardware circuit 16, the messages from the network 9 are stored in a set of queues of the data store 14.
      <br/>
      These queues are also called Microcode Input Queues (MIQ).
      <br/>
      A hardware service table is also updated by the hardware circuit 16.
      <br/>
      This table indicates the status of each queue (empty or not empty);
      <br/>
      The software, by scanning the service table in polling mode, is informed of the status of the queues which indicate if a message is received.
      <br/>
      Then the messages are pulled out of the MIQs so as to be handled by the corresponding tasks;
      <br/>
      Concerning the reception from the hardware circuit 18, the same processing steps occur.
    </p>
    <p num="22">The transmission of data messages operates as in common processing operations, which is not the object of the present invention and thus it will not be described.</p>
    <p num="23">
      The coupler 11-1 receives data messages containing bits from the 32-port bus 9.
      <br/>
      The coupler reassemble the entire data messages so as to transmit them to the processor 10-1 through the hardware circuit 16 so that the data messages are queued in the correct MIQ.
      <br/>
      Not only does the coupler receive the set of bits but it also generates event messages that are processed in the same manner as data messages.
      <br/>
      The event messages and the data messages may have different priority levels.
    </p>
    <p num="24">The number of MIQs in this implementation is limited to a total of 16, but it may be increased to any value as long as the MIQs are ordered in decreasing priority level.</p>
    <p num="25">The coupler 11-1 is responsible for the mapping between message priority and MIQ priority.</p>
    <p num="26">In the preferred embodiment, the present invention may be implemented in a MIQ scheduler part of the operating system.</p>
    <p num="27">FIG. 2 shows the principal steps of the method according to the present invention.</p>
    <p num="28">
      Each MIQ is associated with a set of parameters:
      <br/>
      a static weight, referred to as Stat.Ni, corresponds to the number of messages which may be pulled out from the queue before processing a less prioritized queue,
      <br/>
      a current weight, referred to as Cur.Ni, is the variable that determines the current number of remaining messages that is allowed to be dequeued from the MIQ, this number decreases from the static weight to 1;
      <br/>
      a critical weight, referred to as Crit.Ni, corresponds to the number of messages which may be pulled out from the queue before processing a less prioritized queue, when the MIQ enters in the critical state to be defined later on;
      <br/>
      a maximum delay, referred to as Delay.Maxi, is the maximum time a non-empty MIQ may wait before being served again, in normal state;
      <br/>
      a dormant time, referred to as Dormant.i, is the elapsed time since the non-empty MIQ was last served.
    </p>
    <p num="29">
      The purpose of this chart is to clearly distinguish the normal state from the critical state.
      <br/>
      In the normal state, the queues are served according to their predetermined level of priority.
      <br/>
      In the critical state, all the queues that are in critical state are served according to their predetermined critical level of priority which may be different from the one in normal state.
      <br/>
      The critical state is maintained as long as there is a queue in critical state.
      <br/>
      The main steps of the method are the following:
    </p>
    <p num="30">At power on, the scheduler initializes the set of parameters mentioned above for each queue MIQ, at step 20.</p>
    <p num="31">
      The scheduler enters an infinite loop consisting of dequeueing the highest priority non-empty MIQ, which is for instance the first queue if the MIQs are ordered in a decreasing priority order.
      <br/>
      If the priority order is increasing then the last queue is served first and so on.
    </p>
    <p num="32">
      Thus, at steps 22,24, the first queue Q1 is served, for instance.
      <br/>
      If there is no critical queue at step 25, the critical state is not entered.
      <br/>
      The static weight is then tested to determine if there is still a message to be pulled out from the corresponding MIQ at step 26.
      <br/>
      By looping to step 24, the messages are dequeued from the same MIQ until Stat.Ni is reached (or until Cur.Ni is down to 0).
    </p>
    <p num="33">
      In the latter case, the next MIQ is served at steps 28,30,24, and so on until the queue of the least priority level is served at step 30.
      <br/>
      This is thus the end of the so-called scheduling cycle.
      <br/>
      Then, the scheduler returns back to the initialization at step 20, where the entire set of queues are initialized with the above mentioned set of parameters.
    </p>
    <p num="34">In this preferred implementation, the number of queues is 16, but one may use as many queues as are required by the specific implementation.</p>
    <p num="35">In case the critical phase is entered at step 25, meaning that the maximum aging of one or more queues is reached (the dormant time of the corresponding MIQ is above the maximum delay of that MIQ), the state of this normal state is stored for future come back and the MIQs in critical state are dequeued according to their corresponding critical weight Crit.Ni, at step 27.</p>
    <p num="36">
      The critical queues are dequeued one by one according to their Crit.Ni until the corresponding critical weights are reached, at steps 29,31.
      <br/>
      If other MIQs appear to be critical, they are served in the order of their critical priorities (or weights).
      <br/>
      If no critical MIQ is left, the scheduler exits from this critical state and loops back to the normal state that it previously quit at step 26.
      <br/>
      Then the normal state continues until the next critical state occurs.
    </p>
    <p num="37">FIG. 3 shows in detail a flow chart illustrating the method according to the present invention in normal state.</p>
    <p num="38">
      The scheduler and the hardware share the hardware service table (HDW_ST).
      <br/>
      This service table is a table of bits, each bit representing the status of a MIQ:
      <br/>
      each time a MIQ goes from empty to not empty, hardware circuit 16 or hardware circuit 18 sets the corresponding bit to 1 in the service table;
      <br/>
      each time a MIQ goes from not empty to empty, the hardware circuit which is in fact responsible for the message dequeue from the MIQ (on the scheduler request) resets the corresponding bit in the service table HDW_ST.
    </p>
    <p num="39">
      The scheduler maintains two other software service tables:
      <br/>
      a weight service table (WGH_ST), which indicates, for each priority x, if the MIQ is to be served or not.
      <br/>
      The corresponding bit is set to 1 at system start-up and after each scheduling cycle.
      <br/>
      The corresponding bit is set to 0 when Stat.Ni messages have been dequeued from MIQi (that is Cur.Ni is equal to 0); and
      <br/>
      an active service table (ACT_ST) which is the result of the `AND` operation between the HDW_ST and WGH_ST.
    </p>
    <p num="40">In the initialization step 100, the WGH_ST is set to all 1's, and for each MIQ the Cur.Ni is set to STAT.Ni.</p>
    <p num="41">
      After initialization 100, the scheduler enters its scheduling cycle.
      <br/>
      The first operation is to get the HDW_ST and the WGH_ST from the data store at steps 102,104.
      <br/>
      Then, the AND operation is performed between the two tables and the result is stored in the ACT table, at step 106.
      <br/>
      If the result is all 0's, which means that a scheduling cycle is completed, the initialization operations 110,112 mentioned above are performed and a new scheduling cycle starts.
    </p>
    <p num="42">
      Otherwise, the scheduler looks for the left most `1` in ACT_ST, at step 114, which corresponds to the highest priority MIQ to be dequeued now, for instance the position j. Then, the Cur.Nj is decreased, at step 116.
      <br/>
      If Cur.Nj is equal to 0, at step 118, which means that the allowed number of messages to be dequeued is reached for this MIQ, the corresponding bit in the WGH_ST is reset to 0, at step 124.
      <br/>
      And a new scheduling cycle is started at step 102.
      <br/>
      Otherwise, at step 120, the message is dequeued from MIQJ.
    </p>
    <p num="43">
      By referring to FIG. 3, the dormant time for MIQJ is reset, at step 121.
      <br/>
      And the corresponding task is dispatched to handle the just dequeued message at step 122.
    </p>
    <p num="44">
      The elapsed time is computed by subtracting from the current time the previously saved time corresponding to the last dequeued message, at step 130.
      <br/>
      Meanwhile, the current time is saved for the computation of the next elapsed time.
    </p>
    <p num="45">For each MIQ except MIQj, the dormant time is increased by the just computed elapsed time at step 132.</p>
    <p num="46">
      If none of the Dormant.i exceeds the Delay.maxi, the scheduler remains in the normal service mode and loops back to step 102.
      <br/>
      A new scheduling cycle is then started.
      <br/>
      Otherwise, the scheduler enters a critical service mode at step 140.
    </p>
    <p num="47">FIG. 4 shows in detail a flow chart illustrating the method according to the present invention in critical state.</p>
    <p num="48">During critical service mode, only queues having entered into critical state are processed.</p>
    <p num="49">The scheduler saves the normal state context that is WGH_ST and all the Cur.Ni, in order to return after processing this critical state.</p>
    <p num="50">
      A New WGH_ST is built by setting to 1 all positions of the MIQs in critical states, at step 146.
      <br/>
      At the same time, for all the queues in critical state, the current Ni are set to Crit.Ni at step 148.
    </p>
    <p num="51">
      Then, the next operation 150 is to get the HDW_ST and WGH_ST tables from the data store 102.
      <br/>
      The AND operation is performed between the two tables and the result is stored in the ACT table, at step 152.
      <br/>
      If the result is all 0's, at step 154, which means that the critical state has been completed, the normal state has to be recovered.
      <br/>
      The previously saved WGH_ST and the Cur.Ni are retrieved, at steps 156,158.
      <br/>
      The scheduler exits the critical state at step 160 and a new scheduling cycle starts in normal state, at step 102.
    </p>
    <p num="52">Otherwise, at step 114 the scheduler looks for the left most `1` in the ACT_ST table, which corresponds to the highest priority MIQ to be dequeued now, for instance the position j.</p>
    <p num="53">
      Then, the Cur.Nj is decreased at step 116.
      <br/>
      If the Cur.Nj is equal to 0 at step 118, which means that the allowed number of messages to be dequeued is reached for this MIQ, the corresponding bit in the WGH_ST table is reset to 0, at step 124.
      <br/>
      A new scheduling cycle in critical state is started and the scheduler loops back to step 150.
    </p>
    <p num="54">
      Otherwise, at step 120, the message is dequeued from the critical MIQj.
      <br/>
      Then, the dormant time for MIQj is reset at step 121.
      <br/>
      And the corresponding task is dispatched to handle the just dequeued message at step 122.
    </p>
    <p num="55">
      The elapsed time is computed by subtracting from the current time the previously saved time corresponding to the previously dequeued message at step 130.
      <br/>
      Meanwhile, the current time is saved for the computation of the next elapsed time.
    </p>
    <p num="56">
      For each MIQ except MIQj, the dormant time is increased by the just computed elapsed time at step 132.
      <br/>
      Then, at step 134, if none of the Dormant.i exceeds the Delay.maxi, which means that no new MIQ has entered in critical state, a new scheduling cycle in critical state is started and the scheduler loops to step 150.
    </p>
    <p num="57">Otherwise, which means that a new queue enters a critical state, a new WGH_ST is built by setting to 1 all positions of the MIQs in critical states by looping back to step 146.</p>
    <p num="58">
      FIGS. 5A and 5B illustrate the process of the invention in different steps of an example which is based on 6 MIQs associated with their corresponding sets of parameters.
      <br/>
      The status of HDW_ST, WGH_ST and ACT_ST tables are also shown.
    </p>
    <p num="59">
      Step 1: is the initialization state, where all the MIQs are empty.
      <br/>
      A set of initial weights are assigned to each MIQ.
      <br/>
      The current weights are equal to static ones.
      <br/>
      The status of the HDW_ST, WGH_ST and ACT_ST are also initialized.
    </p>
    <p num="60">
      Step 2: three messages have been queued by the circuit hardware 16 in MIQ (1) and two messages in MIQ (3).
      <br/>
      Thus the HDW_ST is updated by setting the first and third bits to 1, which modifies at the same time the value of the first and the third bits of the ACT_ST.
      <br/>
      The WGH_ST remains unchanged.
    </p>
    <p num="61">
      Step 3: the scheduler dequeues the first message from MIQ (1) because the ACT_ST has its first bit set to 1, meaning that the highest priority non-empty queue is to be dequeued.
      <br/>
      The current weight for MIQ (1), Cur.N1, is decremented, at the same time the dormant time, dorm.1, is reset while the dorm.3 time is increased by the elapsed time, which is in this example 1 unit.
    </p>
    <p num="62">
      Step 4: the scheduler dequeues the second message from MIQ (1) because ACT_ST has its first bit set to 1, meaning that the highest priority non-empty queue is still to be dequeued.
      <br/>
      The current weight for MIQ (1), Cur.N1, is decremented and reaches the value 0, then the first bit of WGH_ST is reset to 0.
      <br/>
      At the same time, the dormant time dorm.1 is reset while dorm.3 is increased by the elapsed time, which is in this example 1 unit.
      <br/>
      Thus, ACT_ST now has only the third bit set to 1.
    </p>
    <p num="63">
      Step 5: by reading the ACT_ST, the scheduler dequeues the first message from MIQ (3) because the ACT_ST has its third bit set to 1.
      <br/>
      The current weight for MIQ (3), Cur.N3, is decremented and reaches the value 0, then the third bit of WGH_ST is reset to 0.
      <br/>
      At the same time the dormant time dorm.3 is reset while the dorm.1 time is increased by the elapsed time, which is in this example 1unit.
      <br/>
      Meanwhile, three messages have been queued in the MIQ (4), which sets the fourth bit of HDW_ST to 1.
      <br/>
      Thus, ACT_ST now has only the fourth bit set to 1.
    </p>
    <p num="64">
      Step 6: by reading the ACT_ST, the scheduler dequeues the first message from MIQ (4) because the ACT_ST has its fourth bit set to 1.
      <br/>
      The current weight for MIQ (4), Cur.N4, is decremented.
      <br/>
      At the same time, the dormant time, dorm.4, is reset while the dorm.1 and dorm.3 times are increased by the elapsed time.
      <br/>
      Meanwhile, one message has been queued in the MIQ (1), the first bit of HDW_ST remains at 1 since previously there was one message left.
      <br/>
      Since the dorm.1 time has reached the maximum delay, this MIQ enters into critical state.
      <br/>
      It should be kept in mind that MIQ (1) as being on the left most side is the highest priority queue.
    </p>
    <p num="65">
      Step 7: is the initialization of the critical state.
      <br/>
      A set of initial critical weights is assigned to each critical MIQ, for instance MIQ (1).
      <br/>
      The current weights are equal to critical static ones.
      <br/>
      The status of the HDW_ST remains unchanged, but the status of WGH_ST is initialized based on the MIQs in critical state.
      <br/>
      ACT_ST is updated accordingly.
      <br/>
      During this step, the scheduler dequeues the first message from MIQ (1) because the ACT_ST has its first bit set to 1, meaning that the highest priority non-empty critical queue is to be dequeued.
      <br/>
      The current weight for MIQ (1), Cur.N1, is decremented, at the same time the dormant time, dorm.1, is reset while the dorm.3 and dorm.4 times are increased by the elapsed time, which is in this example 1 unit.
    </p>
    <p num="66">
      Step 8: the scheduler still dequeues the next message from MIQ (1) because the ACT_ST has its first bit set to 1.
      <br/>
      The current weight for MIQ (1), Cur.N1, is decremented, at the same time the dormant time, dorm.1, is reset while the dorm.3 and dorm.4 times are increased by the elapsed time.
      <br/>
      No more message are left in MIQ (1).
      <br/>
      Thus the first bit of HDW_ST is reset to 0.
      <br/>
      Since the dorm.3 time has reached the maximum delay, this MIQ enters in critical state.
      <br/>
      Thus the third bit of WGH_ST is set to 1, which modifies the third bit of ACT_ST while its first bit is reset.
    </p>
    <p num="67">
      Step 9: the scheduler still dequeues the next message from MIQ (3) because the ACT_ST has its third bit set to 1.
      <br/>
      The current weight for MIQ (3), Cur.N3, is decremented, the dorm.3 time is reset while dorm.4 time is increased by the elapsed time.
      <br/>
      No more messages are left in MIQ (3).
      <br/>
      Thus, the third bit of HDW_ST is reset to 0.
      <br/>
      Since ACT_ST has all its bits reset, the critical state ends.
      <br/>
      The scheduler returns to its previous normal state.
    </p>
    <p num="68">
      Step 10: The current weights are re-initialized to the values saved before entering the critical state.
      <br/>
      The status of the HDW_ST remains unchanged, but the status of WGH_ST is reinitialized to the values saved before entering the critical state.
      <br/>
      ACT_ST is updated accordingly, meaning that only the fourth bit is set to 1.
    </p>
    <p num="69">
      By reading ACT_ST, the scheduler dequeues the first message from MIQ (4) because the ACT_ST has its fourth bit set to 1.
      <br/>
      The current weight for MIQ (4), Cur.N4, is decremented.
      <br/>
      At the same time, the dormant time, dorm.4, is reset.
    </p>
    <p num="70">
      Step 11: By reading ACT_ST, the scheduler dequeues the next message from MIQ (4) because the ACT_ST still has its fourth bit set to 1.
      <br/>
      The current weight for MIQ (4), Cur.N4, is decremented.
      <br/>
      No message is left in MIQ (4) even though the current weight does not reach the value 0 yet.
      <br/>
      The fourth bit in the HDW_ST is reset.
      <br/>
      Thus, all its bits are reset to 0.
      <br/>
      Thus ACT_ST is reset accordingly to 0.
      <br/>
      The end of the scheduling cycle is reached even though WGH_ST does not have all of its bits reset.
      <br/>
      Henceforth, the next step of the process will be step 1.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for controlling data transfer between a host data processing system and a communication network by processing queued messages in a plurality of queues saved in a data store, said method comprising the steps of:</claim-text>
      <claim-text>(a) including in the data store a first service table (ACT_ST) containing a plurality of bits wherein each bit is associated with a corresponding queue so as to determine which queue has to be served, said first service table being stored before entering a critical state and updated according to the critical queues and being the result of an AND operation between two other service tables contained in the data store, specifically:</claim-text>
      <claim-text>- a second service table (HDW_ST) containing a plurality of bits, each bit corresponding to the status of a queue so as to determine if a new message has been enqueued in said queue;</claim-text>
      <claim-text>and - a third service table (WGH_ST) containing a plurality of bits, each bit associated with a corresponding queue so as to determine if said queue is to be served according to the associated predetermined number of allowed dequeue messages; (b) dequeueing, in a normal state, successively queued messages from a plurality of queues according to their associated queue priorities; (c) dequeueing in the normal state, in the order of queue priorities, queued messages from non-empty queues until their associated predetermined number of allowed dequeue messages are reached; (d) interrupting the normal state to enter a critical state, by dequeueing successively queued messages from a plurality of critical queues according to their associated queue priorities, said critical queues having their corresponding aging times exceed predetermined values; (e) dequeueing in the critical state, in the order of critical queue priorities, queued messages from non-empty critical queues until their associated predetermined critical number of allowed dequeue messages are reached;</claim-text>
      <claim-text>and (f) returning to the previous normal state with its set of parameters to continue until the next critical state occurs or until the end of scheduling cycle is reached.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1 wherein step (a) comprises the steps of: reading said service tables HDW_ST, WGH_ST and ACT_ST; selecting a left most `1` in said first service table to dequeue messages from the corresponding queue until the associated predetermined number of allowed dequeue messages is reached; computing the elapsed time since the previous processing of said selected queue in order to determine if its corresponding aging time exceeds a predetermined value;</claim-text>
      <claim-text>and dequeueing a next non-empty queue in the normal state according to its corresponding status bit in said first service table.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 1 wherein step (b) comprises the steps of: saving a current normal state set of parameters; setting in said third service table (WGH_ST) bits that correspond to queues in the critical state; computing bits in a first critical service table (ACT_ST) corresponding to said critical state; selecting a left most `1` in said first service table to dequeue message from the corresponding critical queue until the associated predetermined number of allowed dequeue messages is reached; computing the elapsed time since the previous processing of said selected queue in order to determine if its corresponding aging time exceeds a predetermined value;</claim-text>
      <claim-text>and dequeueing a next non-empty critical queue according to its corresponding status bit in said first service table (ACT_ST).</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A system for controlling data transfer between a host data processing system and a communication network by processing queued messages in a plurality of queues saved in a data store, said system comprising: a first service table (ACT_ST) saved in the data store and containing a plurality of bits wherein each bit is associated with a queue so as to determine which queue has to be served, said service table being stored before entering a critical state and updated according to the critical queues;</claim-text>
      <claim-text>said first service table (ACT_ST) being the result of an AND operation between two other service tables contained in the data store, specifically; - a second service table (HDW_ST) containing a plurality of bits, each bit corresponding to the status of a queue so as to determine if a new message has been enqueued in said queue;</claim-text>
      <claim-text>and - a third service table (WGH_ST) containing a plurality of bits, each bit associated with a corresponding queue so as to determine if said queue is to be served according to the associated predetermined number of allowed dequeue messages; a plurality of registers that are associated with each queue including: - a first register for a static weight corresponding to a number of messages which may be pulled out from said queue, said register being implemented in connection with a second register for a current weight corresponding to a number of messages allowed to be dequeued from said queue, for processing said queued messages in a normal state; - a third register for a maximum delay corresponding to a maximum waiting time of a non-empty queue to be dequeued, said register being implemented in connection with a fourth register for a dormant time corresponding to an elapsed time since said queue was last served, for processing queued messages in a critical state when the contents of said fourth register exceeds the contents of said third register;</claim-text>
      <claim-text>and - a fifth register processing queued message of a critical queue for critical weight corresponding to a number of messages allowed to be dequeued from said critical queue, in a critical state.</claim-text>
    </claim>
  </claims>
</questel-patent-document>