<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182238B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182238</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182238</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22145632" extended-family-id="42109104">
      <document-id>
        <country>US</country>
        <doc-number>09078690</doc-number>
        <kind>A</kind>
        <date>19980514</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09078690</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165768</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>7869098</doc-number>
        <kind>A</kind>
        <date>19980514</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09078690</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  11/00        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>00</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/48        20060101A N20080531RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>48</subgroup>
        <classification-value>N</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20080531</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>714002000</text>
        <class>714</class>
        <subclass>002000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>710266000</text>
        <class>710</class>
        <subclass>266000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>714038130</text>
        <class>714</class>
        <subclass>038130</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>714047200</text>
        <class>714</class>
        <subclass>047200</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>714E11003</text>
        <class>714</class>
        <subclass>E11003</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>718107000</text>
        <class>718</class>
        <subclass>107000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/48C4</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>48C4</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-011/07P2A1</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>011</main-group>
        <subgroup>07P2A1</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/4843</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>4843</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140120</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/0715</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>0715</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140117</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/0757</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>0757</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140120</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>27</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>4</number-of-drawing-sheets>
      <number-of-figures>6</number-of-figures>
      <image-key data-format="questel">US6182238</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Fault tolerant task dispatching</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>WHITESIDE ARLISS E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4356546</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4356546</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>RUBIN HARVEY</text>
          <document-id>
            <country>US</country>
            <doc-number>4628158</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4628158</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>NOVY ROBERT, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4894828</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4894828</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>HERBERMANN CARL R</text>
          <document-id>
            <country>US</country>
            <doc-number>5091847</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5091847</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>NEVITT CHRIS A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5581692</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5581692</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>HANF PETER, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5892893</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5892893</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>MINOWA TOSHIMICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6009370</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6009370</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>TOSHIBA CORP</text>
          <document-id>
            <country>JP</country>
            <doc-number>H0991170</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>JP09091170</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Intel Corporation</orgname>
            <address>
              <address-1>Santa Clara, CA, US</address-1>
              <city>Santa Clara</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>INTEL</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Cooper, Barnes</name>
            <address>
              <address-1>Beaverton, OR, US</address-1>
              <city>Beaverton</city>
              <state>OR</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Trop, Pruner &amp; Hu, P.C.</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Beausoliel, Jr., Robert W.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A fault tolerant task dispatching technique schedules a plurality of tasks, monitors the progress of each task on a periodic basis, detects when a task has failed, and initializes a failed task in a manner that does not interfere with the execution of any non-failed task.
      <br/>
      Task granularity, afforded by the fault tolerant dispatch technique, allows each task (device service routine) to be designed substantially independently of any other task.
      <br/>
      This, in turn, can ease the design and implementation of individual tasks as well as their integration into a computer system.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND</heading>
    <p num="1">The invention relates generally to a fault tolerant task dispatcher.</p>
    <p num="2">
      Embedded controllers are a general class of micro controllers used to support original equipment manufacturer (OEM) specific hardware and software.
      <br/>
      Typically used in mobile computing platforms (e.g., notebook computers), micro controllers process signals to and from a variety of OEM devices such as keyboards, pointing devices, and thermal management systems.
      <br/>
      Modem micro controllers are single chip computers that include a central processing unit, read only memory, random access memory, communication ports, digital-to-analog and analog-to-digital converters, and a relatively large number of input-output ports.
      <br/>
      One function of a microcontroller is to off-load the computational resources (e.g., processor time) used to service an OEM device (e.g., a keyboard) from a computer system's host processor.
      <br/>
      One way a microcontroller provides this capability is through the execution of a series of device service routines known as a tasks.
      <br/>
      As shown in Table ZZ, a microcontroller continually executes a single thread wherein a watchdog timer (coupled to generate a microcontroller hardware reset operation when it expires) is repeatably reset while waiting for a device service routine to indicate it has completed.
      <br/>
      This approach may detect a hardware fault (e.g., microcontroller failing to execute any instructions), but would not detect if a device service routine (or the device itself) has failed.
    </p>
    <heading>-- TABLE ZZ</heading>
    <p num="3">
      -- One Method of Processing Tasks
      <br/>
      --         Task_Code_Label:
      <br/>
      --               :
      <br/>
      --               Reload Watchdog Timer
      <br/>
      --               :
      <br/>
      --               Check for Event from device-N
      <br/>
      --               Loop at Task_Code_Label Until Event
    </p>
    <p num="4">
      Another way a microcontroller may off-load a host processor is shown in Table YY.
      <br/>
      In this approach, a multi-threaded environment allows a dispatcher thread and a task thread to execute separately from one another.
      <br/>
      The dispatcher thread schedules the execution of each device service routine in a round robin fashion, and is invoked every time a dispatch timer expires.
      <br/>
      When invoked, the dispatcher reloads a watchdog timer and then returns control to a specified task thread.
      <br/>
      The task thread loops waiting for its associated service routine to complete.
      <br/>
      As in the prior example, this approach would not detect if a device service routine (or the device itself) has failed.
    </p>
    <heading>-- TABLE YY</heading>
    <p num="5">
      -- Another Method of Processing Tasks
      <br/>
      --         Dispatcher:
      <br/>
      --               :
      <br/>
      --               Reload Watchdog Timer
      <br/>
      --               :
      <br/>
      --               Return to Task Execution
      <br/>
      --         Task_Code_Label
      <br/>
      --               :
      <br/>
      --               Check for Event from device-N
      <br/>
      --               Loop at Task_Code_Label Until Event
    </p>
    <p num="6">
      As evidenced by the preceding examples, a problem in many micro controllers is that if one task fails to terminate, the microcontroller becomes incapable of executing any further instructions (i.e., it is "hung").
      <br/>
      This type of failure can force an end-user to power cycle the entire computer system (of which the microcontroller is but one component) in order to place it back into an operational state.
      <br/>
      Accordingly, there is a need for a dispatcher routine that is tolerant of one or more faults.
    </p>
    <heading>SUMMARY</heading>
    <p num="7">
      In general, embodiments of the invention describe a microcontroller and method to dispatch tasks in a fault tolerant manner.
      <br/>
      One embodiment provides an interrupt service method that receives an interrupt, adjusts a plurality of timer values whose values are above a specified threshold (where each timer value is associated with one of a plurality of tasks), initializing a timer to generate the interrupt at a fixed time interval, and if a timer value associated with a task marked as executing is a specified value, then indicating that task as failed, else if a timer value associated with a task marked as executing is not the specified value, then resuming execution of the task marked as executing.
    </p>
    <p num="8">In another embodiment, a fault tolerant task dispatcher schedules a plurality of tasks for execution, monitors whether a task fails to complete execution, and initializes a task that is determined not to have completed execution within a specified time without interfering with the execution of another of said plurality of tasks.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="9">
      FIG. 1 shows an illustrative mobile computer system incorporating an embedded microcontroller in accordance with one embodiment of the invention.
      <br/>
      FIG. 2 shows an illustrative microcontroller for use in the computer system of FIG. 1.
      <br/>
      FIG. 3 shows a microcontroller initialization process in accordance with one embodiment of the invention.
      <br/>
      FIG. 4 shows one embodiment of FIG. 3's microcontroller read only and random access memories.
      <br/>
      FIG. 5 shows an illustrative microcontroller interrupt service routine.
      <br/>
      FIG. 6 shows an illustrative fault tolerant dispatcher process in accordance with the invention.
    </p>
    <heading>DETAILED DESCRIPTION</heading>
    <p num="10">The following embodiments are illustrative only and are not to be considered limiting in any respect.</p>
    <p num="11">
      Referring to FIG. 1, an illustrative mobile computer system 100 having a microcontroller ( MU C) 102 that uses an embodiment of fault tolerant dispatcher is shown.
      <br/>
      Computer system 100 includes host processor 104 and associated cache memory 106 coupled to system bus 108 through bridge circuit 110.
      <br/>
      Illustrative host processors 102 include the Pentium II.RTM. processor, the Pentium Pro.RTM. processor, the Pentium.RTM. processor, and the 80 * 86 families of processors from Intel Corporation.
      <br/>
      One illustrative bridge circuit 110 is the 82443LX PCI-to-AGP controller made by Intel Corporation.
    </p>
    <p num="12">
      Bridge circuit 110 provides an interface to couple system random access memory (RAM) 112 and accelerated graphics port (AGP) 114 devices.
      <br/>
      Also coupled to system bus 108 are video controller 116 and associated display unit 118, and one or more expansion slots 120.
      <br/>
      Expansion slots 120 may be personal computer memory card international association (PCMCIA) slots.
    </p>
    <p num="13">
      Bridge circuit 122 couples system bus 108 to secondary bus 124, while also providing integrated device electronics (IDE) 126 and universal serial bus (USB) 128 interfaces.
      <br/>
      Common IDE devices include magnetic and optical disk drives.
      <br/>
      Coupled to secondary bus 124 are microcontroller 102, input-output (I/O) circuit 130, keyboard controller (KYBD) 132, system read only memory (ROM) 134, and audio device 136.
      <br/>
      One illustrative bridge circuit 122 is the 82371AB PCI-to-ISA/IDE controller made by Intel Corporation.
      <br/>
      One illustrative microcontroller is the H8/3437 made by Hitachi corporation.
      <br/>
      Input-output circuit 130 may provide an interface for parallel 138 and serial 140 ports, floppy disks 142, and infrared ports 144.
    </p>
    <p num="14">
      Referring to FIG. 2, controller 102 includes read only memory (ROM) 200, random access memory (RAM) 202, dispatch timer 204, watchdog timer 206, and I/O ports 208 operatively connected to devices 210.
      <br/>
      Controller ROM 200 includes microcontroller firmware instructions, task initialization and service routines, dispatcher instructions, and some task data.
      <br/>
      Controller RAM 202 provides a limited amount of memory within which device service routines and fault tolerant dispatcher instructions are executed.
      <br/>
      RAM 202 may also provide storage for some operational parameters (see discussion below).
      <br/>
      Dispatch timer 204 is operatively coupled to generate a microcontroller interrupt when it expires (e.g., counts down to zero).
      <br/>
      The interrupt may be non-maskable or linked to dispatch timer 204 so that masking the interrupt would cause a controller reset operation.
      <br/>
      Watchdog timer 206 is operatively coupled to generate a microcontroller reset operation when it expires (e.g., counts down to zero).
      <br/>
      Input-output ports 208 provide an interface to connect the following devices (210): battery management; host interface; power plane management; docking station management; thermal management; peripheral control; keyboard controller communications; and system management bus (SMBus) controller.
    </p>
    <p num="15">
      Referring to FIG. 3, on computer system 100 power-up or reset, controller 102 self-initializes by executing firmware instructions from ROM 200 (300) and task data are initialized (302).
      <br/>
      One aspect of initializing task data includes establishing a callback timer value in controller RAM 202 for each task to be scheduled by the task dispatcher.
      <br/>
      Callback times specify the amount of time the dispatcher should wait between subsequent calls to a task's TaskCallBack function; that routine which is periodically invoked by the dispatcher to service the task's device (see discussion below).
      <br/>
      Another aspect of initializing task data includes establishing a set of task execution flags and a set of task status flags for each task to be scheduled by the task dispatcher.
      <br/>
      Task execution flags (one for each task) are set to indicate a TaskCallBack function is currently executing, and cleared to indicate a TaskCallBack function is not executing.
      <br/>
      Task status flags (one for each task) are set to indicate a task has failed, and cleared when a task is initialized.
      <br/>
      As shown in FIG. 4, task callback timer values 400 are loaded into controller RAM 202 from controller ROM 200.
      <br/>
      Also included in ROM 200 timer data 402 are execution time values for each task.
      <br/>
      Each execution time value represents the amount of time the dispatcher should allow the associated TaskCallBack function to execute before determining it has failed (see discussion below).
      <br/>
      A portion of controller RAM 202 is also allocated to store task execution flags 404 and task status flags 406.
    </p>
    <p num="16">
      Returning to FIG. 3, following data initialization each task is initialized by executing its associated TaskInit function (304).
      <br/>
      If any TaskInit function fails to complete execution within a specified time period (stored in controller ROM 200's timer data 402), the task's status flag 406 is set to indicate the task has failed.
    </p>
    <p num="17">
      Once task data and task routines have been initialized, dispatch timer 204 and watchdog timer 206 are loaded with preset values (306).
      <br/>
      In general, dispatch 204 and watchdog 206 timers are continually running timers that begin counting down after being set/reset.
      <br/>
      The dispatch timer's preset value is typically between approximately 1 and 10 milliseconds, for example 5 milliseconds.
      <br/>
      The watchdog timer's preset value is typically between approximately 100 and approximately 500 milliseconds, for example 128 milliseconds.
      <br/>
      As discussed above, when dispatch timer 204 expires (e.g., counts down to zero from its preset value), an interrupt is generated that causes controller 102 to invoke an interrupt service routine which, in turn, invokes a fault tolerant dispatcher (see discussion below).
      <br/>
      When watchdog timer 206 expires, microcontroller 102 is reset.
      <br/>
      Resetting microcontroller 102 may cause computer system 100 to reset.
    </p>
    <p num="18">
      When dispatch timer 204 expires (causing an interrupt) a high priority interrupt service routine is executed as shown in FIG. 5.
      <br/>
      First, timer values 402 are adjusted to account for the time elapsed since the last interrupt (500); timer values are held, for convenience, at zero to avoid negative values.
      <br/>
      Next, dispatch timer 204 and watchdog timer 206 are reinitialized (502).
      <br/>
      Task execution flags 404 are then checked to determine if a task is currently being executed.
      <br/>
      If a task is currently executing (the `yes` prong of 504), the timer value 400 associated with that task is checked to see if it is zero.
      <br/>
      If the executing task's timer value is zero (the `yes` prong of 506), the task's associated status flag 406 is set to indicate the task has failed (508).
      <br/>
      If the executing task's timer value is not zero (the `no` prong of 506), the interrupt service routine terminates and execution of the currently active task is resumed (510).
      <br/>
      If no task is currently executing (the `no` prong of 504), the fault tolerant task dispatcher is invoked (512).
    </p>
    <p num="19">
      Referring to FIG. 6, one embodiment of a fault tolerant dispatcher begins by determining if the currently executing task has failed.
      <br/>
      If the current task's status flag 406 indicates it has failed (the `yes` prong of 600), the task is reinitialized by invoking its TaskInit function (602), initializing the task's timer value 400 to its specified callback timer value (604), and marking the task as idle by clearing its execution flag 404 (606). (Marking may be done by having a flag value for each task scheduled by the task dispatcher.
      <br/>
      If the flag associated with a task is set, for example, the task is said to be marked.) Following 606, or if the currently executing task has not failed (the `no` prong of 600), a loop is entered during which it is determined if any task is ready for execution (608).
      <br/>
      Specifically, for each task whose timer value has reached zero (adjusted in 500 of FIG. 5), the task's timer value 400 is loaded with its associated execution timer value 402; its execution flag 404 is set to indicate it is currently executing; and its associated TaskCallBack function is executed.
      <br/>
      If no task timer is zero (the `yes` prong of 610), the dispatcher enters a low power or sleep state (steep 612).
      <br/>
      If all task timer values are non-zero (the `no` prong of 610), the dispatcher begins again from 600.
      <br/>
      A check for zero value timers is performed at 610 because in between performing 608 and 610, a dispatch timer 204 interrupt could have occurred invoking the interrupt service routine of FIG. 5.
      <br/>
      This, in turn, could result in one or more timers being adjusted to zero.
    </p>
    <p num="20">
      The combination of dispatch timer and watchdog timer provides controller 102 with the ability to detect both software faults (via dispatch timer 204) and hardware faults (via watchdog timer 206).
      <br/>
      If a device service routine (software) hangs, dispatch timer 204 may expire and cause an interrupt.
      <br/>
      Through this interrupt, the hung routine may be effectively bypassed.
      <br/>
      If controller hardware fails so that neither the interrupt service routine of FIG. 5 or the fault tolerant dispatcher of FIG. 6 may execute, watchdog timer 206 may expire causing microcontroller 102 to reset.
    </p>
    <p num="21">
      The combination of interrupt service routine (e.g., FIG. 5) and fault tolerant dispatcher (e.g., FIG. 6) provides a granularity of task scheduling that affords a level of fault tolerance (to device service routine failures) not available in prior dispatchers.
      <br/>
      For example, if controller 102 is responsible for N devices, each of the devices' N TaskCallBack functions may fail independently without affecting the controller's ability to manage the other devices.
      <br/>
      An added benefit of this task dispatch granularity is that each task (device service routine) may be designed (coded) substantially independently of any other tasks.
      <br/>
      This may ease the design and implementation of individual tasks as well as their integration into microcontroller 102 and computer system 100.
    </p>
    <p num="22">
      Various changes may be made in the foregoing illustrative embodiments without departing from the scope of the claims.
      <br/>
      For example, dispatch and watchdog timers could be incorporated within the microcontroller or be external to the microcontroller.
      <br/>
      The identity and number of tasks scheduled by the dispatcher can be less than, or more than the eight described.
      <br/>
      In addition, system bus 108 and secondary bus 124 may be proprietary or special purpose buses, peripheral component interface (PCI) buses, industry standard architecture (ISA) buses, extended industry standard architecture (EISA) buses, or combinations of one or more of these busses.
      <br/>
      The methods of FIGS. 5 and 6 may be performed by a computer processor executing instructions organized into program modules.
      <br/>
      Storage devices suitable for tangibly embodying computer program instructions include all forms of non-volatile memory including, but not limited to: semiconductor memory devices such as EPROM, EEPROM, and flash devices; magnetic disks (fixed and floppy); other magnetic media such as tape; and optical media such as CD-ROM disks.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A microcontroller for controlling a plurality of devices through device service routines, comprising:</claim-text>
      <claim-text>a dispatcher to schedule the plurality of device service routines for execution; a detector to detect when a device service routine fails to complete execution within a specified time period;</claim-text>
      <claim-text>and a circuit to terminate the failed device service routine and to dispatch another of the plurality of the device service routines.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The microcontroller of claim 1, wherein the specified time period is determined by a timer.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The microcontroller of claim 2, wherein the timer is configured to generate a periodic interrupt.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The microcontroller of claim 3, wherein the periodic interrupt is a non-maskable interrupt.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The microcontroller of claim 1, wherein the specified time period is between approximately 1 millisecond and approximately 10 milliseconds.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. An interrupt service method comprising: receiving an interrupt; adjusting a timer value, the timer value associated with a device service routine; initializing an interrupt timer to generate the interrupt at a fixed time interval; marking the device service routine as failed if the adjusted timer value is a specified value;</claim-text>
      <claim-text>and resuming execution of the device service routine if the adjusted timer value is not the specified value.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 6, wherein the interrupt is a non-maskable interrupt.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 6, wherein the fixed time interval is between approximately 1 millisecond and approximately 10 milliseconds.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 6, wherein the fixed time interval is 5 milliseconds.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The method of claim 6, wherein marking comprises setting a flag associated with the device service routine.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 6, wherein the specified value is less than or equal to zero.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 6, wherein adjusting comprises decrementing the timer value.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 6 wherein resuming execution further comprising entering a low power mode.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A fault tolerant task dispatching method comprising: identifying a current task from a plurality of tasks, each task associated with a timer value and information indicating whether the task is executing and whether the task is failed; initializing the current task if it is indicated as failed; identifying a next task;</claim-text>
      <claim-text>and scheduling the next task if the timer value associated with the next task is a specified value.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method of claim 14, wherein the specified value is less than or equal to zero.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 15, further comprising entering a low power mode if the timer values associated with each task is not the specified value.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method of claim 14, wherein initializing comprises: executing an initialization routine associated with the failed task; setting a timer value associated with the failed task;</claim-text>
      <claim-text>and indicating the failed task as idle.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method of claim 17, wherein the timer value is greater than zero.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method of claim 14, wherein scheduling comprises: executing a task initialization routine associated with the next task; setting a timer value associated with the next task; indicating the next task as executing;</claim-text>
      <claim-text>and executing a device service routine associated with the next task.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The method of claim 19, wherein the timer value is between approximately 1 millisecond and approximately 10 milliseconds.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. A program storage device, readable by a computer system, having instructions stored thereon for causing the computer system to: identify a current task from a plurality of tasks, each task associated with a timer value and information indicating whether the task is executing and whether the task is failed; initialize the current task if it is indicated as failed; identify a next task;</claim-text>
      <claim-text>and schedule the next task if the timer value associated with the next task is a specified value.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The program storage device of claim 21, wherein the specified value is less than or equal to zero.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The program storage device of claim 21, further comprising instructions to enter a low power mode if the timer values associated with each task is not the specified value.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The program storage device of claim 21, wherein the instructions to initialize include instructions to: execute an initialization routine associated with the failed task; set a timer value associated with the failed task;</claim-text>
      <claim-text>and indicate the failed task as idle.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The program storage device of claim 24, wherein the timer value is greater than zero.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The program storage device of claim 21, wherein instructions to schedule include instructions to: execute a task initialization routine associated with the next task; set a timer value associated with the next task; indicate the next task as executing;</claim-text>
      <claim-text>and execute a device service routine associated with the next task.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The program storage device of claim 26, wherein the timer value is between approximately 1 millisecond and approximately 10 milliseconds.</claim-text>
    </claim>
  </claims>
</questel-patent-document>