<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182086B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182086</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182086</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="21870818" extended-family-id="42108874">
      <document-id>
        <country>US</country>
        <doc-number>09033511</doc-number>
        <kind>A</kind>
        <date>19980302</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09033511</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43165453</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>3351198</doc-number>
        <kind>A</kind>
        <date>19980302</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09033511</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  11/14        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>14</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <further-classification sequence="1">
        <text>707999008</text>
        <class>707</class>
        <subclass>999008</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>707999202</text>
        <class>707</class>
        <subclass>999202</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>711161000</text>
        <class>711</class>
        <subclass>161000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>714016000</text>
        <class>714</class>
        <subclass>016000</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>714E11130</text>
        <class>714</class>
        <subclass>E11130</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>718101000</text>
        <class>718</class>
        <subclass>101000</subclass>
      </further-classification>
      <further-classification sequence="7">
        <text>719313000</text>
        <class>719</class>
        <subclass>313000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-011/1471</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>11</main-group>
        <subgroup>1471</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130823</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99938</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99938</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99953</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99953</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>74</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>7</number-of-drawing-sheets>
      <number-of-figures>8</number-of-figures>
      <image-key data-format="questel">US6182086</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Client-server computer system with application recovery of server applications and client applications</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>MOHAN CHANDRASEKARAN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5170480</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5170480</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>MOHAN CHANDRASEKARAN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5280611</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5280611</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>LOMET DAVID B</text>
          <document-id>
            <country>US</country>
            <doc-number>5287501</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5287501</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>KLEIN JOHANNES</text>
          <document-id>
            <country>US</country>
            <doc-number>5325528</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5325528</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>SPIRO PETER M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5369757</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5369757</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>LOMET DAVID B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5485608</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5485608</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>LOMET DAVID B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5524205</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5524205</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>HADERLE DONALD J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5581750</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5581750</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>RAZ YOAV</text>
          <document-id>
            <country>US</country>
            <doc-number>5701480</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5701480</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>LO SHUI WING, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5857207</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5857207</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="11">
          <text>LOMET DAVID B</text>
          <document-id>
            <country>US</country>
            <doc-number>5870763</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5870763</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="12">
          <text>LOMET DAVID B</text>
          <document-id>
            <country>US</country>
            <doc-number>5933838</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5933838</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="13">
          <text>LOMET DAVID B</text>
          <document-id>
            <country>US</country>
            <doc-number>5946698</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5946698</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="14">
          <text>LOMET DAVID B</text>
          <document-id>
            <country>US</country>
            <doc-number>6067550</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6067550</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Biliris, A. et al., "Transactions in the client-server EOS object store", Proceedings of the Eleventh International Conference on Data Engineering, 1995., Mar. 6-10, 1995, pp. 308-315.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Mohan, C. et al., "Aries/CSA: a method for database recovery in client-server architectures", Proceedings of the 1994 ACM SIGMOND International Conference on Management of Data and Symposium on Principles of Database Systems, May 24-27, 1994, pp. 55-66.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Schuldt, Heiko et al., "Concurrency control and recovery in transactional process management", Proceedings of the eighteenth ACM SIGMOND-SIGACT-SIGART Symposium on Principles of Database Systems, May 31 -Jun. 3, 1999, pp. 316-326.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="4">
          <text>Silva, L. M. et al., "On the optimum recovery of distributed programs", Proceedings of the 20th EUROMICRO Conference on System Architecture and Integration, Sep. 5-8, 1994, pp. 704-711.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="5">
          <text>Slye, J. H. et al., "Support for software interrupts in log-based rollback-recovery", IEEE Transaction on Computers, Oct. 1998, vol. 47, Issue: 10, pp. 1113-1123.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="6">
          <text>Stamos, J. W. et al., "A low-cost atomic commit protocol", Proceedings of the Ninth Symposium on Reliable Distributed Systems, 1990., Oct. 9-12, 1990, pp. 66-75.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="7">
          <text>Bahannon, Philip et al., "Distributed multi-level recovery in main-memory databases", Fourth International Conference on Parallel and Distributed Information Systems, 1996. Dec. 18-20, 1996, ISBN: 0-8186-7475-X, pp. 44-55.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="8">
          <text>Mohan, C. et al., "ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging," ACM Transactions on Database Systems, vol. 17, No. 1, Mar. 1992 pp. 94-162.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="9">
          <text>Lomet, "Persistent Application Using Generalized Redo Recovery", Microsoft Corporation, Redmond, Washington, Undated 23-27 Feb. 1998, pp. 154-163 Proceeding 14th International Conference on Data Engineering.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="10">
          <text>Strom et al., "Optimistic Recovery in Distributed Systems", ACM Transactions on Computer Systems, Vol. 3, No. 3 , Aug. 1985, pp.204-226.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="11">
          <text>Borg et al. "A Message System Supporting Fault Tolerance", Auragen Systems Corporation, 1983, pp. 90-99 Proceeding of the 9th ACM Symposium on Operating Systems Oct. 10-13 1983.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="12">
          <text>Borr, "Transaction Monitoring In Encompass [TM]: Reliable Distrubuted Transaction Processing", Tandem Computers Incorporated, Cupertino, CA, 1981 IEEE, pp. 155-165 Proceedings of the 7th International Conf. on VLDB, Sep. 9-11 1981.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="13">
          <text>Elnozaky et al., "Survey of Rollback-Recovery Protocols in Message-Passing Systems", Carnegie Mellon University, Pittsburgh, P.A. School of Computer Science, Report No. CMU-C3-99-145, Jun. 1999, pp. 1-46.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="14">
          <text>Johnson et al. "Sender-Based Message Logging", Department of Computer Science, Rice University, Houston, TX, FTCS 17: Digest of Papers. The Seventeenth International Symposium on Paula-Tolerant Computing (Cat No. 87CB2418-2) IEEE Comput. Soc. Press, Jul. 6-8 1987,xvi-311 pp..</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="15">
          <text>Alvisi et al., "Message LoggingPessimistic: Optimistic, Casual, and Optimal", IEEE Transaction On Software Engineering, Vol. 24, No. 2, Feb. 1998, pp. 149-159.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="16">
          <text>Bartlett, "A Non-Stop * Kernel" Tandem Computers, Inc., Cupertino, CA, Operating System Review, Vol. 15, No. 5, Dec. 1981, pp. 22-29.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="17">
          <text>Bernstein et al., "Implementing Recoverable Request Using Queues", Digital Equipment Corp., Proceedings of the 1990 SCM Signod International Conference on Management of Data and Symposium on Principles of Database Systems, May 23-26 1990, pp.112-122.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="18">
          <text>Borg et al., "Fault Tolerance Under UNIX", ACM Transaction on Computer Systems, Vol. 7, No. 1, Feb. 1989, pp.1-24.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="19">
          <text>Alvisi et al., "Message Logging Pessimistic, Optimistic, Casual, and Optimal", IEEE Transactions On Software Engineering, vol. 24, No. 2, Feb. 1998, pp. 149-159.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="20">
          <text>Bartlett, "A Non-Stop * Kernel" Tandem Cuter, Inc., Cupertino, CA, 1981, pp. 22-29.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="21">
          <text>Bernstein et al., "Implementing Recoverable Requests Using Queues", Digital Equipment Corp., 1990, pp. 112-122.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="22">
          <text>Borg et al, "A Message System Supporting Fault Tolerance", Auragen Systems Corporation, 1983, pp. 90-99, Proceedings of the 9th ACM Symposium on Operating Systems, 10-13 Oct. 1983.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="23">
          <text>Borg et al., "Fault Tolerance Under UNIX", ACM Transactions on Computer Systems, vol. 7, No. 1, Feb. 1989, pp. 1-24.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="24">
          <text>Borr, "Transaction Monitoring In Encompass [TM]: Reliable Distributed Transaction Processing", Tandem Computers Incorporated, Cupertino, CA, IEEE, pp. 155-165 Proceedings of the 7th International Conf. on VLDB, 9-11 Sept. 1981.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="25">
          <text>Elnozahy et al., "Survey of Rollback-Recovery Protocols in Message-Passing Systems", Undated, pp. 1-46.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="26">
          <text>Johnson et al., "Sender-Based Message Logging", Department of Computer Science, Rice University, Houston, TX, Undated.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="27">
          <text>Lomet, "Persistent Applications Using Generalized Redo Recovery", Microsoft Corporation, Redmond, Washington, Undated 23-27 Feb. 1998, pp. 154-163 Proceedings 14th International Conference on Data Engineering.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="28">
          <text>Strom et al., "Optimistic Recovery in Distributed Systems", ACM Transactions on Computer Systems vol. 3, No. 3, Aug. 1985, pp. 204-226.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Microsoft Corporation</orgname>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>MICROSOFT</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Lomet, David B.</name>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Weikum, Gerhard</name>
            <address>
              <address-1>Saarbruecken, DE</address-1>
              <city>Saarbruecken</city>
              <country>DE</country>
            </address>
          </addressbook>
          <nationality>
            <country>DE</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Lee &amp; Hayes, PLLC</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Alam, Hosain T.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A client-server computer system has one or more clients connected to one or more servers.
      <br/>
      During request/reply interactions, a client-side application sends a request for services (e.g., read a file, return some information, update a database record, process data, etc.) to the server.
      <br/>
      A server-side application request program processes the request, prepares a reply to the request, and returns the reply to the client-side application.
      <br/>
      The server runs a resource manager to log operations and data pages in a manner that enables application and database recovery.
      <br/>
      Among other tasks, the server's resource manager creates a stable log file that can be used to help recover the client-side application in the event of a system crash.
      <br/>
      To capture the client-server interaction, the server's resource manager records the reply in the log buffer and commits the reply record to the stable log before the reply is sent back to the client.
      <br/>
      This results in only one forced logging event for each request/reply exchange.
      <br/>
      The server further maintains an active application table and a message lookup table to speed recovery.
      <br/>
      The active application table lists all currently active applications running at the client and server to identify those applications that should be recovered.
      <br/>
      The message lookup table keeps copies of the logged replies that can be used during client recovery in place of the logged records to avoid searching the server's stable log file.
      <br/>
      The server further truncates parts of its stable log file when notified that reply log records are no longer needed by the client.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>TECHNICAL FIELD</heading>
    <p num="1">
      This invention relates to client-server computer systems.
      <br/>
      More particularly, this invention relates to methods for recovering from system crashes in a manner that ensures that the applications running on the clients and servers persist across the crash.
    </p>
    <heading>BACKGROUND</heading>
    <p num="2">
      Computer systems occasionally crash.
      <br/>
      A "system crash" is an event in which the computer quits operating the way it is supposed to operate.
      <br/>
      Common causes of system crashes include power outage, application operating error, and computer goblins (i.e., unknown and often unexplained malfunctions that tend to plague even the best-devised systems and applications).
      <br/>
      System crashes are unpredictable, and hence, essentially impossible to anticipate and prevent.
    </p>
    <p num="3">
      A system crash is at the very least annoying, and may result in serious or irreparable damage.
      <br/>
      For standalone computers or client workstations, a local system crash typically results in loss of work product since the last save interval.
      <br/>
      The user is inconvenienced by having to reboot the computer and redo the lost i1 work.
      <br/>
      For servers and larger computer systems, a system crash can have a devastating impact on many users, including both company employees as well as its customers.
    </p>
    <p num="4">
      Being unable to prevent system crashes, computer system designers attempt to limit the effect of system crashes.
      <br/>
      The field of study concerning how computers recover from system crashes is known as "recovery." Recovery from system crashes has been the subject of much research and development.
    </p>
    <p num="5">
      In general, the goal of redo recovery is to return the computer system after a crash to a previous and presumed correct state in which the computer system was operating immediately prior to the crash.
      <br/>
      Then, transactions whose continuations are impossible can be aborted.
      <br/>
      Much of the recovery research focuses on database recovery for database computer systems, such as network database servers or mainframe database systems.
      <br/>
      Imagine the problems caused when a large database system having many clients crashes in the midst of many simultaneous operations involving the retrieval, update, and storage of data records.
      <br/>
      Database system designers attempt to design the database recovery techniques which minimize the amount of data lost in a system crash, minimize the amount of work needed following the crash to recover to the pre-crash operating state, and minimize the performance impact of recovery on the database system during normal operation.
    </p>
    <p num="6">
      FIG. 1 shows a database computer system 20 having a computing unit 22 with processing and computational capabilities 24 and a volatile main memory 26.
      <br/>
      The volatile main memory 26 is not persistent across crashes and hence is presumed to lose all of its data in the event of a crash.
      <br/>
      The computer system also has a non-volatile or stable database 28 and a stable log 30, both of which are contained on stable memory devices, e.g. magnetic disks, tapes, etc., connected to the computing unit 22.
      <br/>
      The stable database 28 and log 30 are presumed to persist across a system crash.
      <br/>
      The persistent database 28 and log 30 can be combined in the same storage, although they are illustrated separately for discussion purposes.
    </p>
    <p num="7">
      The volatile memory 26 stores one or more applications 32 and a resource manager 34.
      <br/>
      The resource manager 34 includes a volatile cache 36, which temporarily stores data destined for the stable database 28.
      <br/>
      The data is typically stored in the stable database and volatile cache in individual units, such as A cache manager 38 executes on the processor 24 to manage movement of data pages between the volatile cache 36 and the stable database 28.
      <br/>
      In particular, the cache manager 38 is responsible for deciding which data pages should be moved to the stable database 28 and when the data pages are moved.
      <br/>
      Data pages that are moved from the cache to the stable database are said to be "flushed" to the stable state.
      <br/>
      In other words, the cache manager 38 periodically flushes the cached state of a data page to the stable database 28 to produce a stable state of that data page which persists in the event of a crash, making recovery possible.
    </p>
    <p num="8">
      The resource manager 34 also has a volatile log 40 that temporarily stores log records for operations, which are to be moved into the stable log 30.
      <br/>
      A log manager 42 executes on the processor 24 to manage when the operations are moved from the volatile log 40 to the stable log 30.
      <br/>
      The transfer of an operation from the volatile log to the stable log is known as a log flush.
    </p>
    <p num="9">
      During normal operation, an application 32 executes on the processor 24.
      <br/>
      The resource manager receives requests to perform operations on data from the application.
      <br/>
      As a result, data pages are transferred to the volatile cache 36 on demand from the stable database 28 for use by the application.
      <br/>
      During execution, the resource manager 34 reads, processes, and writes data to and from the volatile cache 36 on behalf of the application.
      <br/>
      The cache manager 38 determines, independently of the application, when the cached Data State is flushed to the stable database 28.
    </p>
    <p num="10">
      Concurrently, the operations being performed by the resource manager on behalf of the application are being recorded in the volatile log 40.
      <br/>
      The log manager 42 determines, as guided by the cache manager and the transactional requirements imposed by the application, when the operations are posted as log records on the stable log 30.
      <br/>
      A logged operation is said to be "installed" when the versions of the pages containing the changes made by the operation have been flushed to the stable database.
    </p>
    <p num="11">
      When a crash occurs, the application state (i.e., address space) of any executing application 32, the data pages in volatile cache 36, and the operations in volatile log 40 all vanish.
      <br/>
      The computer system 20 invokes a recovery manager.
      <br/>
      It begins at the last flushed state on the stable database 28 and replays the operations posted to the stable log 30 to restore the database of the computer system to the state as of the last stably logged operation just prior to the crash.
    </p>
    <p num="12">
      While database recovery techniques are helpful for recovering data, the database techniques offer no help in recovering an application from a system crash.
      <br/>
      Usually all active applications using the database are wiped out during a crash.
      <br/>
      Any state in an executing application is erased and cannot usually be continued across a crash.
    </p>
    <p num="13">
      There has been some work in designing recovery procedures that preserve applications across a system crash.
      <br/>
      One preferred approach is an application recovery system developed by David Lomet, an inventor in this invention.
      <br/>
      The application recovery system is described in a series of patent applications:
    </p>
    <p num="14">
      1. U.S. Ser. No. 08/814,808, entitled "Database Computer System With Application Recovery", filed Mar. 10, 1997;
      <br/>
      2. U.S. Ser. No. 08/813,982, entitled "Database Computer System With Application Recovery And Dependency Handling Read Cache", filed Mar. 10, 1997;
      <br/>
      3. U.S. Ser. No. 08/832,870, entitled "Database Computer System With Application Recovery And Dependency Handling Write Cache", filed Apr. 4, 1997; and
      <br/>
      4. U.S. Ser. No. 08,826,610, entitled "Database Computer System With Application Recovery And Recovery Log Sequence Numbers To Optimize Recovery", filed Apr. 4, 1997.
    </p>
    <p num="15">
      All of these patent applications are assigned to Microsoft Corporation and are incorporated by reference.
      <br/>
      These applications are collectively referred to as the "Lomet applications" throughout this disclosure.
    </p>
    <p num="16">
      Another approach is to make the application "stateless." Between transactions, the application is in its initial state or a state internally derived from the initial state without reference to the persistent state of the database or to other input.
      <br/>
      If the application fails between transactions, there is nothing about the application state that cannot be re-created based on the static state of the stored form of the application.
      <br/>
      Should the transaction abort, the application is replayed, thereby re-executing the transaction as if the transaction executed somewhat later.
      <br/>
      After the transaction commits, the application returns to the initial state.
      <br/>
      Gray and Reuter describe this form of transaction processing in a book entitled, Transaction Processing: Concepts and Techniques, Morgan Kaufmann (1993), San Mateo, Calif.
    </p>
    <p num="17">
      Another approach is to write persistent application checkpoints at every resource manager interaction.
      <br/>
      The notion here is that application states in between resource manager interactions can be re-created from the last such interaction forward.
      <br/>
      This is the technique described by Bartlett, "A NonStop Kernel," Proc.
      <br/>
      ACM Symp. on Operating System Principles (1981) pages 22-29 Borg et al. "A Message System Supporting Fault Tolerance," Proc.
      <br/>
      ACM Symp. on Operating System Principles (Oct. 1983) Bretton Woods, NH pages 90-99.
    </p>
    <p num="18">
      The above application recovery techniques are all restricted to recovery local to or under the control of a single recoverable resource manager (database computer system).
      <br/>
      In the client-server context, however, these recovery techniques are difficult to apply to client-side applications that are interacting with the server.
    </p>
    <p num="19">
      Prior work on application fault-tolerance in distributed systems is based on some form of application "installation points" and/or "message logging".
      <br/>
      The prior work can be categorized into the following three approaches, all of which incur high normal operation and/or recovery costs.
    </p>
    <p num="20">
      1. Fault-tolerant Process Pairs: This approach has aimed to build fault tolerance into the operating system by providing each critical process with a hot-standby backup process, usually on a different processor.
      <br/>
      When the primary process fails, the backup process takes over and re-executes the application starting from the most recent installation point that has been generated by the primary process.
      <br/>
      Messages that would be repeated, especially output to the human user, are suppressed during the re-executed path, based on testing sequence numbers against logged messages.
      <br/>
      While this approach was a pioneering one in the early eighties, it is a heavyweight solution that can be justified only for the most mission-critical high-end applications.
      <br/>
      The reason for this is that the method requires either an application installation point or a forced message log record at every process interaction.
      <br/>
      The frequently required disk I/O greatly limits the achievable throughput of both the server and the clients.
      <br/>
      This approach is described in the above cited Bartlett and Borg papers, as well as by Borr, "Transaction Monitoring in Encompass: Reliable Distributed Transaction Processing," VLDB Conference, Cannes (1981) and by Kim, "Highly Available Systems for Database Applications," ACM Computing Surveys, Vol. 16, No. 1 (1984), pp. 71-98.
    </p>
    <p num="21">
      2. Distributed State Tracking: This approach is based on a model of communicating processes.
      <br/>
      Processes generate installation points only occasionally and independently of each other.
      <br/>
      In addition, messages are logged in an optimistic, non-forced manner.
      <br/>
      When a process fails, it restarts from its most recent installation point, but other processes may also be forced to restart from a former state to guarantee a causally consistent global state.
      <br/>
      Thus, this line of methods incurs recovery dependencies among the various processes that would be unacceptable for a database server.
      <br/>
      Furthermore, the eventually restored global state is not necessarily the most recent, externally observed state.
      <br/>
      This is tolerable when restarting long-running distributed "number-crunching"-style computations, an initial target of this work, but would not mask all application failures from the human user (unless more stringent, forced logging were employed).
      <br/>
      It is exactly for this reason that this algorithmically deep work has had very little impact on real systems.
    </p>
    <p num="22">
      A variation of message logging that eliminates recovery dependencies is pessimistic message logging.
      <br/>
      Unfortunately, this approach is very conservative and thus expensive in that it forces every log record to disk immediately.
      <br/>
      In general, most of the research in this category ignored both the necessity to minimize logging I/O costs and the importance of log truncation for fast restart.
      <br/>
      Rather, it overemphasized communication costs, which is less of an issue with modem networks.
    </p>
    <p num="23">
      3. Persistent Queues: The third line of solutions restricts all interactions between processes to be via persistent queues.
      <br/>
      Here, when a process sends a message to another process, the sender explicitly enqueues the message to a persistent queue.
      <br/>
      This takes place within the boundaries of a distributed transaction involving the queue and the sender; so it incurs the high forced logging I/O costs of a two-phase commit protocol.
      <br/>
      Moreover, the same protocol is used when the receiver dequeues the message.
      <br/>
      This solution has been very successful in the context of transaction-structured applications such as reservation systems (including "pseudo-conversational" applications), and is even suitable for heterogeneous platforms.
      <br/>
      However, its disk I/O costs are very high, and applications must be decomposed completely into sequences of transactions with no application state outside of the queued messages.
    </p>
    <p num="24">
      Despite these efforts, there remains a need to improve application recovery techniques in client-server systems.
      <br/>
      Particularly, there is a need to attain reliable recovery, while minimizing the logging costs and enabling fast restart.
      <br/>
      The inventors have developed such application recovery techniques for client-server systems.
    </p>
    <heading>SUMMARY</heading>
    <p num="25">
      This invention concerns a client-server computer system having one or more clients connected to one or more servers, and techniques for capturing client-server interactions to enable recovery of client-side applications following system crashes.
      <br/>
      Both the server and the client have a volatile main memory with a log buffer, a non-volatile memory with a stable log, and a processing unit.
      <br/>
      Both the client and server have their own independent recovery systems which adequately recover database records and application states for applications that do not involve client-server interactions.
    </p>
    <p num="26">
      In addition to standalone applications, however, the server and client execute one or more client-server applications that are capable of interfacing with one another through normal client-server communications.
      <br/>
      During a common interaction, the client-side application sends a request for services (e.g., read a file, return some information, process data, etc.) to the server.
      <br/>
      The server-side application processes the request, prepares a reply to the request, and returns the reply to the client-side application.
      <br/>
      Each request is self-contained in that everything needed for the request execution is contained within the request.
    </p>
    <p num="27">
      The server runs a resource manager to log operations and manage data pages in a manner that enables application and database recovery.
      <br/>
      Among other tasks, the server's resource manager creates a stable log file that can be used to help recover the client-side application in the event of a system crash.
      <br/>
      To capture the client-server interaction, the server's resource manager records the reply in the log buffer and commits the reply record to the stable log prior to sending the reply back to the client.
    </p>
    <p num="28">
      If the client subsequently crashes, the client will attempt to restart the client-side application using its stable log file during recovery.
      <br/>
      Since the client-side application is assumed to be piecewise deterministic, the client regenerates requests from the logged operations, and resubmits the requests to the server during replay.
      <br/>
      Upon receiving a request, the server recovers the corresponding reply from the server's stable log file and returns the reply.
      <br/>
      Through this replayed interaction, the client is able to recover to the application state just prior to crash, without itself having logged the replies returned from the server.
    </p>
    <p num="29">
      A benefit of the recovery scheme is that it adequately captures the entire client-server exchange with only one forced logging event for each request/reply exchange.
      <br/>
      This is a significant improvement over past message passage recovery techniques.
      <br/>
      The server does not log the request received from the client.
      <br/>
      Moreover, the client does not need to forcibly log its request or the reply from the server, although the client may from time to time "lazily" log the replies in its stable log.
    </p>
    <p num="30">
      To speed recovery, an aspect of this invention involves maintaining an active application table and a message lookup table at the server (and corresponding instances at the client).
      <br/>
      The active application table lists all currently active applications running at the client and server.
      <br/>
      This table is used during recovery to identify those applications that should be recovered.
    </p>
    <p num="31">
      The message lookup table keeps a copy of the logged replies.
      <br/>
      When the client is replaying its log file during recovery and re-submits requests to the server, the server first checks the message lookup table to determine whether the request can be satisfied by a specific log record therein.
      <br/>
      The table helps avoid sequentially searching through the server's stable log file record after record.
      <br/>
      If one or more reply log records become too large, the message lookup table may contain pointers to a separate table on the stable log into which larger active replies can be kept.
    </p>
    <p num="32">
      The server continuously truncates obsolete parts of its stable log file and message lookup table.
      <br/>
      The server has no direct information about when it can safely discard log records pertaining to the client reply messages and truncate its log file.
      <br/>
      Thus, the server relies on stability notifications from the client to inform the server when certain log records are no longer needed.
      <br/>
      The client sends a stability notification on one of two conditions: (1) the client installs application state of the client-side application or (2) the client writes reply log records to the client's stable log file.
      <br/>
      When such a notification is received, the server can remove the corresponding reply from the stable log file and from the message lookup table.
    </p>
    <p num="33">
      When the client-side application completes, the client informs the server using a special notice of termination.
      <br/>
      In response, the server removes the application from its active application table and all corresponding replies from the message lookup table and stable log file.
      <br/>
      The server also forces a log record to the stable log file indicating application termination.
    </p>
    <p num="34">
      One benefit resulting from this client-server recovery scheme is that server recovery is not dependent on the client.
      <br/>
      The server can recover completely without any dependency on the client.
      <br/>
      However, the client is dependent on the server for full recovery.
      <br/>
      This is an acceptable design constraint since the server is considered to be more stable and reliable than the client.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="35">
      FIG. 1 is a block diagram of a conventional database computer system.
      <br/>
      FIG. 2 shows a client-server system that implements a client application recovery scheme.
      <br/>
      FIG. 3 is a process diagram showing process steps taken at the client and server to log client interactions with the server.
      <br/>
      FIG. 4 is a block diagram of a database server used in the client-server system of FIG. 2.
      <br/>
      FIG. 5 is a block diagram of a client used in the client-server system of FIG. 2.
      <br/>
      FIG. 6 shows data structures maintained at the client and server to track messages exchanged between them, and a portion of stable log file maintained at the server.
      <br/>
      FIG. 7 is a process diagram showing similar to FIG. 3, but further shows process steps to inform the server that log records of certain client replies are no longer necessary.
      <br/>
      FIG. 8 is a process diagram showing similar to FIG. 3, but further shows process steps to inform the server that the client application has completed and hence log records of client replies for that application are no longer necessary.
    </p>
    <heading>DETAILED DESCRIPTION</heading>
    <p num="36">
      This invention concerns a client-server application recovery scheme that renders client application programs persistent across system crashes in a client-server system.
      <br/>
      In general, the server force logs replies sent back to clients in response to client requests as a means for providing a persistent log against which an application state of a client application can be replayed to enable recovery.
      <br/>
      According to this scheme, the application recovery scheme allows server recovery independent of client recovery, while client recovery is dependent on the server.
    </p>
    <p num="37">
      FIG. 2 shows a client-server system 50 having a client computer 52 connected to a server computer 54 via a network 56 (e.g., LAN, WAN, Internet, etc.).
      <br/>
      The client 52 is illustrated as a desktop personal computer, but can be implemented in other forms, such as a laptop, a workstation, and so forth.
      <br/>
      The client 52 runs one or more applications.
      <br/>
      The client maintains a recovery log that logs user interactions, enabling the client to capture essentially all of the user inputs.
      <br/>
      The client is not, however, responsible for logging interactions with the server; rather, this task is assigned to the server as is described below in more detail.
    </p>
    <p num="38">
      The server 54 is illustrated as a server-enabled personal computer, such as a computer configured to run the Windows NT operating system from Microsoft Corporation.
      <br/>
      However, the server 54 may further be implemented in other forms, such as a UNIX-based server, a minicomputer, or a mainframe.
      <br/>
      The server is presumed to be servicing more than one client, although only one client is shown for discussion purposes.
    </p>
    <p num="39">
      The client 52 and server 54 are each assumed to have their own independent recovery systems.
      <br/>
      In the event of a failure, both the client and/or server can independently recover data records and application states of independently running applications using conventional techniques and those described in the incorporated Lomet applications described in the Background section.
      <br/>
      However, these recovery techniques do not account for applications dependent on client-server interactions.
      <br/>
      Parts of the client applications may not be fully recoverable without taking into consideration the client's interactions with the server.
    </p>
    <p num="40">
      Accordingly, this invention is directed to a recovery system for client-server applications that takes into account client-server interactions.
      <br/>
      In FIG. 2, the client 52 communicates with the server 54 in conventional fashion.
      <br/>
      Typically, the client submits requests asking the server to perform some task, such as retrieve a file, or return information, or process some data, or the like.
      <br/>
      Upon completion of the task, the server sends a reply to the client
    </p>
    <p num="41">
      An aspect of this invention is to log client-server interactions in a meaningful way so that applications executing on the client can persist through a client crash and/or a server crash.
      <br/>
      In particular, the server logs the reply prior to transmitting the reply back to the client.
    </p>
    <p num="42">
      FIG. 3 shows process steps performed by the client and server during an interaction.
      <br/>
      At step 60, the client sends a request to the server.
      <br/>
      The server processes the request and prepares a reply (step 62).
      <br/>
      At step 64, the server logs the reply on the stable log.
      <br/>
      It does this by flushing the database log buffer to the stable log, including the write log records of the corresponding request-reply pair, with the reply log record being the last log record written.
      <br/>
      The server then sends the reply across the network (step 66) and the client processes the reply (step 68).
    </p>
    <p num="43">
      In this process, the server only logs the reply at a time just prior to sending the reply back to the client.
      <br/>
      This log operation is preferably a forced log operation, meaning that the server commits the reply to the stable log at the time it sends the reply back to the client, and does not wait to commit it at a later time.
    </p>
    <p num="44">
      In fact, the logging of the reply is the only forced log action per request/reply interaction.
      <br/>
      The server does not log the request received from the client.
      <br/>
      Moreover, the client does not log its request or force log the reply from the server.
      <br/>
      The reasons are twofold.
      <br/>
      First, if the client sends a request and subsequently crashes before receiving the reply, the server processes the request and logs the reply.
      <br/>
      During client's normal recovery process, the client will regenerate and resubmit the same request during its replay.
      <br/>
      The client application is assumed to be piecewise deterministic, meaning that the code will execute, given the same inputs, in exactly the same manner to produce the same results each time it is run.
      <br/>
      Thus, the same request will be generated during the client application replay.
      <br/>
      With the client regenerating the original request and the server logging the original response, the process of only logging replies at the server successfully enables recovery of the entire request/reply interaction for client application recovery.
    </p>
    <p num="45">
      Second, if the server fails after receiving the request and before transmitting a reply, the recovery scheme treats the request as a non-event that is not recovered by the server.
      <br/>
      Although the client could log the request and the server could then ask the client to resend the request during the server's recovery, this would make the server's recovery dependent on the client.
      <br/>
      Instead, the application recovery scheme is intentionally designed so that the server is not reliant on the client for recovery.
      <br/>
      Thus, the application recovery scheme inherently avoids logging client requests.
    </p>
    <p num="46">
      As a result, the application recovery scheme of this invention reduces the number of forced log writes per request/reply interaction to one.
      <br/>
      This significantly improves logging efficiency.
      <br/>
      In contrast, conventional message passage systems require more forced logs, with the standard process requiring at least the force logging of both the request and the reply at either the client or server side.
    </p>
    <p num="47">
      There is one assumption, however, that enables the application recovery scheme to achieve this optimal efficiency.
      <br/>
      This assumption is that the client application is synchronous and hence idle between the time it submits a request and the time it receives a reply.
      <br/>
      This is illustrated in FIG. 3 by the "Idle" condition between the request step 60 and the process reply step 68.
    </p>
    <p num="48">
      It is noted that the application recovery scheme also supports client applications that make asynchronous requests to the server and then subsequently issue "wait's" for the replies.
      <br/>
      Asynchronous applications do, however, introduce some complications.
      <br/>
      If the client application waits for replies from the server in a different order than it made the requests, then the order in which the replies are consumed at the server is no longer monotonically increasing in terms of the message sequence number (MSN).
      <br/>
      Hence, rather than rely on the garbage collection process which makes use of the MSN, the server would need to explicitly track each message that is no longer needed.
    </p>
    <p num="49">
      Additionally, with more than one request open at a time, it is possible for the server when executing the requests to reverse the serialization order of the requests--such that a later request serializes before an earlier one.
      <br/>
      This leads to unpredictable results, which are usually not the intended ones.
      <br/>
      The server guards against the serialization reversal by actually executing the requests serially (so that io the asynchrony only applies to the client's execution, not to the order of processing its requests).
      <br/>
      Alternatively, the client application could be required to only have outstanding requests that are independent of each other (and hence have no order dependencies).
    </p>
    <p num="50">
      FIGS. 4 and 5 show the client and server in more detail.
      <br/>
      FIG. 4 shows the server 54 implemented as a database server system.
      <br/>
      It has a computing unit 72, with a processing unit 74 and a volatile main memory 76.
      <br/>
      The volatile main memory 76 is not persistent across system crashes.
      <br/>
      It is presumed to lose all data that it presently stores when a crash occurs.
      <br/>
      Main memory 76 can be implemented, for example, as volatile RAM.
      <br/>
      The server system 54 also includes a non-volatile memory 78 interfaced with the computer unit 72.
      <br/>
      The persistent memory 78 is presumed to persist across a system crash.
      <br/>
      Examples of persistent memory 78 include disk arrays, disk drives (e.g., hard and floppy), read/write CD ROMS, tape backups, reel-to-reel, and the like.
    </p>
    <p num="51">
      The database server system 54 is shown in an operational state in which one or more client-server application requests 80 are loaded in main memory 76 for execution on the processing unit 74.
      <br/>
      The application request programs 80 are permanently stored on non-volatile memory (such as the persistent memory 78) and loaded into the main memory 76 when a client requests its execution.
    </p>
    <p num="52">
      The main memory 76 further includes a resource manager 82 that maintains temporary copies of data pages and application states.
      <br/>
      The resource manager is responsible for managing when to flush data objects and application request objects, and hence when to install operations into the persistent memory 78.
      <br/>
      The resource manager is also responsible for posting operations from the volatile log to the stable log.
      <br/>
      This must be done before the results of an operation are installed in the stable state, thus enforcing a write-ahead log protocol.
      <br/>
      The resource manager 82 is callable by the application programs 80.
    </p>
    <p num="53">
      The resource manager 82 includes a volatile cache 84, a cache manager 86, a volatile log 88, a log manager 90, and a recovery manager 92.
      <br/>
      The volatile cache 84 contains cached states of any executing application 80 and the data pages retrieved from the persistent memory 78.
      <br/>
      The volatile log 88 tracks the operations performed by the server system.
    </p>
    <p num="54">
      The non-volatile memory 78 includes a stable database 94 and a stable log 96.
      <br/>
      The stable database 94 maintains stable versions of the application states (including address spaces) and data objects, and the stable log 96 maintains a sequence of logged operations.
      <br/>
      The database 94 and log 96 are shown separately, but can be implemented in the same storage subsystem.
    </p>
    <p num="55">
      The cache manager 86 manages the volatile cache 84 and is responsible for retrieving data records from the stable database 94 and periodically flushing modified data records back to the stable database 94.
      <br/>
      Additionally, the cache manager 86 manages when to flush cached objects, which may include the application state as an object to be updated in the stable database 94.
      <br/>
      The log manager 90 manages the volatile log 88 and facilitates posting operations from volatile log 88 onto the stable log 96.
    </p>
    <p num="56">
      The resource manager 82 also maintains two additional data structures: an active application table 98 and a message lookup table 100.
      <br/>
      The active application table (AAT) 98 contains status information about ongoing applications (and possibly failed or restarting applications) for which the server or the client is responsible.
      <br/>
      This table is used during recovery to identify those applications that should be recovered.
    </p>
    <p num="57">
      The message lookup table (MLT) 100 contains log records of active reply messages to active applications.
      <br/>
      Active reply messages are those that the client may still need for recovery purposes in the event of a client crash.
      <br/>
      The message lookup table 100 is used to speed recovery of a client.
      <br/>
      When a client is replaying its log file and re-submits requests to the server, the server first checks the message lookup table 100 to determine whether the request can be satisfied by a specific log record therein.
      <br/>
      The table helps avoid sequentially searching through the stable log file record after record.
      <br/>
      If one or more reply log records become too large, the table 100 may contain pointers to a separate table on the stable log or elsewhere in non-volatile memory into which larger active replies can be kept.
    </p>
    <p num="58">
      The tables 98 and 100 are implemented as data structures, which generally reside in the volatile main memory 76.
      <br/>
      The table contents are recoverable from the operations and messages already logged, and the log can be checkpointed by occasionally writing their contents to non-volatile storage.
    </p>
    <p num="59">
      The server 54 tracks active applications that it is servicing (or those for which its clients are responsible) in the active application table 98.
      <br/>
      An application remains listed in the table 98 until the application terminates, or (optionally) is timed out after a predetermined length of time.
      <br/>
      The active application table 98 is useful for determining which applications need to be recovered after a system failure.
      <br/>
      Only active applications listed on the table 98 are recovered.
      <br/>
      Applications not listed in the table need not be recovered.
    </p>
    <p num="60">
      FIG. 5 shows the client 52 in more detail.
      <br/>
      It has a computing unit 102 with a processing unit 104 and a volatile main memory 106.
      <br/>
      It also has a non-volatile memory 108 (e.g., disk memory).
      <br/>
      The client 52 runs one or more applications 110.
      <br/>
      The client also utilizes a resource manager 112, which performs similar caching and logging functions as the server-side resource manager 82 described above with respect to FIG. 4.
      <br/>
      These components are not shown for ease of discussion.
      <br/>
      The client-side resource manager 112 also maintains instances of the active application table 114 and the message lookup table 116.
      <br/>
      The client 52 also maintains a stable log 118 in the non-volatile memory 108.
    </p>
    <p num="61">Message Tracking</p>
    <p num="62">All messages between the client and server are tagged with:</p>
    <p num="63">
      1. a unique application identifier (AppID) that includes an encoding of the corresponding client and is unique across all applications of all clients; and
      <br/>
      2. a message sequence number (MSN) that is unique and monotonically increasing within each client application.
    </p>
    <p num="64">
      The client is assumed to be capable of running multiple applications simultaneously.
      <br/>
      When an application is launched, an application identifier for that application is placed in the client's active application table 98 and, on first contact with the server, in the server's active application table 114.
      <br/>
      As the client application passes a message to the server, that message is tagged with an MSN.
      <br/>
      The server and client use the MSNs to identify and track individual messages exchanged between them.
    </p>
    <p num="65">Server Message Logging</p>
    <p num="66">
      The server 54 generates a log record for each of its own write operations on database objects and each reply message, as well as some additional temporary log records to cope with incomplete requests.
      <br/>
      The log records are posted in the log buffer 88, which is forced to the stable log 96 whenever it is full or according to the write-ahead-logging rule.
    </p>
    <p num="67">
      In addition, the log records for active messages are kept in the message lookup table 100.
      <br/>
      The server 54 forces a reply log record to the stable log 96, by flushing the database log buffer 88, before the reply message is sent to the client 52.
      <br/>
      Making the reply log record stable does not imply that the reply log record is discarded from the message lookup table 100.
      <br/>
      As a restarting client may re-request a reply, keeping it in the message lookup table in volatile storage can save random disk I/O on the log file.
    </p>
    <p num="68">
      To force a reply message to the stable log file 96, the server 54 flushes its log buffer 88 in a single atomic write to the log file.
      <br/>
      If the message lookup table 100 still contains the corresponding request and log records associated with the request that involved reads of database objects, the request and these "read" log records can be removed from the log buffer, i.e. not written to the stable log.
      <br/>
      They can be discarded once the atomic log file write is completed.
    </p>
    <p num="69">
      The server 54 provides request recovery in one of three ways.
      <br/>
      One approach is to log the request actions at the server in a manner that enables "undo" recovery.
      <br/>
      With this approach, the log enables the server to "undo" incomplete requests during recovery.
      <br/>
      If the server knows that the reply to the original request has not yet been sent to the client, the server can relax the obligation of deterministic replay as long as all database writes of concurrently executed requests are kept isolated.
      <br/>
      The server can then undo a request and re-execute it all over again when the client re-submits the request, as if it were a new request.
    </p>
    <p num="70">
      A different interleaving with the reads and writes of other requests does not necessarily recreate the effects of the original request.
      <br/>
      Thus, the undo approach is only valid when the server is sure that the client has not yet seen the original reply.
      <br/>
      The isolation condition typically holds if a request-reply interaction is inside one ACID transaction, assuming a rigorous database concurrency control protocol such as strict two-phase locking.
      <br/>
      When a client request initiates a sequence of transactions on the server (e.g., a request that starts a "mini-batch" stored procedure on the server), the undo would have to be based on compensating transactions.
      <br/>
      The effects of the original transactions would have to be kept quasi-isolated at a higher level of abstraction taking into account application semantics.
      <br/>
      Without some form of isolation, the "undo" option is not applicable.
    </p>
    <p num="71">
      A second approach is to log the application request actions at the server in a manner that enables "redo" recovery, meaning that the log enables the server to reconstruct incomplete requests during recovery.
      <br/>
      The second approach requires the server to log values of all database reads as well as its normal database update logging for a request.
      <br/>
      During server restart, the incomplete request is redone such that all database reads and writes are intercepted.
      <br/>
      Read values are extracted from the logged values, and writes are applied to the database using log sequence number (LSN) testing for idempotence.
      <br/>
      After recovery, the incomplete request then continues execution to completion, logs its reply, and sends the reply to the client as if the server failure had not occurred.
      <br/>
      This approach has a potential pitfall, whose significance depends on further details of the logging method.
      <br/>
      Logging read values may greatly increase the amount of data logged.
    </p>
    <p num="72">
      Whereas the second approach involves a logging of physical read operations that require that the values read be logged, the third approach is a 1 variation of the "redo" recovery scheme that allows logging logical reads.
      <br/>
      A log record for a logical read capture only the point at which the read occurred and the source of the value.
      <br/>
      During recovery, the read value is re-read from the original source.
      <br/>
      To enable this third approach, the server must ensure that recovery reads the same versions of the data as were originally read.
      <br/>
      However, a potential problem is that the cache manager may write pages back to the permanent database before a crash, and then the version that is required by a read may no longer be available nor reconstructable via redo of the logged write operations.
      <br/>
      To avoid this problem, the cache manager is prevented from installing a data object into the database whenever its prior version is still necessary for a possibly replayed read, by tracking and enforcing installation dependencies.
      <br/>
      This third approach to logging logical reads is described in detail in the last three of the Lomet applications referenced in the Background section.
    </p>
    <p num="73">Client Message Logging</p>
    <p num="74">
      A client creates log records for each request and reply message that it exchanges with the server.
      <br/>
      In addition, it creates log records for each input message from the external world, such as interaction with a human user or some form of external sensor/actor (e.g., in an embedded control system).
      <br/>
      The reply messages from the server are kept in the message lookup table at the client.
      <br/>
      The log records for external input are forced to the stable log file 118 immediately.
      <br/>
      None of the other messages needs to be forced to the stable log file.
      <br/>
      Rather the client can write them "lazily", using a low-priority write demon in the background.
      <br/>
      Hence, they are lost should the client crash.
      <br/>
      However, keeping them in a volatile table enables the client to delay or avoid their logging so as to minimize the client's logging cost.
    </p>
    <p num="75">
      The client tracks three different message sequence numbers (MSNs).
      <br/>
      The first MSN is the last used MSN for each of its applications.
      <br/>
      This MSN is referred to as the "LastMSN".
    </p>
    <p num="76">
      The client also tracks a "RedoMSN" for each application.
      <br/>
      Each application can periodically generate an installation point, saving its state onto stable storage 118, typically into a local file on a per application basis using a shadowing technique to provide atomicity of installation points.
      <br/>
      Each installation point is treated as a logged message and tagged with an MSN.
      <br/>
      The "RedoMSN" is either the oldest MSN that follows the most recent installation point of the application or the installation point MSN itself if no more recent message exists.
    </p>
    <p num="77">
      Once an installation point is completed, all prior log records of the corresponding application can be discarded.
      <br/>
      They are now lower than the RedoMSN for the application, which is advanced to the MSN of the IP log record.
      <br/>
      The RedoMSN thus marks the beginning of the redo pass over the log during client recovery for a particular client application.
    </p>
    <p num="78">
      The client further maintains a "StableMSN" for each application, which serves to track by how much the client is lagging behind the server in terms of its stable message logging.
      <br/>
      The StableMSN is increased whenever the client has written a set of chronologically consecutive reply messages to the stable log file 118.
      <br/>
      One concrete policy is to ensure that this "backlog" (relative to the server) is limited by initiating a log file write whenever the difference LastMSN-StableMSN reaches some threshold.
    </p>
    <p num="79">
      It is noted that the server tracks a "RedoMSN" for each corresponding client application in its active application table 98.
      <br/>
      The server's RedoMSN has a corresponding redo log sequence number ("RedoLSN") that points to the log file to recover the log record pertaining to the message.
      <br/>
      The client's StableMSN for a given application is the server's RedoMSN for that application.
      <br/>
      All message log records that the server has on its stable log file with an MSN smaller than the server RedoMSN of the corresponding application are obsolete and can be garbage-collected (because the client does not need them).
    </p>
    <p num="80">FIG. 6 shows the interrelationship of the client active application table 114, client and server message lookup tables 116 and 100 respectively, and the client's and server's stable log files 118 and 96 respectively.</p>
    <p num="81">
      The client active application table 114 lists entries for currently active applications, including application A1 and application A2.
      <br/>
      Each entry in the client active application table 114 has four fields: a StableMSN field 120, a RedoMSN field 122, a LastMSN field 124, and a RedoLSN field 124.
      <br/>
      The client message lookup table 116 and the server message lookup table 100 each show a series of entries for client-server messages.
      <br/>
      The message entries for individual applications are kept in chronological order of the MSNS.
      <br/>
      The entries do not, however, have to be kept in chronological sequence across all active applications.
      <br/>
      Rather, entries can be discarded on a per application basis as permitted by the logging and installation activities of each application.
      <br/>
      The notation "M(x)A " means the message for an application "A" that has been tagged with an MSN of "x".
      <br/>
      Consider, for example purposes, the MSN pointers for the application A1.
    </p>
    <p num="82">
      A LastMSNA1 pointer from field 124 of the client active application table 114 references the last message for application A1 (i.e., M(i+k)A1) in the client message lookup table 116.
      <br/>
      A RedoMSNA1 pointer from field 122 references an entry with the oldest MSN that follows the most recent installation point (IP) of the application A1 (i.e., M(i+j)A1).
      <br/>
      These messages represent the start and end respectively of the sequence of messages that need to be replayed to recover application A1 to bring its state from the present stable version indicated by IPA1 to the last state reached thus far.
    </p>
    <p num="83">
      A StableMSNA1 pointer from field 120 references the last entry that is stable on the client log 118.
      <br/>
      In this example, the StableMSNA1 pointer references message M(i+j+2)A1, which is recorded on the client message lookup table 116 and the client log 118.
      <br/>
      Log records for messages that follow M(i+j+2)A1, as represented by the shaded log records in server log file 96 and corresponding entries in client message lookup table 116, must be requested from the server should a system crash occur.
    </p>
    <p num="84">
      A RedoLSNA1 pointer from field 126 references the log record for the oldest message in the client message lookup table 116 on the client log 118 used to recover client application A1 in an event of a client crash.
      <br/>
      In this case, the RedoLSNA1 pointer is to message M(i+j)A1, which corresponds to the same message being referenced in the client lookup table 116 by the RedoMSNA1 pointer from field 122.
    </p>
    <p num="85">
      The server active application table 98 has a RedoMSN pointer (labeled "RedoMSNC1,A1 ") for the application A1 running on the client C1.
      <br/>
      The RedoMSNC1,A1 pointer references a message M(i+j+3)C1,A1 in the server message lookup table 100 that is the oldest message for client application C1,A1 that is not known to be stable on the client.
    </p>
    <p num="86">
      A corresponding RedoLSNC1,A1 pointer references an entry in the server stable log 96 that contains the corresponding log record for the oldest message M(i+j+3)A1 for client application C1,A1 that is not known to be stable on the client.
      <br/>
      This record must not be truncated from the server log 96.
      <br/>
      If a redo recovery is needed, this message recorded in the log record is made available to client application A1.
      <br/>
      Log records must be present on the server log 96 for this and all subsequent messages for application A1, as represented by the shaded records.
      <br/>
      Note that by combining the logs of the client and the server, all records from application A1 on client C1 that are in the sequence from RedoMSNA1 to LastMSNA1 are stable and hence recoverable to recover application A1.
      <br/>
      As shown in the example, these records are disjoint, but that is not necessary.
      <br/>
      There can be overlap of the log records, where both client and server logs contain a log record for a message, but gaps are not permitted.
    </p>
    <p num="87">
      Both the server and the client continuously truncate obsolete parts of their respective stable logs and message lookup tables.
      <br/>
      Log truncation frees up disk space and memory space.
      <br/>
      Without truncation, the server would have to keep reply log records forever and the log scan time during a restart would grow without bound.
      <br/>
      Log truncation, which is a form of garbage collection, is thus very beneficial for the server.
      <br/>
      Log truncation is discussed separately below, as it pertains to the client and to the server.
    </p>
    <p num="88">Client Log Truncation</p>
    <p num="89">
      In general, the client 52 may discard all log records in stable log 118 and all record entries in message lookup table 116 of an active application at each new installation point for that application.
      <br/>
      However, when the client runs multiple applications simultaneously, the client may not yet be allowed to truncate the stable log file, as other applications may still need parts of the log file earlier than the soon-to-be truncated portion based on the subject application.
    </p>
    <p num="90">
      The client marks the progress for the installed application in the active application table by setting its RedoMSN entry to the MSN of the installation point.
      <br/>
      The minimum RedoMSN among all active applications determines the part of the log file that the client needs to keep.
      <br/>
      The client applications play the role of dirty database pages.
      <br/>
      To quickly reconstruct the minimum RedoMSN after a failure without having to scan the entire log, the client periodically generates a checkpoint log record that contains the active application table.
      <br/>
      This is a standard technique of database-style logging and recovery, applied here to application message logging.
    </p>
    <p num="91">Server Log Truncation</p>
    <p num="92">
      As the server 54 does not itself create application installation points, it has no direct information about when it can safely discard log records pertaining to the client reply messages and hence when it can truncate its log file.
      <br/>
      Rather, the server 54 relies on notifications from the client 52 to inform the server when certain log records are no longer needed.
      <br/>
      These notifications are known as "stability notifications." To avoid extra messages, a stability notification can be piggybacked on a subsequent request message sent to the server.
    </p>
    <p num="93">
      The client 52 sends a stability notification on one of two conditions: (1) an application installation point or (2) the writing of reply log records to the client stable log file 118.
      <br/>
      With respect to the first condition, the client occasionally installs the application state as part of the client-independent recovery scheme.
      <br/>
      Installing application state alleviates the need for the server to hold previous reply message log files on behalf of the client because the stable application state already captures these previous replies.
    </p>
    <p num="94">
      With respect to the second condition, the client application restart time can be significantly reduced if the client can perform some "lazy logging" itself, by writing reply log records to stable storage 118 in a non-forced manner whenever there is available disk bandwidth.
      <br/>
      This reduces the number of log records that need to be retrieved from the server during replay, thereby reducing the application restart time.
      <br/>
      Thus, when the client logs reply messages, the server no longer needs to maintain its copies of the reply messages on its stable log.
    </p>
    <p num="95">
      FIG. 7 shows process steps in which the client sends stability notifications to the server to release previously logged reply log records.
      <br/>
      Steps 60-68 are identical to those shown in FIG. 3, with the added notation of "1" to identify a particular request and reply sequence.
      <br/>
      At step 130, the client performs one of the following two functions: (1) installs the application state of the client application or (2) logs reply messages, including the reply 1, received previously from the server.
      <br/>
      Either of these events triggers a stability notification.
    </p>
    <p num="96">
      At step 132, the client attaches a stability notification to a subsequent request j. The stability notification informs the server that the log record of reply 1 is no longer necessary.
      <br/>
      The client includes in the stability notification the MSN of the reply 1 message, which is effectively the StableMSN for the particular application.
      <br/>
      At step 134, the server uses the MSN to find the reply log record for reply 1 in the message lookup table 100.
      <br/>
      The server then removes the reply log record from the message lookup table 100 and sometime thereafter, when the log file 96 is truncated, discards the log record from the log file.
      <br/>
      At step 136, the server sets the RedoMSN for the corresponding application in the active application table 98 to the smallest MSN higher than the discarded message, and adjusts the corresponding system RedoLSN in the log file 96 accordingly.
    </p>
    <p num="97">
      It is noted that the client may release several log files as a result of installing application state or logging replies.
      <br/>
      In this case, the stability notification may only contain information on the message with the most recent MSN.
      <br/>
      Upon receiving a stability notification with this StableMSN, the server discards all entries in its message lookup table 100 that pertain to that particular application that have MSNs smaller than or equal to this StableMSN.
      <br/>
      The server also sets the application's RedoMSN in the active application table 98 to the smallest MSN higher than the last discarded message.
    </p>
    <p num="98">
      The server does not need to make stable the changes to its message lookup table 100 and active application table 98 that result from a stability notification by, for example, generating a checkpoint log record.
      <br/>
      The server may, however, generate a log record to mark this event in the log, but this log record can be very short and need not be forced.
      <br/>
      Consequently, if the server fails, it may not remember that it effectively truncated its log file and it may scan the log starting from overly old RedoMSNs.
      <br/>
      However, this does not affect correctness.
    </p>
    <p num="99">Client Application Termination</p>
    <p num="100">
      When a client completes an application, it informs the server that the application has completed.
      <br/>
      Application termination is a special condition that involves an independent stability notification so that the server can remove the application from its active application table and all corresponding messages from the message lookup table.
      <br/>
      The server also forces a log record to the stable log file indicating application termination or alternatively generates a checkpoint log record with an updated copy of the entire active application table.
    </p>
    <p num="101">
      Without these procedures, the server may lose a stability notification from an application that terminates and will therefore not send any more notifications.
      <br/>
      The log records for the terminated application would become permanently unreclaimed garbage.
      <br/>
      This would forever prevent the server from truncating its log, a situation to be avoided.
    </p>
    <p num="102">
      FIG. 8 shows process steps for a client application termination.
      <br/>
      At step 140, the application completes at the client.
      <br/>
      At step 142, the client 52 sends a special message containing a notice of application termination to the server.
      <br/>
      The message contains the last MSN of a message pertaining to the completed application and the application ID (AppID) for the terminated application.
      <br/>
      After sending over the termination notice, the client waits for an acknowledgment from the server before it removes the application from its own active application table and commits the termination.
    </p>
    <p num="103">
      At step 144, the server 54 removes all reply records for that application from the message lookup table 100.
      <br/>
      At step 146, the server removes the application ID from the active application table 98.
      <br/>
      The server then writes to the log file an application termination log record and, when the termination log record is stable, sends a confirmation notice acknowledging the termination notice back to the client (step 148).
      <br/>
      The application's log records will be discarded from the stable log file 96 when the log is truncated subsequently.
    </p>
    <p num="104">
      At step 150, the client removes the application from its own active application table 114 and the reply records in the message lookup table 116.
      <br/>
      At step 152, the client commits the termination by writing a log record that documents its termination.
    </p>
    <p num="105">Server Recovery</p>
    <p num="106">
      When restarting after a server failure, the server performs an "analysis pass" and a "redo pass" over the stable log file 96.
      <br/>
      The analysis pass starts from the most recent checkpoint log record (found by looking up the bootstrap file) and scans all log records until the end of the log.
      <br/>
      For application recovery, this pass rebuilds the active application table 114.
      <br/>
      This table 114 is re-initialized from the information in the checkpoint log record, and is then updated whenever the log scan encounters a stability notification log record for the application, which documents either an application installation point, application logging of a reply message, or application termination.
      <br/>
      At the end of the analysis pass, the server 54 knows for which applications it may have to recreate replies.
      <br/>
      It also knows a RedoMSN and a corresponding RedoLSN for each application, so that it can bound the part of the log that contains the potentially required reply log records.
      <br/>
      In addition, the analysis pass also tracks down incompletely executed requests, which need special treatment, as discussed below.
    </p>
    <p num="107">
      The redo pass starts from the minimum of the RedoMSN values among all active applications or the minimum RedoLSN among all database pages in the server's DirtyPageTable, whichever is older.
      <br/>
      For client application recovery, the focus is on the redo of the message log records.
      <br/>
      However, since request execution can write to pages of the database, normal database redo is also performed in the redo scan.
      <br/>
      The server redo pass rebuilds the message lookup table 100 so that it eventually returns to the state as of the crash.
      <br/>
      The server 54 can then deliver logged replies to re-submitted requests in case a client application fails and subsequently restarts as well.
    </p>
    <p num="108">
      A case that needs special consideration is the handling of incomplete request executions where the server has logged redo steps for database writes of a request.
      <br/>
      The request log record itself and corresponding undo or read log records are guaranteed to be on the stable log file at their original points in the interleaved request-execution history.
      <br/>
      Consider the following two cases.
      <br/>
      1. Undo log records are relevant for request-reply interactions that serve as boundaries for a single transaction.
      <br/>
      The server undoes the database writes of all incomplete requests, subsequently executes these requests again as if they were new requests, and finally generates the corresponding replies.
      <br/>
      2. Read log records permit the server to deterministically replay the partial execution of the incomplete requests and then continue executing the requests to completion, and hence generating replies.
    </p>
    <p num="109">
      In both cases, the replies are then handled like replies during normal operation: they are inserted into the message lookup table, forced to the stable log file, and finally sent to the client.
      <br/>
      From this point on the server is again in its normal operation mode.
      <br/>
      Client requests that are lost because the request log record is not forced are re-executed when the client re-submits the request.
    </p>
    <p num="110">Client Recovery</p>
    <p num="111">
      Like server restart, client restart also consists of an analysis pass and a redo pass over its stable log file 118.
      <br/>
      The analysis pass is identical to the server's process and rebuilds the client's active application table 114.
      <br/>
      This table lists all applications that are to be recovered.
      <br/>
      The client recovery restarts the applications that were active at the time of the client failure, resuming their execution in a way that is transparent to the human user.
      <br/>
      This leads to the following differences.
    </p>
    <p num="112">
      The RedoMSN of an application identifies the oldest log record needed for is recovery of that application.
      <br/>
      This may be either the first log record following the application's most recent installation point, or the installation point MSN itself if no more recent log record exists.
      <br/>
      Note that the RedoMSN determined by the analysis pass is a lower bound on the truly required RedoMSN.
      <br/>
      It is possible for an installation point to occur just before the system fails and for the log record describing the installation point to fail to be written to the stable log.
      <br/>
      In this case, a better RedoMSN can be determined from reading the application installation point and examining its tag MSN.
    </p>
    <p num="113">
      The client's redo pass then starts scanning the log 118 from the oldest RedoMSN of all applications in the reconstructed active application table 114.
      <br/>
      The log records of all applications at this client are processed in a single pass over the log as opposed to making a separate pass per application.
      <br/>
      This is an optimization for clients that run "middle-tier" application services and may thus have a large number of concurrently active applications.
    </p>
    <p num="114">
      Each of these applications is re-incarnated upon encountering its analysis-determined RedoMSN log record (i.e., the lower bound for the RedoMSN) during the redo pass.
      <br/>
      The MSN that tags the application installation point is used to determine the true RedoMSN, which may be later because the system may have failed before the stable writing of the log record for this installation point.
      <br/>
      All log records for the application are ignored until the point at which the true RedoMSN is encountered.
    </p>
    <p num="115">
      An application is then re-executed asynchronously to the further redo processing of the log (i.e., in a separate process or thread).
      <br/>
      Note that application requests can also be re-executed in a similar fashion.
      <br/>
      As during normal operation, all requests of the application are intercepted.
      <br/>
      At these points, either client recovery has already encountered the corresponding reply log record or the application process pauses until it is encountered.
      <br/>
      If the reply has been encountered, then it is replayed.
      <br/>
      Otherwise the application waits and replays the reply at the point when it is encountered during the log scan.
      <br/>
      Application replay proceeds after the reply has been redone.
      <br/>
      Note that with asynchronous application re-execution, application restart is sped up substantially, which is especially important if applications perform long computations between server or user interactions.
    </p>
    <p num="116">
      The client's redo pass over the log file 118 proceeds in parallel with application re-execution.
      <br/>
      It re-creates the client's message lookup table 116 to the state as of the last stable log record.
      <br/>
      During the application re-execution, user input messages are consumed from the message lookup table 116, and output messages to the user can be re-created as part of the application re-execution.
      <br/>
      All output messages which are followed by a log record of that application are suppressed (i.e., not sent to the user) as they would be duplicated.
      <br/>
      There is a chance of repeating the very last output message or of missing the very last input message, regardless of how quickly the log is forced.
      <br/>
      A system failure can occur between the time of the input and the time when the input is logged.
      <br/>
      The best that can be done is to reduce the probability that this will occur.
      <br/>
      Similarly, on output, it is possible for the output to be lost before the user sees it, even if it were "sent".
      <br/>
      Regardless of logging, it is impossible to tell whether the user has seen the output or not.
      <br/>
      Thus, one has to re-present the last output in any case.
    </p>
    <p num="117">
      For the request and reply log records, the client's analysis pass has also reconstructed the StableMSN for each active application.
      <br/>
      So the redo pass knows which log records it will eventually encounter on its stable log file.
      <br/>
      All other, more recent reply log records have to be retrieved from the server.
      <br/>
      However, the client does not know its exact point of failure; so it does not know if there are additional log records on the server.
    </p>
    <p num="118">
      When application re-execution reaches the last locally logged reply, application execution simply continues beyond this point and re-enters normal operation.
      <br/>
      The client executes the application until the next interception point and sends the request to the server.
      <br/>
      The client cannot (and does not have to) tell whether this request is a re-send or if it is the original send.
      <br/>
      On a re-send, the server sends back a previously logged reply.
      <br/>
      For a new request, the server does its normal request execution.
      <br/>
      One possible optimization is to check with the server right after the client's analysis pass, and ask the server to asynchronously ship the reply log records that are more recent than the client application's StableMSN.
    </p>
    <p num="119">
      Although the invention has been described in language specific to structural features and/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described.
      <br/>
      Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>In a client-server computer system having a client and a server, a computer-implemented method comprising the following steps:</claim-text>
      <claim-text>client sending a request from the client to the server; server processing the request to prepare a reply to the request; forcibly logging in a stable log at the server a log record containing the reply; sending the reply from the server to the client after the log record is logged in the stable log;</claim-text>
      <claim-text>and wherein the log record is the only forced logging event for the request/reply exchange.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. A computer-implemented method as recited in claim 1, wherein the server logging steps comprise capturing in the log information that enables undo recovery of incomplete requests in the event of a system crash.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. A computer-implemented method as recited in claim 1, wherein the server logging steps comprise capturing in the log information, including data read by the request, that enables redo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. A computer-implemented method as recited in claim 1, wherein the server logging steps comprise capturing in the log information, including references to data read, that enables redo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. A computer-implemented method as recited in claim 1, further comprising the step of maintaining at both the server and the client an active application table listing currently active applications for which the server or the client is responsible.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. A computer-implemented method as recited in claim 5, further comprising the step of recovering only the applications listed on the active application table following a crash.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. A computer-implemented method as recited in claim 1, further comprising the step of maintaining at both the server and the client a message lookup table that temporarily stores records of replies sent from the server to the client.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. A computer-implemented method as recited in claim 7, further comprising the step of using the reply record from the message lookup table should the client resubmit the associated request during recovery from a client crash.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. A computer-implemented method as recited in claim 7, further comprising the step of removing reply records from the message lookup table in response to either of the following events:</claim-text>
      <claim-text>(1) the client installs an application state of an application to which the reply pertains, or (2) the client logs the reply in a stable log at the client.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A computer-implemented method as recited in claim 1, further comprising the step of tagging each reply with a message sequence number (MSN).</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A computer-implemented method as recited in claim 10, further comprising the step of tracking at the client a last used MSN for each application running on the client.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A computer-implemented method as recited in claim 10, further comprising the step of tracking at the client, for each application running at the client, a "redo" MSN that is one of (1) an oldest MSN that follows a most recent installation point of the application, or (2) an MSN assigned to the installation point itself if no more recent message for the application exists.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. A computer-implemented method as recited in claim 10, further comprising the step of tracking at the client, for each application running at the client, a "stable" MSN that pertains to reply messages that are not stable at the client but may have stable log records at the server.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A computer-implemented method as recited in claim 1, further comprising the step of subsequently logging in a stable log at the client a client log record containing a reply received from the server.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A computer-implemented method as recited in claim 14, further comprising the step of discarding the client log record from the client's stable log in response to installing an application state of an application to which the reply pertains at a point in time after receipt of the reply from the server.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. A computer-implemented method as recited in claim 1, further comprising the following steps: generating a stability notification at the client in response to one of (1) installing an application state of an application responsible for the request in a stable log at the client some time after the reply is received from the server, or (2) slogging in the client's stable log the reply received from the server; sending the stability notification from the client to the server;</claim-text>
      <claim-text>and discarding the log record from the stable log at the server in response to receiving the stability notification.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. A computer-implemented method as recited in claim 1, further comprising the following steps: completing an application at the client; sending a notice of termination from the client to the server; logging at the server that the client application has terminated; discarding all log records for replies pertaining to the application from the stable log at the server in response to receiving the notice of termination; sending a confirmation of the termination notice from the server to the client;</claim-text>
      <claim-text>and terminating the application at the client following receipt of the confirmation.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. A computer-implemented method as recited in claim 1, further comprising the step of using the log records for replies at the server's stable log to recover the client following a client crash.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. Computer-readable media distributed at the server and the client having computer-executable instructions to perform the steps in the method as recited in claim 1.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. In a server computer system for serving one or more clients, a computer-implemented method implemented at the server computer system comprising the following steps: receiving a request from a client; processing the request to prepare a reply to the request without logging the request in a stable log; forcibly logging in the stable log a log record containing the reply;</claim-text>
      <claim-text>and sending the reply to the client after the log record is logged in the stable log.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. A computer-implemented method as recited in claim 20, wherein the server logging steps comprise capturing in the log information that enables undo recovery of incomplete requests in the event of a system crash.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. A computer-implemented method as recited in claim 20, wherein the server logging steps comprise capturing in the log information, including data read by the request, that enables redo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. A computer-implemented method as recited in claim 20, wherein the server logging steps comprise capturing in the log information, including references to data read, that enables redo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A computer-implemented method as recited in claim 20, further Comprising the step of maintaining an active application table listing currently active applications running at the client.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. A computer-implemented method as recited in claim 24, further comprising the step of recovering only the applications listed on the active application table following a crash.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. A computer-implemented method as recited in claim 20, further comprising the step of maintaining a message lookup table that temporarily stores records of replies sent to the client.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. A computer-implemented method as recited in claim 26, further comprising the step of using reply records from the message lookup table during recovery of the client in place of the log record on the stable log.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. A computer-implemented method as recited in claim 26, further comprising the step of removing the reply record from the message lookup table in response to either of the following events:</claim-text>
      <claim-text>(1) the client installs an application state of an application to which the reply pertains, or (2) the client logs the reply in a stable log at the client.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. A computer-implemented method as recited in claim 20, further comprising the following steps: receiving a stability notification from the client indicating one of (1) that the client installed an application state of an application to which the reply pertains some time after the reply is sent to the client, or (2) that the client logged the reply in a client-side stable log;</claim-text>
      <claim-text>and discarding the log record from the stable log in response to receiving the stability notification.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. A computer-implemented method as recited in claim 20, further comprising the following steps: receiving a notice of termination from the client indicating that an application to which the reply pertains is terminating;</claim-text>
      <claim-text>and discarding from the stable log all log records for replies pertaining to the terminating application in response to receiving the notice of termination.</claim-text>
    </claim>
    <claim num="31">
      <claim-text>31. A computer-implemented method as recited in claim 20, further comprising the step of using the log record to recover the client following a client crash.</claim-text>
    </claim>
    <claim num="32">
      <claim-text>32. A computer programmed to perform the steps in the method as recited in claim 20.</claim-text>
    </claim>
    <claim num="33">
      <claim-text>33. A computer-readable media distributed at the server and the client, which directs server and client to perform the steps in the method as recited in claim 20.</claim-text>
    </claim>
    <claim num="34">
      <claim-text>34. In a server computer system for serving a client, a computer-implemented method implemented at the server computer system comprising the following steps: storing an application identification of an active application executing on the client in an active application table; receiving from the client a request generated by the application and identified via an application identification; force logging, in a stable log, a log record containing a reply to the request; storing the reply in a message lookup table;</claim-text>
      <claim-text>and sending the reply to the client.</claim-text>
    </claim>
    <claim num="35">
      <claim-text>35. A computer-implemented method as recited in claim 34, further comprising the step of recovering only the active applications listed on the active application table following a client crash.</claim-text>
    </claim>
    <claim num="36">
      <claim-text>36. A computer-implemented method as recited in claim 34, further comprising the step of using the reply stored in the message lookup table in place of the log record to recover the client from a client crash.</claim-text>
    </claim>
    <claim num="37">
      <claim-text>37. A computer-implemented method as recited in claim 34, further comprising the step of removing the reply from the message lookup table in response to either of the following events:</claim-text>
      <claim-text>(1) the client installs an application state of the application, or (2) the client logs the reply in its stable log.</claim-text>
    </claim>
    <claim num="38">
      <claim-text>38. A computer-implemented method as recited in claim 34, further comprising the step of occasionally storing the active application table and the message lookup table on the stable log.</claim-text>
    </claim>
    <claim num="39">
      <claim-text>39. A computer programmed to perform the steps in the method as recited in claim 34.</claim-text>
    </claim>
    <claim num="40">
      <claim-text>40. A computer-readable media distributed at the server and the client, which directs server and client to perform the steps in the method as recited in claim 34.</claim-text>
    </claim>
    <claim num="41">
      <claim-text>41. In a client-server computer system having a client and a server, an application recovery system comprising: a client-side application that executes on the client to send a request to the server; a server-side application request program that executes on the server to process the request, prepare a reply to the request, and return the reply to the client;</claim-text>
      <claim-text>and a resource manager that executes on the server to create a stable log file that can be used to recover the client-side application in the event of a system crash, the resource manager being configured to forcibly log in the stable log file a log record containing the reply, wherein the log record is the only forced logging event for the request/reply exchange.</claim-text>
    </claim>
    <claim num="42">
      <claim-text>42. An application recovery system as recited in claim 41, wherein the resource manager captures in the log information that enables undo recovery of incomplete requests in the event of a system crash.</claim-text>
    </claim>
    <claim num="43">
      <claim-text>43. An application recovery system as recited in claim 41, wherein the resource manager captures in the log information, including data read by the request, that enables undo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="44">
      <claim-text>44. An application recovery system as recited in claim 41, wherein the resource manager captures in the log information, including references to data read, that enables redo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="45">
      <claim-text>45. An application recovery system as recited in claim 41, wherein the resource manager maintains an active application table listing currently active applications running on client.</claim-text>
    </claim>
    <claim num="46">
      <claim-text>46. An application recovery system as recited in claim 45, wherein the resource manager recovers only the applications listed on the active application table following a system crash.</claim-text>
    </claim>
    <claim num="47">
      <claim-text>47. An application recovery system as recited in claim 41, wherein the resource manager maintains a message lookup table that temporarily stores records of the replies sent to the client.</claim-text>
    </claim>
    <claim num="48">
      <claim-text>48. An application recovery system as recited in claim 47, wherein the resource manager uses the reply record from the message lookup table in place of the log record in the stable log to recover the client-side application following a client crash.</claim-text>
    </claim>
    <claim num="49">
      <claim-text>49. An application recovery system as recited in claim 47, wherein the resource manager removes the reply record from the message lookup table in s response to either of the following events:</claim-text>
      <claim-text>(1) the client installs an application state of an application to which the reply pertains, or (2) the client logs the reply in a stable log at the client.</claim-text>
    </claim>
    <claim num="50">
      <claim-text>50. An application recovery system as recited in claim 41, further comprising a client-side resource manager that executes at the client, the client-side resource manager tracking the last received reply for the client-side application.</claim-text>
    </claim>
    <claim num="51">
      <claim-text>51. An application recovery system as recited in claim 41, further comprising a client-side resource manager that executes at the client, the client-side resource manager tracking one of (1) an oldest reply that is received after a most recent installation point of the client-side application, or (2) the installation point itself.</claim-text>
    </claim>
    <claim num="52">
      <claim-text>52. An application recovery system as recited in claim 41, further comprising a client-side resource manager that executes at the client, the client-side resource manager tracking reply messages that are not stable at the client but may have stable log records at the server.</claim-text>
    </claim>
    <claim num="53">
      <claim-text>53. An application recovery system as recited in claim 41, further comprising a client-side resource manager that executes at the client, the client-side resource manager occasionally logging in non-forced manner, in a stable log at the client, a client log record containing the reply received from the server.</claim-text>
    </claim>
    <claim num="54">
      <claim-text>54. An application recovery system as recited in claim 41, further comprising: a client-side resource manager that executes at the client, the client-side resource manager occasionally (1) installing an application state of client-side application in a stable log at the client, or (2) logging in the client's stable log the reply received from the server; the client-side resource manager sending a stability notification to the server indicating that the reply is now stably recorded at the client or that the reply is no longer needed at the server because a later application state has been installed;</claim-text>
      <claim-text>and the resource manager at the server being configured to discard the log record from the stable log at the server in response to receiving the stability notification.</claim-text>
    </claim>
    <claim num="55">
      <claim-text>55. An application recovery system as recited in claim 41, wherein: the client-side application completes and sends a notice of termination to the server; the resource manager forces a log record describing the application termination; the resource manager is configured to discard all log records for replies pertaining to the client-side application from the stable log in response to receiving the notice of termination.</claim-text>
    </claim>
    <claim num="56">
      <claim-text>56. An application recovery system as recited in claim 41, wherein the resource manager uses the log records to recover the client-side application following a client crash.</claim-text>
    </claim>
    <claim num="57">
      <claim-text>57. A server computer system for serving one or more clients, comprising: a volatile main memory having a log buffer; a non-volatile memory that persists across a system crash, the non-volatile memory having a stable log; a processing unit coupled to the main memory and the non-volatile memory; an application stored in the volatile main memory and executable on the processing unit to receive and process requests from a client and to send a reply back to the client;</claim-text>
      <claim-text>and a resource manager stored in the volatile main memory and executable on the processing unit to record the reply in the log buffer and to commit the reply record to the stable log when the reply is sent back to the client.</claim-text>
    </claim>
    <claim num="58">
      <claim-text>58. A server computer system as recited in claim 57, wherein the resource manager captures in the logged reply record information that enables undo recovery of incomplete requests in the event of a system crash.</claim-text>
    </claim>
    <claim num="59">
      <claim-text>59. A server computer system as recited in claim 57, wherein the resource manager captures in the logged reply record information, including data read by the request, that enables redo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="60">
      <claim-text>60. A server computer system as recited in claim 57, wherein the resource manager captures in the logged reply record information, including references to data read, that enables redo recovery of incomplete requests so that their execution can continue, in the event of a system crash.</claim-text>
    </claim>
    <claim num="61">
      <claim-text>61. A server computer system as recited in claim 57, wherein the resource manager maintains an active application table listing currently active applications running on the client.</claim-text>
    </claim>
    <claim num="62">
      <claim-text>62. A server computer system as recited in claim 61, wherein the resource manager recovers only the applications listed on the active application table following a crash.</claim-text>
    </claim>
    <claim num="63">
      <claim-text>63. A server computer system as recited in claim 57, wherein the resource manager maintains a message lookup table that temporarily stores reply records.</claim-text>
    </claim>
    <claim num="64">
      <claim-text>64. A server computer system as recited in claim 63, wherein the resource manager uses the reply record from the message lookup table during recovery of the client in place of the log record on the stable log.</claim-text>
    </claim>
    <claim num="65">
      <claim-text>65. A server computer system as recited in claim 57, wherein the resource manager discards the reply record from the stable log in response to receiving a notification from the client indicating (1) the client has installed an application state of an application to which the reply pertains, or (2) the client has logged the reply in a stable log at the client.</claim-text>
    </claim>
    <claim num="66">
      <claim-text>66. A server computer system as recited in claim 57, wherein the resource manager discards the reply record from the stable log in response to receiving a notification from the client indicating that an application to which the reply pertains is terminating.</claim-text>
    </claim>
    <claim num="67">
      <claim-text>67. A server computer system as recited in claim 57, wherein the resource manager uses the reply record from the stable log to recover the client following a client crash.</claim-text>
    </claim>
    <claim num="68">
      <claim-text>68. For use on a server computer system having a non-volatile memory with a stable log, a stable database, a volatile main memory with a log buffer, and a processing unit, in which the server computer system receives requests from one or more clients and returns replies to the clients, a resource manager executable on the server processing unit to record a client reply in the log buffer and to manage when to flush the reply record from the log buffer to the stable log, the resource manager being configured to commit the reply record to the stable log at or just before a time when the reply is sent to the client.</claim-text>
    </claim>
    <claim num="69">
      <claim-text>69. A resource manager as recited in claim 68, further configured to maintain an active application table listing currently active applications running on the client.</claim-text>
    </claim>
    <claim num="70">
      <claim-text>70. A resource manager as recited in claim 69, further configured to recover only the applications listed on the active application table following a crash.</claim-text>
    </claim>
    <claim num="71">
      <claim-text>71. A resource manager as recited in claim 68, further configured to maintain a message lookup table that temporarily stores a copy of the reply record committed to the stable log.</claim-text>
    </claim>
    <claim num="72">
      <claim-text>72. A resource manager as recited in claim 71, further configured to use the reply record from the message lookup table during recovery of the client in place of the log record on the stable log.</claim-text>
    </claim>
    <claim num="73">
      <claim-text>73. A resource manager as recited in claim 71, further configured to remove the reply record from the message lookup table in response to client notifications of either of the following events:</claim-text>
      <claim-text>(1) the client installs an application state of an application to which the reply pertains, or (2) the client logs the reply in a stable log at the client.</claim-text>
    </claim>
    <claim num="74">
      <claim-text>74. A computer-readable medium storing a resource manager as recited in claim 68.</claim-text>
    </claim>
  </claims>
</questel-patent-document>