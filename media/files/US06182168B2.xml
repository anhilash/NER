<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182168B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182168</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182168</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="25511975" extended-family-id="42076239">
      <document-id>
        <country>US</country>
        <doc-number>09085515</doc-number>
        <kind>A</kind>
        <date>19980527</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09085515</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43120690</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>8551598</doc-number>
        <kind>A</kind>
        <date>19980527</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09085515</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>96687397</doc-number>
        <kind>A</kind>
        <date>19971110</date>
        <priority-linkage-type>3</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-08966873</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  13/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>13</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>710052000</text>
        <class>710</class>
        <subclass>052000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>710020000</text>
        <class>710</class>
        <subclass>020000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>710305000</text>
        <class>710</class>
        <subclass>305000</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-013/30</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>13</main-group>
        <subgroup>30</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-013/30</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>13</main-group>
        <subgroup>30</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>3</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>23</number-of-drawing-sheets>
      <number-of-figures>23</number-of-figures>
      <image-key data-format="questel">US6182168</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Programmable sideband port for generating sideband signal</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>MAGAR SURENDAR S, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4713748</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4713748</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>BOWLER PAUL R, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5231872</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5231872</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>NARAD CHARLES E</text>
          <document-id>
            <country>US</country>
            <doc-number>5287503</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5287503</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>MULLINS JACQUELINE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5596724</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5596724</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>KERTH DONALD A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5644308</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5644308</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>HONG SOON CHUL</text>
          <document-id>
            <country>US</country>
            <doc-number>5644734</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5644734</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>KENNY JOHN D</text>
          <document-id>
            <country>US</country>
            <doc-number>5673400</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5673400</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>HONG SOON CHUL</text>
          <document-id>
            <country>US</country>
            <doc-number>5764924</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5764924</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="9">
          <text>MORO RICARDO J</text>
          <document-id>
            <country>US</country>
            <doc-number>5812879</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5812879</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="10">
          <text>JANDER MARK J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5857080</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5857080</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>AMINI NADER, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5396602</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5396602</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>AMINI NADER, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5450551</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5450551</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="13">
          <text>AMINI NADER, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5522050</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5522050</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="14">
          <text>SANTOS GREGORY N</text>
          <document-id>
            <country>US</country>
            <doc-number>5550989</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5550989</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="15">
          <text>GEPHARDT DOUGLAS D, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5557757</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5557757</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="16">
          <text>ALPERT DONALD B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5559986</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5559986</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="17">
          <text>AMINI NADER, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5564026</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5564026</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="18">
          <text>SMITH MICHAEL G</text>
          <document-id>
            <country>US</country>
            <doc-number>5590377</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5590377</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="19">
          <text>LESTER ROBERT A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5596729</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5596729</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="20">
          <text>O'BRIEN RITA M</text>
          <document-id>
            <country>US</country>
            <doc-number>5596756</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5596756</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="21">
          <text>KABENJIAN GREGORY V</text>
          <document-id>
            <country>US</country>
            <doc-number>5613162</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5613162</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="22">
          <text>JONES CRAIG S, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5619728</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5619728</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <related-documents>
      <division>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>96687397</doc-number>
              <kind>A</kind>
              <date>19971110</date>
            </document-id>
          </parent-doc>
        </relation>
      </division>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Guthrie, Guy Lynn</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <name>Emile, Volel</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Lee, Thomas C.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>LAPSED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A programmable sideband port is provided.
      <br/>
      The programmable sideband port contains a register with a plurality of memory locations each being connected to a bit in the port.
      <br/>
      The port is programmable by a processor which has access to all the memory locations.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">This application is a Division of appln. 08/966,873 filed Nov. 10, 1997.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="3">The present invention relates generally to a data transfer device and, more particularly, to a peripheral component interconnect (PCI) host bridge device.</p>
    <p num="4">2. Description of the Related Art</p>
    <p num="5">
      In 1995, version 2.0 of the peripheral component interconnect (PCI) bus specification was replaced by version 2.1. This new version introduced new requirements intended to better control bus latency and performance.
      <br/>
      For example, the new version only allows a certain amount of cycles during which a PCI target device has to transfer data in response to a request from a master device.
      <br/>
      If the target device cannot respond within the allowable time (e.g., 16 cycles), then the target device must instruct the master device to resend the request at a later time.
      <br/>
      This 16-cycle constraint is intended to free the PCI bus for other transactions instead of holding the bus in a wait state until the data is fetched.
      <br/>
      These new requirements, however, engender new technical problems that are yet to be solved.
    </p>
    <p num="6">
      One solution to these technical problems is to redesign the PCI host bridge (PHB) to accommodate the new requirements.
      <br/>
      A PHB is a hardware that interconnects a system bus to a PCI bus to receive/transmit input/output (I/O) data.
      <br/>
      The PHB accepts I/O commands from the system bus and controls the execution of these commands on the PCI bus.
      <br/>
      Conversely, the PHB accepts direct memory access (DMA) commands from the PCI bus and controls the execution of the DMA commands on the system bus.
      <br/>
      The PHB has an internal arbiter for controlling the PCI bus along interrupt support logic.
      <br/>
      The PHB contains data buffering for processor to I/O commands (i.e., loads, stores) along with data buffering and an internal data cache for DMA accesses to system memory.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="7">
      A host bridge having a dataflow controller is provided.
      <br/>
      In a preferred embodiment, the host bridge contains a read command path which has a mechanism for requesting and receiving data from an upstream device.
      <br/>
      The host bridge also contains a write command path that has means for receiving data from a downstream device and for transmitting the received data to an upstream device.
      <br/>
      A target controller is used to receive the read and write commands from the downstream device and to steer the read command toward the read command path and the write command toward the write command path.
      <br/>
      A bus controller is also used to request control of an upstream bus before transmitting the request for data of the read command and transmitting the data of the write command.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWING</heading>
    <p num="8">
      FIG. 1 is a block diagram of a computer system using the present invention.
      <br/>
      FIG. 2 is a block diagram of a data flow in a PHB of the present invention.
      <br/>
      FIG. 3 is a block diagram of a control and address flow in a PHB of the present invention.
      <br/>
      FIG. 4 depicts a block diagram of a multi-channel structure of a DMA read data buffer.
      <br/>
      FIG. 5 depicts a block diagram of a multi-channel structure of a DMA write data buffer.
      <br/>
      FIG. 6 is a flow diagram of a read data catcher.
      <br/>
      FIGS. 7A and 7B are a flow diagram of a PCI target dispatching read and write addresses.
      <br/>
      FIG. 8 depicts a tree-based LRU assignment algorithm.
      <br/>
      FIGS. 9A, 9B and 9C are a pseudo code implementation of the tree-based LRU assignment algorithm.
      <br/>
      FIGS. 10A, 10B and 10C depict a latched dataflow used in the PHB of the present invention.
      <br/>
      FIGS. 11A, 11B and 11C are a software implementation of the latched dataflow.
      <br/>
      FIG. 12 is a timing diagram of an outbound dataflow of a PHB as a master doing a store to a 32-bit PCI target.
      <br/>
      FIG. 13 is a timing diagram of an outbound dataflow of a PHB as a master doing a store to a 64-bit PCI target.
      <br/>
      FIG. 14 is a timing diagram of an outbound dataflow of a PHB as a target for a DMA read from a 32-bit PCI Master.
      <br/>
      FIG. 15 is a timing diagram of an outbound dataflow of a PHB as a target for a DMA read from a 64-bit PCI target.
      <br/>
      FIG. 16 is a block diagram of a hot plug connection.
    </p>
    <heading>DESCRIPTION OF THE INVENTION</heading>
    <p num="9">
      FIG. 1 is a block diagram of a computer system 100 using the present invention.
      <br/>
      The computer system 100 may contain one to n processor cards 110 (n being a positive integer) connected to a memory controller 120 via a system bus.
      <br/>
      The memory controller 120 is further connected to PCI host bridges (PHB) 130, 140, 150 and 160 through a remote system bus.
      <br/>
      The memory controller is also connected to a system memory 170 through the memory bus.
    </p>
    <p num="10">
      Connected to PHB 130 via PCI bus 1 are small computer system interfaces (SCSI) 1, 2 and 3 as well as an ethernet adapter and an industry standard architecture (ISA) bus bridge 170.
      <br/>
      Three ISA devices may be plugged into the three ISA slots to become part of the computer system 100.
      <br/>
      An ISA device may be a keyboard, a mouse etc.
      <br/>
      Note that bus bridge 170 need not be necessarily an ISA bus bridge, it can be an extended industry standard architecture (EISA) bus bridge or a microchannel bus bridge.
      <br/>
      Furthermore, the ISA bus bridge 170 may be connected to any one of the PCI buses and not necessarily to PCI bus 1.
    </p>
    <p num="11">
      PCI devices such as audio adapter, local area network (LAN) adapter, printers etc. may be connected to the system 100 through the PCI slots of 33 Mhz PCI buses 2 and 3.
      <br/>
      The system 100 may also contain a graphics subsystem (i.e., a graphics adapter) connected to PHB 160 through 50 Mhz PCI bus 4.
    </p>
    <p num="12">
      When a PCI device wants to do a DMA read or write into system memory, it has to first request the use of the local PCI bus to which it is attached from the corresponding PHB.
      <br/>
      The PHBs arbitrate bus requests among those various devices.
      <br/>
      The PHBs also have to request the use of the remote system bus from the memory controller 120.
    </p>
    <p num="13">
      FIG. 2 is a block diagram of a DMA data flow in either one of the PHBs 130, 140, 150 and 160.
      <br/>
      When a PCI device is transferring data to the system memory 120, the data goes from tri-state buffer 210 into DMA write buffer 250.
      <br/>
      The data then continues through multiplexers 255 and 260 until it is put on the remote system bus by tri-state buffer 265.
      <br/>
      Data from the system memory 120 goes from tri-state buffer 270 to DMA read buffer 245 and through multiplexers 220 and 215 before reaching the local PCI bus via tri-state buffer 205.
      <br/>
      Data to and from a processor is put into either MMIO (memory mapped I/O) buffer 0 or 1 before on the remote system bus or the local PCI bus.
    </p>
    <p num="14">
      FIG. 3 is a block diagram of a DMA control and address flow, in either one of the PHBs 130, 140, 150 and 160.
      <br/>
      As can be seen, PCI target 1300 is connected to write and read channel assignments 1305 and 1360.
      <br/>
      The PCI target 1300 is a logic circuit that interprets the PCI protocol and decodes addresses and all signals associated with the PCI bus.
      <br/>
      The decoded address is either transferred to write channel assignment 1305, in the case of DMA write commands, or to the read channel assignment 1360 in the case of DMA read commands.
    </p>
    <p num="15">
      FIGS. 7A and 7B are a flow diagram of a PCI target 1300 dispatching read and write addresses.
      <br/>
      The PCI target 1300 receives an address at step 300.
      <br/>
      At step 302, it determines whether the address matches the address range of the PHB.
      <br/>
      If no, it return to step 300.
      <br/>
      If yes, the PHB responds as target on the PCI bus.
      <br/>
      Then, it is determined whether it is a read or write command.
      <br/>
      If it is a read command, the process goes to step 310.
      <br/>
      If it is a write command the process continues to step 308.
    </p>
    <p num="16">
      If it is a read command, the command is sent to the read channels 1355 (step 310).
      <br/>
      Then it is determined whether any of the read channels respond as having been assigned to process an address that matches this transfer address (step 312).
      <br/>
      If no, the address is dispatched to the read channel assignment 1360 for assignment and the process returns to step 300 (step 316).
      <br/>
      If yes, it is determined whether the responding read channel is ready with the data (step 314).
      <br/>
      If no, the process goes to step 316 and returns to step 300.
      <br/>
      If yes, the data is placed on the PCI bus (step 315).
    </p>
    <p num="17">
      If the command was a write command, the command is sent to the write channels 1310 (step 320).
      <br/>
      Then a determination is made as to whether any of the write channels responded as having been assigned to process an address that matches this transfer address (step 322).
      <br/>
      If no, the process continues to step 326 by dispatching the address to the write channel assignment 1305 and returns to step 300.
      <br/>
      If a channel responded as having been assigned the address, a determination is made as to whether the responding channel is ready to accept data (step 324).
      <br/>
      If no, the process continues to step 326 and returns to step 300.
      <br/>
      If yes, the write channel will begin to receive data from the PCI bus and to place the data in the DMA write buffer 250.
    </p>
    <p num="18">When the write channel assignment 1305 receives the address, it queries the eight write channels 1310 to determine whether the translation control element (TCE) for the new transaction is cached in any one of them. (A TCE translates a 4k PCI I/O page address into a system memory page address.) If none of the channels claim ownership of this 4K page, then the address is assigned to one of the channels according to the present state of each channel and a least most recently used (LRU) algorithm explained below.</p>
    <p num="19">
      The DMA write channels are assigned to fetch and cache the TCEs from the TCE table in system memory.
      <br/>
      The logic of the DMA write channels is referenced by the write channel assignment 1305 to determine the state of each channel.
      <br/>
      Each channel controls one TCE element, thus eight different DMA write streams can be managed at the same time.
      <br/>
      The channel that is assigned the queried address will pass the address to the DMA write buffer load 1315.
      <br/>
      Using this address, the DMA write buffer load 1315 will control the loading of the DMA write buffer 250 of FIG. 2.
      <br/>
      The DMA write buffer load 1315 will prematurely terminate loading of the write buffer 250 if the buffer becomes full before the end of the transaction.
      <br/>
      The PCI device will have to re-initiate the write request command.
      <br/>
      When the re-initiated initiated write command is honored, it will start loading data at the point where the previous command had stopped.
    </p>
    <p num="20">
      The DMA write buffer unload 1320 controls the unloading of the buffer 250.
      <br/>
      The DMA write buffer unload 1320 can be unloading a previously loaded PCI transfer data stream from the DMA write buffer 250 while the DMA write buffer load 1315 is loading another DMA write transfer data stream into the buffer 250.
      <br/>
      Indeed, both the DMA write buffer load 1315 and the DMA write buffer unload 1320 are able to reference the same write channel (i.e., TCE) simultaneously.
      <br/>
      The DMA write buffer 250 can then be regarded as a write-through first-in first-out (FIFO) buffer that preserves the order of all DMA write data transfers.
    </p>
    <p num="21">
      The DMA write buffer unload 1320 is connected to both the DMA write bus control 1335 and the DMA read channel arbiter 1330.
      <br/>
      The DMA read channel arbiter 1330 arbitrates between the eight read channels 1355 and the DMA write buffer load 1315 when it is reading TCE data for the DMA write channels 1310 from the system memory 120.
      <br/>
      Control for the Data from the write buffer 250 to get on the system bus is sent to the DMA write bus control 1335 which makes sure that the bus is granted to the PHB before placing the data on the bus.
    </p>
    <p num="22">
      Similar to the DMA write channel assignment 1305, when the DMA read channel assignment 1360 receives the address from the PCI target 1300, it queries the eight read channels 1355 to determine which one is currently caching data at that address from the system memory 120.
      <br/>
      If no channel responds as having the address for the 4K page, the DMA read channel assignment 1360 assigns the address to one of the eight read channels.
      <br/>
      This channel then begins to fetch and cache data starting at that address.
      <br/>
      The decision regarding which channel to assign the address to is based on the state of each read channel and an LRU algorithm as will be further explained.
    </p>
    <p num="23">
      Depending on the number of DMA Read Request streams active at any given time, each one of the eight DMA read channels 1355 may be assigned to fetch and cache data.
      <br/>
      The data fetched by each of the read channels will come from a specific 4k memory page of the system memory 120.
      <br/>
      Thus, two channels will never both cache valid data for the same 4K I/O page as each channel manages only one TCE.
      <br/>
      In addition, each channel keeps track of a re-assignment state used by the DMA read channel reassignment 1360 to determine which channel to assign the address of the next requested data.
      <br/>
      Using the snoop detection 1350, each channel snoops DMA write transfers and the remote system bus traffic to invalidate its data when the data is modified by another device.
      <br/>
      Hence, as the channels work independently from each other, the PHB can manage up to eight different PCI DMA Read data streams at the same time.
    </p>
    <p num="24">
      Once a read channel is given permission to access the system bus by the DMA read channel arbiter 1330, the address is passed to the DMA read bus control 1340.
      <br/>
      The DMA read bus control 1340 issues the address to the bus and assigns a bus tag used with the read address to a DMA read catcher from the six DMA read catchers 1345.
      <br/>
      By having six DMA read catchers 1345, the PHB may have six DMA read transactions in process (i.e., address issued, data return pending) at any given time.
      <br/>
      As is obvious, therefore, this architecture is designed to pipeline several DMA read transactions to counteract the latency that is usually associated with reading data from the system memory.
    </p>
    <p num="25">
      FIG. 6 is a flow diagram of the read data catcher 1345.
      <br/>
      The process starts at step 600.
      <br/>
      At step 602, one of the DMA read data catchers marks itself as being available for assignment.
      <br/>
      At step 604, it is determined whether the DMA read catcher is being assigned by the DMA Read Bus Controller 1340.
      <br/>
      If not, the process returns to 602 to for the DMA read catcher to continue be available for assignment.
      <br/>
      If yes, the DMA read catcher marks itself as being busy (step 606).
      <br/>
      At step 608, the DMA read catcher stores the DMA read channel it is being serviced along with the system bus read tag issued for the read.
      <br/>
      At step 610, it is determined whether the data is available on the system bus and whether the data tag matches the tag sent with the read request.
      <br/>
      If no, the process returns to step 608.
      <br/>
      If yes, the process continues to step 612 where the data is stored into the DMA Read buffer 245.
      <br/>
      At step 614, the DMA read data catcher notifies the DMA read channel that it is servicing that the data has arrived.
    </p>
    <p num="26">
      The ordering rules for DMA traffic is as follows: (1) a DMA write request must NOT pass a previous DMA write request, (2) a DMA read request must NOT pass a previous DMA write request, (3) a DMA write request may pass a previous DMA read request and (4) a DMA read request may pass a previous DMA read request.
      <br/>
      Accordingly, therefore, (1) and (2) are the only rules that must stay strictly ordered.
      <br/>
      By using the write buffer 250 as a write-through FIFO buffer, the DMA write buffer load 1315 and the DMA write buffer unload 1320 ascertain that rule 1 is adhered to.
      <br/>
      Rules 2 and 3 are managed by the DMA read/write fairness control 1325.
      <br/>
      The multiple read channels 1355 allow the PHB to maximize the performance of rule 4 by allowing the read channels 1355 to run independently of each other.
    </p>
    <p num="27">
      Arbitration control for the DMA write and read channels has a special control to maintain proper order of execution while maintaining fairness across the write and read channels.
      <br/>
      This is handled with a multi-tier arbitration scheme.
      <br/>
      The arbitration scheme is as follows: (1) DMA reads vs.
      <br/>
      DMA writes; (2) read requests from DMA read channels vs.
      <br/>
      DMA write channels and (3) read priority between the eight read channels.
    </p>
    <p num="28">Thus, between DMA write requests and DMA read requests:</p>
    <p num="29">
      (a) a request from DMA write bus controller 1335 (e.g., a DMA write) has higher priority than a request from DMA read controller 1340 (e.g., a DMA read);
      <br/>
      (b) when the DMA write bus controller 1335 detects a second DMA write request from the DMA write buffer unload 1320, it does not allow the DMA read bus controller 1340 to issue a DMA read request onto the remote system bus;
      <br/>
      (c) if the DMA read bus controller 1340 is being retried, the DMA write bus controller operation may take priority and be issued before the DMA read bus controller operation.
    </p>
    <p num="30">
      As mentioned before, the rules for maintaining proper order and fairness between read and write channels are implemented within the DMA read/write fairness control 1325.
      <br/>
      A DMA write channel request to read a TCE has first priority.
      <br/>
      Requests from the eight DMA read channels to read TCEs or data have second priority.
      <br/>
      Therefore, when there is a long continuous stream of DMA write transfers onto the remote system bus, DMA read requests may be precluded from using the system bus for a long period of time.
      <br/>
      To circumvent this occurrence, therefore, the DMA read/write fairness control 1325 only allows eight consecutive write requests to be accepted while a DMA read channel is requesting the use of the system bus.
      <br/>
      Although in this case eight consecutive write requests are allowed to be serviced, it should be understood that depending on the design any other number may be allowed to be serviced consecutively.
      <br/>
      Once the eight write requests have been honored, the DMA read/write fairness control 1325 informs the DMA write buffer load 1315 to stop accepting any new DMA write transactions so that the read channels can be serviced.
      <br/>
      When the DMA write buffer 250 has emptied its current DMA write data, the DMA read/write fairness control 1325 then allows the DMA write buffer load 1315 to start accepting new write transactions.
    </p>
    <p num="31">
      Requests from the eight read channels are accepted on a round robin scheme.
      <br/>
      For example, if a read request from DMA read channel 4 (DRC4) had just been accepted by the DMA read bus control 1340, then the DMA read channel arbiter 1330 would assign the following priority to the channels:
      <br/>
      DRC5&gt;DRC6&gt;DRC7&gt;DRC0&gt;DRC1&gt;DRC2&gt;DRC3&gt;DRC4
    </p>
    <p num="32">
      Returning to FIG. 2, DMA write buffer 250 and DMA read buffer 245 can store 256 bytes and 2 kilobytes of data, respectively.
      <br/>
      They are further subdivided into a multi-channel structure where each channel can independently process a DMA transfer.
      <br/>
      FIG. 4 is a block diagram of the multi-channel structure of DMA read data buffer 245.
      <br/>
      The DMA read buffer 245 can be programmed to run in one of two modes.
      <br/>
      The first mode is an eight independent channel buffer mode capable of storing 256 bytes of data each.
      <br/>
      Each channel buffer is partitioned into four 64 bytes buffer sectors with one TCE register associated with each channel buffer.
      <br/>
      The second mode is a four independent channel buffer mode capable of storing 512 bytes of data.
      <br/>
      Each channel buffer is partitioned into four 128 bytes buffer sectors with one TCE register associated with each channel.
      <br/>
      Shown in FIG. 4 is the DMA read buffer 245 being run in the four independent channel buffer mode.
      <br/>
      This mode is intended to work in a system environment that may perform better with deeper data buffering across fewer channels.
    </p>
    <p num="33">
      When a PCI device initiates a PCI read transfer to the system memory 120, the PHB to which it is connected allocates one of the channels to service the transfer.
      <br/>
      The four buffer sectors of that channel are managed such that transfers between the system memory 120 and a buffer sector is overlapped with read requests from the other sectors.
      <br/>
      Thus, the channel buffer operates like a quad sector ring buffer.
      <br/>
      When the DMA read buffer 245 is operating in the eight independent channel buffer mode, the PHB can accept up to eight PCI read request addresses, one for each channel, even before it has delivered any data.
      <br/>
      Once a channel has been assigned an address, it initiates a request on the remote system bus to fetch the data.
      <br/>
      Each of the eight channels may be actively attempting to issue a read request on the remote system bus at the same time.
      <br/>
      Upon having a sector filled with data, the channel will start delivering the data if the read channel assignment 1360 requests a reading from that address.
      <br/>
      Once a particular channel has made forward progress by delivering data, it may be reassigned based on the LRU algorithm mentioned earlier.
      <br/>
      Note that since the DMA read buffer 245 is solely used for DMA reads, the data in the caches is never "dirty".
      <br/>
      Note also that all channels are set to zero at power on.
    </p>
    <p num="34">
      The TCE registers are of 64 bits each.
      <br/>
      The first 36 bits contain the address of the real memory page number (RPN).
      <br/>
      The next two bits show the control status c. The following 25 bits contain the I/O address.
      <br/>
      This address is used to fetch the TCE address.
      <br/>
      The last bit is a snoop bit v. As shown in FIG. 4, a TCE cache register is maintained for each DMA read channel when the TCE mode is enabled.
      <br/>
      The cached TCE entry determines the RPN to which all four sectors of the corresponding channel are mapped in system memory.
    </p>
    <p num="35">
      When a bus master (e.g., a PCI device) requests a read from system memory, the PHB will acknowledge the transaction with a device select signal (DEVSEL_).
      <br/>
      Then, the PHB will check for a valid TCE, fetch a new TCE if necessary and perform one or four buffer sector read requests if the data is not already in the DMA read buffer 245.
      <br/>
      Three different PCI read commands are used by the PHB to determine how many buffer sectors to fetch: memory read, memory read line and memory read multiple.
    </p>
    <p num="36">
      The memory read multiple command from a PCI bus master device causes the PHB to fetch all four sectors of a channel (i.e., the sector addressed by the bus master and the next three sectors).
      <br/>
      The DMA read channel will retry the bus master until the first sector has been fetched.
      <br/>
      If the bus master is in the midst of a burst transaction, the request can be serviced without delay (i.e. TRDY will continue to be asserted).
      <br/>
      Once the bus master has crossed over from the first buffer sector into the second, the first sector will be re-loaded with the next sequential sector (i.e., a fifth sector).
      <br/>
      When a DMA device approaches the end of the 4K page, the PHB will stop prefetching at the 4k page boundary.
      <br/>
      Upon detecting that a PCI device has read the last sector of the 4k page, the PHB will invalidate the channel thereby allowing it to be reassigned.
    </p>
    <p num="37">
      The memory read and the memory read line commands from a PCI bus master cause the PHB to fetch only one sector.
      <br/>
      A read channel will retry the bus master until the first sector has been fetched.
      <br/>
      Again, if the bus master is doing a burst transaction, the request will be serviced without delay until the end of the sector.
      <br/>
      If the bus master requests to read at an address that is in a different buffer sector (e.g., the address references the next sector), the PHB will initiate a request for the new sector and retry the PCI master until the data has been fetched from system memory.
      <br/>
      If the remote system bus latency is such that the read channel cannot continue to provide read data after the start of data delivery, the PHB will do a target disconnect at the sector boundary and continue to pre-fetch data to fill its cache.
      <br/>
      If the PCI bus master starts a new transaction at the next sequential address, then the PHB will start to deliver the read data from its cache.
      <br/>
      If the new address is not within the sector, then the read channel will retry the transfer (i.e., will do a delayed read transaction) until the requested data is fetched.
      <br/>
      Note that the PHB can pipeline up to six read requests from system memory and each read channel can issue up to four reads (one for each buffer sector).
    </p>
    <p num="38">
      FIG. 5 is a block diagram of the multi-channel structure of DMA write data buffer 250.
      <br/>
      The PHB implements one set of DMA write buffers which accommodate four buffer sectors (each sector is of 64 bytes).
      <br/>
      All DMA write data is routed through this buffer. (Note that it is referred to as a buffer and not as a cache because dirty data is always written into memory as soon as a DMA device moves from one sector to the next or when the device relinquishes the PCI bus.) The four sectors in the buffer are managed such that transfers between one sector and system memory can occur at the same time as the PCI bus writes to any of the other three sectors.
      <br/>
      Thus, just like the DMA read buffer 245, the DMA write buffer 250 operates as a quad sector ring buffer.
    </p>
    <p num="39">
      An eight entry TCE cache is maintained for bus master DMA write transfers.
      <br/>
      During a DMA write operation, one of the eight cached TCEs will be used to determine the RPN to which all four sectors of the DMA write buffer set are mapped.
      <br/>
      For example, when a bus master requests a write to memory, the PHB will compare the PCI address to the I/O address registers associated with each of the TCEs.
      <br/>
      If that comparison is false, the required TCE will be loaded from system memory using a similar LRU algorithm to the one used for the read channels.
      <br/>
      Once a TCE is fetched (or if the valid TCE is already cached), the DMA write buffer load 1315 will begin storing the data into the DMA write buffer 250 starting at the sector referenced by the TCE.
      <br/>
      Once the sector is filled, data will begin to flow to the next sector, at that time then, the data in the first sector can be written into system memory.
    </p>
    <p num="40">
      The PHB implements a set of mask bits which indicates which parts of the DMA write buffer 250 contain data.
      <br/>
      One mask bit is set for each byte of data written into the buffer.
      <br/>
      The mask bits are addressed in the same manner as the buffer itself is addressed.
      <br/>
      Once a sector is filled and data begins to flow to the next sector or when control of the bus is relinquished, the mask bits are examined to determine how many bytes within a particular cache line have to be written to memory.
      <br/>
      When the data in a buffer sector is written into system memory, all mask bits associated with that sector are reset.
    </p>
    <p num="41">
      When a device initiates a data burst that starts in the middle of a sector, data will be written in the buffer starting at that point.
      <br/>
      If the data burst fills up the initial sector and starts to fill the next sector, at that time the initial sector will be marked as busy indicating that it is ready to be flushed to system memory.
      <br/>
      This allows the DMA write buffer logic to store only the initial address of a data burst and the number of sectors associated with that burst, the mask bits indicating the valid bytes in a sector.
    </p>
    <p num="42">
      The PHB may be put into a mode where it will combine DMA writes into 128-byte block writes whenever possible.
      <br/>
      In this mode, the PHB will attempt to wait for two 64-byte sectors to fill up before issuing the DMA write on the remote system bus.
      <br/>
      The PHB will only combine two 64-byte buffers when all 128 bytes have valid data and the 128-byte block starts on a 128-byte address boundary.
      <br/>
      Once the transfer has terminated, the buffer is flushed to remove remaining data for that write access.
    </p>
    <p num="43">
      When a PCI device relinquishes the PCI bus after performing a DMA write, the PHB will flush to memory the last sector that was written.
      <br/>
      If some of the bytes in the sector have not been written, the PHB will perform a sequence of writes so that only the valid data is written into memory.
      <br/>
      This prevents the need of performing a "read-modify-write" sequence.
      <br/>
      Thus, the DMA write buffer 250 may be viewed as a simple time delay I/O buffer.
      <br/>
      Note that the PHB never assumes ownership of the data in this buffer so no snooping is needed.
    </p>
    <p num="44">
      As mentioned before, the PHB employs a least recently used (LRU) algorithm for selecting a read channel for reassignment.
      <br/>
      The selection is based on the present state of each of the read channels.
      <br/>
      The states are as follows:
    </p>
    <p num="45">
      State 1: a channel is not currently assigned an address.
      <br/>
      This state is entered into when:
    </p>
    <p num="46">
      i. coming out of reset;
      <br/>
      ii. the channel has been marked invalid due to a snoop hit; or
      <br/>
      iii. the channel issues a target abort due to an error fetching a TCE or data.
    </p>
    <p num="47">
      State 2: a channel has made forward progress and the PCI command was a "Memory Read" or a "Memory Read Line".
      <br/>
      This state is entered into when:
      <br/>
      i. the channel delivers at least one byte of data to the PCI device.
    </p>
    <p num="48">
      State 3: a channel has made forward progress and the PCI command was a "Memory Read Multiple".
      <br/>
      This state is entered into when:
      <br/>
      i. the channel delivers at least one byte of data to the PCI device.
    </p>
    <p num="49">
      State 4: a channel has not made forward progress.
      <br/>
      This state is entered into when:
      <br/>
      i. the channel has been re-assigned and is in the process of fetching a TCE and enough data to start the PCI transfer.
      <br/>
      Once the DMA read channel is ready and the PCI master returns a matching read address, this DMA channel will transition from state 4 to either state 2 or 3.
      <br/>
      If the PHB retries the operation and the PCI master never returns with a matching address, the PHB will expire the operation (based on time-out value on the order of 221 PCI clock cycles).
      <br/>
      This serves as a protection against having the PHB remained in a "no forward progress state"; or
      <br/>
      ii. the channel has been configured to be disabled.
    </p>
    <p num="50">Note that the LRU will mark a channel as most recently accessed even if the address is retried.</p>
    <p num="51">The following pseudo-code determines which DMA read channel is assigned to a new PCI transaction:</p>
    <p num="52">
      If any of the read channels are in state 1 then
      <br/>
      assign one of the channels in state 1 based on a priority where channel 0 is highest and channel 7 is lowest;
    </p>
    <p num="53">else</p>
    <p num="54">
      if any of the read channels are in state 2 then
      <br/>
      assign one of the channels in state 2 based on an LRU type algorithm which takes the least most recently used read channel from the list of state 2 channels;
    </p>
    <p num="55">else</p>
    <p num="56">
      if any of the read channels are in state 3 then
      <br/>
      assign one of the channels in state 3 based on an LRU type algorithm which takes the least most recently used read channel from the list of state 3 channels;
    </p>
    <p num="57">
      else
      <br/>
      all channels are in state 4 (no DMA will be assigned to this new PCI read address).
    </p>
    <p num="58">
      Similarly, the PHB employs an LRU algorithm for selecting a write channel for re-assignment.
      <br/>
      The algorithm is the same as that of the read channels with the exception of the state 2.
      <br/>
      The write channel algorithm does not have a state 2 because all writes are treated equal.
    </p>
    <p num="59">The following pseudo-code determines which DMA write channel is assigned to a new PCI transaction:</p>
    <p num="60">
      If any of the write channels are in state 1 then
      <br/>
      assign one of the channels in state 1 based on a priority where channel 0 is highest and channel 7 is lowest;
    </p>
    <p num="61">else</p>
    <p num="62">
      if any of the read channels are in state 3 then
      <br/>
      assign one of the channels in state 3 based on an LRU type algorithm which takes the least most recently used channel from the list of state 3 channels;
    </p>
    <p num="63">
      else
      <br/>
      all channels are in state 4 (no DMA will be assigned to this new PCI write transaction).
    </p>
    <p num="64">
      Returning to FIG. 3, the DMA read channels 1355 uses PCI arbiter 1365 to increase arbitration efficiency when doing PCI posted memory reads.
      <br/>
      For example, when a PCI device requests data from the system memory 120, until the data is available in the DMA read buffer 245, the PCI device will continually request the data from the PHB.
      <br/>
      This constant use of the PCI bus fosters inefficient traffic on the bus.
      <br/>
      In this embodiment, the PCI arbiter 1365, in addition to performing the duty of an ordinary PCI arbiter, provides an indication of the state of the read channels 1355.
    </p>
    <p num="65">
      In particular, when a DMA read channel is assigned the task of fetching data, in addition to the normal address/command information, it is also informed by the PCI arbiter of which PCI device was granted the PCI bus (i.e., PCI Req/Gnt pair 3).
      <br/>
      Upon being assigned the address, a DMA channel will inform the PCI arbiter 1365 for which of the PCI devices it is presently fetching data by asserting a signal.
      <br/>
      The arbiter 1365 uses this information to mask further requests for the data from that PCI device.
      <br/>
      When the read channel is ready to transfer the requested data to the PCI device, it deactivates the signal.
      <br/>
      The arbiter 1365 then unmasks the requests from the PCI device and provides high priority of the PCI bus grant to that PCI device.
      <br/>
      The following algorithm may be used to implement the use of the arbiter to increase PCI bus efficiency:
      <br/>
      1.
      <br/>
      PCI device A does an initial attempt at a DMA read from system memory;
      <br/>
      2. the PHB retries device A and masks device A's request line off internally (i.e., blocking device A from gaining control of the bus until the DMA read data is available);
      <br/>
      3. device A requests the PCI bus to retry the operation, but since its request is blocked, the arbiter does not get the request; meanwhile the PHB is fetching the data from system memory;
      <br/>
      4. the data is placed in the DMA read buffer 245 and the mask is removed from device A's request line; and
      <br/>
      5. the arbiter 1355 grants the bus to device A to receive the requested data.
    </p>
    <p num="66">
      As is obvious, the PHB has the ability to fetch and cache data and TCES.
      <br/>
      In order to do so and maintain coherency, the DMA read and write channels must snoop traffic from both the PCI bus and the remote system bus.
      <br/>
      Below is a description of the rules used to maintain coherency.
    </p>
    <p num="67">Read Data Cache Rules</p>
    <p num="68">
      The MESI protocol defines that a cache line can be in 1 of 4 states (Modified, Exclusive, Shared, or Invalid).
      <br/>
      The modified state indicates that an addressed block of data is valid only in the cache having the modified block and the modified data has not been written back into the system memory.
      <br/>
      The exclusive state indicates the data is present only in the noted block and is consistent with system memory.
      <br/>
      If a block of data is shared, it is valid in more than one cache and is consistent with system memory.
      <br/>
      When a block is invalid, it is not resident in that cache.
    </p>
    <p num="69">
      In order to streamline the design, the PHB only maintains data in either the Shared state or the Invalid state (i.e., will never hold data in the Modified or Exclusive state).
      <br/>
      This greatly simplifies the cache control logic needed in the Host Bridge.
      <br/>
      Consequently, only one bit is used to represent the state of the TCE and the data.
      <br/>
      In this case, if either the TCE or the Data took a hit in the snoop logic, then everything would be assumed invalid by resetting the bit.
      <br/>
      A tradeoff can be made as to whether the PHB contains two bits to represent the state of the data: one for the TCE cached and the other for the data cached.
      <br/>
      Two bits would provide better efficiency when data hits were detected at the expense of additional logic and complexity.
    </p>
    <p num="70">
      For ease of implementation, the PHB is designed to have only one of the 8 DMA read channels 1355 contained valid data for a particular 4K I/O page.
      <br/>
      This eliminates contention problems usually associated with two or more DMA channels responding to requests for data they thought they both had.
    </p>
    <p num="71">
      As mentioned before, the DMA read buffers 1355 have each four buffer sectors.
      <br/>
      For ease of implementation, only the address associated with the buffer sector at the head of the queue is used in the comparison with the PCI transaction when determining if the data has been hit.
      <br/>
      The other three buffer sectors serve as prefetch buffers which are available to sustain the burst of data for as long as the PCI master desires.
      <br/>
      This structure matches with typical I/O traffic which consists of large contiguous block transfers that may be broken up across several different PCI burst accesses mixed with small transfers that jump around in system memory.
    </p>
    <p num="72">TCE Cache Rules</p>
    <p num="73">
      Every TCE in the PHB TCE cache is unique.
      <br/>
      This means that for every 4K PCI I/O address that the PHB responds to as a target, there exists a unique TCE entry in the TCE table.
      <br/>
      No two DMA read channels, in the PHB, will be assigned to process the same unique TCE (i.e., same 4K PCI I/O page.).
      <br/>
      The RPN values stored in each TCE may not be unique.
      <br/>
      This means that even though no two Read Channels will ever be using the same TCE, it is possible that RPNs for different channels may point to the same real page in system memory.
    </p>
    <p num="74">
      When a new DMA read/write TCE is loaded and the RPN hits a valid read/write channel RPN cached within the PHB, then the read/write channel TCE will be marked as having a `delayed hit` (i.e., to be invalidated once forward progress has been made).
      <br/>
      Once the read/write channel has made forward progress (i.e., PCI data delivered in the case of a read channel or PCI data is accepted in the case of a write channel) and is not active in a PCI transfer, it will be marked as invalid.
      <br/>
      If the read/write channel has already made forward progress and is currently not active in a PCI transfer when the snoop hit occurs, then the `delayed hit` condition takes effect immediately to invalidate the TCE.
    </p>
    <p num="75">
      The PHB is not required to guarantee the consistency of its cached TCE entries if a DMA write is performed to any part of the system memory which contains all or part of the TCE table.
      <br/>
      If this type of transfer is attempted, it is the responsibility of the software to manage the potential inconsistency.
      <br/>
      This means the TCE caches in the DMA write or read channels need not snoop DMA write traffic.
    </p>
    <p num="76">PHB Snooping Rules</p>
    <p num="77">
      All cached TCEs fetched from the TCE table will be snooped to the 4K page level on `Page Kill` operations and snooped to the 128 byte level for all other global system bus operations.
      <br/>
      The snooping of any given cached TCE starts when the PHB's request for a TCE from memory is on the remote system bus (before the TCE data is actually received).
    </p>
    <p num="78">
      All four sectors in any valid DMA read cache will be associatively snooped to the 4K page level.
      <br/>
      The PHB will compare the RPN of the cached read TCE's to the snoop address from the system bus to determine whether a hit has occurred on one of the read data caches.
      <br/>
      This DMA read data cache snooping begins as soon as the TCE data is received from memory.
      <br/>
      The DMA write buffer will not be snooped since write data is not cached.
    </p>
    <p num="79">PHB Coherency States</p>
    <p num="80">
      Each channel must track the coherency state of the data and TCE it has cached.
      <br/>
      In order to do so, each channel maintains two latches: a VALID latch, and a DELAY-HIT latch.
      <br/>
      The VALID latch is used to indicate the state of the TCE/DATA.
      <br/>
      The DELAY_HIT latch serves as a DKILL queue for this channel to log whether the data in the channel needs to be invalidated.
      <br/>
      When the DELAY_HIT latch gets set, there may be a delay before the channel can actually invalidate its data (i.e., set VALID latch set back to 0) so that data thrashing which could lead to livelock/deadlock conditions can be avoided.
      <br/>
      Below are the conditions for what sets and resets the VALID and DELAYED_HIT latches:
    </p>
    <p num="81">READ Channel:</p>
    <p num="82">
      VALID latch is set when:
      <br/>
      1) RPN data received (i.e., TCE data fetched is complete).
    </p>
    <p num="83">
      VALID latch is reset when all of the following cases below are true:
      <br/>
      1) Channel has made forward progress (i.e., at least one byte of data has been delivered to the PCI master);
      <br/>
      2) Channel is not still waiting on any prefetch data;
      <br/>
      3) DELAYED_HIT latch is set; and
      <br/>
      4) Channel is currently not involved in PCI transfer
    </p>
    <p num="84">
      DELAYED_HIT latch is set when any one of the following cases are true:
      <br/>
      1) snoop hit on TCE after TCE address has been issued but before TCE data has returned;
      <br/>
      2) snoop hit on TCE or DATA when VALID latch is set to 1;
      <br/>
      3) the new RPN fetched for this read channel matches a Write Channels Valid RPN;
      <br/>
      4) a new RPN fetched by a write channel matches the RPN currently valid for this read channel;
      <br/>
      5) when this read channel has detected that the last buffer sector for this 4K page has been delivered to the PCI master; or
      <br/>
      6) when an error has occurred while fetching data/TCE for this channel.
    </p>
    <p num="85">
      DELAYED_HIT latch is reset when:
      <br/>
      1) same conditions that reset the VALID latch.
    </p>
    <p num="86">WRITE Channel:</p>
    <p num="87">
      VALID latch is set when:
      <br/>
      1) RPN data received (i.e., TCE data fetch completes).
    </p>
    <p num="88">
      VALID latch is reset when all of the following cases are true:
      <br/>
      1) Channel has made forward progress (i.e., at least one byte of data has been received from the PCI master);
      <br/>
      2) DELAYED_HIT bit is set; and
      <br/>
      3) Channel is currently not involved in PCI transfer.
    </p>
    <p num="89">
      DELAYED_HIT latch is set when any of the following cases are true:
      <br/>
      1) snoop hit on TCE after TCE address has been issued but before TCE data has returned;
      <br/>
      2) snoop hit on TCE when VALID latch is set to 1;
      <br/>
      3) a new RPN fetched by a read channel matches the RPN currently valid for this write channel; or
      <br/>
      4) when an error has occurred while fetching TCE for this channel.
    </p>
    <p num="90">
      DELAYED_HIT latch is reset when:
      <br/>
      1) same conditions that reset the VALID latch.
    </p>
    <p num="91">
      Because the read channels snoop data on a 4K page boundary (as opposed to snooping on a cache line boundary), special considerations must be made to still maintain coherency.
      <br/>
      The Read channel monitors the write channels activity not on a cache line basis, but rather at the 4K page basis.
      <br/>
      This simplifies the task by the read and write channels because now they only need to compare their current page (i.e., RPN) against any new TCE data (i.e., RPN) as it arrives from the TCE read (as opposed to checking data "real time" on a cache line basis as it is being transferred).
      <br/>
      The way this is done, as seen in the rules above, the read channel must detect whenever a PCI device is writing (i.e., modifying) data that is within the 4K page it is caching.
      <br/>
      Instead of watching for when the data is actually written, the read channel watches for when any write channel fetches a new TCE.
      <br/>
      The read channel can then check the new RPN being fetched by the write channel to detect if the write is within the same page.
      <br/>
      A similar check is done by the write channels whenever they detect a read channel has fetched a new TCE (i.e., TPN).
      <br/>
      This is necessary in order to trigger the write channel to refetch a TCE (RPN data) so the read channel can again be able to detect whether a write channel has started after the read channel started caching data.
    </p>
    <p num="92">
      Rule 4 under read Channel DELAYED_HIT set is used to properly the out of order sequence that can occur when a new channel is guaranteed to make forward progress before a DELAYED_HIT has actually invalidated the channel.
      <br/>
      For instance, the Write Channel may fetch its TCE first followed by a Read channel's TCE fetch for the same page (the Write Channel would set its DELAY_HIT) latch when it detects the Read Channel RPN matching its own) but, because the PHB has retried both PCI masters, the Read channel may deliver data before the write data is delivered, leaving the Read channel with stale data.
      <br/>
      The rule then adds the condition for the Read Channel to set its own DELAY _HIT latch when it receives its RPN for the TCE fetched and one of the write channels detects its RPN matches that of the read channel.
      <br/>
      LRU Algorithm for DMA Channel Assignment in a PCI Host Bridge
    </p>
    <p num="93">
      Within the DMA Read Assignment and DMA Write Assignment portions of the PHB is an LRU-type assignment arbiter.
      <br/>
      The arbiter is based on an LRU assignment algorithm used in 8 way set associative L2 type cache controllers to determine which of the 8 segments in the cache is the oldest.
      <br/>
      This implementation has been adapted to an arbiter type environment where the number of available selection is dynamic (i.e, a function of the number of channels currently available for assignment whereas with an 8-way set associative cache, the number is always static at 8).
    </p>
    <p num="94">
      In this description the number of DMA channels is eight.
      <br/>
      The selection of which of the 8 channels to assign is done using a tree-based LRU assignment algorithm which is tailored to use minimal hardware.
      <br/>
      The register TREE_SEL_REG has a bit combination that will uniquely point at a node (i.e., selected device) in the tree.
      <br/>
      Each node, when it is selected, forces the bit pattern to point away from the limb selection in the tree that points to that node (i.e., making itself the Most Recently Used node).
      <br/>
      The output selection of the tree is then selectively steered to only those legs that can be legally selected (i.e., available for reassignment).
      <br/>
      The output of this modified LRU selection is then used to indicate which channel has been assigned.
      <br/>
      See FIG. 8 for a depiction of the tree-based LRU algorithm and FIG. 9 for a pseudo code of the implementation.
    </p>
    <p num="95">
      Note that the tree-base LRU-type structure is not a true LRU but instead has been modified to minimize the logic required (a true LRU would require much more logic).
      <br/>
      This solution, although not an exact LRU, comes very close to the accuracy that one would get with a true LRU implementation.
    </p>
    <p num="96">Dynamic Disable of Load Data Ordering Within a PCI Host Bridge</p>
    <p num="97">
      Data from a processor load (i.e., Delayed Read Completion data) must not bypass DMA write data (e.g., the DMA write data must flush to system memory before the Load Data can be delivered).
      <br/>
      The purpose of this rule is to provide a mechanism for the processor to synchronize interrupts it receives with DMA write data.
      <br/>
      This is necessary because the PCI allows interrupts to bypass DMA write data.
    </p>
    <p num="98">
      The PHB handles this constraint by having the master controller take a snapshot of the state of the four buffer sectors in the DMA write buffer.
      <br/>
      This snapshot is taken whenever the PHB master control logic has just received load data off the PCI bus.
      <br/>
      The master controller will wait until the DMA write buffer sectors have been emptied.
      <br/>
      At this point, the master controller knows the write data that arrived prior to its Load data has been flushed so it can deliver its Load data to the processor.
      <br/>
      Because the DMA write buffer is a write-through buffer, the PHB master controller logic that performs the snapshot is strictly passive in that the DMA write buffer is unaffected when the master control logic is waiting for certain buffer sectors to empty.
    </p>
    <p num="99">
      The PHB's master controller's snapshot consists of a simple four-bit latch (each bit representing whether a particular buffer sector has valid data or not.
      <br/>
      A logical "1" in a bit position means that particular buffer sector contained data at the time of the snapshot).
      <br/>
      This snapshot register captures the state of the four-bit status register that the DMA write logic uses to indicate which buffer sectors have data and which do not.
      <br/>
      Once the snapshot is taken, each bit that was initially set to a "1" will eventually get cleared when that buffer sector has been emptied by the DMA write buffer logic.
      <br/>
      When all bits in the snapshot register are cleared, the master controller knows the data that was in the DMA write buffer at the time the Load data arrived has now been flushed and the Load data can be delivered in a manner.
    </p>
    <p num="100">
      In this PHB, there are actually two master controllers to pipeline processor Load/Store traffic.
      <br/>
      To provide proper ordering for each controller, each master controller has its own snapshot logic to synchronize its Load data with the flushing of the DMA write buffer.
    </p>
    <p num="101">Dynamic Disable of PCI Interrupt Synchronization Ordering for a PCI Host Bridge</p>
    <p num="102">
      As described above, the PHB is required to order the delivery of Load data received from the PCI bus with previously received DMA write data.
      <br/>
      The PHB design, however, provides the ability to dynamically turn off this ordering rule either statically (i.e., via a mode bit) or dynamically when it detects an abnormal condition since this ordering rule may be prone to cause deadlocks.
    </p>
    <p num="103">
      The solution then is to implement the PCI ordering rule in such a way that allows it to be easily disabled dynamically or through a software configuration register.
      <br/>
      This is done by keeping the Load buffer independent from the DMA write buffer and imposing the ordering restriction through a simple control handshake between the two buffers that can be switched on or off.
    </p>
    <p num="104">
      Uses for the mode bit are:
      <br/>
      1. dynamic switch for fault isolation whenever the PHB detects an error and goes into the error state, a system may still need to perform fault isolation.
      <br/>
      For this to happen, this ordering rule must be turned off in order to allow the fault isolation routines access (via Load/Store commands), to the PCI bus and internal registers inside the host bridge because the bus arbitration logic has gone into an error recovery mode where it will only grant the bus to the processor for it to perform diagnostics (all other traffic has been stopped).
      <br/>
      A deadlock would occur otherwise if inbound DMA traffic is not allowed to flush once the system enters the error state.
      <br/>
      2. static switch by software to be disabled Sometimes during testing when a system experiences a deadlock condition, it is fixed by redesigning the ASIC since the deadlock is usually deep inside the ASIC.
      <br/>
      Having this mode bit allows the system to break the deadlock and do other tests.
      <br/>
      The ordering rule can be patched temporarily in software to continue testing while the hardware is being fixed.
    </p>
    <p num="105">
      A second convenience for having this mode bit permanently switch off is because the system performance will actually be better.
      <br/>
      The burden of maintaining the ordering rule can be handled in software or ignored completely since some special applications may not even require this rule.
      <br/>
      The net result is a system that is much less likely to have deadlock conditions.
    </p>
    <p num="106">PCI 32/64 Bit Dataflow Design for a PCI Host Bridge or a PCI Device</p>
    <p num="107">
      The PCI protocol is not a true latch to latch protocol.
      <br/>
      The PCI protocol forces the master and target control logic to use the current state of the PCI bus control signals (i.e., UNLATCHED_PCI_CNTLS(n:O)) signals to determine what should be on the data/control signals in the next cycle.
      <br/>
      This means that the master and control logic within the PHB must run the UNLATCHED_PCI_CNTLS(n:0) signals through many levels of logic before it may arrive at a latch.
      <br/>
      The number of levels of logic needed can vary greatly depending on how a PCI ASIC design decides to do its data and control flow.
      <br/>
      This can become a critical design point when it comes to meeting a faster PCI timing (i.e., 50, 66 MHz).
      <br/>
      The more levels of logic used on the UNLATCHED_PCI_CNTLS(n:0), the harder it becomes to meet the setup/hold requirements of the PCI specifications due to the length and the wide variety of fast and slow paths associated with these UNLATCHED_PCI_CNTRLS(n:0).
      <br/>
      The impacts of this may not be discovered until late in the design cycle.
      <br/>
      By then, it may be very difficult to meet the PCI bus timings.
      <br/>
      So attention must be paid to the dataflow from the onset of the design phase to minimize the impacts at the end of the phase.
    </p>
    <p num="108">
      FIGS. 10A-10C depict a dataflow used in the PHB to solve this problem and FIGS. 11A-11 C are a software implementation of this dataflow.
      <br/>
      In FIGS. 10A-10C, only the parts of the dataflow and controls that are a function of the UNLATCHED_PCI_CNTLS(n:0) are actually connected to them.
      <br/>
      This includes the data muxtiplexers and the control logic that feed the output boundary registers and control latches, respectively.
      <br/>
      The logic that feed the control output latches is simplified down to a simple set/reset term to minimize the logic levels.
      <br/>
      All other dataflow/control logic responds to the latched version (LATCHED_PCI_CNTRL(n:0)) of the PCI control signals.
      <br/>
      This includes the master/target state machines, the master/target address generator, the master/target byte counters, the master/target read/write data buffer addressing generators.
      <br/>
      As a result, the outbound dataflow has a unique structure to compensate for the delay of a cycle later.
      <br/>
      The PHB, when sending data, must be able to react to the PCI device pacing the data through the IRDY- and TRDY- signals.
    </p>
    <p num="109">
      The unique feature in the output bound dataflow is the `holding register` (called PCI_D1_HI(31:0) and PCI_D1_LOW(3:0)).
      <br/>
      Because the dataflow, that is a function of the LATCHED_PCI_CNTLS(n:0), is always a cycle late in responding to what is happening on the PCI bus, this portion of the dataflow requires one holding register to save the extra words it has read from the buffer during data pacing.
      <br/>
      This holding register will be selected whenever the consumer of the data reactivates its IRDY- or TRDY- signal.
      <br/>
      With this dataflow structure, the controls become very simple and can handle any combination of data pacing for 32bit or 64bit PCI devices.
    </p>
    <p num="110">
      Both the PHB master and target logic share the same outbound and inbound dataflow.
      <br/>
      The dataflow is able to handle a 64 bit PCI transfer and will dynamically switch to supporting a 32 bit transfer in response to what the PCI device indicates it is capable of at the beginning of the transfer.
    </p>
    <p num="111">Multipurpose Sideband Port in PCI Host Bridge to Control Sideband Signals</p>
    <p num="112">
      The PCI spec allows the system designer to define sideband signals for a given system that can be used by a PCI device specially built to understand what these sideband signals mean.
      <br/>
      When using a PHB that is to be used in a system requiring different sideband signals with different definitions, the PHB can implement an internal register that exists in the processor's address map such that it can be written directly by the processor.
      <br/>
      The bits in this register are simply connected to the sideband signals for the PCI bus.
      <br/>
      This makes the PHB independent of the definition of these sideband signals.
      <br/>
      Software could then do a store to this Sideband register to set up the sideband signals properly prior to doing a store to the PCI device.
      <br/>
      The PCI device would then decode the sideband signals based on its built-in understanding.
      <br/>
      Software could then reset or change the sideband signals prior to accessing a second device to decode the sideband signals in a different manner.
    </p>
    <p num="113">
      FIG. 16 is a block diagram of a hot plug connection.
      <br/>
      This figure depicts one type of application where the ZPC_SIDEBAND_SEND(0:7) signals are wired to the PCI power control logic to send power-on/power-off commands to the individual PCI slots of a system that supports hot plugging.
      <br/>
      The PHB can receive commands back from the power logic through the ZPC_SIDEBAND_RECEIVE(0:7) that may contain status type information.
      <br/>
      In this example, the ZPC_SIDEBAND_SEND(0:7) and ZPC_SIDEBAND_RECEIVE(0:7) signals are used to communicate with a non-PCI device.
      <br/>
      Alternatively, ZPC_SIDEBAND_SEND(0:7) and ZPC_SIDEBAND_RECEIVE(0:7) signals could also be connected directly to a PCI device to provide sideband signals from the PHB to a PCI device.
      <br/>
      These signals could serve as discrete reset pins for the individual PCI devices or could serve as a functional indicator (i.e., serves as extra configuration or address selects from the PHB to the PCI target).
    </p>
    <p num="114">
      Although the present invention has been fully described above with reference to specific embodiments, other alternative embodiments will be apparent to those of ordinary skill in the art.
      <br/>
      Therefore, the above description should not be taken as limiting the scope of the present invention which is defined by the appended claims.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A programmable sideband port for generating sideband signals comprising:</claim-text>
      <claim-text>a register, said register being connected to said port and being accessible by a processor for programming said register;</claim-text>
      <claim-text>and means for converting a content of said register into sideband signal.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The sideband port of claim 1 wherein said register includes a plurality of memory locations, each of said memory locations being connected to a bit in said port.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The sideband port of claim 2 wherein each of said memory locations is individually accessible by said processor.</claim-text>
    </claim>
  </claims>
</questel-patent-document>