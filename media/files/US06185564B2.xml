<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185564B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185564</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185564</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="22294444" extended-family-id="42113623">
      <document-id>
        <country>US</country>
        <doc-number>09103297</doc-number>
        <kind>A</kind>
        <date>19980623</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09103297</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43171913</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>10329798</doc-number>
        <kind>A</kind>
        <date>19980623</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09103297</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F  17/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>17</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/50        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>50</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <further-classification sequence="1">
        <text>707999002</text>
        <class>707</class>
        <subclass>999002</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>707999009</text>
        <class>707</class>
        <subclass>999009</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>707999100</text>
        <class>707</class>
        <subclass>999100</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>707E17007</text>
        <class>707</class>
        <subclass>E17007</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>711150000</text>
        <class>711</class>
        <subclass>150000</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>711151000</text>
        <class>711</class>
        <subclass>151000</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/52</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>52</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20131024</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99932</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99932</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99939</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99939</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>47</number-of-claims>
    <exemplary-claim>5</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>15</number-of-drawing-sheets>
      <number-of-figures>17</number-of-figures>
      <image-key data-format="questel">US6185564</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Generation and validation of reference handles in a multithreading environment</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>WALSH JAMES E</text>
          <document-id>
            <country>US</country>
            <doc-number>5375241</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5375241</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>DRAVES RICHARD P</text>
          <document-id>
            <country>US</country>
            <doc-number>5802590</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5802590</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>CRELIER REGIS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5909580</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5909580</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>CABRERA LUIS FELIPE, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6029160</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6029160</doc-number>
          </document-id>
        </patcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Microsoft Corporation</orgname>
            <address>
              <address-1>Redmond, WA, US</address-1>
              <city>Redmond</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>MICROSOFT</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Douceur, John R.</name>
            <address>
              <address-1>Bellevue, WA, US</address-1>
              <city>Bellevue</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Bernet, Yoram</name>
            <address>
              <address-1>Seattle, WA, US</address-1>
              <city>Seattle</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Bar, Ofer</name>
            <address>
              <address-1>Newcastle, WA, US</address-1>
              <city>Newcastle</city>
              <state>WA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Lyon, Harr &amp; DeFrank</orgname>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>DeFrank, Edmond A.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Homere, Jean R.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      The present invention is embodied in a system and method for generating and validating reference handles for consumers requiring access to resources in a multi-threaded environment of a computer system.
      <br/>
      The system of the present invention includes a resource manager having a handle administrator, a plurality of consumers, and a plurality of resources.
      <br/>
      The handle administrator includes an assignment routine, a release routine, a dereference routine, and multi-threading sub-routines enabling operation of the present invention in multi-threaded environments.
      <br/>
      The assignment routine issues new handles, the release routine releases handles that are no longer required (thus rendering the handle invalid), the dereference routine dereferences handles into a pointer to a resource, which entails verifying that the handle is valid, and the multi-threading sub-routines enable safe invalidation of handles in multi-threaded environments and also ensure consistent use of pertinent values, such as array pointers and array sizes during operation of the expansion and contraction sub-routines.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="2">The present invention is related to computer systems for generating, managing and validating reference handles of consumers requiring access to resources.</p>
    <p num="3">2. Related Art</p>
    <p num="4">
      It is not uncommon for software modules operating on computer systems to require access to shared resources.
      <br/>
      For example, a given computer program may require access to files maintained by a file system, or it may require access to network connections maintained by a network driver.
      <br/>
      Network drivers may require access to information structures maintained by a network packet classifier.
      <br/>
      This is a complex arrangement that includes numerous software modules, such as software drivers requiring access to many shared resources and an access supervisor that either maintains the resources or at least intercedes in access by the software modules to the resource.
    </p>
    <p num="5">
      Such intercession exists for several reasons, one especially important reason being when a software module deletes a resource.
      <br/>
      If a first software module were to delete a first resource, while other software modules maintain direct pointers to the first resource, the pointers of the other software modules would be unaware of the deletion of the resource and would no longer point to a valid resource.
      <br/>
      Attempts have been made to solve this problem by notifying software modules when a resource deletion occurs.
      <br/>
      However, this requires detailed accounting and tracking of software modules and their respective pointers to the resources.
      <br/>
      As a result, this process is extremely expensive and very complex.
    </p>
    <p num="6">
      Another attempt to solve this problem involves having an access supervisor intercede when a software module requires access to a particular resource.
      <br/>
      Interceding ensures that the particular resource still exists before the software module is granted access to the particular resource.
      <br/>
      Typically, this is accomplished by having the access supervisor issue to each software module a handle to a particular resource, rather than allowing each software module a direct pointer to that particular resource.
      <br/>
      The software module does not use the handle to access the resource directly.
      <br/>
      Instead, the software module presents the handle to the access supervisor, which can dereference the handle to obtain a pointer to the resource for that software module.
      <br/>
      Although this approach allows the access supervisor to have control over the management of the shared resources, prior methods that follow this approach provide only rudimentary control, and thus have several limitations.
    </p>
    <p num="7">
      First, prior methods are inefficient, expensive and limited in their use because they lack constant-time operations, which is a problem when the number of simultaneously active handles is large.
      <br/>
      Also, the handle databases of prior methods have limited flexibility because they are not capable of growing and shrinking arbitrarily in an efficient manner.
      <br/>
      In addition, prior methods lack fast and efficient dereferencing and are ineffective in a multi-threaded environment.
      <br/>
      Further, prior methods lack efficient processes for recycling handles to increase handle space and to optimize the handle database.
      <br/>
      Therefore, what is needed is a computer-implemented system for generating and validating reference handles effectively and efficiently that overcomes these limitations.
    </p>
    <p num="8">Whatever the merits of the prior systems and methods, they do not achieve the benefits of the present invention.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="9">
      To overcome the limitations in the prior art described above, and to overcome other limitations that will become apparent upon reading and understanding the present specification, the present invention is embodied in a system and method for generating and validating reference handles for consumers requiring access to resources in a multi-threaded environment of a computer system.
      <br/>
      The generation and validation of reference handles in a multi-threaded environment provides efficient management and administration of consumers' access to resources in numerous computer environments, such as networked computers and non-networked personal computers.
    </p>
    <p num="10">
      The present invention includes a resource manager having a handle administrator, a plurality of consumers, and a plurality of resources.
      <br/>
      In the description that follows, the term "consumer" refers to a software module that, among other things, requires access to a resource (e.g., a printer driver requiring access to a dynamic link library file).
      <br/>
      The term "resource manager" refers to a software module that either maintains the resources or at least intercedes in access by the consumers to the resource.
      <br/>
      The resource manager manages handles that it issues to consumers.
    </p>
    <p num="11">
      The handle administrator includes an assignment routine, a release routine, and a dereference routine.
      <br/>
      The assignment routine issues new handles, the release routine releases handles that are no longer required (thus rendering the handle invalid), and the dereference routine dereferences handles into a pointer to a resource which entails verifying that the handle is valid.
      <br/>
      In addition, the present invention includes an auxiliary sub-routine for managing used and unused records, an expansion sub-routine for efficiently expanding the handle database, a handle recycling sub-routine for recycling handles, a contraction sub-routine for efficiently contracting the handle database, a hysteresis sub-routine for probabilistically contracting the handle database, a memory allocation failure sub-routine, and multi-threading sub-routines enabling operation of the present invention in multi-threaded environments.
    </p>
    <p num="12">
      A feature of the present invention is that handle assignment and release are constant-time operations, which is especially important if the number of simultaneously active handles is large.
      <br/>
      Another feature is that the handle administrator of the present invention has efficient assignment, release, and dereferencing routines that effectively work in a multi-threaded environment.
      <br/>
      Another feature of the present invention is that the size of the database is capable of growing arbitrarily, which is important if the number of handles is unknown ahead of time; and the size of the database is capable of shrinking when possible, which is especially important if the number of handles varies dramatically.
      <br/>
      Yet another feature of the present invention is that if the number of handles issued over a lifetime exceeds the size of the handle space, then handles can be recycled.
    </p>
    <p num="13">Therefore, the handle administrator of the present invention is designed to work efficiently and effectively when the number of simultaneously active handles is large, when the number of simultaneously active handles is unknown ahead of time, when the number of simultaneously active handles varies dramatically over time, when handle dereferencing needs to be very fast, when operating in multi-threaded environments, and when the number of handles issued over a lifetime is large relative to the handle space.</p>
    <p num="14">Further, the multi-threading sub-routines enable safe invalidation of handles in multi-threaded environments and also ensure consistent use of pertinent values, such as array pointers and array sizes during operation of the expansion and contraction sub-routines.</p>
    <p num="15">The foregoing and still further features and advantages of the present invention as well as a more complete understanding thereof will be made apparent from a study of the following detailed description of the invention in connection with the accompanying drawings and appended claims.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="16">
      Referring now to the drawings in which like reference numbers represent corresponding parts throughout:
      <br/>
      FIG. 1 is a block diagram illustrating an apparatus for carrying out the invention;
      <br/>
      FIG. 2 is a general block diagram illustrating the interaction between the main components of the present invention;
      <br/>
      FIG. 3 is a flow diagram illustrating the basic operation of the handle administrator of the present invention;
      <br/>
      FIG. 4 is an architectural block diagram illustrating the main components and the sub-components of a working example of the present invention;
      <br/>
      FIGS. 5-7 are diagrams visually illustrating the handle recycling sub-routine of the present invention;
      <br/>
      FIG. 8 is a flow diagram illustrating the assignment routine of the present invention;
      <br/>
      FIG. 9 is a flow diagram illustrating the release routine of the present invention;
      <br/>
      FIG. 10 is a flow diagram illustrating the dereference routine of the present invention;
      <br/>
      FIGS. 11A and 11B are flow diagrams illustrating the expansion sub-routine of the assignment routine of the present invention;
      <br/>
      FIGS. 12A and 12B are flow diagrams illustrating the contraction sub-routine of the release routine of the present invention;
      <br/>
      FIG. 13 is a flow diagram illustrating the record updating sub-routine of the contraction sub-routine of the present invention;
      <br/>
      FIG. 14 is a flow diagram illustrating the revoke ancient handles sub-routine of the expansion sub-routine of the present invention; and
      <br/>
      FIG. 15 is a flow diagram illustrating the record processing sub-routine of the revoke ancient handles sub-routine of the present invention.
    </p>
    <heading>DETAILED DESCRIPTION OF THE INVENTION</heading>
    <p num="17">
      In the following description of the invention, reference is made to the accompanying drawings which form a part hereof, and in which is shown by way of illustration a specific example in which the invention may be practiced.
      <br/>
      It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.
    </p>
    <p num="18">Overview</p>
    <p num="19">Exemplary Operating Environment</p>
    <p num="20">
      FIG. 1 and the following discussion are intended to provide a brief, general description of a suitable computing environment in which the invention may be implemented.
      <br/>
      Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer.
      <br/>
      Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types.
      <br/>
      Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like.
      <br/>
      The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network.
      <br/>
      In a distributed computing environment, program modules may be located on both local and remote memory storage devices.
    </p>
    <p num="21">
      With reference to FIG. 1, an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer 100, including a processing unit 102, a system memory 104, and a system bus 106 that couples various system components including the system memory 104 to the processing unit 102.
      <br/>
      The system bus 106 may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures.
      <br/>
      The system memory includes read only memory (ROM) 110 and random access memory (RAM) 112. A basic input/output system 114 (BIOS), containing the basic routines that helps to transfer information between elements within the personal computer 100, such as during start-up, is stored in ROM 110.
      <br/>
      The personal computer 100 further includes a hard disk drive 116 for reading from and writing to a hard disk, not shown, a magnetic disk drive 118 for reading from or writing to a removable magnetic disk 120, and an optical disk drive 122 for reading from or writing to a removable optical disk 124 such as a CD ROM or other optical media.
      <br/>
      The hard disk drive 116, magnetic disk drive 128, and optical disk drive 122 are connected to the system bus 106 by a hard disk drive interface 126, a magnetic disk drive interface 128, and an optical drive interface 130, respectively.
      <br/>
      The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the personal computer 100.
      <br/>
      Although the exemplary environment described herein employs a hard disk, a removable magnetic disk 120 and a removable optical disk 130, it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROM), and the like, may also be used in the exemplary operating environment.
    </p>
    <p num="22">
      A number of program modules may be stored on the hard disk, magnetic disk 120, optical disk 124, ROM 110 or RAM 112, including an operating system 132, one or more application programs 134, other program modules 136, and program data 138.
      <br/>
      A user may enter commands and information into the personal computer 100 through input devices such as a keyboard 140 and pointing device 142.
      <br/>
      Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like.
      <br/>
      These and other input devices are often connected to the processing unit 102 through a serial port interface 144 that is coupled to the system bus 106, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB).
      <br/>
      A monitor 146 or other type of display device is also connected to the system bus 106 via an interface, such as a video adapter 148.
      <br/>
      In addition to the monitor 146, personal computers typically include other peripheral output devices (not shown), such as speakers and printers.
    </p>
    <p num="23">
      The personal computer 100 may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer 150.
      <br/>
      The remote computer 150 may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer 100, although only a memory storage device 152 has been illustrated in FIG. 1.
      <br/>
      The logical connections depicted in FIG. 1 include a local area network (LAN) 154 and a wide area network (WAN) 156. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and Internet.
    </p>
    <p num="24">
      When used in a LAN networking environment, the personal computer 100 is connected to the local network 154 through a network interface or adapter 158.
      <br/>
      When used in a WAN networking environment, the personal computer 100 typically includes a modem 160 or other means for establishing communications over the wide area network 156, such as the Internet.
      <br/>
      The modem 160, which may be internal or external, is connected to the system bus 106 via the serial port interface 144.
      <br/>
      In a networked environment, program modules depicted relative to the personal computer 100, or portions thereof, may be stored in the remote memory storage device.
      <br/>
      It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.
    </p>
    <p num="25">Basic System</p>
    <p num="26">
      FIG. 2 is a general block diagram illustrating the interaction between the main components of the present invention.
      <br/>
      The present invention includes a resource manager 200, a plurality of consumers 212, 214, 216, and a plurality of resources 218, 220, 222.
      <br/>
      The resource manager 200 also has a 200 a handle administrator 230.
      <br/>
      The consumers 212, 214, 216 are software modules.
      <br/>
      The resources 218, 220, 222 are computer software resources, such as dynamic link library files.
      <br/>
      The software modules 212, 214, 216 may at some time require access (either sole or shared) to one or all of the resources 218, 220, 222.
      <br/>
      For instance, a printer driver software module usually requires access to a dynamic link library file resource.
    </p>
    <p num="27">
      The handle administrator 230 generates and validates reference markers or handles to provide consumer and resource administration facilities to the resource manager 200.
      <br/>
      The handle administrator 230 efficiently manages access to the resources 218, 220, 222 with the use reference handles.
      <br/>
      The handle administrator 230 intercedes with reference handles when a consumer requires access to a particular resource.
      <br/>
      Interceding involves issuing, to the consumer, a handle to a particular resource, rather than allowing the consumer a direct pointer to that particular resource.
      <br/>
      The consumer cannot use the handle to access the resource directly.
      <br/>
      Instead, the consumer presents the handle to the handle administrator 230, which first verifies that the handle is valid, then dereferences the handle to obtain a pointer to the resource for that consumer.
      <br/>
      Thus, interceding ensures that the particular resource still exists before the consumer is granted access to the particular resource.
    </p>
    <p num="28">
      In general, the handle administrator assigns, releases, and dereferences handles to the consumers 212, 214, 216 that point to the resources 218, 220, 222.
      <br/>
      The resource manager 200 is a software module that either maintains the resources 218, 220, 222 or at least intercedes in access by the consumers 212, 214, 216 to the resources 218, 220, 222.
      <br/>
      The resource manager 200 manages the handles that it issues to consumers 212, 214, 216.
    </p>
    <p num="29">
      FIG. 3 is a flow diagram illustrating the general operation of the handle administrator of the present invention.
      <br/>
      Referring to FIG. 2 along with FIG. 3, the handle administrator 230 implements the above described operations with an assignment routine 310 for issuing new handles, a release routine 312 for releasing handles that are no longer needed, and a dereference routine 314 for converting a handle into a pointer to a resource, including verifying that the handle is valid.
      <br/>
      The present invention provides each of these operations in the form of a function that can be invoked by code in the resource manager 200.
      <br/>
      Namely, these functions can be defined as an assign_handle( ) function, a release_handle( ) function, and a dereference_handle( ) function, respectively.
    </p>
    <p num="30">
      The assign_handle( ) function accepts a pointer to a resource and returns a handle that will henceforth refer to the pointer.
      <br/>
      The release_handle( ) function accepts a handle and marks it as invalid, such that it should no longer refer to a resource pointer, and returns a status code indicating whether the handle it was passed is a valid handle.
      <br/>
      The dereference_handle( ) function accepts a handle, checks its validity, and if the handle is valid, returns a pointer to the appropriate resource, but if the handle is invalid, returns a null pointer.
      <br/>
      The implementation of these functions is fairly complex, so the following section presents an incremental description of the handle administrator, beginning with the most basic system and progressively adding valuable features until the final system is reached.
    </p>
    <p num="31">
      A handle could in theory be any type of value, since it is opaque to the resource manager 200 and to the consumers 212, 214, 216.
      <br/>
      In the present invention, a handle is an unsigned integer.
      <br/>
      At its most basic, the data structure of the present invention comprises an array of records, each of which contains the fields described in Table 1.
    </p>
    <p num="32">
      -- TABLE 1
      <br/>
      -- Fields in each record of basic system
      <br/>
      --        Type             Field         Description
      <br/>
      --        Handle           handle        handle value
      <br/>
      --        Resource *       resource      pointer to resource
    </p>
    <p num="33">The nomenclature "Resource*" in Table 1 is defined as a "pointer to Resource." This nomenclature is standard in the C programming language and will be used throughout.</p>
    <p num="34">
      Initially, the handle value for each record is set equal to the index of that record, as indicated in the example of Table 2.
      <br/>
      Each currently valid handle corresponds to a record in the array.
    </p>
    <p num="35">
      -- TABLE 2
      <br/>
      -- Initial state of basic system of size 4
      <br/>
      -- Index                   handle  Resource
      <br/>
      -- 0                       0       Null
      <br/>
      -- 1                       1       Null
      <br/>
      -- 2                       2       Null
      <br/>
      -- 3                       3       Null
    </p>
    <p num="36">When the handle administrator 230 is asked to issue a new handle, via a call to assign_handle( ), it selects an unused record (box 320), sets the resource field of the record to the resource pointer that is passed as an argument (box 322), and returns the handle value in the handle field of the record (box 324).</p>
    <p num="37">
      For example, if the resource manager 200 calls assign_handle( ) with a pointer to resource A, the handle administrator may select the record at index 0, in which case it will set the resource field to point to resource A and return a handle value of 0 to the resource manager.
      <br/>
      The array of records will thus be modified as indicated in Table 3.
    </p>
    <p num="38">
      -- TABLE 3
      <br/>
      -- State of example basic system after one assignment
      <br/>
      -- Index                   handle  Resource
      <br/>
      -- 0                       0       A
      <br/>
      -- 1                       1       Null
      <br/>
      -- 2                       2       Null
      <br/>
      -- 3                       3       Null
    </p>
    <p num="39">
      When the handle administrator 230 is asked for the pointer that corresponds to a given handle, via a call to dereference_handle( ), it computes an index by taking the value of the handle modulo the size of the array (box 326), it compares the value in the handle field of the indexed record to the handle value that is passed as an argument (box 328), and it determines if the values match (box 330).
      <br/>
      If the two values match, the passed handle is judged to be valid (box 332), and the pointer in the resource field of the indexed record is returned (box 334).
      <br/>
      If the two values do not match, the passed handle is judged to be invalid (box 336), and a null pointer is returned (box 338).
    </p>
    <p num="40">
      For example, if the resource manager 200 calls dereference_handle( ) with a handle of value 0, the handle administrator 230 computes an index by taking this value modulo 4, yielding an index of 0.
      <br/>
      It then compares the handle to the value in the handle field of record 0.
      <br/>
      Since the two values match, the pointer to resource A is returned.
    </p>
    <p num="41">
      When the handle administrator 230 is asked to release a handle, via a call to release_handle( ), it computes an index by taking the value of the handle modulo the size of the array (box 340), it compares the value in the handle field of the indexed record to the handle value that is passed as an argument (box 342), and it determines if the values match (box 344).
      <br/>
      This comparison is not strictly necessary, but it is a simple check for an erroneous argument.
      <br/>
      If the two values do not match, the passed handle is judged to be invalid (box 346), and a failure status code is returned (box 348).
      <br/>
      Otherwise, it increments the value in the handle field by the size of the array (box 350), sets the resource field to a null pointer value (box 352), and returns a success status code (box 354).
      <br/>
      The reason for incrementing the handle value by the size of the array is so that the new value of the handle field will yield the same index when taken modulo the array size.
      <br/>
      The reason for setting the resource field value to null is so that the handle administrator can determine that the record is unused and that it therefore may be reassigned.
    </p>
    <p num="42">
      For example, if the resource manager calls release_handle( ) with a handle of value 0, the handle administrator computes an index by taking this value modulo 4, yielding an index of 0.
      <br/>
      It then compares the handle to the value in the handle field of record 0.
      <br/>
      Since the two values match, the value in the handle field is set to 4 and the value in the resource field is set to null.
      <br/>
      The array of records will thus be modified as indicated in Table 4.
    </p>
    <p num="43">
      -- TABLE 4
      <br/>
      -- State of example basic system after one release
      <br/>
      -- Index                   handle  resource
      <br/>
      -- 0                       4       null
      <br/>
      -- 1                       1       null
      <br/>
      -- 2                       2       null
      <br/>
      -- 3                       3       null
    </p>
    <p num="44">
      Now, if the resource manager calls dereference_handle( ) with a handle of value 0, the handle administrator computes an index by taking this value modulo 4, yielding an index of 0.
      <br/>
      It then compares the handle to the value in the handle field of record 0.
      <br/>
      Since the two values do not match, a null pointer is returned.
    </p>
    <p num="45">
      Next, suppose that the resource manager calls assign_handle( ) again, this time with a pointer to resource B. Furthermore, suppose that the handle administrator selects record 0, sets the resource field to point to resource B, and returns a handle value of 4 to the resource manager.
      <br/>
      The array of records will thus be modified as indicated in Table 5.
    </p>
    <p num="46">
      -- TABLE 5
      <br/>
      -- State of example basic system after another assignment
      <br/>
      -- Index                   handle  resource
      <br/>
      -- 0                       4       B
      <br/>
      -- 1                       1       null
      <br/>
      -- 2                       2       null
      <br/>
      -- 3                       3       null
    </p>
    <p num="47">
      If the resource manager calls dereference_handle( ) with a handle of value 4, the handle administrator computes an index by taking this value modulo 4, yielding an index of 0.
      <br/>
      It then compares the handle to the value in the handle field of record 0.
      <br/>
      Since the two values match, the pointer to resource B is returned.
      <br/>
      By contrast, if the resource manager calls dereference_handle( ) with a handle of value 0, the handle administrator computes an index by taking this value modulo 4, yielding an index of 0, which is the same index that it computed for a handle value of 4.
      <br/>
      However, when it compares this handle to the value in the handle field of record 0, the two values do not match, so a null pointer is returned.
    </p>
    <p num="48">Working Example</p>
    <p num="49">
      FIG. 4 is an architectural block diagram illustrating the main components and the sub-components of a working example of the present invention.
      <br/>
      Now that the basic system has be described above, the following sections below describe an incremental description of a working example of the handle administrator of the present invention, beginning with the auxiliary structure and progressively adding valuable features until the final working example is described.
    </p>
    <p num="50">Referring to FIG. 4, the assignment routine 310 of the handle administrator 230 includes an auxiliary sub-routine 402 for managing used and unused records, an expansion sub-routine 404 for efficiently expanding the handle database, a handle recycling sub-routine 406 for recycling handles, a memory allocation failure sub-routine 412, and a revocation sub-routine 414 for automatically revoking ancient handles.</p>
    <p num="51">
      The auxiliary sub-routine can have a linked list 420, binary tree 422, or any other 424 search tree sub-routine suitable for carrying out the invention.
      <br/>
      The expansion sub-routine 404 has a multi-threading sub-routine 426.
      <br/>
      The revoke sub-routine has a record processing 432 sub-routine for processing high and low records.
    </p>
    <p num="52">
      The release routine has a contraction sub-routine 434 and a hysteresis sub-routine 436.
      <br/>
      The contraction sub-routine 434 has a multi-threading sub-routine 437.
      <br/>
      The dereference routine 312 has a multi-threading sub-routine 438.
    </p>
    <p num="53">Auxiliary Structure</p>
    <p num="54">
      The following section describes the auxiliary sub-routine 402 of the present invention.
      <br/>
      As described above, the handle administrator 230, in response to each call to assign_handle( ), searches through the array to find an unused record.
      <br/>
      If the array size is very small, as it is in the above example, this is not a very expensive operation.
      <br/>
      However, the cost varies linearly with the array size, so it can be quite expensive if the array size is large.
      <br/>
      A simple optimization, such as maintaining a linked list of unused records can reduce this cost to a constant.
      <br/>
      When a new handle is to be issued, a record from this list is selected; and when a handle is released, the associated record is added to the list.
      <br/>
      This requires adding a new field to each record, as indicated in Table 6.
    </p>
    <p num="55">
      -- TABLE 6
      <br/>
      -- Fields in each record of basic system with list
      <br/>
      --      Type           Field          Description
      <br/>
      --      Handle         handle         handle value
      <br/>
      --      Resource *     resource       pointer to resource
      <br/>
      --      Record *       next record    pointer to next record in list
    </p>
    <p num="56">
      The new field, next_record, is a pointer to a record.
      <br/>
      A pointer to the head of the list is maintained, and each unused record contains a pointer to another record on the list, except the last, which contains a null pointer. (Note that array indices could have been used instead of pointers to link the records of the list.)
    </p>
    <p num="57">
      Further optimizations with linked lists 420 and search trees 422, 424 can be made depending on the desired efficiency of the system.
      <br/>
      For instance, when a new handle is to be issued, an optimization method can be implemented so that the proper record is selected from the unused records in the array with efficiency considerations.
      <br/>
      For example, if the record with the lowest index were selected, then the handle value in the lower records would tend to increase (as handles are assigned and released) faster than those in the upper records.
      <br/>
      Since the handle space is limited by the number of bits in the handle, eventually the lower records might exhaust all of their possible handle values well before the upper records consume a significant portion of their possible values, thus inefficiently utilizing the handle space.
      <br/>
      This problem can be eliminated by issuing handles from all records with relatively even frequency, which can be accomplished by issuing the lowest handle value among all unused records.
      <br/>
      To facilitate this procedure, the unused records should be stored in a structure that lends itself to rapid selection of the record with the lowest handle value, such as a search tree 422.
      <br/>
      However, searching for the lowest value in a set (or equivalently, inserting a new value in sorted position into a set) is an inherently logarithmic-time operation, rather than a constant time operation.
      <br/>
      It is rather desirable for the assign_handle( ) and release_handle( ) functions to be constant time, irrespective of the number of active handles.
    </p>
    <p num="58">
      The preferred approach preserves the constant-time operation of the assign and release functions (and does not interfere with the enhancements described in subsequent sections), and issues handles from the records with approximately even frequency.
      <br/>
      The approach is to use a linked list 420 as described above, wherein records are removed for assignment from the head of the list and are placed upon release at the tail of the list.
      <br/>
      This requires maintaining a pointer to the tail of the list in addition to the pointer to the head.
      <br/>
      Given a relatively random release pattern, this approach will tend to distribute the assignment of handles relatively evenly among the records.
      <br/>
      It should be noted that, given any auxiliary structure, it is no longer necessary for the handle administrator 230 to set the resource field value to null when a handle is released, since the record's presence in the structure indicates that it is unused.
    </p>
    <p num="59">Database Expansion</p>
    <p num="60">
      The following section describes the expansion sub-routine 404 which is utilized when the assign_handle( ) function is called but all records are in use.
      <br/>
      Without a mechanism to increase the size of the handle database, there is no desirable way to respond to a request for a handle assignment when the database is full: Either the request is rejected, or a handle entry is taken from those already in use.
      <br/>
      Broadly, the expansion sub-routine 404 is performed to increase the size of the array so that more records are available for assignment.
      <br/>
      However, it is not generally possible to allocate additional memory immediately following a given area of used memory, since that following memory area may be in use for storing other data.
      <br/>
      Therefore, increasing the size of the array requires allocating a separate, larger area of memory, copying the information from the smaller array into the larger array, and deallocating the memory for the smaller array.
      <br/>
      The new increased size is selected in a manner that preserves mapping of distinct handles to distinct entries.
    </p>
    <p num="61">For example, consider a full array of size 4 as illustrated in Table 7.</p>
    <p num="62">
      -- TABLE 7
      <br/>
      -- State of example basic system prior to expansion
      <br/>
      -- Index                   handle  resource
      <br/>
      -- 0                       4       B
      <br/>
      -- 1                       1       A
      <br/>
      -- 2                       10  D
      <br/>
      -- 3                       7       C
    </p>
    <p num="63">
      If the array size were increased to 6, then an attempt to dereference handle 7 would yield an index of 1 (=7 mod 6).
      <br/>
      However, an attempt to dereference handle 1 would also yield an index of 1, resulting in a conflict.
      <br/>
      In general, the expansion should be such that if two handles yield the same index in the larger array, then they should also have yielded the same index in the smaller array (although the converse is nether required nor desired).
      <br/>
      This can be accomplished by increasing the array size by an integral multiplicative constant.
      <br/>
      Choosing the constant and the initial array size to be powers of 2 simplifies the effort somewhat, since it allows simple bit manipulation operations to be employed in the place of more involved mathematical operations.
      <br/>
      For the remainder of the description, it is assumed that the multiplicative constant is 2, such that the size of the array is doubled with each expansion.
      <br/>
      Thus, the array size is increased to 8, as illustrated in Table 8.
    </p>
    <p num="64">
      -- TABLE 8
      <br/>
      -- State of example basic system after expansion
      <br/>
      --        Index  handle             resource  next record
      <br/>
      --        0      8                  null      3
      <br/>
      --        1      1                  A         Null
      <br/>
      --        2      10            D         Null
      <br/>
      --        3      11            null      6
      <br/>
      --        4      4                  B         Null
      <br/>
      --        5      5                  null      0
      <br/>
      --        6      14            null      Null
      <br/>
      --        7      7                  C         Null
    </p>
    <p num="65">
      Note that there are no conflicts among the assigned handles.
      <br/>
      Handles 1 and 10, which had previously yielded respective indices of 1 and 2 (1 mod 4=1; 10 mod 4=2), still do (1 mod 8=1; 10 mod 8=2); however, handles 4 and 7, which had previously yielded respective indices of 0 and 3 (4 mod 4=0; 7 mod 4=3), now yield respective indices of 4 and 7 (4 mod 8=4; 7 mod 8=7).
      <br/>
      After memory for the larger array is allocated, the records are copied from the smaller array to the larger array, in accordance with the indices computed with respect to the larger array.
      <br/>
      The resource pointers of all other records in the larger array are set to null values (although, as mentioned above, this is not strictly necessary if there is an auxiliary structure that keeps track of which records are unused).
      <br/>
      Values for the handle fields of these other records are computed as described below.
    </p>
    <p num="66">
      To begin with, it should be noted that there are two indices in the larger array that correspond to each index in the smaller array.
      <br/>
      For example, indices 0 and 4 in the larger example array above correspond to index 0 in the smaller example array, meaning that any handle value which yields an index of 0 or 4 in the larger array will yield an index of 0 in the smaller array.
      <br/>
      Thus, when the smaller array is expanded into the larger array, the record at index 0 in the smaller array belongs at either index 0 or index 4 in the larger array.
      <br/>
      These two indices are known as "duals" of each other.
      <br/>
      When copying a record from the smaller array into the larger array, the handle value modulo the new array size yields the index of one of the duals, into which is copied the record.
      <br/>
      The value for the handle field in the other dual is set equal to the copied record's handle value plus the size of the smaller array.
    </p>
    <p num="67">
      For instance, the record in index 0 of the small array illustrated in Table 7 has a handle value of 4.
      <br/>
      Taking this value modulo the larger array size (8) yields 4, so this record is copied into the record with index 4 in the larger array, as illustrated in Table 8.
      <br/>
      The dual of this record is record 0, so its resource pointer is set to null, and its handle value is set to 8 (4+4).
    </p>
    <p num="68">
      For a second example, the record in index 1of the small array illustrated in Table 7 has a handle value of 1.
      <br/>
      Taking this value modulo the larger array size (8) yields 1, so this record is copied into the record with index 1 in the larger array, as illustrated in Table 8.
      <br/>
      The dual of this record is record 5, so its resource pointer is set to null, and its handle value is set to 5 (1+4).
    </p>
    <p num="69">If the unused records are kept in an auxiliary structure as described in the previous section, the new unused records are inserted into that structure.</p>
    <p num="70">
      If, as described above, the size of the array is increased by a multiplicative constant, then the array will grow geometrically, which has the very desirable property that the mean time to issue a handle is asymptotically bounded by a constant.
      <br/>
      Specifically, consider that in the above example the array size grew from 4 to 8 in response to a single request to issue a handle.
      <br/>
      This required 4 records to be copied and 4 new records to be initialized.
      <br/>
      The next 3 handle assignments will not require expanding the array, so the average cost of issuing each of these 4 handles is one copy and one initialization.
      <br/>
      Similarly, if no handles are released, then the next assignment will grow the array size from 8 to 16, requiring 8 copies and 8 initializations.
      <br/>
      The next 7 handle assignments will not require expanding the array, so the average cost of issuing each of these 8 handles is one copy and one initialization.
      <br/>
      If any handles are released during such a sequence of operations, then the average cost per assignment will be lower.
      <br/>
      Thus, the array grows geometrically, and thus, the mean time to issue a handle is asymptotically bounded by a constant.
    </p>
    <p num="71">
      Table 8 also illustrates the next_record field of auxiliary sub-routine 402 described above.
      <br/>
      Although the next_record field is defined in Table 6 as a pointer to a record, in Table 8 it is shown as the index of a record for clarity.
      <br/>
      The goal of auxiliary sub-routine 402 is to maintain the unused records in a list that is approximately sorted by handle value.
      <br/>
      In Table 8, the list of unused records is shown as fully sorted, which is ideal but not guaranteed behavior.
      <br/>
      The head of the list is the record with index 5, which information is stored by sub-routine 402 in a location that is separate from the table itself.
      <br/>
      As seen in Table 8, the record with index 5 has a handle value of 5, which is the smallest unused handle value in the database.
      <br/>
      This record has a next_record value of 0, indicating that the next record in the list of unused records is the record with index 0, which has a handle value of 8.
      <br/>
      This record has a next_record value of 3, indicating that the next record in the list of unused records is the record with index 3, which has a handle value of 11.
      <br/>
      This record has a next_record value of 6, indicating that the next record in the list of unused records is the record with index 6, which has a handle value of 14.
      <br/>
      This record has a next_record value of null, indicating that it is the last unused record in the list.
      <br/>
      Thus, the list of unassigned handle values is seen to be in the order +5, 8, 11, 14}, which is correctly sorted.
      <br/>
      All records with assigned handles have next_record values of null.
    </p>
    <p num="72">Database Contraction</p>
    <p num="73">
      The following section describes the contraction sub-routine 434.
      <br/>
      Although contraction of the handle database is not necessary, it may be desirable, especially if the memory footprint of the handle administrator is critical.
      <br/>
      The contraction sub-routine 434 frees system memory.
      <br/>
      If more handles are required than there are records available in which to store them, then the database should be expanded with the expansion sub-routine 404.
      <br/>
      However, as handles are released, a situation could arise wherein far fewer handles are required than there are records.
      <br/>
      Although this does not cause direct functional problems, it can cause indirect problems, namely the consumption of more system resources (in particular, memory) than necessary.
    </p>
    <p num="74">
      As an example, consider a scenario in which, ordinarily, there are approximately 10 active handles at any given time, leading to an array size of 16, given the binary expansion described above.
      <br/>
      If, over a short period of time, the number of active handles increases to 1000, then the array size will increase to 1024.
      <br/>
      Once this brief burst is over, the number of active handles reduces to 10; however, if the array size remains at 1024, then 99% of the memory consumed by the handle administrator is being wasted.
    </p>
    <p num="75">
      The present invention thus includes a contraction sub-routine 434 for contracting the handle database.
      <br/>
      Although similar to the reverse of the expansion sub-routine, there are complex additions to the contraction sub-routine.
      <br/>
      First, whereas it is normally possible to expand the database (assuming more memory can be allocated), in some situations it is not possible to contract the database, even if the number of active handles is not greater than half of the array size.
      <br/>
      Consider the array of handle records illustrated in Table 9.
    </p>
    <p num="76">
      -- TABLE 9
      <br/>
      -- Example basic system in non-contractible state
      <br/>
      -- Index                   handle  resource
      <br/>
      -- 0                       16      null
      <br/>
      -- 1                        1 A
      <br/>
      -- 2                       10      D
      <br/>
      -- 3                       11      null
      <br/>
      -- 4                       12      null
      <br/>
      -- 5                        5 E
      <br/>
      -- 6                       22      null
    </p>
    <p num="77">-- 7                        7 C</p>
    <p num="78">
      Although this array of size 8 contains only 4 active handles, contraction of the array to a size 4 would cause a conflict.
      <br/>
      Specifically, handle 1 and handle 5 would both yield the same array index for their records (1 mod 4=5 mod 4=1).
      <br/>
      In other words, they are duals of each other, and since they are both assigned, they would conflict if the array size were reduced to 4.
      <br/>
      Two records that are duals of each other and are both assigned will be referred to hereinafter as an "assigned pair." In general, a handle array can be contracted only if it contains no assigned pairs, such as the array illustrated in Table 8.
    </p>
    <p num="79">
      The count of assigned pairs in the database can be tracked with the following process.
      <br/>
      When the database is initialized, or when it is expanded, the count of assigned pairs is set to zero.
      <br/>
      Whenever a handle is issued from a record whose dual already holds an assigned handle, then the assigned pair count is incremented by one.
      <br/>
      Whenever a handle is released from a record whose dual holds an assigned handle, then the assigned pair count is decremented by one.
      <br/>
      Recalculation of the assigned pair count after a contraction will be described in detail below.
    </p>
    <p num="80">
      In addition, there is a minimum array size restriction for the contraction sub-routine.
      <br/>
      Clearly, the array cannot be contracted if its size is one, but it is desirable to set a larger value for the minimum array size.
      <br/>
      Namely, the preferred method of the present invention requires a minimum array size of two, and therefore the array should be at least of size four before the contraction sub-routine is utilized.
      <br/>
      Other restrictions of the contraction sub-routine are desirable as well, and will be described in detail in a subsequent section.
    </p>
    <p num="81">It should be noted that the contraction sub-routine requires adding a new field to each record, as illustrated in Table 10.</p>
    <p num="82">
      -- TABLE 10
      <br/>
      -- Fields in each record of contractible system
      <br/>
      --        Type           Field            Description
      <br/>
      --        Handle         handle           handle value
      <br/>
      --        Handle         next handle      next handle value
      <br/>
      --        Resource *     resource         pointer to resource
    </p>
    <p num="83">
      The new field, next_handle, holds the next handle value that will be issued from the record.
      <br/>
      If the record is unused, then this value is equal to the handle value.
      <br/>
      If the record is in use, then this value is greater than the handle value by some multiple of the array size.
      <br/>
      An array of records containing the next_handle field is illustrated in Table 11.
      <br/>
      This example array will be used for the discussion of contraction.
    </p>
    <p num="84">
      -- TABLE 11
      <br/>
      -- State of example basic system prior to contraction
      <br/>
      --                                  next
      <br/>
      --        Index  handle             handle  resource
      <br/>
      --        0       8             8 null
      <br/>
      --        1      17                 17      null
      <br/>
      --        2      10                 18      D
      <br/>
      --        3      11                 11      null
      <br/>
      --        4       4             4 null
      <br/>
      --        5       5            13      E
      <br/>
      --        6      30                 30      null
      <br/>
      --        7       7            15      C
    </p>
    <p num="85">
      Note that the five records not containing assigned handles have handle and next_handle fields that are equal, whereas the three records containing assigned handles have handle and next_handle values that differ.
      <br/>
      By default, the difference between a record's handle value and its next_handle value is equal to the current array size.
    </p>
    <p num="86">
      Handle assignment and release involving this new field will now be discussed.
      <br/>
      If, for example, record 0 is selected to issue a handle, then the handle issued would have the value 8, and the next_handle field would be incremented by the array size, resulting in a value of 16.
      <br/>
      Further, when handle value 8 is released, then the handle field of record 0 is updated with the next_handle field of record 0, yielding the value of 16.
      <br/>
      Thus, use of the next_handle field serves to split into two steps the incrementing of a handle value by the array size that was described in a previous section.
    </p>
    <p num="87">
      The need for the next_handle field and its use in contraction will be described below.
      <br/>
      But first, Table 12 is shown to illustrate the state of the array after the contraction is complete.
    </p>
    <p num="88">
      -- TABLE 12
      <br/>
      -- State of example basic system after contraction
      <br/>
      --                                  next
      <br/>
      --        Index  handle             handle  resource
      <br/>
      --        0      4                   4 null
      <br/>
      --        1      5                  13      E
      <br/>
      --        2      10            26      D
      <br/>
      --        3      7                  11      C
    </p>
    <p num="89">
      The contraction sub-routine sets all three fields of each record.
      <br/>
      Specifically, for the resource field, if neither of the corresponding duals is in use, then the resource pointer is set to null.
      <br/>
      Otherwise, the resource pointer is set to the resource pointer of the record that is in use.
      <br/>
      For example, to set the resource pointer of record 0 in the smaller array the two corresponding dual records in the larger array (0 and 4) are examined.
      <br/>
      Since neither is in use, the appropriate value is a null pointer.
      <br/>
      For another example, to set the resource pointer of record 1 in the smaller array, the two corresponding dual records in the larger array (1 and 5) are examined.
      <br/>
      Since record 5 is in use, the appropriate value is copied from record 5 in the larger array, namely a pointer to resource E.
    </p>
    <p num="90">
      For the next_handle field, the larger of the next_handle fields is selected from each corresponding dual, and the size of the smaller array is subtracted from this value.
      <br/>
      For example, to set the next_handle field of record 0 in the smaller array, the two corresponding dual records in the larger array (0 and 4) are examined.
      <br/>
      Since the next_handle fields are respectively 8 and 4, and the larger of these is 8, the value of 8 is selected and then the size of the smaller array (4) is subtracted from 8 to get a value of 4.
    </p>
    <p num="91">
      This procedure guarantees that the next handle value issued from the new record will not be identical to a handle value that was already issued and released.
      <br/>
      For example, the record at index 1 of the larger array has a handle value of 17, implying that this record had previously issued a handle value of 9 (=17-8).
      <br/>
      Thus, when the array is contracted and the new record's next_handle field is set to 13, handle value 9 will not be re-issued.
      <br/>
      By contrast, if the next_handle field was not added to the records, then after handle 5 had been released, the next handle value issued from this record would have been computed as 9 (=5+4).
    </p>
    <p num="92">
      It should be noted that handle values that have never been issued may be eliminated.
      <br/>
      For example, the record at index 6 of the larger array has a handle value of 30, implying that this record had previously issued a handle value of 22 (=30-8).
      <br/>
      So, when the array is collapsed, the next_handle field of record 2 of the smaller array is set to 26, preventing handle value 22 from being re-issued.
      <br/>
      However, this next_handle value also prevents handle value 18 from being issued, even though it had not been issued before.
      <br/>
      But contracting the array is performed in order to reduce the space requirement of the database, so the space available to store such information is also reduced.
      <br/>
      Experiments have shown that even with highly fluctuating array sizes, if the handles are released randomly, then handle values are consumed only about 12% to 16% more rapidly than they would have been without contraction.
    </p>
    <p num="93">
      The handle field of each record is set with the following procedure.
      <br/>
      If neither of the corresponding duals is in use, then the handle value is set equal to the record's next_handle field.
      <br/>
      Otherwise, the handle value is set to the handle field of the record that is in use.
      <br/>
      For example, to set the handle value of record 0 in the smaller array, the two corresponding dual records in the larger array (0 and 4) are examined.
      <br/>
      Since neither is in use, the handle value is set to the next_handle value, which is 4.
      <br/>
      As another example, to set the handle value of record 1 in the smaller array, the two corresponding dual records in the larger array (1 and 5) are examined.
      <br/>
      Since record 5 is in use, the handle value is copied from record 5 in the larger array, specifically a value of 5.
    </p>
    <p num="94">
      Completing the contraction process requires an additional step, namely the recalculation of the assigned pair count.
      <br/>
      The process is straightforward and is as follows.
      <br/>
      The sub-routine iterates through half of the array, and at each step, if the record and its dual are both assigned, then the sub-routine increments the assigned pair count.
      <br/>
      Note that it is not necessary to zero the assigned pair count prior to this procedure.
      <br/>
      This is because it is already required to be zero for a contraction to occur.
      <br/>
      It is slightly easier to implement this procedure if the array is never smaller than two records, so that each record in the array has a dual.
    </p>
    <p num="95">
      Note that the procedures described in this section require determining whether an arbitrary record is assigned.
      <br/>
      If the only indication of a record's assignment status is the list on which the record is held, this status can be relatively expensive to determine.
      <br/>
      This is because it can require searching through the entire list.
      <br/>
      However, as indicated in previous sections, a record can be deemed unassigned by setting its resource pointer to null, which will allow a fast, constant-time determination of the record's assignment status.
      <br/>
      One potential problem with this technique is that a consumer could conceivably desire to assign a handle to a null pointer, and doing so would cause the handle administrator to incorrectly determine whether a record is assigned.
      <br/>
      As mentioned above, if a record is unassigned, then its next_handle value is equal to its handle value.
      <br/>
      In contrast, if a record is assigned, then its next_handle value is not equal to its handle value.
      <br/>
      This condition is checked by the present invention to determine whether a record is assigned.
    </p>
    <p num="96">Improving Contraction Opportunities</p>
    <p num="97">
      As mentioned in the previous section, contracting a handle array requires not merely that there be no more active handles than will fit in the contracted array but furthermore that the array contain no assigned pairs.
      <br/>
      As the array size grows, this becomes progressively less likely.
      <br/>
      The probability that a random configuration of n handles will yield no assigned pairs in an array of size m is given by the following formula:
      <br/>
      P(m, n)=1-U(m, n)/C(m, n)
    </p>
    <p num="98">C is the binomial coefficient of m and n, and U is given by the following recurrence:</p>
    <p num="99">U(m, n)=C(m-2, n-2)+2U(m-2, n-1)+U(m-2, n)U(2, 0)=0; U(2, 1)=0; U(2, 2)=1</p>
    <p num="100">
      This expression becomes computationally expensive to evaluate as the values of m and n increase.
      <br/>
      However, for some fairly small values, Table 13 shows the probability that no assigned pairs exist given various array sizes and various numbers of assigned handles.
    </p>
    <p num="101">
      -- TABLE 13
      <br/>
      -- Probability of contractibility for m records and n assigned handles
      <br/>
      --                  n = 2 n = 4 n = 8 n = 16
      <br/>
      --        m = 2 0         --     --   --
      <br/>
      --        m = 4 0.67      0           --   --
      <br/>
      --        m = 8 0.86      0.23        0         --
      <br/>
      --        m = 16 0.93      0.62        0.02      0
      <br/>
      --        m = 32 0.97      0.81        0.31      1.1e-4
    </p>
    <p num="102">
      As can be seen in Table 13, with an array size of 32, there is only a one-in-a-thousand chance that a random set of 16 assigned handles will happen to have no assigned pairs.
      <br/>
      Thus, although it might be desirable to contract such an array from 32 records to 16 records, it is not likely that this can be accomplished.
      <br/>
      Once the number of assigned handles drops to 8, then the probability rises to 31% that the array can be contracted to a size of 16, but then there is only a 2% probability that it can be contracted further to a size of 8.
    </p>
    <p num="103">
      Because the condition that enables contraction is relatively unlikely to arise on its own, it is desirable to actively pursue this condition.
      <br/>
      The handle administrator has no control over which handles are released, but it can control from which records handles are assigned, and this does present an avenue by which the expected number of assigned pairs can be reduced.
    </p>
    <p num="104">
      For instance, consider the handle array illustrated in Table 9.
      <br/>
      There is only one assigned pair of records, namely those with indices 1 and 5.
      <br/>
      Suppose that, prior to the release of either of these handles, the resource manager requests the issue of a new handle.
      <br/>
      In accordance with the auxiliary sub-routine, as described above, the selected record should be the one with the lowest handle value, which is record 3.
      <br/>
      However, if record 3 is selected, and then handle 1 is released, the array cannot be contracted.
      <br/>
      This is because there is still an assigned pair of records, namely those with indices 3 and 7.
      <br/>
      As such, the production of the assigned pair hindered the ability to contract the database.
      <br/>
      Alternately, if the handle was issued from either the record with index 0 or the record with index 4, then an assigned pair would not have been produced, and thus when handle 1 was released, the array could be contracted.
      <br/>
      Index 4 should be chosen over index 0, since it has a lower handle value.
    </p>
    <p num="105">
      As a result, a handle should be issued from a record that will not produce an assigned pair, if possible.
      <br/>
      One way to implement this requirement is to maintain two lists of unused records, one of which contains those records from which handles can be issued without producing an assigned pair, and one of which contains those records from which the issue of handles will produce an assigned pair.
      <br/>
      Then, only a handle is issued from the second list if the first list is empty.
    </p>
    <p num="106">
      As an example, for the handle array illustrated in Table 9, the primary list contains only record 4, whereas the secondary list contains records 0, 3, and 6.
      <br/>
      The reason that record 0 is on the secondary list, rather than on the primary list, is that once a handle is issued from record 4, issuing a handle from record 0 will produce an assigned pair.
      <br/>
      Record 4, rather than record 0, is on the first list because it has a lower handle value.
    </p>
    <p num="107">
      If handle 1 is released, then record 1 is placed onto the secondary list, since record 1's dual (record 5) has a handle that is assigned.
      <br/>
      If handle 10 is released, the handle value of record 2 is incremented by the array size to become 18, which is smaller than the handle value (22) of its dual (record 6), so record 2 is placed onto the primary list.
      <br/>
      If handle 7 is released, the handle value of record 7 is incremented by the array size to become 15, which is larger than the handle value (11) of its dual (record 3), so record 7 should be placed onto the secondary list, and record 3 should be relocated from the secondary list to the primary list.
      <br/>
      Since record 3 could be at any arbitrary location in the secondary list, it can be efficiently removed only if the list is doubly linked.
      <br/>
      Thus, a new field is added to each record, as illustrated in Table 14.
    </p>
    <p num="108">
      -- TABLE 14
      <br/>
      -- Fields in each record of contractible system with doubly linked list
      <br/>
      --      Type          Field         Description
      <br/>
      --      Handle        handle        handle value
      <br/>
      --      Handle        next handle   next handle value
      <br/>
      --      Resource *    resource      pointer to resource
      <br/>
      --      Record *      next record   pointer to next record in list
      <br/>
      --      Record *      prev record   pointer to previous record in list
    </p>
    <p num="109">The new field, prev_record, is a pointer to a record, and each unused record uses this field to point to the previous record of whichever list it is on.</p>
    <p num="110">
      After the contraction has been performed, each record has a different dual than it did before.
      <br/>
      For example, in Table 12, the dual of record 0 is record 2, whereas prior to the contraction, its dual was record 4.
      <br/>
      Similarly, the dual of record 1 is record 3, whereas prior to the contraction, its dual was record 5.
      <br/>
      Thus, it is determined on which list each unused record belongs, according to the new pairing arrangement.
    </p>
    <p num="111">
      Referring back to the example in which the array illustrated in Table 11 is contracted to the array illustrated in Table 12, prior to the contraction, the primary list contains record 4.
      <br/>
      Also, the secondary list contains records 0, 1, and 6, in this order (assuming that they are sorted correctly, which is likely but not guaranteed).
      <br/>
      After the contraction, the only unused records are those that correspond to a record on the primary list before the contraction.
      <br/>
      In the example, pre-contraction record 4 is the only one on the primary list, and the corresponding post-contraction record is record 0, which, as can be seen in Table 12, is the only unused record after the contraction.
    </p>
    <p num="112">
      Since it is desirable to preserve the order of the lists, this sub-routine of the present invention generates the new primary and secondary lists in two steps.
      <br/>
      First, in concert with calculating the new assigned pair count, each record and its dual are tagged with indications of the lists on which they belong.
      <br/>
      Second, the old primary list is iterated through and each record is placed onto the indicated list.
    </p>
    <p num="113">Contraction Hysteresis</p>
    <p num="114">
      In the previous section, a mechanism was presented to increase the likelihood that an array can be contracted.
      <br/>
      The following section describes a contraction hysteresis sub-routine 436 that delays contracting an array beyond the point at which it becomes possible to do so.
    </p>
    <p num="115">
      It was mentioned above that, if the array is expanded geometrically, then the mean time to issue a handle is asymptotically bounded by a constant.
      <br/>
      However, this is not guaranteed to be the case if the array is contracted as well as expanded.
      <br/>
      For instance, consider an example in which the number of active handles is 4 and in which the array size is also 4.
      <br/>
      When another handle is issued, the array is expanded to a size of 8, requiring 4 records to be copied and 4 records to be initialized.
      <br/>
      If this new handle is then released, the array can be contracted back to a size of 4, requiring the merging of 4 pairs of records.
      <br/>
      This sequence can be repeated indefinitely, such that each assignment will thus require 4 copies and 4 initializations, as the number of active handles oscillates between 4 and 5.
      <br/>
      Alternately, if the array size were to oscillate between 8 and 9, then each assignment would require 8 copies and 8 initializations.
      <br/>
      In general, if contractions are performed as soon as possible, the mean computational cost of an assignment becomes bounded by a linear function of the number of active handles, rather than by a constant.
    </p>
    <p num="116">
      The mean computational cost of assignments and releases can be returned to a constant value by adding appropriate hysteresis to the contraction operation.
      <br/>
      The method by which this hysteresis is achieved is as follows.
      <br/>
      A computational debt value is maintained.
      <br/>
      Initially, this value is set to zero, and each time an expansion operation is performed, the value is increased by the number of entry splitting operations, where a entry split comprises one entry copy and one entry initialization.
      <br/>
      Similarly, each time a contraction operation is performed, the value is increased by the number of record pairs merged.
      <br/>
      Each time an assignment or release operation is performed, the computational debt is decremented by one, with a lower limit of zero for the value of the debt.
      <br/>
      The array is only contracted if the computational debt is equal to zero.
    </p>
    <p num="117">
      Consider again the example above, in which the array size is increased from 4 to 8 when a fifth handle is assigned.
      <br/>
      Assuming that the computational debt was previously zero, this expansion causes the debt to be set to 4, and the accompanying assignment immediately decrements it to 3.
      <br/>
      If the handle is then released, this operation decrements the debt to 2, and since this is greater than zero, the array is not contracted.
      <br/>
      When the next handle is assigned, bringing the number of active handles back up to 5, the array need not be expanded, since it is already of size 8, and this assignment decrements the computational debt to 1.
      <br/>
      The next release decrements the computational debt to zero, so the array is then contracted if it can be; however, at this point, the cost of the previous expansion has been amortized over the previous two expansions and two contractions, so the mean cost per operation is a constant.
      <br/>
      Similarly, the present contraction will increase the computational debt to 4, so that the cost of the merges will be amortized over future assignment and release operations.
    </p>
    <p num="118">
      For large array sizes, tracking computational debt in the manner just described is very effective.
      <br/>
      However, for small array sizes, the cost of copying, initializing, and merging records is small relative to the cost of allocating and deallocating memory for expansions and contractions.
      <br/>
      Thus, even though the mean computational cost per operation is kept constant by this system, that constant value may be unacceptably high due to allocation/deallocation chatter.
      <br/>
      A simple solution to this problem is to add the cost of the allocation and deallocation operations into the computational debt incurred by expansion and contraction.
      <br/>
      The cost of memory allocation and deallocation was empirically determined for one specific implementation of the working example to be 12 times the cost of a single record-modifying operation.
      <br/>
      Thus, for this particular implementation, each time an expansion or contraction operation is performed, the computational debt is increased by a value of 12 plus the number of records that are modified.
    </p>
    <p num="119">Memory Allocation Failure</p>
    <p num="120">
      It is possible that an attempt to allocate memory will fail, and any system that allocates memory (such as the present invention) should be prepared to deal with allocation failure.
      <br/>
      The invention allocates memory on three occasions: at initialization, at each expansion, and at each contraction.
      <br/>
      If memory cannot be allocated at initialization, the creation of the handle administrator fails.
    </p>
    <p num="121">
      If memory cannot be allocated for an expansion, the obvious approach is to fail the attempt to assign a new handle for which there is no room in the array.
      <br/>
      However, there is an alternative approach, but it relies on modifying the semantics of the handle administrator.
      <br/>
      Up to this point, the system has functioned such that a handle is valid once it is assigned, and it remains valid until it is released.
      <br/>
      However, since a call to the dereference routine may return a null pointer, each consumer should be prepared for a handle to become invalid, if only because some other consumer may have released the handle.
      <br/>
      Thus, the new semantics empower the handle administrator to revoke handles, which will cause a handle to become invalid just as if it were released by an consumer.
    </p>
    <p num="122">
      Given this authority, the handle administrator can deal with a failed memory allocation by revoking one of the handles that are currently assigned and then assigning a new handle from this record.
      <br/>
      This approach may be desirable because the new handle is more likely to be used than a handle that was assigned a long time ago.
      <br/>
      This consideration suggests that the handle to revoke under these circumstances should be the oldest assigned handle, which requires keeping track of the order in which handles are assigned.
      <br/>
      Each record contains a pair of pointers to other records, and each unassigned record is on one of two lists.
      <br/>
      Up to this point, the assigned records have not been on any list, but it is trivial to place them on one such that they are in order of their assignment.
      <br/>
      Each time a record is assigned, it is placed at the tail of the list; when a record is released, it is removed from the list, and when a record is to be revoked due to memory allocation failure, it is taken from the head of the list.
      <br/>
      If memory cannot be allocated for a contraction, then the contraction is simply not performed.
      <br/>
      Since contracting the array is never necessary and can be delayed for other reasons as explained in the previous section, this response to allocation failure is acceptable.
    </p>
    <p num="123">Handle Recycling</p>
    <p num="124">
      As mentioned in the overview section, a handle is an unsigned integer.
      <br/>
      If the size of the integer is, for example, 32 bits, then there are only four billion or so unique handles that can be issued.
      <br/>
      In some scenarios, this may be sufficient.
      <br/>
      However, in others, it may not be.
      <br/>
      For instance, long-lived systems that assign and release handles very frequently may exhaust the handle space.
      <br/>
      One alternative to this problem is to make the handles bigger, but there may be cases for which this is either not practical or not sufficient.
      <br/>
      Another alternative is to utilize a recycle handle sub-routine 406 for recycling handles that have been invalid for a long time, under the theory that agents have had ample opportunity to notice that the handles have become invalid and are thus not going to attempt to dereference them again.
      <br/>
      It should be noted that the handle recycling sub-routine 406 is an optional function.
    </p>
    <p num="125">
      The handle recycling sub-routine 406 provides efficient handle recycling.
      <br/>
      If the handle value in a record is increased to a value beyond the representable range, then the value "wraps around" to a value which is equal to the larger value modulo the number of values in the representable range.
      <br/>
      For example, if the handle value (in hexadecimal) is FFFFFFFA, and this is increased by 8 (assuming that is the array size), then the result is 2, which is a handle value that was probably issued approximately four billion handle issuances earlier.
      <br/>
      There is, however, a danger that even though this handle value was issued a long time ago, it may have been released only recently.
      <br/>
      Thus, a consumer holding this handle may not yet have had the opportunity to notice that the handle has become invalid.
      <br/>
      A solution to this potential problem is to revoke any handles that become older than a set cutoff, so that consumers have sufficient opportunity to notice that the handles have become invalid.
    </p>
    <p num="126">
      Thus, the present invention periodically revokes very old handles.
      <br/>
      The mechanism by which this is accomplished is as follows.
      <br/>
      First, two quantities are defined, the maximum handle range and the handle range step.
      <br/>
      For the following examples, it is assumed that the handles are 16-bit integers, that the maximum handle range is (hexadecimal) 9000, and that the handle range step is (hexadecimal) 2000.
      <br/>
      Initially a base value is set to 0, and a threshold value is set to the base value plus the maximum handle range, which in this case is 9000, as illustrated in FIG. 5.
      <br/>
      The shaded region in the figure illustrates the valid range of assigned handles, which is shown as 0 to about 2400, meaning that the largest handle value issued was about 2400.
    </p>
    <p num="127">
      As more handles are issued, the range of assigned handles grows.
      <br/>
      Once a handle value greater than the threshold value is issued, the system scans through all records in the array and revokes any handle within the range from the handle base (in this case 0) to the handle base plus the handle range step (in this case 2000).
      <br/>
      Then, the handle base and the threshold are increased by the handle range step, as shown in FIG. 6.
    </p>
    <p num="128">
      In all likelihood, there are very few (perhaps no) handles in this range, so the actual effect of this procedure is often unseen from outside the handle administrator.
      <br/>
      Once this procedure is completed, handles can continued to be issued until the next threshold value is reached, at which point another revocation pass is performed.
      <br/>
      Eventually, the threshold value will wrap around, as shown in FIG. 7.
    </p>
    <p num="129">
      Additionally, a comparison modification is utilized to enable the comparison of handle values to be performed correctly even after the values have wrapped around.
      <br/>
      In several places in the above-described methods, two handle values are compared to determine which one is larger.
      <br/>
      If handle values are allowed to wrap around, then this comparison is made relative to the handle base value, rather than as an absolute comparison.
      <br/>
      For example, consider the two handles E320 and 1162 in the scenario illustrated in FIG. 7.
      <br/>
      A standard comparison would conclude that E320 is the larger value.
      <br/>
      However, as can be seen in FIG. 7, this value is actually smaller than the other relative to the handle base value.
      <br/>
      In other words, if the range were to be shifted until the handle base were at zero, then this handle would be smaller.
    </p>
    <p num="130">
      This comparison can be performed correctly by first subtracting the handle base value from each handle value before comparing the result: E320-C000=2320 and 1162-C000=5162, and 2320 is less than 5162.
      <br/>
      Note that the subtractions implicitly wrap around for the same reason that addition implicitly wraps around.
      <br/>
      Namely, it is a by-product of integer math on a digital computer.
    </p>
    <p num="131">Multi-Threading</p>
    <p num="132">
      The handle administrator may be deployed in a multi-threaded environment with multi-threading sub-routines 426, 437, 438 for the assignment, release, and dereference routines 310, 314, 312, respectively.
      <br/>
      Due to the potential for conflicts in multi-threaded environments, it is common to employ locks to prevent different threads from interfering with each other in their use of a common data structure.
      <br/>
      There are two locking strategies that are common, single-access and single-writer/multi-reader.
      <br/>
      In single-access locking, only one thread may have access to the database at any given time, no matter what the thread is doing with the database.
      <br/>
      In single-writer/multi-reader, either one thread may access the database with read/write privileges, or any number of threads may access the database with read-only privileges.
      <br/>
      The second type of locking is clearly less restrictive and therefore preferable, if it can be supported.
      <br/>
      The present invention contains a mechanism that allows an even less restrictive form of locking.
      <br/>
      In this case, only one thread may access the database with read/write privileges, but any number of other threads may access the database with read privileges, even during the write access.
    </p>
    <p num="133">
      In particular, the system contains a lock.
      <br/>
      In order to invoke the assign_handle( ) routine, this lock is first taken.
      <br/>
      In order to invoke the release_handle( ) routine, this lock is first taken.
      <br/>
      However, a lock need not be taken in order to invoke dereference_handle( ).
      <br/>
      This is achieved with two different techniques, as described in this section.
    </p>
    <p num="134">
      To begin with, consider the situations in which multi-threading can cause problems.
      <br/>
      One situation occurs when the dereference_handle( ) routine attempts to validate a handle that is in the process of being invalidated by a call to release_handle( ) that is occurring in another thread.
      <br/>
      For correct behavior, the system behaves as though these two operations occur sequentially, even though they might in practice partially overlap.
      <br/>
      If the dereferencing occurs before the releasing, then a valid pointer will be returned; if the dereferencing occurs after the releasing, then a null pointer will be returned, indicating that the handle is not valid.
      <br/>
      The danger of multi-threading is that an invalid pointer will be returned.
      <br/>
      This can be avoided, without using locks, by careful ordering of read and write operations.
      <br/>
      The dereference_handle( ) routine performs steps in the following order:
    </p>
    <p num="135">Read value of pointer from record and store locally.</p>
    <p num="136">Read value of handle from record and validate against passed handle.</p>
    <p num="137">If handle is valid, return locally stored pointer; otherwise, return null pointer.</p>
    <p num="138">
      The alternate, and more natural, order is for the routine to first validate the handle and then read the pointer from the record.
      <br/>
      However, it is possible that, in between these two operations, the record will be invalidated and then reassigned to another pointer, and thus the wrong pointer will be returned by the dereference routine.
    </p>
    <p num="139">
      The above situation concerned the problem of safely invalidating handles.
      <br/>
      Another potential problem occurs with resizing the array.
      <br/>
      When the array is resized, a new array is allocated, and information from the old array is copied with modification into the new array.
      <br/>
      During this copying, the old array is unmodified, so handles can still be dereferenced by using the old array.
      <br/>
      Once the copying is complete, handles can be dereferenced by using either array, so at this point the system can safely switch the array pointer from the old array to the new array, after which it can safely deallocate the old array.
      <br/>
      It is important that the pointer to the array and the array size be switched simultaneously.
      <br/>
      If the dereference routine were to use an inconsistent set of these values when looking for a handle's record, it would compute the wrong array index from the handle value.
    </p>
    <p num="140">
      The system ensures that the two values are seen consistently by making use of two auxiliary variables called verifiers.
      <br/>
      Ordinarily, the two verifiers have the same value, but they are set to different values (by the expand and contract routines) when the array pointer and array size might be inconsistent.
      <br/>
      The verifiers are read and checked by the dereference routine to determine the consistency of the array pointer and array size variables.
      <br/>
      Between copying the records to the new array and deallocating the old array, the expand and contract procedures perform the following steps in order:
      <br/>
      Increment verifier 0.
    </p>
    <p num="141">Update array pointer and array size.</p>
    <p num="142">Set verifier 1 equal to verifier 0.</p>
    <p num="143">
      The dereference routine performs the following steps in order:
      <br/>
      Read value of verifier 1 and store locally.
    </p>
    <p num="144">Read array pointer and array size.</p>
    <p num="145">Compute record index.</p>
    <p num="146">Read values of pointer and handle from indexed record.</p>
    <p num="147">Read value of verifier 0 and compare to locally stored value of verifier 1.</p>
    <p num="148">If verifiers do not match, then repeat all above steps.</p>
    <p num="149">
      The repeat clause in the above procedure means that the dereference routine might spin for a while as it waits for the other thread to complete the array resizing.
      <br/>
      However, this is very unlikely, since the time during which the verifiers do not match is extremely short.
    </p>
    <p num="150">Integrated Components</p>
    <p num="151">
      The following section details an example of the present invention with the above-described components in an integrated system.
      <br/>
      FIGS. 8-15 illustrate an integrated system including the assignment routine, the release routine, the dereference routine, the expansion sub-routine, the contraction sub-routine, the record updating sub-routine, the revoke sub-routine, and the record processing sub-routine as described in the above working example.
      <br/>
      It should be noted that all addition and subtraction operations are implicitly performed modulo the size of the handle space, and all comparison operations are performed relative to the handle base value, as described in the section above on handle recycling.
    </p>
    <p num="152">
      FIG. 8 is a flow diagram illustrating the assignment routine of the present invention.
      <br/>
      The routine is started (box 800) and then it is determined whether the population is less than the array size (is any entry in the array currently unassigned?) (box 802).
      <br/>
      If the population is not less than the array size, then an attempt to expand the array with the expansion sub-routine (see FIGS. 11A and 11B) is performed (box 804).
      <br/>
      It is then determined whether the expansion was successful (box 806).
      <br/>
      If the expansion was not successful, then the operation of the routine depends on how the system has been configured.
      <br/>
      Namely, if the system has been configured not to allow the handle administrator to revoke issued handles, then the routine returns with a failure code (dashed line to box 810).
      <br/>
      However, if the handle administrator has been configured with the authority to revoke issued handles, then it executes a memory allocation failure sub-routine (box 808).
      <br/>
      The memory allocation failure subroutine revokes the least-recently assigned handle in order to free an entry in the handle database for a new handle assignment.
      <br/>
      It performs this revocation by moving the least-recently assigned record from the assigned list to the secondary list, setting the record's handle equal to the next handle, decrementing the assigned pair count, and decrementing the population (box 808).
    </p>
    <p num="153">
      After either decrementing the population (box 808) or if the database expansion is successful (box 806) or if the population is less than the array size (box 802), steps are performed to improve contraction opportunities.
      <br/>
      This entails first determining whether the primary list is empty (box 812).
      <br/>
      If the primary list is not empty, then the primary list is indicated (box 814).
      <br/>
      If the primary list is empty, then the secondary list is indicated and the assigned pair count is incremented (box 816).
      <br/>
      In either case, next, the record is moved from the head of the indicated list to the tail of the assigned list, the record's resource pointer is set, the record's next handle is a incremented by the array size, the population is incremented, and the computational debt is decremented limited to zero for contraction hysteresis (box 818).
      <br/>
      It is then determined whether the handle value is greater than a threshold value (box 820).
      <br/>
      If the handle value is greater than the threshold value, then the revoke ancient handles sub-routine is performed (see FIG. 14) (box 822), and the record's handle is returned (box 824).
      <br/>
      If however the handle value is not greater than the threshold value, then the record's handle is returned (box 824) without first performing the revoke ancient handles sub-routine.
    </p>
    <p num="154">
      FIG. 9 is a flow diagram illustrating the release routine of the present invention.
      <br/>
      The function starts (box 900) and then computes the record index (box 902).
      <br/>
      Next, it is determined whether the record matches the handle (box 904).
      <br/>
      If the record does not match the handle, then an fail code is returned (box 906), indicating that the handle is invalid.
      <br/>
      If the record does match the handle, it is determined whether the record's dual has been assigned (box 908).
    </p>
    <p num="155">
      If the record's dual has not been assigned, then it is determined whether the dual's next handle is less than the record's next handle (box 910).
      <br/>
      If the dual's next handle is not less than the record's next handle, then the primary list is indicated (box 912).
      <br/>
      If the dual's next handle is less than the record's next handle, then the dual is moved from the secondary list to the tail of the primary list, and the secondary list is indicated (box 914).
      <br/>
      If however, the record's dual has been assigned (as determined in box 908), the secondary list is indicated, and the assigned pair count is decremented (box 916).
    </p>
    <p num="156">
      After either the primary list is indicated (box 912), the secondary list is indicated (box 914), or the assigned pair count is decremented (box 916), the record from the assigned list is moved to the tail of the indicated list, the record's handle is set equal to the next handle, the population is decremented, and the computational debt is decremented, limited to zero (box 918).
      <br/>
      Next, it is determined whether the array size is greater than two, whether the assigned pair count is equal to zero, and whether the debt is equal to zero (box 920).
      <br/>
      If all of the aforementioned are true, then the contraction sub-routine is called (see FIGS. 12A and 12B) (box 922).
      <br/>
      If the contraction was successful a valid success code is returned (box 924).
      <br/>
      If the steps of box 918 are false, then the sub-routine returns (box 924) with a success code.
    </p>
    <p num="157">
      FIG. 10 is a flow diagram illustrating the dereference routine of the present invention.
      <br/>
      The function can operate in a multi-threaded environment by starting (box 1000) and then making a local copy of verifier 1 (box 1002).
      <br/>
      Next, the record index is computed given an array size (box 1004).
      <br/>
      A local copy of the record's resource pointer is then made (box 1006).
      <br/>
      Next, a local copy of record's handle value is made (box 1008).
      <br/>
      It is then determined whether the local verifier matches verifier 0 (box 1010).
      <br/>
      If the local verifier does not match verifier 0, the above steps are repeated (boxes 1002-1008).
      <br/>
      If the local verifier does match verifier 0, then it is determined whether the local copy of the record's handle matches the handle (box 1012).
      <br/>
      If the local copy of the record's handle matches the handle, then the local copy of the record's pointer is returned (box 1014).
      <br/>
      If however, the local copy of the record's handle does not match the handle, then a null pointer is returned (box 1016).
    </p>
    <p num="158">
      FIGS. 11A and 11B are flow diagrams illustrating the expansion sub-routine of the assignment routine of the present invention.
      <br/>
      The function starts (box 1100) and then a new array of double size is allocated (box 1102).
      <br/>
      Next, it is determined whether the allocation was successful (box 1104).
      <br/>
      If the allocation was not successful, then an expansion fail code is returned (box 1106).
      <br/>
      If the allocation was successful, then an old record variable is set to the first record in the old array (box 1108).
      <br/>
      Next, the new record index for the old record's next handle is computed, the new record's next handle is set to the old record's next handle, and the new record's dual's next handle is set to the old record's next handle plus the old array size (box 1110).
      <br/>
      The new record's index for the old record's handle is computed, the new record's handle is set to the old record's handle, the new record's resource pointer is set to the old record's resource pointer, the old record on the assigned list is replaced with a new record, and the new record's dual handle is set to the new record's dual's next handle (box 1112).
      <br/>
      Next, the old record variable is set to the next record in the old array (box 1114).
      <br/>
      It is then determined whether the records are exhausted (box 1116).
      <br/>
      If the records are not exhausted, the steps in boxes 1110-1114 are repeated.
      <br/>
      These steps are cycled until all the records are exhausted (box 1116).
    </p>
    <p num="159">
      When the records are exhausted, the unassigned records are placed on the secondary list in the order of the duals on the assigned list, and the debt is increased by the memory allocation cost plus the old array size (box 1118).
      <br/>
      Verifier 0 is incremented, the array size and the array pointer are updated, and verifier 1 is set equal to verifier 0 (box 1120).
      <br/>
      The old array is deallocated, and the assigned pair count is set to zero (box 1122).
      <br/>
      Then, an expansion success code is returned (box 1124).
    </p>
    <p num="160">
      FIGS. 12A and 12B are flow diagrams illustrating the contraction sub-routine of the assignment and release routines of the present invention.
      <br/>
      The function starts (box 1200), and then a new array of half size of the previous array is allocated, and a tag array of this same size is allocated (box 1202).
      <br/>
      It is then determined if the allocations were successful (box 1204).
      <br/>
      If either allocation was not successful, the contraction sub-routine is terminated and contraction is not performed (box 1206).
      <br/>
      If the allocations were successful, then a low record 0 variable is set to the first record in the old array, a low record 1 variable is set to the record in the old array 1/4 up from the first record, a high record 0 variable is set to the record in the old array 1/2 up from the first record, a high record 1 variable is set to the record in the old array 3/4 up from the first record, a new record 0 variable is set to the first record in the new array, and a new record 1 variable is set to the record in the new array 1/2 up from the first record (box 1208).
      <br/>
      The handle, the next handle, and the resource pointer are then set for new record 0, and the appropriate record on the list is replaced with the new record 0 (box 1210), as illustrated in detail in FIG. 13. Next, the handle, the next handle, and the resource pointer are set for new record 1, and the appropriate record on the list is replaced with the new record 1 (box 1212), as illustrated in detail in FIG. 13. It is then determined whether both new records are unassigned (box 1214).
      <br/>
      If both new records are unassigned, then the record with the smaller handle value is tagged for the primary list and the record with the larger handle value is tagged for the secondary list (box 1216).
      <br/>
      If at least one new record is assigned, then both records are tagged for the secondary list (box 1218), although only the unassigned record will actually be placed on the secondary list by subsequent steps in the routine.
      <br/>
      It is then determined whether both new records are assigned (box 1220).
      <br/>
      If both new records are assigned, then the assigned pair count is incremented (box 1222).
      <br/>
      If either both new records have not been assigned (box 1220) or after the record with the larger handle value is tagged for the secondary list (box 1216) or after the assigned pair count is incremented (box 1222), each record pointer is set to the next record in the array (box 1224).
      <br/>
      Next, it is determined whether all records have been exhausted (box 1226).
      <br/>
      If the records have not been exhausted, the routine cycles through the steps in boxes 1210-1224.
      <br/>
      If however, the records are exhausted, each unassigned record is placed on the list for which it has been tagged, in the same order as the current unassigned list.
      <br/>
      The debt is increased by the memory allocation cost plus the old array size (box 1228).
      <br/>
      Next, verifier 0 is incremented, the array size and array pointer are updated, and verifier 1 is set equal to verifier 0 (box 1230).
      <br/>
      The old array and tag array are then deallocated, and the assigned pair count is set to zero (box 1232).
      <br/>
      The sub-routine then returns (box 1234).
    </p>
    <p num="161">
      FIG. 13 is a flow diagram illustrating the record updating sub-routine of the contraction sub-routine of FIGS. 12A and 12B.
      <br/>
      The function starts (box 1300) and then the new record's next handle is set to the larger of next handles from high and low records minus the new array size (box 1302).
      <br/>
      Next, it is determined whether the high or low record has been assigned (box 1304).
      <br/>
      If the high or low record has been assigned, then the assigned record's handle and resource pointer are copied to the new record, and the assigned record on the assigned list is replaced with the new record (box 1306).
      <br/>
      If, however, the high or low record has not been assigned, the new record's handle is set equal to the new record's next handle, and the old record with the smaller handle value on the primary list is replaced with the new record (box 1308).
      <br/>
      After either the assigned record on the assigned list is replaced with the new record (box 1306) or the old record with the smaller handle value on the primary list is replaced with the new record (box 1308), the sub-routine returns (box 1310).
    </p>
    <p num="162">
      FIG. 14 is a flow diagram illustrating the revoke ancient handles sub-routine of the assignment sub-routine of the present invention.
      <br/>
      The function starts (box 1400), and then a low record variable is set to the first record in the array, and a high record variable is set to the record in the array 1/2 up from the first record (box 1402).
      <br/>
      Next, it is determined whether there is at least one handle in the revocation range (box 1404).
      <br/>
      The revocation range begins at the handle base, and the size of the revocation range is equal to the handle range step.
      <br/>
      If at least one handle is in the revocation range, then it is determined whether both records are assigned (box 1406).
      <br/>
      If both records are assigned, then the assigned pair count is decremented (box 1408).
      <br/>
      If both records are not assigned or after the assigned pair count is decremented (box 1408), the low record (box 1410) and the high record (box 1412) are each processed in accordance with the steps of FIG. 15. Next, it is determined whether either record is assigned (box 1414).
      <br/>
      If either record has been assigned (box 1414), the other record is placed on the secondary list (box 1416).
      <br/>
      If either record has not been assigned, the record with the smaller handle value is placed on the primary list and the record with the larger value is placed on the secondary list (box 1418).
      <br/>
      After either the other record is placed on the secondary list (box 1416), the record with the larger handle is placed on the secondary list (box 1418), or if at least one handle is not in the revocation range (box 1404), each record pointer is set to the next record in the array (box 1420).
      <br/>
      Next, it is determined whether all records have been exhausted (box 1422).
      <br/>
      If the records have been not exhausted, the above routine is processed again (boxes 1404-1420).
      <br/>
      When the records are exhausted, the handle database and threshold are increased by the handle range step (box 1424) and then the sub-routine returns (box 1426).
    </p>
    <p num="163">
      FIG. 15 is a flow diagram illustrating the record processing sub-routine of the revoke ancient handles sub-routine of FIG. 14. The function starts (box 1500), and then it is determined whether the record is unassigned or in the revocation range (box 1502).
      <br/>
      If the record is unassigned or in the revocation range, the record is removed from the list (box 1504).
      <br/>
      If the record is assigned or is not in the revocation range (box 1502) or after the record is removed from the list (box 1504), it is determined whether the record handle is in the revocation range (box 1506).
      <br/>
      If the record is not in the revocation range, the routine is terminated (box 1508).
      <br/>
      If the record is in the revocation range, it is determined whether the record has been assigned (box 1510).
      <br/>
      If the record has been assigned, the population is decremented (box 1512).
      <br/>
      If the record was not assigned (box 1510) or after the population is decremented, the record's next handle value is increased to the base value plus the handle range step plus the index of the record, unless it is already greater, and the handle value is set equal to the next handle value (box 1514).
      <br/>
      The sub-routine then returns (box 1516).
    </p>
    <p num="164">
      The foregoing description of the invention has been presented for the purposes of illustration and description.
      <br/>
      It is not intended to be exhaustive or to limit the invention to the precise form disclosed.
      <br/>
      Many modifications and variations are possible in light of the above teaching.
      <br/>
      It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5.</claim-text>
      <claim-text>A computer-implemented method for managing data access to at least one resource of a computer system in a multi-threaded environment, said method comprising: allocating an area in computer readable memory for an original handle database containing a plurality of reference handles; assigning a reference handle by generating a unique value for an assigned reference handle and associating said reference handle with the resource with a resource pointer; determining and storing a pointer value of said resource pointer; verifying validity of said reference handle and retrieving and providing said stored pointer value if said verified reference handle is deemed valid; issuing a new reference handle to a consumer when said consumer requires access to at least one of the resources; associating said issued reference handle with said resource requiring access by assigning a unique value to said issued reference handle; releasing issued reference handles and deeming their respective handle values as being unassigned for reference handles that are no longer required by consumers and classifying said released handles as invalid;</claim-text>
      <claim-text>and wherein said method generates and validates reference handles for providing efficient management and administration of consumers' access to resources in computer systems.</claim-text>
      <claim-text>1. A computer-implemented method for managing data access to at least one resource of a computer system in a multi-threaded environment, said method comprising:</claim-text>
      <claim-text>allocating an area in computer readable memory for an original handle database containing a plurality of reference handles; assigning a reference handle by generating a unique value for an assigned reference handle and associating said reference handle with the resource with a resource pointer; determining and storing a pointer value of said resource pointer; verifying the existence of said reference handle;</claim-text>
      <claim-text>and retrieving and providing said stored pointer value if said verified reference handle is deemed to have an existing value.</claim-text>
      <claim-text>2. The method of claim 1, further comprising providing a null pointer if said verified reference handle is deemed invalid.</claim-text>
      <claim-text>3. The method of claim 1, wherein said verifying step comprises in consecutive order: a) reading the resource pointer; b) reading and verifying the handle value;</claim-text>
      <claim-text>and c) returning the pointer.</claim-text>
      <claim-text>4. The method of claim 1, further including recycling handle values.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 5, further comprising managing assigned and unassigned handle values with a set of records, each record containing fields, one field of each record being a handle value field indicating a handle value.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 6, wherein said managing assigned and unassigned handle values comprises: maintaining a list of records, wherein the handle value fields of said records indicate unassigned handle values; selecting a handle value from said list with indicia of unassigned handle values when a new handle is to be issued;</claim-text>
      <claim-text>and adding a released handle value to said list with indicia of unassigned handles when a handle is released.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The method of claim 7, wherein said maintained list is a linked list, wherein issued handles are assigned previously unassigned handle values from records at a head portion of said list and wherein released handles values are placed in records at a tail portion of said list.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The method of claim 7, wherein said maintained list is a search tree and wherein an unassigned handle value with the lowest handle value among all unassigned handle values is selected first to be assigned to an issued handle.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. A computer-implemented method for managing data access to at least one resource of a computer system in a multi-threaded environment, said method comprising: allocating an area in computer readable memory for an original handle database containing a plurality of reference handles; issuing a new handle to a consumer when said consumer requires access to at least one of the resources; associating said issued handle with said resource requiring access by assigning a unique value to said issued handle; allocating an area in said computer readable memory for a modified handle database created having a size of a multiplicative constant different than said original handle database size; copying data located in said original handle database into said modified handle database; reading a size value of said modified database; simultaneously and consistently utilizing said size value of said modified database and a database pointer value to said modified database for reorganizing said copied data in said modified handle database so as to prevent a future conflict in handle values;</claim-text>
      <claim-text>and deallocating said area in said computer readable memory occupied by said original handle database.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The method of claim 10, wherein said reading and utilizing steps comprise: initiating a first verifier and assigning a value to said first verifier; initiating a second verifier and assigning a matching value of said first verifier; incrementing said value of said first verifier; updating said database pointer value and said size of said modified database after a modified database is created;</claim-text>
      <claim-text>and setting a second verifier equal to said first verifier.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 11, further comprising: (a) reading and storing said value of said second verifier; (b) reading said database pointer value and said size of said modified database; (c) computing a record index of said modified database from said original database, said indexed record containing a reference handle value and resource pointer value; (d) reading values of said resource pointers and said reference handles from said indexed record; (e) reading a value of said first verifier and comparing said read value with said stored value of said second verifier;</claim-text>
      <claim-text>and (f) repeating steps (a)-(e) until said first verifier value matches said second verifier value.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 10, further comprising: issuing a new reference handle to a consumer when said consumer requires access to at least one of the resources; associating said issued reference handle with said resource requiring access by assigning a unique value to said issued reference handle; releasing issued reference handles and deeming their respective handle values as being unassigned for reference handles that are no longer required by consumers and classifying said released handles as invalid;</claim-text>
      <claim-text>and wherein said method generates and validates reference handles for providing efficient management and administration of consumers' access to resources in computer systems.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 13, further comprising managing assigned and unassigned handle values with a set of records, each record containing fields, one field of each record being a handle value field indicating a handle value.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method of claim 14, wherein said managing assigned and unassigned handle values comprises: maintaining a list of records, wherein the handle value fields of said records indicate unassigned handle values; selecting a handle value from said list with indicia of unassigned handle values when a new handle is to be issued;</claim-text>
      <claim-text>and adding a released handle value to said list with indicia of unassigned handles when a handle is released.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 15, wherein said maintained list is a linked list, wherein issued handles are assigned previously unassigned handle values from records at a head portion of said list and wherein released handles values are placed in records at a tail portion of said list.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method of claim 15, wherein said maintained list is a search tree and wherein an unassigned handle value with the lowest handle value among all unassigned handle values is selected first to be assigned to an issued handle.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method of claim 10, further including recycling handle values.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. A management device operating in a multi-threaded environment for managing data access to a plurality of resources stored on computer readable memory of a computer system, said management device comprising: an original handle database stored in the computer readable memory of the computer system and containing a plurality of reference handles; a plurality of consumers randomly requiring access to said resources;</claim-text>
      <claim-text>and a handle administrator comprising an assignment module for assigning a reference handle by generating a unique value for an assigned reference handle and associating said reference handle with the resource with a resource pointer and a dereference module for determining and storing a pointer value of said pointer, for verifying the existence of said reference handle, and for retrieving and providing said stored pointer value if said verified reference handle is deemed to have an existing value.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The management device of claim 19, wherein said dereference module provides a null pointer if said verified reference handle is deemed invalid.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The management device of claim 19, wherein said dereference module is programmed for verifying, in consecutive order, by: a) reading the resource pointer; b) reading and verifying the handle value;</claim-text>
      <claim-text>and c) returning the pointer.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The management device of claim 19, further including a handle recycling module for recycling handle values.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. A management device operating in a multi-threaded environment for managing data access to a plurality of resources stored on computer readable memory of a computer system, said management device comprising: an original handle database stored in the computer readable memory of the computer system and containing a plurality of reference handles; a plurality of consumers randomly requiring access to said resources;</claim-text>
      <claim-text>and a handle administrator comprising an assignment module for assigning a reference handle by generating a unique value for an assigned reference handle and associating said reference handle with the resource with a resource pointer and a dereference module for determining and storing a pointer value of said pointer, for verifying validity of said reference handle, and for retrieving and providing said stored pointer value if said verified reference handle is deemed valid; wherein said assignment module is preprogrammed for issuing a new reference handle to a consumer when said consumer requires access to at least one of the resources, for associating said issued reference handle with said resource requiring access by assigning a unique value to said issued reference handle, and for releasing issued reference handles and deeming their respective handle values as being unassigned for reference handles that are no longer required by consumers and classifying said released handles as invalid; wherein reference handles are generated and validated for providing efficient management and administration of consumers' access to resources in computer systems.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The management device of claim 23, wherein said assignment module further comprises an auxiliary sub-module for managing assigned and unassigned handle values with a set of records, each record containing fields, one field of each record being a handle value field indicating a handle value.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The management device of claim 24, wherein said auxiliary sub-module is preprogrammed for managing assigned and unassigned handle values by: maintaining a list of records, wherein the handle value fields of said records indicate unassigned handle values; selecting a handle value from said list with indicia of unassigned handle values when a new handle is to be issued;</claim-text>
      <claim-text>and adding a released handle value to said list with indicia of unassigned handles when a handle is released.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The management device of claim 25, wherein said maintained list is a linked list, wherein issued handles are assigned previously unassigned handle values from records at a head portion of said list and wherein released handles values are placed in records at a tail portion of said list.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The management device of claim 25, wherein said maintained list is a search tree and wherein an unassigned handle value with the lowest handle value among all unassigned handle values is selected first to be assigned to an issued handle.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. A management device operating in a multi-threaded environment for managing data access to a plurality of resources stored on computer readable memory of a computer system, said management device comprising: an original handle database stored in the computer readable memory of the computer system and containing a plurality of reference handles; a plurality of consumers randomly requiring access to said resources;</claim-text>
      <claim-text>and a handle administrator comprising,</claim-text>
      <claim-text>- an assignment module for assigning a reference handle by generating a unique value for an assigned reference handle and associating said reference handle with the resource with a resource pointer, - a modify module for allocating an area in said computer readable memory for a modified handle database created having a size of a multiplicative constant different than said original handle database size and for copying data located in said original handle database into said modified handle database, and - a dereference module for reading a size value of said modified database and for simultaneously and consistently utilizing said size value of said modified database and a database pointer value to said modified database for reorganizing said copied data in said modified handle database so as to prevent a future conflict in handle values, - wherein said modify module is further preprogrammed for deallocating said area in said computer readable memory occupied by said original handle database.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The management device of claim 28, wherein said dereference module is preprogrammed for reading and utilizing by: initiating a first verifier and assigning a value to said first verifier; initiating a second verifier and assigning a matching value of said first verifier; incrementing said value of said first verifier; updating said database pointer value and said size of said modified database after a modified database is created;</claim-text>
      <claim-text>and setting a second verifier equal to said first verifier.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. The management device of claim 29, wherein said dereference module is further preprogrammed for: (a) reading and storing said value of said second verifier; (b) reading said database pointer value and said size of said modified database; (c) computing a record index of said modified database from said original database, said indexed record containing a reference handle value and resource pointer value; (d) reading values of said resource pointers and said reference handles from said indexed record; (e) reading a value of said first verifier and comparing said read value with said stored value of said second verifier;</claim-text>
      <claim-text>and (f) repeating steps (a)-(e) until said first verifier value matches said second verifier value.</claim-text>
    </claim>
    <claim num="31">
      <claim-text>31. The management device of claim 30, wherein said maintained list is a search tree and wherein an unassigned handle value with the lowest handle value among all unassigned handle values is selected first to be assigned to an issued handle.</claim-text>
    </claim>
    <claim num="32">
      <claim-text>32. The management device of claim 30, wherein said dereference module is programmed for verifying, in consecutive order, by: a) reading the resource pointer; b) reading and verifying the handle value;</claim-text>
      <claim-text>and c) returning the pointer.</claim-text>
    </claim>
    <claim num="33">
      <claim-text>33. The management device of claim 28, wherein said dereference module provides a null pointer if said verified reference handle is deemed invalid.</claim-text>
    </claim>
    <claim num="34">
      <claim-text>34. The management device of claim 28, wherein said assignment module is preprogrammed for issuing a new reference handle to a consumer when said consumer requires access to at least one of the resources, for associating said issued reference handle with said resource requiring access by assigning a unique value to said issued reference handle, and for releasing issued reference handles and deeming their respective handle values as being unassigned for reference handles that are no longer required by consumers and classifying said released handles as invalid; wherein reference handles are generated and validated for providing efficient management and administration of consumers' access to resources in computer systems.</claim-text>
    </claim>
    <claim num="35">
      <claim-text>35. The management device of claim 34, wherein said assignment module further comprises an auxiliary sub-module for managing assigned and unassigned handle values with a set of records, each record containing fields, one field of each record being a handle value field indicating a handle value.</claim-text>
    </claim>
    <claim num="36">
      <claim-text>36. The management device of claim 35, wherein said auxiliary sub-module is preprogrammed for managing assigned and unassigned handle values by: maintaining a list of records, wherein the handle value fields of said records indicate unassigned handle values; selecting a handle value from said list with indicia of unassigned handle values when a new handle is to be issued;</claim-text>
      <claim-text>and adding a released handle value to said list with indicia of unassigned handles when a handle is released.</claim-text>
    </claim>
    <claim num="37">
      <claim-text>37. The management device of claim 36, wherein said maintained list is a linked list, wherein issued handles are assigned previously unassigned handle values from records at a head portion of said list and wherein released handles values are placed in records at a tail portion of said list.</claim-text>
    </claim>
    <claim num="38">
      <claim-text>38. The management device of claim 28, further including a handle recycling module for recycling handle values.</claim-text>
    </claim>
    <claim num="39">
      <claim-text>39. A computer-readable medium having computer-executable components for causing a computer to function as a resource administration system for generating and validating reference handles for consumers requiring access to a plurality of resources in a multi-threaded environment, said system comprising: a computer-readable storage medium;</claim-text>
      <claim-text>and a computer data access system stored on said medium, said computer data access system having a handle administrator and an original handle database stored in the computer readable memory of the computer system and containing a plurality of reference handles; wherein said computer data access system is preprogrammed for assigning a reference handle by generating a unique value for an assigned reference handle and associating said reference handle with the resource with a resource pointer, for determining and storing a pointer value of said pointer, for verifying the existence of said reference handle, and for retrieving and providing said stored pointer value if said verified reference handle is deemed to have an existing value.</claim-text>
    </claim>
    <claim num="40">
      <claim-text>40. The system of claim 39, wherein said system is preprogrammed to provide a null pointer if said verified reference handle is deemed invalid.</claim-text>
    </claim>
    <claim num="41">
      <claim-text>41. The system of claim 39, wherein said system is preprogrammed for verifying, in consecutive order, by: a) reading the resource pointer; b) reading and verifying the handle value;</claim-text>
      <claim-text>and c) returning the pointer.</claim-text>
    </claim>
    <claim num="42">
      <claim-text>42. A computer-readable medium having computer-executable components for causing a computer to function as a resource administration system for generating and validating reference handles for consumers requiring access to a plurality of resources in a multi-threaded environment, said system comprising: a computer-readable storage medium;</claim-text>
      <claim-text>and a computer data access system stored on said medium, said computer data access system having a handle administrator and an original handle database stored in the computer readable memory of the computer system and containing a plurality of reference handles; wherein said computer data access system is preprogrammed for assigning a reference handle by generating a unique value for an assigned reference handle and associating said reference handle with the resource with a resource pointer, for determining and storing a pointer value of said pointer, for verifying validity of said reference handle, and for retrieving and providing said stored pointer value if said verified reference handle is deemed valid; wherein said system is preprogrammed for issuing a new reference handle to a consumer when said consumer requires access to at least one of the resources, for associating said issued reference handle with said resource requiring access by assigning a unique value to said issued reference handle, and for releasing issued reference handles and deeming their respective handle values as being unassigned for reference handles that are no longer required by consumers and classifying said released handles as invalid; wherein reference handles are generated and validated for providing efficient management and administration of consumers' access to resources in computer systems.</claim-text>
    </claim>
    <claim num="43">
      <claim-text>43. The system of claim 42, wherein said system is further preprogrammed for managing assigned and unassigned handle values with a set of records, each record containing fields, one field of each record being a handle value field indicating a handle value.</claim-text>
    </claim>
    <claim num="44">
      <claim-text>44. The system of claim 43, wherein system is preprogrammed for managing assigned and unassigned handle values by: maintaining a list of records, wherein the handle value fields of said records indicate unassigned handle values; selecting a handle value from said list with indicia of unassigned handle values when a new handle is to be issued;</claim-text>
      <claim-text>and adding a released handle value to said list with indicia of unassigned handles when a handle is released.</claim-text>
    </claim>
    <claim num="45">
      <claim-text>45. The system of claim 44, wherein said maintained list is a linked list, wherein issued handles are assigned previously unassigned handle values from records at a head portion of said list and wherein released handles values are placed in records at a tail portion of said list.</claim-text>
    </claim>
    <claim num="46">
      <claim-text>46. The system of claim 44, wherein said maintained list is a search tree and wherein an unassigned handle value with the lowest handle value among all unassigned handle values is selected first to be assigned to an issued handle.</claim-text>
    </claim>
    <claim num="47">
      <claim-text>47. The system of claim 44, further including a handle recycling module for recycling handle values.</claim-text>
    </claim>
  </claims>
</questel-patent-document>