<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06182155B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06182155</doc-number>
        <kind>B2</kind>
        <date>20010130</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6182155</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="4160617" extended-family-id="3857643">
      <document-id>
        <country>US</country>
        <doc-number>09002362</doc-number>
        <kind>A</kind>
        <date>19980102</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09002362</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>3988558</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>CA</country>
        <doc-number>2204971</doc-number>
        <kind>A</kind>
        <date>19970509</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997CA-2204971</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010130</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/46        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>46</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>719315000</text>
        <class>719</class>
        <subclass>315000</subclass>
      </main-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/54P1</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>54P1</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/548</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>548</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>7</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>6</number-of-drawing-sheets>
      <number-of-figures>7</number-of-figures>
      <image-key data-format="questel">US6182155</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Uniform access to and interchange between objects employing a plurality of access methods</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>NAKANO RUSSELL T, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5369766</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5369766</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>BEZVINER DAWN E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5613148</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5613148</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>CHOW CHUNGHEN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5642511</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5642511</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>FOODY DANIEL M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5732270</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5732270</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>COLYER ADRIAN MARK</text>
          <document-id>
            <country>US</country>
            <doc-number>5862328</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5862328</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>COLYER ADRIAN MARK</text>
          <document-id>
            <country>US</country>
            <doc-number>5903725</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5903725</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>O'FARRELL WILLIAM G, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5655101</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5655101</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Noveck, David, Token Module for OSF/1 AD Version 2, OSF Research Institute, pp. 1-32, Jul. 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Reasoner, S., "Management By Proxy Agent," Wescon Technical Papers, vol. 35, pp. 190-195, Nov. 1991.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>Marc Shapiro, "Structure and Encapsulation in Distributed Systems: The Proxy Principle", Proceeding of the 6th International Conference on Distributed Systems (1986) pp. 199-204.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>International Business Machines Corporation</orgname>
            <address>
              <address-1>Armonk, NY, US</address-1>
              <city>Armonk</city>
              <state>NY</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>IBM</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Cheng, Michael</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Thomson, Brian Ward</name>
            <address>
              <address-1>Ontario, CA</address-1>
              <city>Ontario</city>
              <country>CA</country>
            </address>
          </addressbook>
          <nationality>
            <country>CA</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Scully, Scott, Murphy &amp; Presser</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Oberley, Alvin E.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      Uniform access to and interchange between objects with use in any environment that supports interface composition through interface inheritance and implementation inheritance from a common base class is provided.
      <br/>
      Proxies are used to provide both cross-language and remote access to objects.
      <br/>
      The proxies and the local implementations for objects share a common set of interface base classes, so that the interface of a proxy for an object is indistinguishable from a similar interface of the actual implementation.
      <br/>
      Each proxy is taught how to deal with call paramters that are proxies of the other kind.
      <br/>
      A roster of language identifiers is developed, and a method is added to each object implementation which, when called, checks whether it matches the language that the object implementation is written in.
      <br/>
      If so, it returns a direct pointer to the object implementation.
      <br/>
      Common client coding can then be used to deal with both same language and cross-language calls.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">
      1.
      <br/>
      Technical Field
    </p>
    <p num="2">This invention relates generally to the field of multi-language, distributed programming environments, and provides, in particular, a mechanism for transparently issuing remote and local cross-language, and local same language calls from an object oriented environment.</p>
    <p num="3">2. Prior Art</p>
    <p num="4">
      Object oriented (OO) technology is significantly different, on design level, from the more conventional process-based technology.
      <br/>
      The latter is often called procedural technology, and programming in such technology generally results in hierarchies of nested computer programs or procedures.
    </p>
    <p num="5">
      By contrast, the focus of OO design is on how the problem can be broken down into a set of autonomous entities that can work together to provide a solution.
      <br/>
      The autonomous entities of OO technology are called objects.
    </p>
    <p num="6">
      Essentially, an object oriented program is created using a set of language tools, abstractions and constructs that support a particular form of user-defined types, called "classes".
      <br/>
      Each such type associates a collection of declared data with a set of operations on that data.
      <br/>
      Variables, or instances, of such types in the running programs are the objects.
    </p>
    <p num="7">
      Classes can be related to one another by inheritance.
      <br/>
      The properties, behaviours, data, and operations of a parent, or "base", class may be inherited without modification by some child, or "derived" class, or the behaviours, properties, and operations may be selectively refined under control of the programmer.
      <br/>
      When defining a derived class, one may start by building on an existing base class which is similar to the one to be created.
      <br/>
      The derived class inherits the implementation and behaviour of the base class, except as modified by amendments detailed in the derived class definition.
      <br/>
      Several classes can inherit the behaviours of a common parent, and a derived class may inherit from more than one base class.
    </p>
    <p num="8">
      A member function is a function or operation defined as a behaviour of some user-defined type where that type participates in a hierarchy of other types.
      <br/>
      Functions are not directly called out, but are invoked on an object.
    </p>
    <p num="9">Since the first development of OO technology concepts in the 1970's and the invention of the C++ programming language in the 1980's, OO programming languages have proliferated, many directed to specialty applications.</p>
    <p num="10">
      The concept of reusable objects has a number of advantages in terms reducing programming development time and cost.
      <br/>
      However, use of a specific OO programming language may have draw backs.
      <br/>
      For example, C++ lacks inherent concurrency.
    </p>
    <p num="11">
      This can be addressed in a distributed programming environment that provides the appearance of concurrency in performing multiple operations simultaneously.
      <br/>
      One system described in Canadian Patent Application No. 2,097,540 to IBM Canada Ltd., laid open Dec. 2, 1994, provides transparent access to data objects located in the memory address spaces of remote processors of the same type.
      <br/>
      The memory space of each of the multiple processors in the distributed environment is segmented; a data object is referenced at parallel segments in each processor.
      <br/>
      Where the data object resides in the local memory of a processor, the memory segment referencing it contains a variable record identifying its actual address in the processor's memory.
      <br/>
      Where the data object resides in the memory of a remote processor, the memory segment contains a variable record simply identifying the remote processor.
      <br/>
      The reference points directly to the parallel memory segment containing the data objects actual address in the remote processor.
      <br/>
      The application also describes a mechanism to handle data object migration within the processor cluster.
    </p>
    <p num="12">
      Another way to represent remote objects locally is through the use of "proxies".
      <br/>
      An early approach to the use of proxies is found in M. Shapiro, "Structure and Encapsulation of Distributed Systems: The Proxy Principle", Proceedings of Sixth International Conference of Distributed Computer Systems, May 1986, pp. 198-204, where proxies are described as being of the nature of "stubs" introduced as interfaces between clients and services.
    </p>
    <p num="13">
      Proxies are often used to allow access to remote objects transparently, so that the interface of the proxy that is accessible to the client is indistinguishable from a similar interface of the actual implementation.
      <br/>
      This "local-remote transparency" allows the use of a consistent programming style in the client, and permits common code to deal with both local and remote objects.
      <br/>
      IBM's DSOM and IONA Orbix, which conform to the Object Management Group's Common Object Request Broker Architecture (OMG CORBA), are examples of this use of proxies.
      <br/>
      These environments also offer symmetry, in that a mixture of implementations and proxies can exist on both sides of a remote connection.
      <br/>
      The use of proxies enables the support of complex interfaces involving complicated data types, exceptions, and inheritance.
    </p>
    <p num="14">In addition to the value added by distributed processing, access to functions provided in other programming languages can enhance the usability of object oriented languages such as C++. For example, the Java programming language provides a particularly useful format for Internet transmission, COBOL provides an efficient way to extract and combine fields from complex business records, etc.</p>
    <p num="15">
      Proxies are used to provide cross-language access to local objects.
      <br/>
      The TwinPeaks project at SunSoft and ILOG Corporations is developing a tool to construct a Java language proxy automatically from a C++ class declaration, although the result is not symmetric.
      <br/>
      Microsoft's COM and Java virtual machine technology provide a symmetric capability between C++ and Java, utilizing dynamically generated proxies on the Java side.
    </p>
    <p num="16">At present, there are no solutions that provide a combination of these features: remote access, transparency, symmetry, complex interfaces, and high-performance local cross-language access.</p>
    <p num="17">Remote technology can be used to achieve many of these features, for example by using a C++ Object Request Broker (ORB) in communication with a Java ORB, but can support only limited forms of a high-performance path for local cross-language use.</p>
    <p num="18">
      Microsoft Distributed COM has some similar capabilities.
      <br/>
      However its support for navigation among related interfaces is obtrusive, and expensive because it implies an interaction between a client and a, possibly remote, implementation.
      <br/>
      Local COM provides a high-performance local cross-language alternative, but it is not transparent because the data types handled are only a subset of those available in the distributed or cross-process case.
    </p>
    <p num="19">At present, no solution supports symmetric and transparent cross-language calls in a local or remote processing environment, with complex interfaces and inheritance, and a high-performance optimization of local access.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="20">It is an object of the present invention to provide a uniform programming interface for remote and local cross-language, as well as for local same-language calls, while optimizing each one.</p>
    <p num="21">It is also an object of the present invention to provide a symmetric programming capability in which references to objects in a remote environment, local objects in one programming language environment, and local objects in a second programming language environment may be exchanged among the environments.</p>
    <p num="22">
      Accordingly, the present invention provides a method for constructing implementations and proxies, permitting a client to access an object directly, or through a proxy, without awareness on the part of the client as to which is used.
      <br/>
      This is achieved by providing, in a multi-language computing environment supporting interface composition through inheritance and implementation inheritance from common base classes, a mechanism to give apparently transparent access to objects.
    </p>
    <p num="23">The mechanism consists of a pure interface base class adapted to generate a hierarchy of pure interface classes containing only method implementations and instance data common to proxies and implementations, means for generating an implementation in response to a user access request on a local, same language implementation object, said implementation inheriting from the pure interface class hierarchy, and means to generate a first proxy object in response to a user access request on a cross-language implementation object, said first proxy object inheriting from the pure interface class hierarchy.</p>
    <p num="24">
      In addition, the present invention provides that the implementations and proxies so constructed support the composition of interfaces through inheritance, and the efficient navigation among related interfaces.
      <br/>
      This is achieved by providing means to generate target objects that present identical interfaces to the client in a distributed computing environment supporting interface composition through inheritance and implementation inheritance from common base classes in which target objects generated in response to user access requests include implementation objects in response to user access requests on local same-language implementation objects, proxy objects pointing to language-independent tokens in response to user access requests on local cross-language implementation objects and proxy objects having methods to encapsulate user requests as transmissible messages in response to user access requests on remote implementation objects.
    </p>
    <p num="25">
      The present invention also provides that multiple forms of proxies may be employed, each form suited to a particular circumstance encountered at execution time, including but not limited to one proxy form to access a remote object and a second proxy form to access a same-process object implemented in a different language.
      <br/>
      The appropriate proxy form is selected at the time of execution of the program, according to circumstances in effect at that time, and this is done without awareness on the part of the client as to which proxy form is used.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="26">
      Preferred embodiments of the present invention will now be described, by way of example only, with reference to the accompanying drawings, in which:
      <br/>
      FIG. 1 is a schematic representation of method invocation on a remote object under the CORBA architecture (defined below);
      <br/>
      FIGS. 2A and 2B are schematic representations showing the structure of the class hierarchies presently used to provide local and remote object access under the CORBA architecture; and
      <br/>
      FIGS. 3A and 3B are schematic representations similar to FIG. 2 showing modification of the CORBA architecture according to the preferred embodiment of the invention;
      <br/>
      FIG. 4 is a series of 5 schematic representations, of the same type as FIG. 1, illustrating different types of access between objects in a mixed C++ and Java environment; and
      <br/>
      FIG. 5 is a schematic representation of the class hierarchy structure to implement the different types of access in FIG. 4.
    </p>
    <heading>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS OF THE INVENTION</heading>
    <p num="27">
      The preferred embodiments of the present invention have been implemented in accordance with the Object Management Group's Common Object Request Broker Architecture (OMG CORBA).
      <br/>
      The detailed description that follows is expressed primarily in terms of support for the C++ programming language.
      <br/>
      However, from reviewing this disclosure, it will become clear to one skilled in the art that the present invention is useful in any object oriented programming architecture and language combination that supports interface composition through interface inheritance, and implementation inheritance from common base classes.
    </p>
    <p num="28">
      The present state of the art of CORBA implementation in C++ is illustrated schematically in FIG. 1. C++ client 2 possesses a reference 4 (a C++ pointer) to a proxy object which presents to the client the same interface possessed by a remote object implementation 14.
      <br/>
      When the client invokes methods through the reference, methods in the proxy object are invoked.
      <br/>
      These proxy object methods make use of facilities provided by an Object Request Broker (ORB) 8 to encapsulate the method invocation as a transmissible message that is sent to a peer ORB 10.
      <br/>
      The peer ORB may execute in a different process on the same machine as the client, or in a different machine connected by a network.
      <br/>
      The peer ORB may also inhabit a different programming language environment.
    </p>
    <p num="29">
      The peer ORB passes the message to a Dispatcher 12, which uses facilities provided by the ORB to un-encapsulate the method invocation and then invokes the desired method directly on the object implementation 14.
      <br/>
      Result values and exceptions are collected by the Dispatcher and encapsulated in a reply message that is returned to the client ORB, and then through the proxy object back to the client program.
    </p>
    <p num="30">
      The client reference 4 may instead point directly to a C++ implementation 16 that is local to the client's machine.
      <br/>
      Because the interface presented by the implementation is indistinguishable from that presented by the proxy, the client program is unaware of whether the reference points directly to an implementation or to a proxy object.
      <br/>
      In this fashion the current state of the art provides transparency between local and remote objects.
    </p>
    <p num="31">
      CORBA defines an Interface Definition Language (IDL) that is used to define these interfaces without reference to a particular programming language.
      <br/>
      Transformation tools read an IDL definition and generate corresponding proxy class and Dispatcher definitions in a desired programming language, such as C++ or Java.
      <br/>
      CORBA specifies rules that define the correspondence for a number of programming languages.
    </p>
    <p num="32">
      FIG. 2A is a diagram of the C++ class inheritance structure that supports this behaviour in the current practice.
      <br/>
      A hierarchy of proxy classes 20 whose inheritance structure matches the inheritance structure of the IDL declarations is generated.
      <br/>
      Each proxy class provides C++ virtual functions At the base of the proxy class structure is a common base class 22 which contributes behaviour and instance data common to all proxy objects, and is necessary for the correct operation of the ORB.
      <br/>
      The client 24 may, by means of the reference 26 that it possesses, access the interface of a proxy class and of all the other proxy classes from which it inherits.
    </p>
    <p num="33">
      FIG. 2B illustrates how an implementation 28 may equally be the target of a reference.
      <br/>
      The implementation inherits from a C++ proxy class and overrides the methods provided in the proxy classes.
      <br/>
      When client 30 calls a method on this composite object, the C++ virtual function mechanism ensures that the override methods provided by the implementation are invoked in preference to the methods supplied by the proxy classes.
      <br/>
      The Skeleton class 32 helps provide the Dispatcher with capability for an ORB to use and is not relevant in the case where the client is local to the implementation.
    </p>
    <p num="34">
      The present invention improves on this structure by providing for multiple kinds of proxies each suited to a particular circumstance.
      <br/>
      Concurrently-filed application titled "Transparent Use Of Compiled or Interpreted Objects in an Object Oriented System" Ser.
      <br/>
      No. 09/074,222, which is commonly assigned, describes an inter-language call mechanism applicable within a single process.
      <br/>
      This mechanism has an efficiency advantage over the use of communicating ORBs, but utilizes different proxy classes and dispatchers than those used with an ORB.
    </p>
    <p num="35">
      The present invention restructures the class hierarchy as diagrammed in FIG. 3A. A hierarchy of pure interface classes 40 is generated that presents the same appearance to the client 44 as did the proxy class hierarchy of FIG. 2A, and introduces the same C++ virtual functions, but does not contain any method implementations whose function is specific to an ORB proxy.
      <br/>
      The pure interface classes, as well as their common base class 42, only contribute method implementations and instance data that are common to the different proxy kinds and implementations in use.
    </p>
    <p num="36">
      Parallel hierarchies of generated proxy classes 48 and 52 inherit from the pure interface class hierarchy and provide, by means of C++ virtual function overrides, implementations of the methods appropriate to different kinds of proxies.
      <br/>
      By way of example, class hierarchy 48 provides ORB proxy method implementations, and common ORB proxy base class 50 introduces instance data and common method implementations necessary for the proper operation of the ORB with this proxy object but not necessary for the proper operation of other proxy kinds.
      <br/>
      Class hierarchy 52 provides local cross-language proxy method implementations that make use of the run time facilities described in the above referenced application, "Transparent Use of Compiled or Interpreted Objects in an Object Oriented System", and its common base class 54 introduces instance data necessary for the proper operation of a local cross-language proxy but not necessary for the operation of other proxy kinds.
    </p>
    <p num="37">
      FIG. 3B illustrates the structure of implementations built using the class hierarchies of the present invention.
      <br/>
      The Implementation 74 inherits, through its Skeleton class 72, from a member of the pure interface hierarchy class 60.
      <br/>
      The Skeleton also inherits from the common base class 70 of the ORB proxy class hierarchy, which provides some common method implementations and instance data required for the ORB to interact correctly with this implementation.
    </p>
    <p num="38">
      An ORB Dispatcher object 76 is used by the ORB to invoke methods of the implementation when a request is received from a remote client 64.
      <br/>
      According to the present invention, the Dispatcher uses a reference into the pure interface class hierarchy in order to access the implementation, just as a client would do, and is able to invoke methods on any kind of object that inherits from the pure interface classes, including different kinds of implementation and even different kinds of proxies.
    </p>
    <p num="39">In the above described manner transparency is achieved, because a client reference refers to a member of the pure interface class hierarchy, that hierarchy being present in and common to all kinds of proxies and implementations, therefore a use of the client reference may invoke any kind of proxy or implementation.</p>
    <p num="40">Complex interfaces with inheritance are accommodated because the pure interface class hierarchy is constructed as interfaces related by inheritance, and it is common to all proxies and implementations.</p>
    <p num="41">Symmetry is provided by ensuring that the implementations of the proxy methods of each kind of proxy, and the instance data and implementation provided by the interface base class, function together in all desired usage combinations.</p>
    <p num="42">High performance optimization of local access is provided by supporting direct access to a local same-language implementation, a specialized proxy for access to a local different-language implementation, and a third ORB proxy for access to remote implementations.</p>
    <p num="43">The symmetry and high performance optimization aspects of the present invention will be further elaborated with respect to the preferred embodiment.</p>
    <p num="44">
      The environment in which the preferred embodiment of the present invention is employed includes the C++ and Java programming languages.
      <br/>
      The SOM technology described in the above referenced application, "Transparent Use of Compiled or Interpreted Objects in an Object Oriented System", involves a SOM Runtime component which, together with SOM proxies and Dispatchers, enables access from C++ to objects in the same process implemented in Java, and from Java to objects implemented in C++. The correct functioning of this technology depends on any objects which are to function as SOM proxies and implementations storing in their instance data an identifying token known as a SOMRef that is supplied by the SOM Runtime.
      <br/>
      In addition, the SOMRef stored within the object must be accessible to (other) SOM proxies and SOM dispatchers.
      <br/>
      Any object meeting this requirement is "SOM enabled".
    </p>
    <p num="45">
      Also present in the environment in which the preferred embodiment of the present intention is employed is an ORB which, together with ORB proxies and Dispatchers, makes C++ implementations accessible from remote clients and permits access in C++ to remote implementations.
      <br/>
      The correct functioning of this technology depends on objects storing in their instance data several ORB-specific data, and making these data available to ORB proxies and to the ORB itself.
      <br/>
      Any object meeting this requirement is "ORB enabled".
    </p>
    <p num="46">The environment of the preferred embodiment does not include an ORB that can be directly accessed from Java.</p>
    <p num="47">In this environment the symmetry requirement is that C++ implementations and ORB proxies may be passed into Java code and accessed from there, and that Java implementations may be passed into C++ and accessed from there.</p>
    <p num="48">The high performance optimization requirement is expressed in terms of five cases that are illustrated in FIG. 4.</p>
    <p num="49">Case A: Direct access to an implementation shall be used whenever a client 100 and implementation 102 are local and in the same language.</p>
    <p num="50">
      Case B: A single C++ SOM proxy 112 and Java SOM dispatcher 116 shall be used whenever a C++ client 110 and a Java implementation 118 are local to one another.
      <br/>
      A language-independent SOMRef 114 is passed across the language environments.
    </p>
    <p num="51">Case C: A single C++ ORB Proxy 122 pointing to an ORB 124 shall be used when the client 120 is C++ and the implementation is remote.</p>
    <p num="52">
      Case D: A tandem composition of a Java SOM proxy 132, C++ SOM dispatcher 136, and C++ ORB proxy 138 shall be used when the client 130 is Java and the implementation is remote.
      <br/>
      A language-independent SOMRef 134 is again passed across the languages.
    </p>
    <p num="53">Case E: A single Java SOM proxy 142 and C++ SOM dispatcher 146 (through SOMRef 144) shall be used whenever a Java client 140 and a C++ implementation 148 are local to one another.</p>
    <p num="54">
      FIG. 5 schematically illustrates the C++ class inheritance structure pursuant to the present invention which satisfies these requirements.
      <br/>
      A set of interface classes 180 is generated from IDL describing the interfaces desired by the user.
      <br/>
      These generated interface classes inherit from the common interface base class 182, which in the preferred embodiment is the CORBA::Object class.
      <br/>
      In this class are introduced instance data and methods that are common to all proxies and implementations.
      <br/>
      In particular, the instance datum "m_somref" 184 is introduced here, as are the methods "_SOMProxy ( )" 186 and "_ORBProxy( )" 188 which return pointer values.
      <br/>
      Default implementations of the methods are supplied that return null pointers.
    </p>
    <p num="55">
      A set of ORB proxy classes 190 is also generated, each proxy class of which inherits from a corresponding member of the set of interface classes.
      <br/>
      The generated ORB proxy classes also inherit from a common ORB proxy base class 192, which in the preferred embodiment is the CORBA::Object_ORBProxy class.
      <br/>
      In the common ORB proxy base class are introduced the instance data and methods that are common to ORB proxies and ORB-accessible implementations, the inclusion of which renders an object ORB enabled.
      <br/>
      The ORB proxy base class also overrides the "_ORBProxy( )" method and causes that method to return a pointer to the ORB proxy base class, instead of a null pointer.
    </p>
    <p num="56">
      ORB proxies are instances of an ORB proxy class, and therefore contain the "m_somref" instance data 184 and the "_SOMProxy( )" and "_ORBProxy( )" methods 186, 188 introduced by the common interface base class 182.
      <br/>
      The instance data 184 is directly accessible to SOM proxies and dispatchers, and therefore an ORB proxy is SOM-enabled.
      <br/>
      This satisfies Case D of FIG. 4.
    </p>
    <p num="57">
      A Skeleton class 200 is also generated, that inherits from the interface class hierarchy and from the ORB proxy base class.
      <br/>
      A C++ Implementation class 202, constructed by the user, inherits from this class.
    </p>
    <p num="58">
      C++ implementations are instances of a C++ implementation class, and therefore contain the "m_somref" instance data 184 and the "_SOMProxy( )" and "_ORBProxy( )" methods 186, 188 introduced by the common interface base class 182.
      <br/>
      The instance data is directly accessible to SOM proxies and dispatchers, thereby SOM-enabling a C++ implementation.
      <br/>
      This satisfies Case E of FIG. 4.
    </p>
    <p num="59">
      As the C++ Implementation class 202 also inherits from the ORB Proxy base class 192, the C++ implementation also contains all the instance data and methods introduced by that class sufficient to allow the correct operation of the ORB and ORB proxies and ORB dispatchers.
      <br/>
      The ORB, ORB proxies, and ORB dispatchers access this data indirectly by first calling the _ORBProxy( ) method of the object, which returns a pointer to the ORB proxy base class portion of the object, and then accessing the data directly using the returned pointer.
      <br/>
      By this mechanism, a C++ implementation is also ORB enabled.
      <br/>
      This satisfies Case C of FIG. 4.
    </p>
    <p num="60">
      As the C++ Implementation class 202 also inherits from the generated interface base class hierarchy, it may be directly referenced by a C++ client.
      <br/>
      This satisfies Case A of FIG. 4.
    </p>
    <p num="61">
      A set of SOM proxy classes 210 is also generated, each proxy class of which inherits from a corresponding member of the set of interface classes 180.
      <br/>
      The generated SOM proxy classes also inherit from a common SOM proxy base class 212, which in the preferred embodiment is the Object_SOMProxy class.
      <br/>
      The SOM proxy base class overrides the "_SOMProxy( )" method and causes it to return a pointer to the SOM proxy base class, intstead of a null pointer.
      <br/>
      This satisfies Case B of FIG. 4.
    </p>
    <p num="62">While the invention has been particularly shown and described with respect to preferred embodiments thereof, it will be understood by those skilled in the art that the foregoing and other changes in form and details may be made therein without departing from the spirit and scope of the invention.</p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>Having thus described our invention, what we claim as new, and desire to secure by letters patent is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A mechanism for providing a client access to implementation objects in a multi-language computing environment supporting interface composition through inheritance and implementation inheritance from common base classes, said mechanism comprising:</claim-text>
      <claim-text>a pure interface base class adapted for generating a hierarchy of pure interface classes containing only method implementations and instance data common to proxies and implementations; a means for directly accessing an implementation object in response to a user access request on a local same-language implementation object, said implementation inheriting from the pure interface class hierarchy;</claim-text>
      <claim-text>and a means for generating a first proxy object in response to a user access request on a local cross-language implementation object, said first proxy object inheriting from the pure interface class hierarchy; wherein said mechanism provides said client with apparently transparent access to said implementation objects.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The mechanism according to claim 1, further comprising a means for generating a language-independent token representing a cross-language implementation object where the user access request is to a local cross-language implementation object; wherein the means for generating the first proxy object is adapted for providing in said first proxy, a pointer to said token.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The mechanism according to claim 1, further comprising a means for generating a broker object having methods for encapsulating the user access request as a transmissible message where the user access request is to a remote implementation object; wherein the means for generating the first proxy object is adapted for providing in said first proxy, a pointer to said broker object.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The mechanism according to claim 1, wherein the pure interface base class is further adapted for generating in said hierarchy of pure interface classes, at least one class containing instance data to refer to a language-independent token representing a cross-language implementation object.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The mechanism according to claim 1, wherein the pure interface base class is further adapted for generating in said hierarchy of pure interface classes, at least one class containing method implementations for encapsulating the user access request as a transmissible message.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. A mechanism for providing a client access to implementation objects in a distributed computing environment supporting interface composition through inheritance and implementation inheritance from common base classes, said mechanism comprising: a means for directly accessing implementation objects in response to user access requests on local same-language implementation objects; a means for generating proxy objects pointing to language-independent tokens representing cross-language implementation objects in response to user access requests on local cross-language implementation objects; a means for generating proxy objects having methods for encapsulating user access requests as transmissible messages in response to user access requests on remote implementation objects; each said directly accessing and each said generating means presenting identical interfaces to the client to thereby provide said client with apparently transparent access to said implementation objects.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The mechanism according to claim 6, each said directly accessing means and each said generating means further comprising: a pure interface base class adapted for generating a hierarchy of pure interface classes containing only method implementations and instance data common to proxy objects and implementation objects.</claim-text>
    </claim>
  </claims>
</questel-patent-document>