<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06192517B1.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as first publication">
      <document-id>
        <country>US</country>
        <doc-number>06192517</doc-number>
        <kind>B1</kind>
        <date>20010220</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6192517</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B1</original-publication-kind>
    <application-reference family-id="25477869" extended-family-id="42072397">
      <document-id>
        <country>US</country>
        <doc-number>09436636</doc-number>
        <kind>A</kind>
        <date>19991109</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1999US-09436636</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43115442</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>43663699</doc-number>
        <kind>A</kind>
        <date>19991109</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1999US-09436636</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>94229297</doc-number>
        <kind>A</kind>
        <date>19971001</date>
        <priority-linkage-type>1</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997US-08942292</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010220</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <term-of-grant>
      <disclaimer/>
    </term-of-grant>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/45        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>45</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F  12/02        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>02</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>717154000</text>
        <class>717</class>
        <subclass>154000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>711E12006</text>
        <class>711</class>
        <subclass>E12006</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>711E12009</text>
        <class>711</class>
        <subclass>E12009</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-008/443</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>8</main-group>
        <subgroup>443</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130822</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-012/023</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>023</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130822</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-012/0253</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>12</main-group>
        <subgroup>0253</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130822</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99952</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99952</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>Y10S-707/99953</classification-symbol>
        <section>Y</section>
        <class>10</class>
        <subclass>S</subclass>
        <main-group>707</main-group>
        <subgroup>99953</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>A</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130518</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>21</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>10</number-of-drawing-sheets>
      <number-of-figures>11</number-of-figures>
      <image-key data-format="questel">US6192517</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Method, apparatus, and product for improved garbage collection in a memory system through the removal of reference conflicts</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>MADDEN WILLIAM C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5119483</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5119483</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>RAZDAN RAHUL, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5696956</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5696956</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="3">
          <text>THATTE SATISH, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4757438</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4757438</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="4">
          <text>BARTLETT JOEL F</text>
          <document-id>
            <country>US</country>
            <doc-number>4907151</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4907151</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>POGUE MICHAEL A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4920483</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4920483</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <text>AUSLANDER MARC A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5129088</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5129088</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>HOURI AVSHALOM, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5222221</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5222221</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>NEWMAN GARY H, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5301288</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5301288</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>SERLET BERTRAND</text>
          <document-id>
            <country>US</country>
            <doc-number>5355483</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5355483</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>ARSENAULT MARK E</text>
          <document-id>
            <country>US</country>
            <doc-number>5408650</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5408650</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>HASTINGS REED</text>
          <document-id>
            <country>US</country>
            <doc-number>5535329</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5535329</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>NILSEN KELVIN D, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5560003</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5560003</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="13">
          <text>MORSE PETER L</text>
          <document-id>
            <country>US</country>
            <doc-number>5561786</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5561786</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="14">
          <text>PASE DOUGLAS M, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5566321</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5566321</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Title: Avoiding Conflict Misses Dynamically in Large Direct-Mapped Caches, author: Bershad et al, ACM, 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Title: Garbage collection for strongly typed languages using run-time type reconstruction, ACM, 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="3">
          <text>Title: A transformation based approach for storage optimization, author: Cheng, ACM, 1995. Title: Adaptive Query Optimization in a Deductive Databae System, author; Derr, ACM, 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>Diwan, Amer et al., "Compiler Support for Garbage Collection in a Statically Typed Language," Object Systems Laboratory, Department of Computer Science, University of Massachusetts, Amherst.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>Chung, Kin-Man and Yuen, Herbert, "A "Tiny' Pascal Compiler: the P-Code Interpreter," BYTE Publications, Inc., Sep. 1978.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="6">
          <text>Chung, Kin-Man and Yuen, Herbert, "A "Tiny' Pascal Compiler: Part 2: The P-Compiler," BYTE Publications, Inc., Oct. 1978.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="7">
          <text>Thompson, Ken, "Regular Expression Search Algorithm," Communications of the ACM, vol. II, No. 6, p. 149 et seq., Jun. 1968.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="8">
          <text>Mitchell, James G., Maybury, William, and Sweet, Richard, Mesa Language Manual, Xerox Corporation.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="9">
          <text>Pier, Kenneth A., "A Retrospective on the Dorado, A High-Performance Personal Computer," Xerox Corporation, Aug. 1983.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="10">
          <text>Pier, Kenneth A., "A Retrospective on the Dorado, A High-Performance Personal Computer," IEEE Conference Proceedings. The 10th Annual International Symposium on Computer Architecture, 1983.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="11">
          <text>Jones, Richard and Lins, Raphael, "Garbage Collection, Algorithms for Automatic Dynamic Memory Management," John Wiley &amp; Sons, 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="12">
          <text>Gosling, James, et al., "The Java Language Specification," Addison-Wesley, 1996. select readings. Lindholm, Tim and Yellin, Frank, "The java Virtual Machine Specification," select pages Addison-Wesley, 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="13">
          <text>Lindholm, Tim and Yellin, Frank, "The Java Virutal Machine Specification," select pages Addison Wesley, 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="14">
          <text>Lindholm, Tim and Yellin, Frank, "The Java Virutal Machine Specification," Addison Wesley, 1997.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="15">
          <text>Gosling, James; Joy, Bill; and Steele, Guy, "The Java Language Specification," Addison Wesley, 1996.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="16">
          <text>Detlefs, David L., Concurrent Garbage Collection for C++, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, May 4, 1990, pp. 1-46.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="17">
          <text>Bartlett, Joel F., "Compacting Garbage Collection with Ambiguous Roots," Digital Equipment Corporation, Feb. 1988, pp. 1-35.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="18">
          <text>Ferreira, Paulo, "Garbage Collection in C++, Position Paper for the OOPSLA '91 Workship on Garbage Collection," Jul. 1991, pp. 1-5.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="19">
          <text>Gosling, James, "ACM SIGPLAN Workship on Intermediate Representations (IR '95)," Sun Microsystems Laboratories, 1995, pp. 111-118.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="20">
          <text>Bartlett, Joel F., "Mostly-Copying Garbage Collection Picks Up Generations and C++," WRL Technical Note TN-12, Digital Equipment Corporation, Oct. 1989, pp. 1-13.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="21">
          <text>Boehm, Hans-Juergen and Weiser, Mark, "Garbage Collection in an Uncooperative Environment," Software-Practice and Experience, vol. 18(9), John Wiley &amp; Sons, Ltd., Sep. 1988, pp. 807-820.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="22">
          <text>Caplinger, Michael, "A Memory Allocator with Garbage Collection for C," Bell Communication Research, USENIX Winter Conference, Dallas, Texas, Feb. 9-12, 1988, pp. 325-330.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="23">
          <text>Grehan, Rick, "If Memory Serves . . . ," BYTE Publications, Inc., Aug. 1989.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="24">
          <text>Grehan, Rick, "Virtually Virtual Memory," BYTE Publications, Inc., Sep. 1990.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="25">
          <text>Imai, Akira and Tick, Evan, "Evaluation of Parallel Copying Garbage Collection on a Shared-Memory Multiprocessor", IEEE Transactions On Parallel and Distributed Systems, vol. 4, No. 9, Sep. 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="26">
          <text>Kuechlin, Wolfgang W. and Nevin, Nicholas J., "On Multi-Threaded List-Processing and Garbage Collection," IEEE, 1991.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="27">
          <text>Harbaugh, Sam and Wavering, Bill, "HeapGuard.TM. Eliminating Garbage Collection in Real-Time Ada Systems," Integrated Software, Inc.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="28">
          <text>Bott, Ed, "Windows' Invisible Wall: The 64K Barrier," PC Contact, Mar. 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="29">
          <text>Karen, et al., "Garbage Collection for Prolog based on WAM," Communications of the ACM, vol. 31, Issue 6, Jun. 1988.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="30">
          <text>Wallace, David V., and Tiemann, Michael, "Simple Garbage Collection in G++," Cygnus Support.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="31">
          <text>Caro, Alexander, "A Novel 64 Bit Data Representation for Garbage Collection and Synchronizing Memory", Computation Structures Group Memo 396, Apr. 9, 1997.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="32">
          <text>Courts, Robert, "Improving Locality of Reference in a Garbage-Collecting Memory Management System," Communications of the ACM, vol. 31, No. 5, Sep. 1988.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="33">
          <text>Moon, David A., "Garbage Collection in a Large Lisp System," Association for Computing Machinery, 1984.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="34">
          <text>Barrett, David A., "Improving the Performance of Conservative Generational Garbage Collection," Technical Report CU-CS-784-95, University of Colorado at Boulder, Sep. 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="35">
          <text>Aho, Alfred V., Sethl, Ravi, and Ullman, Jeffrey D., "Compilers: Principles, Techniques, and Tools," Addison-Wesley Publishing Company, 1988; Copyright.COPYRGT. 1986 by Bell Telephone Laboratories, Inc.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="36">
          <text>Holzle, Urs, "A Fast Write Barrier for Generational Garbage Collectors," OOPSLA '93 Garbage Collection Workshop, Washington, DC, Oct. 1993.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="37">
          <text>"GC FAQ-draft," http://www.centerline.com/people/chae/GC/GC-faq.html, Jan. 6, 1997.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="38">
          <text>Shaw, Richard H., "An Introduction to the Win32 API (Programming Specification, Application Programming Interface, Power Programming)," PC Magazine, Apr. 26, 1994.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="39">
          <text>Wilson, Paul R., et al., "Dynamic Storage Allocation: A Survey and Critical Review," Department of Computer Sciences, University of Texas at Austin, Austin, Texas.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="40">
          <text>Gosling, James, et al., "ACM SIGPLAN Workshop on Intermediate Representations," Sun Microsystems Laboratories, 1995.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="41">
          <text>Wilson, P.R., et al., "Design of the Opportunistic Garbage Collector," Proceedings of the Object Oriented Programming Systems Languages An Applications Conference, New Orleans, vol. 24, No. 10, Oct. 1989.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <continuation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>94229297</doc-number>
              <kind>A</kind>
              <date>19971001</date>
            </document-id>
          </parent-doc>
        </relation>
      </continuation>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Sun Microsystems, Inc.</orgname>
            <address>
              <address-1>Palo Alto, CA, US</address-1>
              <city>Palo Alto</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>SUN MICROSYSTEMS</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Agesen, Ole</name>
            <address>
              <address-1>Franklin, MA, US</address-1>
              <city>Franklin</city>
              <state>MA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Detlefs, David L.</name>
            <address>
              <address-1>Westford, MA, US</address-1>
              <city>Westford</city>
              <state>MA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Finnegan, Henderson, Farabow, Garrett &amp; Dunner, L.L.P.</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Hafiz, Tariq R.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      In accordance with the present invention a method for modifying a sequence of instructions to improve memory management within a storage device during execution of the instructions, comprises the steps, performed by a processor, of (a) analyzing the sequence of instructions for a conflict indicating an undeterminable variable type, (b) determining the type of conflict, and (c) modifying the sequence of instructions to eliminate the conflict based on the determination.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This is a continuation of application Ser.
      <br/>
      No. 08/942,292, filed Oct. 1, 1997, which is incorporated herein by reference.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      A.
      <br/>
      Field of the Invention
    </p>
    <p num="3">This invention generally relates to garbage collection for computer systems and, more particularly, to a methodology for determining the existence of reference conflicts in Java bytecodes and for modifying the bytecodes to eliminate the conflicts, thereby improving the performance of garbage collection.</p>
    <p num="4">B. Description of the Related Art</p>
    <p num="5">
      An important concept in memory management of computer systems is the way in which memory is allocated to a task, deallocated, and then reclaimed.
      <br/>
      Memory deallocation and reclamation may be explicit and controlled by an executing program, or may be carried out by another special purpose program which locates and reclaims memory which is unused, but has not been explicitly deallocated. "Garbage collection" is the term used to refer to a class of algorithms used to carry out memory management, specifically, automatic reclamation.
      <br/>
      There are many known garbage collection algorithms, including reference counting, mark-sweep, and generational garbage collection algorithms.
      <br/>
      These, and other garbage collection techniques, are described in detail in a book entitled "Garbage Collection, Algorithms For Automatic Dynamic Memory Management" by Richard Jones and Raphael Lins, John Wiley &amp; Sons, 1996.
      <br/>
      Unfortunately, many of the described techniques for garbage collection have specific requirements which cause implementation problems.
    </p>
    <p num="6">
      The Java (tm)  programming language is an object-oriented programming language that is described, for example, in a text entitled "The Java Language Specification" by James Gosling, Bill Joy, and Guy Steele, Addison-Wesley, 1996.
      <br/>
      This language is typically compiled to a universal executable format, using a "bytecode instruction set," which can be executed on any platform supporting the Java virtual machine (JVM).
      <br/>
      The JVM is described, for example, in a text entitled "The Java Virtual Machine Specification," by Tim Lindholm and Frank Yellin, Addison Wesley, 1996.
    </p>
    <p num="7">
      The JVM may stop an executing program at many bytecode boundaries to execute a garbage collector and optimize memory management in accordance with the collector's algorithm.
      <br/>
      The difficulty with this scheme, however, is providing accurate information for garbage collection at all points where collection is required.
    </p>
    <p num="8">
      In an object-oriented system, such as one or more related programs written in Java, a "class" provides a template for the creation of "objects" (which represent items or instances manipulated by the system) having characteristics of that class.
      <br/>
      The term template denotes that the objects (i.e., data items) in each class, share certain characteristics or attributes determined by the class.
      <br/>
      Objects are typically created dynamically during system operation.
      <br/>
      Methods associated with a class generally operate on the objects of the same class.
    </p>
    <p num="9">
      An object may be located by a "reference," or a small amount of information that can be used to access the object.
      <br/>
      One way to implement a reference is by means of a "pointer" or "machine address," which uses multiple bits of information, however, other implementations are possible.
      <br/>
      Objects can themselves contain primitive data items, such as integers or floating point numbers, and/or references to other objects.
      <br/>
      In this manner, a chain of references can be created, each reference pointing to an object which, in turn, points to another object.
    </p>
    <p num="10">
      Garbage collection algorithms generally determine reachability of objects from the references held in some set of roots.
      <br/>
      When an object is no longer reachable, the memory that the object occupies can be reclaimed and reused even if it has not been explicitly deallocated by the program.
      <br/>
      To be effective, garbage collection techniques should be able to, first, identify references that are directly accessible to the executing program, and, second, given the reference to an object, identify references contained within that object, thereby allowing the garbage collector to transitively trace chains of references.
    </p>
    <p num="11">
      In most language implementations, stacks form one component of the root set.
      <br/>
      A stack is a region of memory in which stack frames may be allocated and deallocated.
      <br/>
      In typical object-oriented systems, each method executing in a thread of control allocates a stack frame, and uses the slots of that stack to hold the values of local variables.
      <br/>
      Some of those variables may contain references to heap-allocated objects.
      <br/>
      Such objects must be considered reachable as long as the method is executing.
      <br/>
      The term stack is used because the stack frames obey a last-in/first-out allocation discipline within a given thread of control.
      <br/>
      There is generally a stack associated with each thread of control.
    </p>
    <p num="12">
      A garbage collector may be exact or conservative in how it treats different sources of references, such as stacks.
      <br/>
      A conservative collector knows only that some region of memory (e.g., a slot in the stack frame) may contain references, but does not know whether or not a given value in that region is a reference.
      <br/>
      If such a collector encounters a value that is a possible reference value, it must keep the referenced object alive.
      <br/>
      Because of the uncertainty in recognizing references, the collector is constrained not to move the object, since that would require updating the reference, which might actually be an unfortunately-valued integer or floating-point number.
      <br/>
      The main advantage of conservative collection is that it allows garbage collection to be used with systems not originally designed to support collection.
      <br/>
      For example, the collectors described in Bartlett, Joel F., mostly-Copying Collection Picks Up Generations and C++, Technical Report TN-12, DEC Western Research Laboratory, October 1989, and Boehm, Hans Juergen and Weiser, Mark, Garbage Collection in an Uncooperative Environment.
      <br/>
      Software-Practice &amp; Experience, 18(9), p. 807-820, September 1988, use conservative techniques to support collection for C and C++programs.
    </p>
    <p num="13">
      In contrast, a collector is exact in its treatment of a memory region if it can accurately distinguish references from non-reference values in that region.
      <br/>
      Exactness has several advantages over conservatism.
      <br/>
      A conservative collector may retain garbage referenced by a non-reference value that an exact collector would reclaim.
      <br/>
      Perhaps more importantly, an exact collector is free to relocate objects referenced only by exactly identified references.
      <br/>
      In an exact system, one in which references and non-references can be distinguished everywhere, this enables a wide range of useful and efficient garbage-collection techniques that cannot easily be used in a conservative setting.
    </p>
    <p num="14">
      However, a drawback of exact systems is that they must provide the information that makes them exact, i.e., information on whether a given value in memory is a reference or a primitive value.
      <br/>
      This may introduce both performance and complexity overhead.
      <br/>
      For purposes of this description, "val" is used to refer to a primitive data item, such as an integer or a floating point number, that does not function as a reference ("ref").
    </p>
    <p num="15">
      One technique for providing information distinguishing references from primitive values in exact systems is "tagging," in which values are self-describing: one or more bits in each value is reserved to indicate whether the value is a reference.
      <br/>
      The MIT LISP Machine was one of the first architectures which used garbage collection and had a single stack with explicitly tagged memory values.
      <br/>
      Its successor, the Symbolics 3600, commercially available from Symbolics Inc., Cambridge, Mass., also used explicitly tagged memory values.
    </p>
    <p num="16">
      If tagging is not used, then the system must associate data structures with each memory region allowing references and non-references to be distinguished in that region.
      <br/>
      For example, each object may start with a reference to a descriptor of the type of the object, which would include a "layout map" describing which fields of the object contain references.
      <br/>
      Stack frames also contain references, and if the JVM were to offer exact garbage collection it must be able to distinguish slots in the frame assigned to variables that contain references from those that contain primitive values.
      <br/>
      A "stack map" is a data structure that, for each execution point at which a collection may occur, indicates which slots in the stack frame contain references.
    </p>
    <p num="17">
      The layout map of an object is associated with the object type such that all objects of a given type have the same layout map, and the map of an object is the same for its entire lifetime.
      <br/>
      In contrast, the layout of a stack frame may change during its lifetime.
      <br/>
      A given stack frame slot may be uninitialized at the start of a method, hold a reference for one block in the method, then hold an integer for another block.
      <br/>
      This introduces certain difficulties in relying on the stack maps for determining appropriate garbage collection points.
    </p>
    <p num="18">
      For example, a compiler may translate a program fragment of a method such that two variables, one representing a primitive value and the other representing a reference, are mapped to the same slot in the stack frame.
      <br/>
      In fact, whether a given stack frame slot contains a reference at a given point in a method execution may depend not only on the current point in the program execution but also on the control path leading to that point.
      <br/>
      Along one control path, the stack frame slot might be assigned a primitive value, while along another path the same slot might be assigned a reference.
      <br/>
      That fact that there are two possibilities makes it impossible to use a stack map to determine the stack layout at garbage collection points.
    </p>
    <p num="19">
      In general, program code written in the Java language is compiled by a Java compiler, and the compiled program consists of the bytecodes that are executed by the JVM.
      <br/>
      However, not all Java programs need go through the same compiler.
      <br/>
      Moreover, it is possible to construct a bytecode program directly, using tools such as "Java assemblers," bypassing a compiler altogether.
      <br/>
      Thus, Java source code is not the exclusive source of bytecodes executable by the JVM.
      <br/>
      Consequently, the JVM Specification lays out a set of rules defining well-formed Java class files, along with a description of a procedure called the "bytecode verifier" for checking adherence to those rules.
      <br/>
      According to one of these rules, the verifier rejects instructions that do not satisfy predetermined constraints.
      <br/>
      For example, the iadd bytecode causes the JVM to pop the top two elements of the operand stack used for method execution, add the values together, and push the result on the top of the operand stack.
      <br/>
      However, the verifier knows that the iadd bytecode constraint requires that the top two elements on the operand stack be integers.
      <br/>
      If the verifier cannot prove that a method in a class file pushes two integers on the operand stack before executing an iadd instruction, the verifier will reject that class file.
    </p>
    <p num="20">
      Consider the case of a method that has two control paths leading to the same instruction I, which uses some local (i.e., stack-allocated) variable v. If I places some constraint on v, the verifier must prove that this constraint is met no matter which control path reaches I. Thus, when two control paths join at a common instruction, the verifier must show that subsequent constraints on variables such as v are satisfied assuming only the least general type for v that describes the value assigned along both control paths.
      <br/>
      This least general type describing both possible types of v is called the "merge" of its types along the two paths.
    </p>
    <p num="21">
      The JVM explicitly allows one exception to this control path rule to accommodate the Java bytecode instruction set for a pair of operations called jsr and ret.
      <br/>
      The jsr insthiction jumps to an address specified in the instruction and pushes a return address value (i.e., the address of the instruction immediately following the jsr) on the operand stack of the current method.
      <br/>
      The ret instruction specifies a local variable that must contain a return address, and jumps to that return address.
      <br/>
      The intended use of these bytecodes is in the implementation of the
      <br/>
      try +body} finally +handler}
    </p>
    <p num="22">
      construct of the Java language, in which the instructions included in the finally's handler are executed no matter how the try's body is exited.
      <br/>
      The Java compiler translates the handler as a jsr subroutine within the method.
      <br/>
      Every instruction that exits try's body, such as a return statement (when the bytecodes for body are completed normally) or throw statement (when the bytecodes for body "throw" an exception representing an error condition to be handled by a "universal error handler"), are preceded in the translation by a jsr to that subroutine, which would store the pushed return address in a local variable, perform the work of the handler, then perform a ret.
      <br/>
      Although a jsr subroutine resembles a real method, there is a crucial difference: it executes in the same stack frame as its containing method and has access to all the local variables of this method.
    </p>
    <p num="23">
      According to the exception for verification of jsr subroutines, the bytecode verifier permits a local variable v that is neither read nor written in a jsr to retain its type across a jsr to that subroutine.
      <br/>
      This exception causes difficulty for implementing exact garbage collection in the JVM.
    </p>
    <p num="24">
      Consider the case shown in FIG. 1 in which there are two jsr's, one from PATH A and a second from PATH B, leading to the same jsr subroutine C. At the jsr from PATH A, a local variable r3 is used to hold an integer value (7), and at the other jsr from PATH B, r3 holds a reference (to a location holding the string "HI").
      <br/>
      Assume that the jsr subroutine C does not use r3 in any way.
      <br/>
      In this case, the exception forjsr subroutines allows each of PATH A and PATH B to assume that r3 is of the appropriate type for its use after return from the jsr.
      <br/>
      However, should a garbage collection occur at gc point while a thread is in the jsr subroutine C, the JVM is unable to determine from the stack map whether r3 contains a reference.
      <br/>
      Thus, the path leading to the subroutine constitutes the determinative factor for the contents of r3.
      <br/>
      If r3 contains a reference then the garbage collector must process it as a reference; otherwise, it should ignore r3.
      <br/>
      Similarly, as shown in FIG. 2, the stack map is unclear as to the contents of r3 ; from PATH B the variable contains a reference but from PATH A the variable is not initialized.
    </p>
    <p num="25">
      Simply ignoring these conflicts (i.e., the ref-val conflict and ref-uninit conflict) by disallowing garbage collections for the duration of the jsr subroutine is not an option since try-finally handlers can perform arbitrary computation, including calling methods that may execute indefinitely and allocate an unbounded number of objects.
      <br/>
      Accordingly, there is a need for a technique to eliminate the ref-val and ref-uninit conflicts associated with bytecodes defining two control paths leading to the same sequence of instructions, such as a subroutine, where it is generally not possible to determine whether a variable contains a reference during execution of the subroutine due to the existence of either type of conflict.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="26">
      Methods and systems consistent with the present invention improve garbage collection by modifying code that introduces a conflict in the assignment of variables for identifying references.
      <br/>
      The conflict exists, for example, when a method includes code defining at least two control paths leading to a common subroutine and the garbage collector initiated during execution of the subroutine cannot determine whether a variable represents a reference.
      <br/>
      By rewriting the code in accordance with the principles of the present invention to eliminate the conflicts, the collector is able to reclaim memory space effectively during execution of the subroutine.
    </p>
    <p num="27">In accordance with the present invention, as embodied and broadly described herein, a method for modifying a sequence of instructions to improve memory management within a storage device during execution of the instructions, comprises the steps, performed by a processor, of (a) analyzing the sequence of instructions for a conflict indicating an undeterminable variable type, (b) determining the type of conflict, and (c) modifying the sequence of instructions to eliminate the conflict based on the determination.</p>
    <p num="28">In accordance with another aspect of the present invention, as embodied and broadly described herein, a method for generating a sequence of bytecodes for execution by a virtual machine, comprises the steps of determining whether the bytecode set includes bytecodes defining two paths branching to a routine, determining whether a variable assignment from each path causes a conflict of unknown variable type in the routine, and modifying all bytecodes of one of the paths that cause the conflict with a new variable assignment.</p>
    <p num="29">In accordance with another aspect of the present invention, as embodied and broadly described herein, a method for generating bytecodes executable by a virtual machine, comprises the steps of analyzing a sequence of bytecodes for bytecodes defining two paths in which at least one bytecode of one path uses a variable to store a primitive value and at least one bytecode of the other path uses the variable to store a reference, determining whether both paths branch to a routine comprised of a subset of the sequence of bytecodes, and modifying the bytecode of one of the paths to use a different variable.</p>
    <p num="30">In accordance with yet another aspect of the present invention, as embodied and broadly described herein, a method for modifying a sequence of instructions to improve memory management within a storage device during execution of the instructions by a virtual machine, comprises the steps of preprocessing a sequence of instructions, identifying a first subset of the sequence of instructions that uses a storage location for a value, identifying a second subset of the sequence of instructions that uses the storage location for a reference, determining whether both subsets branch to a routine comprised of a third subset of the sequence of instructions, and modifying instructions from the first or second subset to use a new storage location.</p>
    <p num="31">In accordance with still another aspect of the present invention, as embodied and broadly described herein, a method for modifying a sequence of instructions executable by a virtual machine, comprises the steps of preprocessing a sequence of instructions, identifying a first subset of the sequence of instructions that uses a variable for a reference, identifying a second subset of the sequence of instructions, determining whether both subsets branch to a routine comprised of a third subset of the sequence of instructions, and adding at least one instruction to the sequence of instructions to initialize the variable based on whether the variable is used by an instruction in the second subset.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="32">
      The accompanying drawings, which are incorporated in and constitute a part of this specification and, together with the description, serve to explain the advantages and principles of the invention. In the drawings,
      <br/>
      FIG. 1 is a block diagram of program flow used to explain a reference-primitive value conflict for garbage collection;
      <br/>
      FIG. 2 is a block diagram of program flow used to explain a reference-uninitialized variable conflict for garbage collection;
      <br/>
      FIG. 3A is a schematic block diagram illustrating a computer architecture suitable for use with the present invention;
      <br/>
      FIG. 3B is a conceptual illustration of a program stack;
      <br/>
      FIG. 3C is a conceptual illustration of a program stack, including frames, suitable for use with the present invention;
      <br/>
      FIG. 3D is a conceptual illustration of a program stack with reference locations represented by a bit vector;
      <br/>
      FIG. 4 illustrates a code rewriter consistent with the present invention;
      <br/>
      FIG. 5 is a flowchart of the steps performed by the code rewriter consistent with the present invention;
      <br/>
      FIG. 6 is an example of program code written in the Java language that includes a try-finally instruction;
      <br/>
      FIG. 7 is an example of compiled bytecodes for the program code of FIG. 6 with both reference-primitive value and reference-uninitialized variable conflicts; and
      <br/>
      FIG. 8 is an example of bytecodes without the conflicts shown in the bytecodes of FIG. 7, which conflicts were corrected in accordance with the present invention.
    </p>
    <heading>DETAILED DESCRIPTION</heading>
    <p num="33">
      The following detailed description of the invention refers to the accompanying drawings.
      <br/>
      The description includes exemplary embodiments, other embodiments are possible, and changes may be made to the embodiments described without departing from the spirit and scope of the invention.
      <br/>
      The following detailed description does not limit the invention.
      <br/>
      Instead, the scope of the invention is defined by the appended claims.
    </p>
    <p num="34">
      Systems consistent with the present invention address the requirements of exact garbage collection algorithms.
      <br/>
      Specifically, such systems enable exact garbage collectors to distinguish references from non-references within a stack in situations where heretofore such distinctions were not possible because of variable assignment conflicts.
      <br/>
      The conflicts are caused by certain conditions set by rules and exceptions dictated by Java's bytecode verifier.
      <br/>
      They made it impossible for a collector, which relies on only the program counter to determine the stack map to use, to determine conclusively whether a local variable with an assigned stack frame slot represents a reference.
      <br/>
      Such conflicts are eliminated by rewriting selected bytecodes to refer to a different variable or adding additional bytecodes to initialize the variable, thus improving operation of the garbage collector.
    </p>
    <p num="35">
      Although the illustrative embodiments of systems consistent with the present invention are described with reference to a computer system implementing the Java programming language on the JVM specification, the invention is equally applicable to other computer systems having similar requirements.
      <br/>
      Specifically, the invention may be implemented with both object-oriented and nonobject-oriented programming systems.
      <br/>
      Further, the invention may be implemented with systems having single threads and single data stacks as well as with multi-threaded systems, having multiple simultaneous program stacks.
      <br/>
      Prior to describing the invention in detail, the descriptions of computer systems suitable for use with the present invention and a program stack structure are provided for the reader's benefit.
    </p>
    <p num="36">Computer System and Program Stack Architecture</p>
    <p num="37">
      FIG. 3A illustrates the system architecture for a computer system with which the invention may be implemented.
      <br/>
      The exemplary computer system of FIG. 3A is for descriptive purposes only.
      <br/>
      Although the description may refer to terms commonly used in describing particular computer systems, such as in IBM PS2 personal computer, the description and concepts equally apply to other computer systems such as network computers, work stations, and main frame computers having architectures dissimilar to FIG. 3A.
    </p>
    <p num="38">
      Computer system 100 includes a central processing unit (CPU) 105, which may be implemented with a conventional microprocessor, a random access memory (RAM) 110 for temporary storage of information, and a read only memory (ROM) 115 for permanent storage of information.
      <br/>
      A memory controller 120 is provided for controlling RAM 110.
    </p>
    <p num="39">
      A bus 130 interconnects the components of computer system 100.
      <br/>
      A bus controller 125 is provided for controlling bus 130.
      <br/>
      Interrupt controller 135 is used for receiving and processing various interrupt signals from the system components.
    </p>
    <p num="40">
      Mass storage may be provided by diskette 142, CD ROM 147, or a hard disk drive 152.
      <br/>
      Data and software may be exchanged with computer system 100 via removable media such as diskette 142 and CD ROM 147.
      <br/>
      Diskette 142 is insertable into diskette drive 141 which is, in turn, connected to bus 30 by a controller 140.
      <br/>
      Similarly, CD ROM 147 is insertable into CD ROM drive 146 which is, in turn, connected to bus 130 by controller 145.
      <br/>
      Hard disk 152 is part of a fixed disk drive 151, which is connected to bus 130 by controller 150.
    </p>
    <p num="41">
      User input to computer system 100 may be provided by a number of devices.
      <br/>
      For example, a keyboard 156 and mouse 157 are connected to bus 130 by controller 155.
      <br/>
      It will be obvious to those skilled in the art that other input devices such as an audio transducer may be connected to bus 130 via an appropriate controller.
    </p>
    <p num="42">
      DMA controller 160 is provided for performing direct memory access to RAM 110.
      <br/>
      A visual display is generated by video controller 165 which controls video display 170.
      <br/>
      Computer system 100 also includes a communications adapter 190 which allows the system to be interconnected to a local area network (LAN) or a wide area network (WAN), schematically illustrated by bus 191 and network 195.
    </p>
    <p num="43">
      Operation of computer system 100 is generally controlled and coordinated by operating a system software, which may be single or multiple threaded.
      <br/>
      The operating system controls allocation of system resources and performs tasks such as process scheduling, memory management, networking, and I/O services, among other things.
    </p>
    <p num="44">
      In computing systems with which the invention may be implemented, an ongoing computation uses a "program stack" or "stack," to support procedure calls and to hold intermediate computational quantities such as references, and primitive values.
      <br/>
      FIG. 3B illustrates conceptually the structure of a conventional program stack implemented in system memory.
      <br/>
      Three important positions in memory define the stack: the stack base, the stack pointer, i.e., the current stack top, and the stack limit.
      <br/>
      Typically, these positions are identified by memory addresses kept in three machine registers.
    </p>
    <p num="45">
      When a datum is pushed onto the stack, it is stored into the unused memory location nearest the stack pointer.
      <br/>
      The stack pointer is then advanced toward the stack limit.
      <br/>
      If the stack pointer is too close to the stack limit, the stack is said to "overflow" and some special action must be taken, e.g., signal and error or allocate more memory to hold the stack.
    </p>
    <p num="46">
      When a datum is popped from the stack, the stack pointer recedes toward the stack base, causing the memory that holds the datum to become regarded as unused memory again.
      <br/>
      If the stack pointer is too close to the stack base, the stack is said to "underflow" and some special action must be taken, e.g., signal an error.
      <br/>
      Depending on the implementation, the stack base may reside at either a higher or lower memory address than the stack limit.
    </p>
    <p num="47">
      In most implementations of the Java programming language, data on the program stack is grouped into "frames," as illustrated in FIG. 3C. Each frame corresponds to one level of method invocation.
      <br/>
      Every frame is divided into three regions: parameters, local variables, and evaluation temporaries.
      <br/>
      Parameters are closest to the stack base while the evaluation temporaries are furthest from the stack base.
      <br/>
      Each of these three regions may be empty, depending on the particular subroutine to be executed with that frame.
      <br/>
      As the subroutine executes, the number of evaluation temporaries may vary as items are pushed onto or popped from the stack, however, the number of parameters and local variables typically does not vary.
      <br/>
      For purposes of this description, the term "operand stack" is used to refer to the portion of each stack frame used for evaluation temporaries.
    </p>
    <p num="48">
      To simplify addressing of parameters in local variables, an additional address, the "frame pointer," typically kept in a machine register, indicates the start of the parameter area in the active stack frame.
      <br/>
      Instructions can then access a parameter or local variable in the active frame by specifying an offset from the active frame pointer.
    </p>
    <p num="49">
      When the method is invoked, some items at the top of the operand stack become parameters within the new frame.
      <br/>
      In other words, the newly invoked method uses data items from its calling method.
      <br/>
      The active frame pointer is saved on this stack along with the program counter.
      <br/>
      The frame pointer is then loaded with the address of the new frame while the program counter is loaded with the address of the code for the method.
    </p>
    <p num="50">
      A technique by which references are designated on a stack is shown in FIG. 3D, which illustrates a logical stack 1000 and accompanying stack map or bit vector 1014.
      <br/>
      While stack 1000 is conceptually shown as a block of contiguous memory locations, an actual stack may be comprised of several non-contiguous blocks of memory.
      <br/>
      However, for purposes of this description, the stack acts logically as a single contiguous block of memory.
      <br/>
      Each memory location, for example memory location 1002, can hold a variety of information, including different data types and references or pointers.
      <br/>
      As previously mentioned, the location of references are important to garbage collection, which must either modify or follow the references.
    </p>
    <p num="51">
      In FIG. 3D memory locations designated as 1004, 1006, and 1008 illustratively contain reference information.
      <br/>
      The location of the references in a stack is mapped by bit vector 1014, which contains a bit for each location in the stack.
      <br/>
      For example, bit 1010 corresponds to location 1002 and bit 1012 corresponds to location 1004.
      <br/>
      As shown in FIG. 3D, the bits in the bit vector have been set in locations corresponding to the references locations, thus bit vector 1014 has locations 1012, 1016, and 1018 set in order to indicate that the corresponding stack location contains a reference.
      <br/>
      Programs, such as garbage collectors, which need to access the references can then examine the bit vector to determine which corresponding stack locations contain references even though the actual data in the stack locations does not positively identify references.
    </p>
    <p num="52">
      Although this description focuses on references stored in the stack frame, Java implementations may use machine registers to store references and primitive values to further improve execution time.
      <br/>
      Assignment of primitive values and references to these machine registers can also result in instances of ref-val and ref-uninit conflicts, and those skilled in the art will recognize that the methodology described herein may be used to resolve such conflicts.
    </p>
    <p num="53">Code Rewriter</p>
    <p num="54">
      Systems consistent with the present invention include a code rewriter in a virtual machine, such as the JVM.
      <br/>
      As shown in FIG. 4, the input to code rewriter 400 includes an instruction sequence, i.e., bytecodes, that have passed a bytecode verification process and, as such, satisfies syntax and other constraints.
      <br/>
      In general, code rewriter 400 determines whether any ref-val or ref-uninit conflicts are present in the bytecodes and modifies the instruction sequence to eliminate such conflicts.
      <br/>
      It eliminates ref-val conflicts by changing variable assignments such that bytecodes creating such conflicts do not refer to the same local variable.
      <br/>
      In the case of ref-uninit conflicts, code rewriter 400 adds bytecodes to the instruction sequence to initialize the variables creating such conflicts.
    </p>
    <p num="55">Conflict Elimination Process</p>
    <p num="56">
      FIG. 5 is a flowchart of the steps performed by code rewriter 400 to locate and eliminate both ref-val and ref-uninit conflicts.
      <br/>
      First, code rewriter 400 sets a variable named "DO-IT-AGAIN" to "FALSE" (step 505).
      <br/>
      Those skilled in the art will recognize that the DO-IT-AGAIN variable used to make sure the process steps are repeated until all ref-val and ref-uninit conflicts are eliminated from the code.
    </p>
    <p num="57">
      Next, code rewriter 400 examines an input set of bytecodes for ref-val conflicts (step 510) and, if any conflicts are located, code rewriter 400 modifies the bytecodes to eliminate those conflicts (step 520).
      <br/>
      Ref-val conflicts are eliminated by modifying bytecodes from one of the paths creating the conflict to refer to a local variable different from the unchanged bytecodes in the other path.
      <br/>
      For example, in the conflict example shown in FIG. 1, the variable r3 in PATH B may be changed to variable r4, or the variable r3 in PATH A may be changed to variable r4.
      <br/>
      If there are any ref-val conflicts, code rewriter 400 sets the DO-IT-AGAIN variable to "TRUE" (step 525).
    </p>
    <p num="58">
      Similarly, code rewriter 400 examines an input set of bytecodes for ref-uninit conflicts (step 530) and, if any conflicts are located, code rewriter 400 modifies the bytecodes to eliminate those conflicts (step 540).
      <br/>
      Ref-uninit conflicts are eliminated by adding bytecodes before both of the paths creating the conflict to initialize the variable causing the conflict.
      <br/>
      Code rewriter 400 then sets the DO-IT-AGAIN variable to "TRUE" (step 545).
    </p>
    <p num="59">
      Code rewriter 400 then tests the contents of DO-IT-AGAIN (step 560).
      <br/>
      If DO-IT-AGAIN was set to "TRUE" in either step 525 or step 545, flow returns to step 505.
      <br/>
      This ensures that code rewriter 400 repeats the process until all ref-val and ref-uninit conflicts are eliminated from the bytecodes, including any conflicts created during conflict elimination (steps 520 and 540) of a previous iteration.
      <br/>
      Otherwise, DO-IT-AGAIN is "FALSE", and the process is complete.
    </p>
    <heading>EXAMPLE</heading>
    <p num="60">
      The following example provides a further understanding of the conflict resolution process that eliminates the ref-val and ref-uninit conflicts from bytecode sequences.
      <br/>
      As explained, conflicts generally arise in bytecodes corresponding to the Java try-finally instruction, although other bytecode sets, including those resulting from other Java instructions, may also cause conflicts.
    </p>
    <p num="61">
      FIG. 6 shows an example of the Java instructions for a method 600 that includes a try-finally clause.
      <br/>
      Instructions 610 and 620 are statements used to declare objects of two classes A and B, respectively.
      <br/>
      Instructions 630 constitute the body of the try and instructions 640 constitute the handler of the finally clause.
      <br/>
      This try-finally clause is a method of class A 620.
      <br/>
      Regardless of whether instructions 630 are completed successfully (i.e., without error), the JVM will perform bytecodes corresponding to instructions 640.
      <br/>
      The ellipse (. . .) is used to signify that there are additional instructions which are not shown because the are not pertinent to the present explanation.
    </p>
    <p num="62">
      In general, instructions 630 set a variable "itmp" equal to the integer value I ("int itmp=1").
      <br/>
      Then, a method called "tryltOut" is invoked.
      <br/>
      Following "tryItOut" the instruction "i=i+itrnp" sets the variable "i" equal to the sum of its current value and the value of "itmp" (which is always 1).
      <br/>
      For example, since "i" is initialized to 7, if no other code modifies "i", the first invocation of "tryFinally" will increment "i" from 7 to 8.
      <br/>
      Then, a new object of class B is allocated, with the variable "b" being used to identify the new object, and tryItOut is called again before the method useIt( ) is invoked on the new object b. The sole instruction of finally handler 640 simply invokes the wrapItUp method.
    </p>
    <p num="63">
      FIG. 7 contains an example of the bytecodes 700 that a Java compiler may generate to implement the try-finally of FIG. 6 in the JVM.
      <br/>
      Those skilled in the art will recognize that an explanation of bytecodes 700 is easily discernable with reference to the JVM Specification described above.
    </p>
    <p num="64">
      Each bytecode has an instruction number, which is illustrated symbolically in FIG. 7 by the "0:" adjacent bytecode 702, the "n:" adjacent bytecode 730, the "E:" adjacent bytecode 732, and the "H:" adjacent bytecode 740.
      <br/>
      The "-" sign is used to show a branch to a specific sequence of bytecodes.
      <br/>
      Thus, the "-H" in bytecode 728 is used to refer to the sequence of bytecodes beginning with the bytecode at instruction number "H".
    </p>
    <p num="65">
      Bytecodes 702-730 comprise instructions corresponding to the try clause 630, and bytecodes 740-744 comprise instructions corresponding to the finally clause 640 of FIG. 6.
      <br/>
      The "E:" instruction number is used to show that bytecodes 732-738 comprise the error handler, or "universal exception handler," which operates when an exception or error occurs during execution of bytecodes 702-730, or the bytecodes corresponding to instruction numbers 0-n as defined in the Exception table 750.
    </p>
    <p num="66">
      Bytecode 702 is used to push the integer value 1 on top of the operand stack.
      <br/>
      For purposes of the following description, the term "variable" is used to refer to a stack frame slot; thus, "variable 3" means the third stack frame slot.
      <br/>
      The compiler selected variable 3 to store the value for itmp so bytecode 704 stores the value (1) from the top of the operand stack in variable 3.
      <br/>
      Bytecode 706 invokes the tryltOut method, the details of which are not shown.
    </p>
    <p num="67">
      Bytecode 708 pushes the value of static variable "i", which may also have a slot in the stack frame or correspond to a machine register, and bytecode 710 pushes the value stored in variable 3 on the operand stack as well so that bytecode 712 can pop both integers from the operand stack, add them together, push the result back on the operand stack.
      <br/>
      Then, bytecode 714 saves the result, which is now on the top of the operand stack, in static variable i. This set of bytecodes 708-714 corresponds to the Java instruction "i=i+itmp".
    </p>
    <p num="68">
      Bytecode 716 allocates space for a new object of class B, and pushes the reference or pointer where the new B can be located in the memory heap on the top of the operand stack.
      <br/>
      Bytecode 717 duplicates the top entry in the operand stack.
      <br/>
      Bytecode 718 calls a special routine that initializes the new object pointed to by the reference on the top of the operand stack.
      <br/>
      Determining that variable 3 can be reused, and perhaps to optimize execution, the compiler decides to use variable 3 again in bytecode 720 to store the reference to the new object.
      <br/>
      Bytecodes 716-720 correspond to the Java instruction "B b=new B0 ". Bytecode 722 invokes the routine tryItOut again before bytecode 724 pushes the reference for the new object back on the operand stack so it can be used by the uselt method, which is invoked in bytecode 726.
      <br/>
      To make sure bytecodes 740-744, which correspond to the finally clause 640, are executed wheb bytecodes 702-730 of the try clause are completed, the compiler sets up bytecodes 740-744 for the finally clause 640 as a separate routine, which is identified in this example by the instruction number "H" (which symbolizes the "handler"), and uses bytecode 728 to jump to the routine identified by the H.
    </p>
    <p num="69">
      Bytecode 740 stores in variable 2 the value of the program counter, which is the instruction number for the bytecode following the jsr 728, i.e., "n" for bytecode 730.
      <br/>
      The return bytecode signifies the end of method 600.
      <br/>
      Bytecode 742 invokes the routine for wrapItUp, after which bytecode 744 causes the JVM to restore the program counter with the value stored in variable 2, i.e., the instruction number for the bytecode following the bytecode that branched to the handler.
    </p>
    <p num="70">
      Exception handler 760 begins with bytecode 732 that stores a reference in variable 1 for the exception that caused entry into handler 760, which is on the top of the operand stack.
      <br/>
      To make sure the finally handler is executed even when an exception occurs, bytecode 734 causes the JVM to branch to bytecode 740.
      <br/>
      Following return to handler 760, the exception in variable 1 is pushed on the stack by bytecode 736, after which bytecode 738 throws the exception such that when an exception occurs during method execution that exception is returned to the invoker of method 600.
    </p>
    <p num="71">
      The example bytecodes in FIG. 7 include examples of both kinds of conflicts.
      <br/>
      Local variable 1, which is used in the universal exception handler 760 to hold the thrown exception across the jsr, causes a ref-uninit conflict.
      <br/>
      If an exception is thrown, variable 1 holds a reference in the finally clause; if no exception is thrown, it is uninitialized.
      <br/>
      The solution is to add the following two instructions to the top of the method to initialize variable 1:
    </p>
    <p num="72">aconst_null</p>
    <p num="73">astore 1--</p>
    <p num="74">These instructions ensure that variable 1 holds a reference along both paths.</p>
    <p num="75">
      The second conflict is a ref-val conflict on variable 3.
      <br/>
      At compile time, the Java compiler decided that variable 3 was unused after the last use of "itmp" in the Java code, and, thus, it reused variable 3 for the object "b".
      <br/>
      But the path to the finally clause may be from an exception during the first call to "tryItOut", in which case variable 3 contains an integer, or the path to the finally clause may be after the second call to "tryltOut" raised an exception, in which case variable 3 contains a reference, specifically, to object "b".
      <br/>
      Alternatively, the path to the finally clause may be after neither invocation of tryItOut raises an exception, i.e., the try clause completes successfully, in which case variable 3 also contains the reference "b".
    </p>
    <p num="76">
      In accordance with one implementation of the present invention, the solution to the ref-val conflict is to rewrite uses of variable 3 as shown in FIG. 8.
      <br/>
      Bytecodes 800 include bytecodes 810 and 820 as the solution to the ref-uninit conflict with variable 1 and bytecodes 830 and 840 change the uses of variable 3 in bytecodes 720 and 724 (of FIG. 7) to variable 4, which in fact solves the ref-val conflict by eliminating the possible dual use of variable 3 for both a value and reference.
    </p>
    <p num="77">
      The Java bytecode instruction set includes in each instruction sufficient type information to determine whether a given instruction uses a local variable as a reference.
      <br/>
      In particular, the astore and aload instructions are the only instructions that access references in local variables, so code rewriter 400 need only search for these instructions accessing the local variable to be rewritten, correcting those to refer to a different local variable.
    </p>
    <p num="78">
      There is one exception to this property: the astore instruction is usually used to pop a reference (or address, hence the prefix letter a) from the operand stack and store it in a local variable, but it may also be used to do the same with return addresses pushed on the operand stack byjsr instructions.
      <br/>
      Accordingly, code rewriter 400 maintains sufficient information to determine whether the entry at the operand stack top at the point of an astore is such a return address to circumvent this complication.
      <br/>
      If the astore operates on a return address from the operand stack, code rewriter 400 ignores that instruction during the rewriting process.
    </p>
    <p num="79">Conclusion</p>
    <p num="80">
      In accordance with the present invention a virtual machine can distinguish stored references from non-references to improve exact garbage collection.
      <br/>
      This is accomplished by either adding new instructions or rewriting existing instructions, depending on the type of conflict.
      <br/>
      When it is determined that an instruction sequence t includes code defining at least two control paths leading to a common jsr subroutine and it is not possible to determine whether a variable from both paths is a reference or non-reference, and that variable is used after return from the subroutine on at least one of the paths, one or more instructions, including those from one of the paths, are rewritten to eliminate the use of the same variable as the other path and, with it, the conflict itself.
      <br/>
      By eliminating such conflicts, a garbage collector in accordance with the present invention can effectively reclaim memory space during execution of the subroutine.
    </p>
    <p num="81">
      The foregoing description of an implementation of the invention has been presented for purposes of illustration and description.
      <br/>
      It is not exhaustive and does not limit the invention to the precise form disclosed.
      <br/>
      Modifications and variations are possible in light of the above teachings or may be acquired from practicing of the invention.
      <br/>
      For example, the described implementation includes software but the present invention may be implemented as a combination of hardware and software or in hardware alone.
      <br/>
      The scope of the invention is defined by the claims and their equivalents.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A method for modifying a sequence of instructions to improve memory management within a storage device during execution of the instructions, comprising the steps, performed by a processor, of:</claim-text>
      <claim-text>determining whether the sequence of instructions reflects a conflict indicated by an undeterminable variable type resulting from two paths of instructions that branch to a routine;</claim-text>
      <claim-text>and modifying the sequence of instructions to eliminate the conflict based on the determination.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The method of claim 1, wherein the determining step includes the substep of determining whether an instruction from a first one of the two paths uses a variable in a manner different from an instruction from a second one of the two paths.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The method of claim 1, wherein the determining step includes the substeps of ascertaining whether an instruction from a first one of the two paths uses a storage location for a value;</claim-text>
      <claim-text>and ascertaining whether an instruction from a second one of the two paths uses the storage location for a reference.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The method of claim 3, wherein the modifying step includes the substep of rewriting the instruction from the first one of the two paths that uses the storage location for a value to use a different storage location.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The method of claim 3, wherein the modifying step includes the substep of rewriting the instruction from the second one of the two paths that uses the storage location for a reference to use a different storage location.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The method of claim 1, wherein the determining step includes the substeps of ascertaining whether an instruction from a first one of the two paths uses a storage location for a reference;</claim-text>
      <claim-text>and ascertaining whether a second one of the two paths uses the storage location.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The method of claim 6, wherein the modifying step includes the substep of adding an instruction that initializes the storage location.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. An apparatus for modifying a sequence of instructions to improve memory management within a storage device during execution of the instructions, comprising: a memory containing a program;</claim-text>
      <claim-text>and a processor responsive to the program and configured to (i) determine whether the sequence of instructions reflects a conflict indicated by an undeterminable variable type resulting from two paths of instructions that branch to a routine, and (ii) modify the sequence of instructions to eliminate the conflict based on the determination.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The apparatus of claim 8, wherein when the processor determines whether the sequence of instructions reflects a conflict indicated by an undeterminable variable type resulting from two paths of instructions that branch to a routine, the processor determines whether an instruction from a first one of the two paths uses a variable in a manner different from an instruction from a second one of the two paths.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The apparatus of claim 8, wherein when the processor determines whether the sequence of instructions reflects a conflict indicated by an undeterminable variable type resulting from two paths of instructions that branch to a routine, the processor ascertains whether an instruction from a first one of the two paths uses a storage location for a value, and ascertains whether an instruction from a second one of the two paths uses the storage location for a reference.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. The apparatus of claim 10, wherein when the processor modifies the sequence of instructions to eliminate the conflict based on the determination, the processor rewrites the instruction from the first one of the two paths that uses the storage location for a value to use a different storage location.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The apparatus of claim 10, wherein when the processor modifies the sequence of instructions to eliminate the conflict based on the determination, the processor rewrites the instruction from the second one of the two paths that uses the storage location for a reference to use a different storage location.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The apparatus of claim 8, wherein when the processor determines whether the sequence of instructions reflects a conflict indicated by an undeterminable variable type resulting from two paths of instructions that branch to a routine, the processor ascertains whether an instruction from a first one of the two paths uses a storage location for a reference, and ascertains whether a second one of the two paths uses the storage location.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The apparatus of claim 13, wherein when the processor modifies the sequence of instructions to eliminate the conflict based on the determination, the processor adds an instruction that initializes the storage location.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A computer-readable medium containing instructions for causing a processor to perform a method for modifying a sequence of instructions to improve memory management within a storage device during execution of the instructions, the method comprising: determining whether the sequence of instructions reflects a conflict indicated by an undeterminable variable type resulting from two paths of instructions that branch to a routine;</claim-text>
      <claim-text>and modifying the sequence of instructions to eliminate the conflict based on the determination.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The computer-readable medium of claim 15, wherein the determining step includes the substep of determining whether an instruction from a first one of the two paths uses a variable in a manner different from an instruction from a second one of the two paths.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The computer-readable medium of claim 15, wherein the determining step includes the substeps of ascertaining whether an instruction from a first one of the two paths uses a storage location for a value;</claim-text>
      <claim-text>and ascertaining whether an instruction from a second one of the two paths uses the storage location for a reference.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The computer-readable medium of claim 17, wherein the modifying step includes the substep of rewriting the instruction from the first one of the two paths that uses the storage location for a value to use a different storage location.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The computer-readable medium of claim 17, wherein the modifying step includes the substep of rewriting the instruction from the second one of the two paths that uses the storage location for a reference to use a different storage location.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The computer-readable medium of claim 15, wherein the determining step includes the substeps of ascertaining whether an instruction from a first one of the two paths uses a storage location for a reference;</claim-text>
      <claim-text>and ascertaining whether a second one of the two paths uses the storage location.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. The computer-readable medium of claim 20, wherein the modifying step includes the substep of adding an instruction that initializes the storage location.</claim-text>
    </claim>
  </claims>
</questel-patent-document>