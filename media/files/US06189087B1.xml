<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06189087B1.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as first publication">
      <document-id>
        <country>US</country>
        <doc-number>06189087</doc-number>
        <kind>B1</kind>
        <date>20010213</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6189087</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B1</original-publication-kind>
    <application-reference family-id="22517123" extended-family-id="522550">
      <document-id>
        <country>US</country>
        <doc-number>08906730</doc-number>
        <kind>A</kind>
        <date>19970805</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1997US-08906730</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43024049</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>90673097</doc-number>
        <kind>A</kind>
        <date>19970805</date>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997US-08906730</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>US</country>
        <doc-number>62838996</doc-number>
        <kind>A</kind>
        <date>19960405</date>
        <priority-linkage-type>B</priority-linkage-type>
        <priority-active-indicator>N</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1996US-08628389</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="3">
        <country>US</country>
        <doc-number>14638393</doc-number>
        <kind>A</kind>
        <date>19931029</date>
        <priority-linkage-type>B</priority-linkage-type>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="3">
        <doc-number>1993US-08146383</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010213</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <term-of-grant>
      <disclaimer/>
    </term-of-grant>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/38        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>38</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   9/318       20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>318</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="4">
        <text>G06F   9/455       20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>455</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>712208000</text>
        <class>712</class>
        <subclass>208000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>712209000</text>
        <class>712</class>
        <subclass>209000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>712212000</text>
        <class>712</class>
        <subclass>212000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>712215000</text>
        <class>712</class>
        <subclass>215000</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>712E09029</text>
        <class>712</class>
        <subclass>E09029</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>712E09037</text>
        <class>712</class>
        <subclass>E09037</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>712E09049</text>
        <class>712</class>
        <subclass>E09049</subclass>
      </further-classification>
    </classification-national>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/382</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>382</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30149</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30149</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30152</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30152</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30174</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30174</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130620</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3816</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3816</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="6">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3836</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3836</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="7">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/384</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>384</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140317</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="8">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3855</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3855</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140317</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="9">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3857</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3857</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140317</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>34</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>16</number-of-drawing-sheets>
      <number-of-figures>18</number-of-figures>
      <image-key data-format="questel">US6189087</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Superscalar instruction decoder including an instruction queue</invention-title>
    <references-cited>
      <citation srep-phase="applicant">
        <patcit num="1">
          <text>CHRISTENSEN N, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>3781808</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US3781808</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="2">
          <text>WOLF GERHARD</text>
          <document-id>
            <country>US</country>
            <doc-number>4044338</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4044338</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="3">
          <text>CUSHING DAVID E, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4161784</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4161784</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="4">
          <text>RIFFE JOSEPHUS, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4502111</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4502111</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>SHINTANI YOOICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4736288</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4736288</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <text>TORNG HWA C</text>
          <document-id>
            <country>US</country>
            <doc-number>4807115</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4807115</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>KURIYAMA KAZUNORI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4858105</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4858105</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>STIMAC GARY A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4926322</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4926322</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>DAO TICH T, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4928223</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4928223</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>PORTANOVA GREGORY A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4992934</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4992934</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>ACHARYA KISHORE C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5056006</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5056006</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="12">
          <text>CIRCELLO JOSEPH C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5101341</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5101341</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="13">
          <text>TAMURA GLENN A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5128888</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5128888</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="14">
          <text>JOHNSON WILLIAM M</text>
          <document-id>
            <country>US</country>
            <doc-number>5129067</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5129067</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="15">
          <text>CIRCELLO JOSEPH C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5131086</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5131086</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="16">
          <text>JOHNSON WILLIAM M</text>
          <document-id>
            <country>US</country>
            <doc-number>5136697</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5136697</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="17">
          <text>KOHN LESLIE D</text>
          <document-id>
            <country>US</country>
            <doc-number>5155816</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5155816</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="18">
          <text>KISHIGAMI HIDECHIKA, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5155817</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5155817</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="19">
          <text>GIBSON GLENN A</text>
          <document-id>
            <country>US</country>
            <doc-number>5155820</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5155820</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="20">
          <text>TRAN THANG M</text>
          <document-id>
            <country>US</country>
            <doc-number>5185868</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5185868</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="21">
          <text>GILL MICHAEL C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5222230</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5222230</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="22">
          <text>MCFARLAND HAROLD L, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5226126</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5226126</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="23">
          <text>FAVOR JOHN G, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5226130</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5226130</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="24">
          <text>HOTTA TAKASHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5233694</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5233694</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="25">
          <text>SUZUKI NARIKO</text>
          <document-id>
            <country>US</country>
            <doc-number>5233696</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5233696</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="26">
          <text>TRAN THANG M</text>
          <document-id>
            <country>US</country>
            <doc-number>5251306</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5251306</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="27">
          <text>DELANO ERIC R, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5337415</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5337415</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="28">
          <text>HORST ROBERT W</text>
          <document-id>
            <country>US</country>
            <doc-number>5390355</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5390355</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="29">
          <text>COON BRETT, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5438668</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5438668</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="30">
          <text>KAHLE JAMES A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5465373</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5465373</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="31">
          <text>SATO TAIZO, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5488710</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5488710</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="32">
          <text>ANDO HIDEKI</text>
          <document-id>
            <country>US</country>
            <doc-number>5497496</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5497496</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="33">
          <text>STILES DAVID R</text>
          <document-id>
            <country>US</country>
            <doc-number>5513330</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5513330</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="34">
          <text>WHITE SCOTT A, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5632023</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5632023</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="35">
          <text>WITT DAVID B, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5651125</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5651125</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="36">
          <text>AMDAHL CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0259095</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-259095</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="37">
          <text>DIGITAL EQUIPMENT CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0380854</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-380854</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="38">
          <text>DIGITAL EQUIPMENT CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0381471</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-381471</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="39">
          <text>IBM</text>
          <document-id>
            <country>EP</country>
            <doc-number>0454984</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-454984</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="40">
          <text>IBM</text>
          <document-id>
            <country>EP</country>
            <doc-number>0454985</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-454985</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="41">
          <text>NAT SEMICONDUCTOR CORP</text>
          <document-id>
            <country>EP</country>
            <doc-number>0459232</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-459232</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="42">
          <text>FUJITSU LTD</text>
          <document-id>
            <country>EP</country>
            <doc-number>0498654</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-498654</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="43">
          <text>FUJITSU LTD</text>
          <document-id>
            <country>EP</country>
            <doc-number>0506972</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-506972</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="44">
          <text>ADVANCED MICRO DEVICES INC</text>
          <document-id>
            <country>EP</country>
            <doc-number>0533337</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>EP-533337</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="45">
          <text>INTEL CORP</text>
          <document-id>
            <country>GB</country>
            <doc-number>2263987</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>GB2263987</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="46">
          <text>AEB JACKED STRUCTURES LTD</text>
          <document-id>
            <country>GB</country>
            <doc-number>2263895</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>GB2263895</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="47">
          <text>INTEL CORP</text>
          <document-id>
            <country>GB</country>
            <doc-number>2281422</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>GB2281422</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="48">
          <text>SEIKO EPSON CORP</text>
          <document-id>
            <country>WO</country>
            <doc-number>9301546</doc-number>
            <kind>A1</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>WO9301546</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="49">
          <text>SEIKO EPSON CORP</text>
          <document-id>
            <country>WO</country>
            <doc-number>9320507</doc-number>
            <kind>A2</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>WO9320507</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>Mike Johnson, "Superscalar Microprocessor Design", (Prentice Hall series in innovative technology), 1991, pp. 129-130, 133-134,A 261-272.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>U.S. Patent Application Serial No. 07/929,770 filed Apr. 12, 1992 entitled "Instruction Decoder and Superscalar Processor Utilizing Same" -David B. Witt and William M. Johnson.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>D.W. Anderson, F.J. Sparacio, F.M. Tomasulo, The IBM System/360 Model 91: Machine Philosophy and Instruction-handling1, chapter 18, Part 2 Regions of Computer Space, Section 3 Concurrency: Single-Processor Systems, IBM Journal, vol. 11, Jan. 1967, pp. 276-292.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>Michael Slater, "AMD's K5 Designed to Outrun Pentium", Microprocessor Report, Oct. 24, 1994, pp. 1, 6-11.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="5">
          <text>"System/370 Emulator Assist Processor for a Reduced Instruction Set Computer", IBM Technical Disclosure Bulletin, vol. 30, No. 10, Mar. 1988, pp. 308-309.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="6">
          <text>Shreekant S. Thakkar and William E. Hostmann, "An Instruction Pitch Unit for a Graph Reduction Machine", IEEE (C) 1986, pp. 82-91.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="7">
          <text>Toyohiko Yoshida, et al, "The Approach to Multiple Instruction Execution in the GMICRO/400 Processor", (C)1991, IEEE, pp. 185-195.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="8">
          <text>Tom R. Halfhill, "AMD K6 Takes on Intel P6", BYTE magazine, Jan. 1996, pp. 67-68, 70, and 72.</text>
        </nplcit>
      </citation>
    </references-cited>
    <related-documents>
      <continuation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>62838996</doc-number>
              <kind>A</kind>
              <date>19960405</date>
            </document-id>
            <parent-status>ABANDONED</parent-status>
          </parent-doc>
        </relation>
        <relation>
          <parent-doc>
            <document-id>
              <country>US</country>
              <doc-number>14638393</doc-number>
              <kind>A</kind>
              <date>19931029</date>
            </document-id>
            <parent-status>ABANDONED</parent-status>
          </parent-doc>
        </relation>
      </continuation>
    </related-documents>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Advanced Micro Devices, Inc.</orgname>
            <address>
              <address-1>Sunnyvale, CA, US</address-1>
              <city>Sunnyvale</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>ADVANCED MICRO DEVICES</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Witt, David B.</name>
            <address>
              <address-1>Austin, TX, US</address-1>
              <city>Austin</city>
              <state>TX</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Goddard, Michael D.</name>
            <address>
              <address-1>Windlesham, GB</address-1>
              <city>Windlesham</city>
              <country>GB</country>
            </address>
          </addressbook>
          <nationality>
            <country>GB</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Skjerven, Morrill, MacPherson, Franklin &amp; Friel, LLP</orgname>
          </addressbook>
        </agent>
        <agent sequence="2" rep-type="agent">
          <addressbook lang="en">
            <name>Terrile, Stephen A.</name>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Vu, Viet D.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A superscalar complex instruction set computer ("CISC") processor having a reduced instruction set computer ("RISC") superscalar core includes an instruction cache which identifies and marks raw x86 instruction start and end points and encodes "pre-decode" information, a byte queue which is a queue of aligned instruction and pre-decode information of the "predicted executed" state, and an instruction decoder which generates type, opcode, and operand pointer values for RISC-like operations (ROPs) based on the aligned pre-decoded x86 instructions in the byte queue and determines the number of possible x86 instruction dispatch for shifting the byte que.
      <br/>
      The instruction decoder includes in each dispatch position a logic conversion path, a memory conversion path, and a common conversion path for converting CISC instructions to ROPs.
      <br/>
      An ROP multiplexer directs x86 instructions from the byte queue to the conversion paths, a select circuit assembles ROP information from the appropriate conversion paths, and a shared circuit processes ROP information from the select circuit for shared resources.
      <br/>
      ROP type and opcode information is dispatched from the instruction decoder to the RISC core.
      <br/>
      Pointers to the A and B source operands are furnished by the instruction decoder to a register file and to a reorder buffer in the RISC core, which in turn furnish the appropriate "predicted executed" versions of the A and B operands to various functional units in the RISC core in coordination with the ROP type and opcode information.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <p num="1">
      This application is a continuation of U.S. patent application Ser.
      <br/>
      No. 08/628,389 filed Apr. 5, 1996, entitled "METHOD AND APPARATUS FOR DECODING ONE OR MORE COMPLEX INSTRUCTIONS INTO CONCURRENTLY DISPATCHED SIMPLE INSTRUCTIONS" and naming David W. Witt and Michael D. Goddard as inventors, now abandoned, which is itself a continuation of U.S. patent application Ser.
      <br/>
      No. 08/146,383 filed Oct. 29, 1993, now abandoned. U.S. patent application Ser.
      <br/>
      No. 08/628,389 is incorporated herein, in its entirety, by reference.
    </p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="3">The invention relates to microprocessor architecture, and more particularly to superscalar instruction decoder architecture.</p>
    <p num="4">2. Description of Related Art</p>
    <p num="5">
      General purpose processors typically are based on scalar instruction sets.
      <br/>
      Processor architectures are either RISC (Reduced Instruction Set Computer) -based or CISC (Complex Instruction Set Computer) -based.
      <br/>
      Each approach has its advantages and disadvantages, as has been widely discussed in the literature.
    </p>
    <p num="6">
      The term "superscalar" describes a computer implementation that improves performance by concurrent execution of scalar instructions.
      <br/>
      Progress in implementing superscalar RISC architectures has been good.
      <br/>
      Scalar RISC architectures typically are defined with a pipelined implementation in mind, and include many features which facilitate superscalar implementation.
      <br/>
      These features include a fixed format and fixed length instructions, explicit instruction operands, and a load/store architecture.
      <br/>
      Superscalar RISC architectures are described in Johnson, Superscalar Microprocessor Design, Prentice Hall, Englewood Cliffs, N.J., 1991, which is incorporated herein by reference in its entirety.
    </p>
    <p num="7">
      Although interest has been expressed in achieving superscalar CISC architectures, progress has been hindered in part because few CISC architectures were defined with superscalar implementation in mind.
      <br/>
      CISC architectures were defined at a time when the principal implementation technique was microcode interpretation of the instruction set, with an emphasis on deciding which operations should be combined into instructions rather than designing operations so that they could be overlapped.
      <br/>
      While enormously versatile, microcode interpretation does not facilitate development of pipelined architectures or superscalar architectures.
      <br/>
      Difficulties arise from numerous aspects of conventional CISC architectures, including instruction format complexity, frequent register reuse, frequent memory access, and the inclusion of unusually complex instructions.
    </p>
    <p num="8">
      An example of a CISC instruction format is the instruction format of the Intel i486 (tm)  microprocessor, which is available from Intel Corporation of Santa Clara, Calif.
      <br/>
      In this instruction format, an instruction may have an operation code ("opcode") consisting of one or two opcode bytes, a modify register or memory ("mod r/m") byte, a scale-index-base ("sib") byte, displacement bytes, and immediate date bytes.
      <br/>
      The opcode specifies the operation code, and may also contain a register identifier.
      <br/>
      The mod r/m byte specifies whether an operand is in a register or in memory.
      <br/>
      If the operand is in memory, fields in the mod r/m byte specify the addressing mode to be used.
      <br/>
      Certain encodings of the mod r/m byte indicate that a second byte, the sib byte, follows to fully specify the addressing mode.
      <br/>
      The sib byte consists of a 2-bit scale field, a 3-bit index field, and a 3-bit base field.
      <br/>
      These fields are used in complex memory addressing modes to specify how address computation is done.
      <br/>
      The displacement byte is used in address computation.
      <br/>
      The immediate data byte is used for an instruction operand.
      <br/>
      One or more additional bytes, known as prefix bytes, may appear before the opcode byte.
      <br/>
      The prefix byte changes the interpretation of the instruction, adding additional complexity.
      <br/>
      The length of the instruction can vary as well.
      <br/>
      The mninimum instruction consists of a single opcode byte and is 8 bits long.
      <br/>
      A long instruction that includes a prefix byte may be 104 bits long.
      <br/>
      Longer instructions containing more than a single prefix byte are possible as well.
    </p>
    <p num="9">
      An example of a recent microprocessor having a CISC superscalar architecture is the Pentium (tm)  microprocessor, available form Intel Corporation of Santa Clara, Calif.
      <br/>
      The improved performance of the Pentium microprocessor relative to the i486 microprocessor is due in part to its superscalar architecture.
      <br/>
      Unfortunately, even new superscalar CISC architectures such as the Pentium microprocessor remain limited by various aspects of conventional CISC architectures, including instruction format complexity, frequent register reuse, frequent memory access, and the inclusion of unusually complex instructions.
    </p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="10">
      Improved processor performance is facilitated by the present invention, which in one embodiment is a method for instruction decoding in which the CISC opcodes and addressing information of CISC instructions which map to respective numbers of RISC-like operations (ROPs) are identified and aligned into dispatch positions based on the number of ROPs to which the instructions map.
      <br/>
      ROP opcodes and addressing information are decoded from the CISC opcodes and addressing information based on, for each CISC instruction, the position of a dispatch position decoding the CISC instruction relative to other dispatch positions decoding the same CISC instruction.
      <br/>
      The ROP opcode and addressing information from the dispatch positions is driven in parallel to a RISC core.
    </p>
    <p num="11">Other embodiments of the invention include means for carrying out the foregoing method.</p>
    <p num="12">
      Another embodiment of the invention is an apparatus for dispatching up to a plurality "m" of ROPs in parallel, wherein the ROPs are mapped from one or more CISC instructions.
      <br/>
      The apparatus includes a memory for storing a CISC instruction and pre-decode information, which includes a value identifying the number of ROPs to which the CISC instruction maps.
      <br/>
      A multiplexer having a plurality "m" of outputs is coupled to the memory for directing information from the CISC instruction to unallocated ones of the multiplexer outputs equal to the number of ROPs to which the CISC instruction maps, up to "m" ROPs.
      <br/>
      A plurality of conversion paths are respectively coupled to the multiplexer outputs for converting the CISC instruction information into respective ROPs to which the CISC instruction maps.
      <br/>
      Dispatch logic is coupled to the conversion paths for dispatching the ROPs in a current dispatch window.
    </p>
    <p num="13">
      In another embodiment, the simple and common CISC instructions are encoded into one to three ROP sequences of primitive ROPs, which are then dispatched in parallel.
      <br/>
      The encoding is done for each dispatch position in a "fastpath," which decodes a CISC instruction into an ROP and dispatches it to the RISC core.
      <br/>
      The fastpath uses pre-decoded information accompanying each CISC instruction byte to determine where instruction boundaries are and the number of ROPs for each CISC instruction.
    </p>
    <p num="14">
      In another embodiment, complicated instructions, ie., those requiring four or more ROPs, and infrequently used instructions are encoded using an entrypoint into microcode ROM.
      <br/>
      At the entrypoint, no additional CISC instructions are issued, so that the full issue width is available for the complex instruction.
      <br/>
      The ROPs from microcode ROM are dispatched from the four dispatch positions.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="15">
      FIG. 1 is a architecture-level block diagram of a processor for achieving superscalar execution of a CISC instruction set.
      <br/>
      FIG. 2 is a timing diagram for a five effective stage sequential execution pipeline in the processor of FIG. 1.
      <br/>
      FIG. 3 is a timing diagram for a five effective stage execution pipeline having a misprediction penalty, in the processor of FIG. 1.
      <br/>
      FIG. 4 is a pictorial representation of a pre-decoded x86 instruction suitable for storage in a byte queue of the processor of FIG. 1.
      <br/>
      FIG. 5 is a pictorial representation of an element of the pre-decoded x86 instruction of FIG. 4.
      <br/>
      FIG. 6 is a pictorial representation of a conversion of an x86 instruction known as an ADD instruction to a pre-decoded x86 instruction.
      <br/>
      FIG. 7 is an architecture-level block diagram of an instruction decoder.
      <br/>
      FIG. 8 is a timing diagrams for major events involving the fast conversion paths and the memory ROM paths of the instruction decoder of FIG. 7.
      <br/>
      FIG. 9 is a data-address-control signal level block diagram showing interconnections between the ROP multiplexer of the instruction decoder of FIG. 7 and various other functional blocks of the processor of FIG. 1.
      <br/>
      FIGS. 10A, 10B, and 10C are flowcharts showing a method implemented by the ROP multiplexer of FIG. 9.
      <br/>
      FIGS. 11 and 12 are pictorial representations of the dispatch of pre-decoded x86 instructions by the ROP multiplexer of FIG. 9.
      <br/>
      FIG. 13 is a functional block diagram of a microcode ROM controller useful in the instruction decoder of FIG. 7.
      <br/>
      FIG. 14 is a pictorial representation of various formats for the contents of a control ROM useful in the microcode ROM controller of FIG. 11.
      <br/>
      FIG. 15 is a data-address-control signal level block diagram showing interconnections between the ROP select functional block of the IDECODE and various other functional blocks of the processor of FIG. 1.
      <br/>
      FIG. 16 is a data-address-control signal level block diagram showing interconnections between the ROP shared functional block of the IDECODE and various other functional blocks of the processor of FIG. 1.
    </p>
    <heading>DESCRIPTION OF THE PREFERRED EMBODIMENT</heading>
    <p num="16">
      The architecture of a processor 100 for achieving a superscalar execution of a CISC instruction set is shown in FIG. 1.
      <br/>
      The CISC addresses, data, and control transfers between the major functional blocks of the processor 100 as well as to and from external memory are communicated on an internal address and data ("IAD") bus 102, which is interfaced to an external bus (not show) by a bus interface unit ("BIU") 160 in conjunction with a physical tag store 162 and a memory management unit 164.
      <br/>
      The IAD bus 102 is a 64-bit bus.
      <br/>
      Another bus called the transfer target bus, or XTARGET bus 103, is a 32-bit bus with various prioritized uses, including updating the IDECODE 108 from the branch section BRNSEC 135 in the event of microbranch misprediction, exceptions, and resets; and updating a branch FIFO in the BRNSEC 135 from the IDECODE.
    </p>
    <p num="17">
      The CISC instructions, illustratively instructions used by x86 class microprocessors (hereinafter x86 instructions), are parsed and pre-decoded in an instruction cache ("ICACHE") 104, the pre-decoded x86 instructions are copied to a byte queue ("BYTEQ") 106, and the pre-decoded x86 instructions are mapped in an instruction decoder ("IDECODE") 108 to respective sequences of instructions for RISC-like operations ("ROPs").
      <br/>
      These ROPs have a number of useful characteristics, including a "source A--operation--source B --&gt; destination" structure, fixed location of opcode and source operands, suitability for load/store architectures, and direct calculation of load/store addressing modes.
    </p>
    <p num="18">
      The ROPs for the RISC core 110 are three operand instructions: two source operands A and B, and one destination operand.
      <br/>
      The main ROP fields are listed in Table 1.
    </p>
    <p num="19">
      -- TABLE 1
      <br/>
      --                    SUB-
      <br/>
      --                    FIELD
      <br/>
      -- BITS   FIELD       BITS    DESCRIPTION
      <br/>
      -- 58:56  FU                  Three bit field specifies the functional unit
      <br/>
      --                            to which the ROP is to be dispatched.
      <br/>
      -- 55:48  OPCODE      53:48   Actual Opcode.
      <br/>
      Six bit subfield specifies
      <br/>
      --                            the opcode to be sent to the functional
      <br/>
      --                            units.
      <br/>
      --                    55:54   Extra Operand Size Information.
      <br/>
      Two bit
      <br/>
      --                            subfield specifies extra operand size
      <br/>
      --                            information for floating point ROPs.
      <br/>
      -- 47:40  DEST        47:43   Register Specification.
      <br/>
      Five bit subfield
      <br/>
      --                            either directly specifies a register number,
      <br/>
      --                            or specifies the  * 86 instruction field
      <br/>
      --                            containing the register number.
      <br/>
      --                    42:40   Operand Size.
      <br/>
      Three bit subfield either
      <br/>
      --                            directly specifies the size of the operand
      <br/>
      --                            (8-bit high byte, 8-bit low byte, 16-bit,
      <br/>
      --                            or 32-bit), or specifies how to determine
      <br/>
      --                            the size from decode information such as
      <br/>
      --                            segment attributes and instruction prefixes.
      <br/>
      -- 39:32  SOURCE A            Can be used for half of a 16-bit immediate
      <br/>
      --                            operand when combined with SOURCE B.
      <br/>
      --                    39:35   Register Specification.
      <br/>
      Five bit subfield
      <br/>
      --                            either directly specifies a register number,
      <br/>
      --                            or specifies the  * 86 instruction field
      <br/>
      --                            containing the register number.
      <br/>
      --                    34:32   Operand Size.
      <br/>
      Three bit subfield either
      <br/>
      --                            directly specifies the size of the operand
      <br/>
      --                            (8-bit high byte, 8-bit low byte, 16-bit, or
      <br/>
      --                            32-bit), or specifies how to determine the
      <br/>
      --                            size from decode information such as seg-
      <br/>
      --                            ment attributes and instruction prefixes.
      <br/>
      -- 31:24  SOURCE B            Can be used for 8-bit immediate operand,
      <br/>
      --                            or for half of a 16-bit immediate operand
      <br/>
      --                            when combined with SOURCE A.
      <br/>
      --                    31:27   Register Specification.
      <br/>
      Five bit subfield
      <br/>
      --                            either directly specifies a register number,
      <br/>
      --                            or specifies the  * 86 instruction field
      <br/>
      --                            containing the register number.
      <br/>
      --                    26:24   Operand Size.
      <br/>
      Three bit subfield either
      <br/>
      --                            directly specifies the size of the operand
      <br/>
      --                            (8-bit high byte, 8-bit low byte, 16-bit,
      <br/>
      --                            or 32-bit), or specifies how to determine
      <br/>
      --                            the size from decode information such as
      <br/>
      --                            segment attributes and instruction prefixes.
      <br/>
      -- 23:16  OPERAND             Eight bit field contains additional
      <br/>
      --        TYPE                information about the Destination, Source
      <br/>
      --                            A, and Source B operands.
      <br/>
      For all oper-
      <br/>
      --                            ands, it specifies whether the register is
      <br/>
      --                            integer, soft special, floating point upper
      <br/>
      --                            half, or floating point lower half.
      <br/>
      For the
      <br/>
      --                            source registers, it additionally specifies
      <br/>
      --                            whether the Source A or B fields contain
      <br/>
      --                            register numbers and sizes or immediate
      <br/>
      --                            data.
      <br/>
      --                    23:22   Destination Type.
      <br/>
      Two bit subfield
      <br/>
      --                            specifies the destination type.
      <br/>
      --                    21:19   Source A Type.
      <br/>
      Three bit subfield
      <br/>
      --                            specifies the Source A type.
      <br/>
      --                    18:16   Source B Type.
      <br/>
      Three bit subfield
      <br/>
      --                            specifies the Source B type.
      <br/>
      -- 15:8   L/S                 Eight bit field provides extra control
      <br/>
      --        CONTROL             information for load and store ROPs.
      <br/>
      This
      <br/>
      --                            information is directed to the load/store
      <br/>
      --                            functional unit on one of the two INSLS
      <br/>
      --                            buses when the ROP is dispatched.
      <br/>
      --                    15      Displacement.
      <br/>
      One bit subfield controls
      <br/>
      --                            whether decode drives the displacement
      <br/>
      --                            field from the  * 86 instruction on the
      <br/>
      --                            FASTCN buses to the load/store
      <br/>
      --                            functional unit.
      <br/>
      --                    14      32-Bit Addressing.
      <br/>
      One bit subfield forces
      <br/>
      --                            use of 32-bit addressing regardless of
      <br/>
      --                            decoded size.
      <br/>
      --                    13      Lock.
      <br/>
      One bit subfield directs the load/
      <br/>
      --                            store functional unit to perform a locked
      <br/>
      --                            memory access.
      <br/>
      --                    12:8    Segment Register.
      <br/>
      Five bit subfield
      <br/>
      --                            specifies the segment register to use
      <br/>
      --                            for the access.
      <br/>
      --  7:0 DISPATCH            Eight bit field controls some aspects of
      <br/>
      --        /ROB                dispatching or retiring ROPs, as follows.
      <br/>
      --                     7 Serialize.
      <br/>
      One bit field directs decode to
      <br/>
      --                            wait until all previous ROPs have been
      <br/>
      --                            retired before dispatching this ROP.
      <br/>
      Used
      <br/>
      --                            for ROPs which use or modify state which
      <br/>
      --                            is not speculatively managed by the
      <br/>
      --                            reorder buffer.
      <br/>
      --                     6 Scaling.
      <br/>
      One bit field directs whether
      <br/>
      --                            scaling is on or off (1-on, 0-off).
      <br/>
      --                     5 Backup.
      <br/>
      One bit field directs the reorder
      <br/>
      --                            buffer to save a backup copy of certain
      <br/>
      --                            state when this ROP is retired, in the
      <br/>
      --                            event of an exception.
      <br/>
      --                     4 Interrupt Check.
      <br/>
      One bit field directs the
      <br/>
      --                            reorder buffer to check for the presence
      <br/>
      --                            of an external interrupt when this ROP
      <br/>
      --                            is retired.
      <br/>
      --                     3 Writeback.
      <br/>
      Indicates that this ROP
      <br/>
      --                            modifies the register specified by the
      <br/>
      --                            Destination field, which is used by the
      <br/>
      --                            reorder buffer for dependency checking
      <br/>
      --                            and updating of the register file.
      <br/>
      --                     2:0 Flag Control.
      <br/>
      Indicates what bits in the
      <br/>
      --                            EFLAGS register the ROP modifies.
      <br/>
      Bit 2
      <br/>
      --                            controls OF; bit 1 controls SF, ZF, AF and
      <br/>
      --                            PF as a group, and bit 0 controls CF.
      <br/>
      Also
      <br/>
      --                            used to control Floating Point Status
      <br/>
      --                            register updates.
    </p>
    <p num="20">
      The ICACHE 104 is a first level instruction cache which identifies and marks raw x86 instruction start and end points and encodes "pre-decode" information.
      <br/>
      The BYTEQ 106 is a queue of instruction and pre-decode information of the "predicted executed" state.
      <br/>
      The BYTEQ 106 is in effect an interface between the ICACHE 104 and the IDECODE 108, and may be integrated with either, distributed across both, or implemented as a separate unit.
      <br/>
      Depending on how many ROPs the x86 instructions map to, up to four x86 instructions can be dispatched concurrently.
      <br/>
      The ICACHE 104 is described in further detail in U.S. patent application Ser.
      <br/>
      No. 08/145,905 filed Oct. 29, 1993 (David B. Witt and Michael D. Goddard, "Pre-Decode Instruction Cache and Method Therefor Particularly Suitable for Variable Byte-Length Instructions"), which is incorporated herein by reference in its entirety.
      <br/>
      The BYTEQ 106 is described in flrther detail in U.S. patent application Ser.
      <br/>
      No. 08/145,902 filed Oct. 29, 1993 (David B. Witt "Speculative Instruction Queue and Method Therefor Particularly Suitable for Variable Byte-Length Instructions"), which is incorporated herein by reference in its entirety.
    </p>
    <p num="21">
      The IDECODE 108 generates type, opcode, and pointer values for all ROPs based on the pre-decoded x86 instructions in the BYTEQ 106, and determines the number of possible x86 instruction dispatches for shifting the BYTEQ 106.
      <br/>
      The IDECODE 108 also maintains program counter values of speculatively-executed ROPs, and maintains speculative mapping of floating point pointers for speculative floating point execution.
    </p>
    <p num="22">
      The ROP instructions are dispatched to a superscalar RISC core 110 over various buses.
      <br/>
      The RISC core 110 supports four ROP issue, five ROP results, and up to sixteen speculatively executed ROPs.
      <br/>
      Up to four sets of pointers to the A and B source operands are fuimshed over respective buses by the IDECODE 108 to a register file REGF 112 and to a reorder buffer ROB 114 in the RISC core 110.
      <br/>
      The REGF 112 and ROB 114 in turn fiunish the appropriate "predicted executed" versions of the RISC operands A and B to various functional units in the RISC core 110 via an A &amp; B source operand bus 116.
      <br/>
      RISC opcode information is dispatched from the IDECODE 108 via a type and dispatch information ("TAD") bus 118.
    </p>
    <p num="23">
      The RISC core 110 includes numerous functional units such as a first arithmetic logic unit ("ALU0") 131, a second arithmetic logic and shift unit ("ALU1 &amp; SHF") 132, a special register block ("SRB") 133, a load/store section ("LSSEC") 134, a branch section ("BRNSEC") 135, and a floating point unit ("FPU") 136. It will be appreciated that the functional units may be dedicated to a particular type of function as in the ALU0131, or may combine a plurality of functions as in the ALU1 &amp; SHF 132 and the LSSEC 134.
      <br/>
      The functional units 131, 132, 133, 134, 135 and 136 include respective reservation stations 121, 122, 124, 125 AND 126 having inputs connected to the operand bus 116 and the TAD bus 118.
      <br/>
      The reservation stations allow speculative ROPs to be dispatched to the functional units 131-132 and 134-136 regardless of whether their source operands are currently available.
    </p>
    <p num="24">
      The REGF 112 is a physical register file which contains the mapped x86 registers for the integer and floating point instructions, and also contains temporary integer and floating point registers for holding intermediate calculations.
      <br/>
      The REGF 112 decodes up to two register pointers for each of up to four concurrently dispatched ROPs and fiunishes the values of the selected entries onto the A and B source operand bus 116 as appropriate from its eight read ports.
      <br/>
      The REGF 112 includes four write ports for retiring speculative execution state operands from the ROB 114 over a writeback bus 113.
      <br/>
      The ROB 114 is a circular FIFO with head and tail queue pointers for keeping track of the relative order of speculatively executed ROPs.
      <br/>
      The storage locations are dynamically allocated to instruction results.
      <br/>
      When an instruction is decoded, its result value is allocated a location, or destination, in the ROB 114, and its destination-register number is associated with this location.
      <br/>
      For a subsequent instruction having no dependencies, the operand bus 116 is driven from the REGF 112.
      <br/>
      However, when a subsequent instruction has dependencies and refers to the renamed destination register to obtain the value considered to be stored therein, the instruction obtains instead the value stored in the ROB 114, or a tag for the location in the ROB 114 allocated to this value if the value is undetermined.
      <br/>
      The value or tag is flunished to the functional units over the TAD 118 bus.
      <br/>
      When results are obtained from completion of execution in the functional units 131-136, the results and their respective result tags are furnished to the ROB 114 over a four bus wide result tag and result bus 140, as well as to the reservation stations 121-122 and 124-126.
      <br/>
      The ROB 114 also handles exceptions and mispredictions, and maintains the state of certain visible registers, including the program counter and the execution flags.
      <br/>
      A suitable unit for the RISC core 110 is disclosed in U.S. patent application Ser.
      <br/>
      No. 08/146,382 filed Oct. 29, 1993, which is incorporated herein by reference in its entirety, and which issued as U.S. Pat. No. 5,651,125. Other suitable RISC cores as well as suitable RISC instruction sets are well known in the art.
    </p>
    <p num="25">
      The processor 100 of FIG. 1 uses in-order dispatch of ROPs from the IDECODE 108, out-of-order issue with respect to the issue of instructions among the functional units, in-order issue with respect to the issue of instructions to a functional unit from its respective reservation station, and out-of-order completion.
      <br/>
      Accordingly, the IDECODE 108 is isolated from completion in the functional units of the RISC core 110 so that except for stalls, the IDECODE 108 continues to decode instructions regardless of whether they can be promptly completed.
      <br/>
      To take advantage of lookahead, the IDECODE 108 decodes instructions and places them into available locations in the reservation stations 121-122 and 124-126 of the functional units 131-132 and 134-136 as long as the reservation stations can receive them.
    </p>
    <p num="26">
      DCACHE 150 is closely aligned to LSSEC 134, which handles both integer and floating point load and store operations.
      <br/>
      Up to two load operations simultaneously access the DCACHE 150 and forward their operations to the result bus 140.
      <br/>
      Cache hit/miss checking for data stored in the DCACHE 150 is also done by the LSSEC 134.
    </p>
    <p num="27">
      The processor 100 also includes the physical tag store 162, the memory management unit 164, and a bus interface unit 160, which interfaces with a conventional external bus coupled to a conventional external memory 166.
      <br/>
      The physical tag store 162 contains tags which relate to the contents of the ICACHE 104 and the DCACHE 150.
      <br/>
      The memory management unit 164 performs memory address conversions.
      <br/>
      The bus interface unit 160 takes requests for read/write cycles from the physical tag store 162, and watches read/write cycles on the external bus to ensure cache consistency in the physical tag store 162, the ICACHE 104, and the DCACHE 150 and, upon detection, to update, invalidate, or provide data as appropriate.
      <br/>
      The DCACHE 150 and the LSSEC 134 are flrther described in U.S. patent application Ser.
      <br/>
      No. 08/146,381, filed Oct. 29, 1993 (David B. Witt, "Linearly Addressed Microprocessor Cache"), which is incorporated herein by reference in its entirety.
      <br/>
      The physical tag store 162 and the LSSEC 134 are further described in U.S. patent application Ser.
      <br/>
      No. 08/146,376, filed Oct. 29, 1993 (William M. Johnson, David B. Witt, and Murali Chinnakonda, "High Performance Load/Store Functional Unit and Data Cache"), which is incorporated herein by reference in its entirety.
    </p>
    <p num="28">
      The processor 100 of FIG. 1 operates in effect as a five stage pipeline.
      <br/>
      A timing diagram for a sequential execution pipeline is shown in FIG. 2.
      <br/>
      The first pipeline stage is a fetch stage, in which the value of a fetch program counter FPC31:0 is determined and compared with tags of the ICACHE 104 to determine a cache hit or miss.
      <br/>
      The next two pipeline stages are decode stages DECODE1 and DECODE2.
      <br/>
      Multiple instructions ICBYTEnB12:0, which are the next to be speculatively decoded instructions, are fetched in accordance with FPC and forwarded to the BYTEQ 106 in phase one of the DECODE1 stage.
      <br/>
      Entries BYTEQn7:0 of the BYTEQ 106 are decoded to various ROP fields ROPMUXP3:0, which become valid in phase two of the DECODE1 stage.
      <br/>
      The various outputs of the IDECODE 108 become valid in phases one and two of the DECODE2 stage.
      <br/>
      For example, the A &amp; B operand pointers for the four ROPs become valid in phase one of the DECODE2 stage, thereby allowing the A and B operands from the REGF 112 and the ROB 114 or their tags from the ROB 114 to be accessed in phase two of the DECODE2 stage.
      <br/>
      In the subsequent execute, result, and retire stages, the A and B source operands and tags become valid and are furnished to the functional unit reservation stations 121-122 and 124-126, the finctional units 131-136 execute the ROPs and arbitrate for the result bus 140, results are written to the reservation stations 121-122 and 124-126 and to the ROB 114, and operands are retired from the ROB 114 to the REGF 112.
    </p>
    <p num="29">
      A timing diagram for a sequential execution pipeline having a mispredicted branch is shown in FIG. 3.
      <br/>
      This misprediction penalty from execution of the branch to the execute store of the corrected path is three clock cycles.
      <br/>
      A branch compare is done during the execution of the branching instruction.
      <br/>
      If a branch misprediction is detected, a fetch stage is entered into.
      <br/>
      The branch target address XTARGET31:0 becomes valid in phase one of FETCH and is driven onto a bus as FPC, and multiple instructions ICBYTEnB12:0 are fetched in accordance with FPC.
      <br/>
      The next two pipeline stages are the decode stages DECODE1 and DECODE2, which proceed essentially as described for the sequential execution pipeline shown in FIG. 2.
    </p>
    <p num="30">Byte Queue Characteristics</p>
    <p num="31">
      The BYTEQ 106 functions as an interface between the ICACHE 104 and the IDECODE 108.
      <br/>
      Conceptually, the byte queue BYTEQ 106 is a queue of up to sixteen entries representing zero, one or more pre-decoded x86 instructions.
      <br/>
      Each pre-decoded x86 instruction starts on an instruction start and ends on an instruction end, and consists of one or more elements.
      <br/>
      Each element includes a valid bit, an x86 instruction byte, pre-decode information of the predicted executed state, and branch misprediction information.
    </p>
    <p num="32">
      A general representation of a pre-decoded x86 instruction resulting from the processing of an x86 instruction in the ICACHE 104 is shown in FIG. 4.
      <br/>
      The ICACHE 104 parses and pre-decodes the x86 instructions, and stores the results.
      <br/>
      As x86 instructions are dispatched from the BYTEQ 106 and subsequent x86 instructions are advanced to the head of the queue, the pre-decoded x86 instructions are copied into locations of the BYTEQ 106 as there is space available.
      <br/>
      If one or more prefixes are present in the raw x86 instruction, the pre-decoded x86 instruction includes one or more prefix elements.
      <br/>
      The last prefix element is a consolidated prefix element containing complete prefix information for the IDECODE 108, while the other prefix elements are re-coded prefix elements containing partial information and are not used by the IDECODE 108.
      <br/>
      FIG. 4 shows re-coded prefix element 402 and consolidated prefix element 404.
      <br/>
      An OPCODE element 410 containing an x86 instruction opcode byte follows the prefix elements 402 and 404.
      <br/>
      If the raw x86 instruction performs special memory addressing, the pre-decoded x86 instruction includes a mod r/m element, e.g. mod r/m element 412.
      <br/>
      If the raw x86 instruction requires certain addressing modes, the pre-decoded x86 instruction includes an sib element; e.g. sib element 414.
      <br/>
      If the raw x86 instruction requires displacement information for address computation or contains immediate data, the pre-decoded x86 instruction includes a displacement/immediate data element; e.g. displacement/immediate data element 416.
    </p>
    <p num="33">
      FIG. 4 also shows an example of how pre-decode information is asserted.
      <br/>
      All elements in the illustrated pre-decoded x86 instruction are valid, as indicated by an asserted "v" bit.
      <br/>
      The first element of the pre-decoded x86 instruction of FIG. 4, the re-coded prefix 402, is identified by an asserted "s" bit.
      <br/>
      The rop bits, which indicate the number of ROPs required for the x86 instruction, are not shown asserted because the re-coding operations may not yield valid rop information.
      <br/>
      The next element of the pre-decoded x86 instruction of FIG. 4 is the consolidated prefix 404, which is accompanied by valid rop bits (all subsequent elements of the pre-decoded x86 instruction contain valid rop bits).
      <br/>
      The x86 instruction opcode element 410 which follows is identified by an asserted "op" bit.
      <br/>
      The displacement-immediate element 416 is marked as the last element of the pre-decoded x86 instruction by an asserted "e" bit.
    </p>
    <p num="34">
      Note that if the raw x86 instruction contains a two byte opcode, the first byte is handled by the ICACHE 104 like a prefix byte so that the consolidated prefix of the pre-decoded x86 instruction immediately precedes an opcode element containing the second opcode byte of the raw x86 instruction.
      <br/>
      In this event, the re-coded prefix immediately preceding the consolidated prefix does contain valid rop bits.
    </p>
    <p num="35">
      A representative element of the BYTEQ 106 is shown in detail in FIG. 5.
      <br/>
      Bit BYTEQVx indicates whether the element is valid.
      <br/>
      A byte selected from or iiderived from the bytes of the raw x86 instruction is contained in BYTEQx7:0, and may be re-coded prefix information, consolidate prefix information, opcode information, mod r/m information, sib information, or displacement or immediate data information.
      <br/>
      Pre-decode information includes BYTEQP2x, which indicates when logic 1 that the accompanying raw byte is an opcode byte; BYTEQP1 x and BYTEQP0x, which indicate the number of ROPs needed to execute the x86 instruction (see Table 2); BYTEQSx, which indicates whether the accompanying raw byte is the first byte of the x86 instruction; and BYTEQEx, which indicates whether the accompanying raw byte is the last byte of the x86 instruction.
      <br/>
      Branch misprediction information includes BYTEQNSx, BYTEQCLM0x and BYTEQCLM1x.
    </p>
    <p num="36">
      --        TABLE 2
      <br/>
      --        BYTEQP1 BYTEQP0         DESCRIPTION
      <br/>
      --        00                      One ROP  * 86 instruction
      <br/>
      --        01                      Two ROP  * 86 instruction
      <br/>
      --        10                      Three ROP  * 86 instruction
      <br/>
      --        11                      Micro-ROM entry point
    </p>
    <p num="37">
      FIG. 6 is an example of the parsing of one of the common x86 instruction forms, and how the pre-decoded x86 instruction is stored in locations of the BYTEQ 106.
      <br/>
      Assume, for example, that the operation desired is a register to memory addition of a quantity in the 32-bit general register EAX to a quantity in the memory location pointed to by EBX+ECX*8, with the sum being placed in the memory location pointed to by EBX+ECX*8.
      <br/>
      The address mode using EBX+ECX*8 is one of the complicated x86 address modes.
      <br/>
      The instruction is represented in x86 assembly language by the single instruction:
      <br/>
      ADD EBX+ECX*8, EAX
    </p>
    <p num="38">One embodiment of a three operand RISC architecture would require the following sequence of three ROPs to perform an arithmetic operation equivalent to the x86 ADD instruction.</p>
    <p num="39">
      LOAD TEMP, EBX+ECX*8
      <br/>
      ADD TEMP, TEMP, EAX
      <br/>
      STORE EBX+ECX*8, TEMP
    </p>
    <p num="40">
      The LOAD ROP writes the quantity stored in memory at the address determined by the quantity in EBX added to the quantity in ECX times 8 into a temporary register TEMP.
      <br/>
      The ADD ROP adds the quantity in register TEMP and the quantity in register EAX, and stores the result in register TEMP.
      <br/>
      The STORE ROP stores the quantity in register TEMP into memory at the address determined by the quantity in EBX added to the quantity in ECX times 8.
    </p>
    <p num="41">
      As shown in FIG. 6, the ADD register to memory instruction is contained in three raw bytes: an ADD opcode byte, a mod r/m byte, and an sib byte.
      <br/>
      The ICACHE 104 generates appropriate pre-decode information, allocates three locations of the BYTEQ 106 to the x86 instruction, and writes the pre-decode information and the x86 instruction bytes (branch mispredict information omitted for clarity) to the respective locations of the BYTEQ 106.
      <br/>
      All locations are indicated as valid.
      <br/>
      No prefix byte is present.
      <br/>
      The pre-decode information for the opeode byte is 11001, indicating that the byte queue entry at the first location is an opcode of an x86 instruction requiring a sequence of three ROPs to execute, is not the last byte of the pre-decoded x86 instruction, and is the start byte of the pre-decoded x86 instruction.
      <br/>
      The pre-decode information for the mod r/m byte is 01000, indicating that the element is not an opcode, is part of an x86 instruction requiring a sequence of three ROPs to execute, is not the last byte of the pre-decoded x86 instruction, and is not the start byte of the allocated x86 instruction.
      <br/>
      The pre-decode information for the sib byte is 01010, indicating that the element is not an opcode, is part of an x86 instruction requiring a sequence of three ROPs to execute, is the last byte of the pre-decoded x86 instruction, and is not the start byte of the pre-decoded x86 instruction.
    </p>
    <p num="42">
      FIG. 6 also contains an example of the parsing of an x86 instruction form which maps to more than three ROPs, and how the pre-decoded x86 instruction is stored in locations of the BYTEQ 106.
      <br/>
      Assume, for example, that the operation desired is to load the quantity in memory pointed to by the EAX register into the ECX register, and then to load the sum of the quantity in memory pointed to by the EAX register and the original quantity in the ECX register into the EAX register.
      <br/>
      The instruction is represented in x86 assembly language by the single instruction:
      <br/>
      XADD EAX, ECX
    </p>
    <p num="43">One embodiment of a three operand RISC architecture would require the following sequence of four ROPs to perform an arithmetic operation equivalent to the x86 XADD instruction.</p>
    <p num="44">
      LOAD TEMP1, EAX
      <br/>
      ADD TEMP0, TEMP1, ECX
      <br/>
      STORE EAX, TEMP0
      <br/>
      OR ECX, TEMP1,0
    </p>
    <p num="45">
      The LOAD ROP writes the quantity stored in memory using the address specified by the EAX register into a temporary register TEMP1.
      <br/>
      The ADD ROP adds the quantity in the TEMP1 register and the quantity in the ECX register, and stores the result in another temporary register TEMP0.
      <br/>
      The STORE ROP stores the sum in the temporary register TEMP0 in memory using the address specified by the EAX register.
      <br/>
      The OR instruction moves the quantity in the temporary register TEMP1 to the register ECX by performing a logical inclusive OR operation of the quantities in TEMP1 with zero, and placing the result in the ECX register.
    </p>
    <p num="46">
      As shown in FIG. 6, the XADD instruction is contained in three raw bytes: a second byte prefix byte, the second byte XADD opcode byte, and a mod r/m byte.
      <br/>
      The ICACHE 104 generates appropriate pre-decode information, allocates three locations of the BYTEQ 106 to the x86 instruction, and writes the pre-decode information and the x86 instruction bytes (branch mispredict information omitted for clarity) to the respective locations of the BYTEQ 106.
      <br/>
      All locations are indicated as valid.
      <br/>
      Note that the raw second byte prefix byte 00001111 is coded by the ICACHE 104 and stored in the BYTEQ 106 as the consolidated prefix 00000001.
      <br/>
      The pre-decode information for the consolidated prefix byte is 01101, indicating that the byte queue entry at the first location is not an opcode.
      <br/>
      The pre-decode information for the second byte of the XADD instruction is 11100, indicating that the byte queue entry at the second location is an opcode of an x86 instruction requiring a sequence of more than three ROPs to execute, is not the last byte of the pre-decoded x86 instruction, and is not the start byte of the pre-decoded x86 instruction.
      <br/>
      The pre-decode information for the mod r/m byte is 01110, indicating that the element is not an opcode and is the last byte of the pre-decoded x86 instruction.
    </p>
    <p num="47">IDECODE Overview</p>
    <p num="48">
      The IDECODE 108 is a two-stage pipelined decoder which receives pre-decoded x86 instruction bytes from the BYTEQ 106, translates them into respective sequences of ROPs, and rapidly dispatches ROPs from a plurality of dispatch positions.
      <br/>
      To maximize the opportunity for multiple instruction issue, the translation is handled in a hardwired fast conversion path for most simple instructions which, in the embodiment of FIG. 7, are x86 instructions which map to three ROPs or less.
      <br/>
      Instructions which require more than three ROPs and infrequently used instructions are handled by microcode sequences contained in microcode ROM.
      <br/>
      Whether an x86 instruction is handled in the fast conversion path or microcode ROM, the pre-decoded x86 instruction information is duplicated at multiple dispatch positions to allow each dispatch position to work independently and in parallel with other dispatch positions.
    </p>
    <p num="49">
      In the DECODE1 stage, the IDECODE 108 determines whether ROPs for an x86 pre-decoded instruction are to be generated in the fastpath or the microcode ROM path.
      <br/>
      In the embodiment of FIG. 7, information for ROP sequences either is generated by fastpath logic for up to four x86 instructions per cycle using up to four ROPs, or is read from microcode ROM for one pre-decoded x86 instruction.
      <br/>
      The information from the fastpath and the microcode ROM path which is required to generate an ROP includes the type of functional unit to which the ROP is designated to go, the specific simple RISC-like instruction to be executed at the functional unit, source and destination pointers for the ROP, size information of the ROP, addressing mode if a load or a store ROP, and immediate fields if any from the instruction for the ROP.
      <br/>
      Preferably, microcode ROM accesses are not mixed with fastpath decode, which avoids having to shift microcode ROPs.
      <br/>
      In the DECODE2 stage, the IDECODE 108 selects and augments the ROP information from either the fastpath or the microcode ROM and furnishes complete ROPs which are executed in the functional units 131-136.
    </p>
    <p num="50">The IDECODE 108 also controls shifting of the BYTEQ 106, so that fully dispatched pre-decoded x86 instructions are shifted out of the BYTEQ 106 and the next undispatched or partially dispatched pre-decoded x86 instruction is shifted to the "head of queue."</p>
    <p num="51">
      The IDECODE 108 also detects problems in the BYTEQ 106 and indirectly redirects the ICACHE 104 as appropriate by forcing a microcode entrypoint.
      <br/>
      The IDECODE 108 also accepts microcode ROM entry points initiated by cache refill logic in the ICACHE 104, and by exception and microbranch misprediction logic in the BRNSEC 135.
      <br/>
      Microcode entry points generated by the BRNSEC 135 are communicated to the IDECODE 108 over the XTARGET bus 103.
    </p>
    <p num="52">
      The architecture of the IDECODE 108 is shown in FIG. 7, and a timing diagram for major events in the IDECODE 108 is shown in FIG. 8.
      <br/>
      An ROP multiplexer ROPMUX 700 directs entries of the BYTEQ 106 to four dispatch positions 710, 720, 730 AND 740, which include respective fast converters FASTCONV0712, FASTCONV1722, FASTCONV2732, and FASTCONV3742; respective common stages ICOMMON0714, ICOMMON1724, ICOMMON2734, and ICOMMON3744; and respective microcode ROMs MROM0716, MROM1726, MROM2736, and MROM3746.
      <br/>
      MROM0716, MROM1726, MROM2736, and MROM3746 are controlled by microcode ROM controller IDECCNTL 760.
      <br/>
      These elements generally form the first stage of the IDECODE 108.
      <br/>
      The second stage of the IDECODE 108 generally is implemented in ROPSELECT0718, ROPSELECT1728, ROPSELECT2738, and ROPSELECT3748, and in ROPSHARED 790.
    </p>
    <p num="53">
      The IDECODE 108 is controlled by IDECCNTL 760.
      <br/>
      The IDECCNTL 760 contains logic implementation in combinatorial logic or programmable array logic for providing general control functions such as funishing instruction type information on the TAD bus 118, predicting how many of the ROPs in the current dispatch window can be accepted by the RISC core 110, informing the ICACHE 104 how to shift the BYTEQ 106 in view of the prediction, informing the ROPMUX 700 of the number of ROPs yet to be dispatched for the pre-decoded x86 instruction at the head of the BYTEQ 106, and accessing microcode and control ROM.
      <br/>
      To provide these functions, the IDECCNTL 760 receives various information from the functional units 131-136 of the RISC core 110 as well as from other units of the processor 100.
    </p>
    <p num="54">
      FASTCONVx 902 (FIG. 9 and FIG. 15) is representative of each of the fast converters FASTCONV0712, FASTCONV1722, FASTCONV2732, and FASTCONV3742.
      <br/>
      FASTCONVx 902 performs a fast conversion of many types of "simple" x86 instructions (i.e. those which map to 3 or fewer ROPs) into ROPs.
      <br/>
      The FASTCONVx 902 in each dispatch position converts the x86 instruction to a respective one of a sequence of ROPs (a sequence being one or more ROPs) needed to carry out the x86 instruction, and modifies the operation of the ROP for certain prefixes and SIB bytes.
      <br/>
      FASTCONVx 902 is implemented either as programmable array logic or as combinatorial logic latched early in phase one of the DECODE2 stage.
    </p>
    <p num="55">
      Rarely used x86 instructions and x86 instructions requiring ROP sequences of more than 3 ROPs to execute are mapped to microcode ROM.
      <br/>
      Generally, the x86 instructions which map to more than three ROPs are the complex interactive instructions such as the CALL gate instruction, the STRING move instruction, and the transcendental floating point routines.
      <br/>
      In that event, control logic in the IDECODE 108 forms a microcode ROM address known as an entrypoint, and based on the entrypoint, reads the ROP sequence from the microcode ROM instructions stored in the MROM0716, MROM1726, MROM2736, and MROM3746 at four ROPs per cycle.
      <br/>
      MROMx 906 (FIG. 9 and FIG. 15) is representative of each of the microcode ROMs MROM0716, MROM1726, MROM2736, and MROM3746.
      <br/>
      MROMx 906 is a 1024 * 59 ROM array for handling x86 instructions which are not convertible in FASTCONVx 902.
    </p>
    <p num="56">
      The dispatch positions 710, 720, 730 and 740 also include respective pipeline stages ICOMMON0714, ICOMMON1724, ICOMMON2734, and ICOMMON3744.
      <br/>
      ICOMMONx 904 (FIG. 9 and FIG. 15) is representative of each of the pipeline stages ICOMMON0714, ICOMMON1724, ICOMMON2734, and ICOMMON3744.
      <br/>
      The ICOMMONx 904 is associated with the FASTCONVx 902 and MROMx 906 of the dispatch position x (x=0,1,2,3).
      <br/>
      Portions of x86 instruction conversion operations which can be effectively handled in a particular way regardless of whether the instruction is a fastpath or microcode ROM instruction, and which do not require generation in the MROMx 906, are carried out and pipelined, along with common data not requiring conversion, through ICOMMONx 904 in step with the processing of instruction portions in the various stages of FASTCONVx 902 or MROMX 906.
      <br/>
      ICOMMONx 904 also keeps track of register pointers which are used for performing address calculations used both by fastpath instructions and MROM instructions.
      <br/>
      Advantageously, the FASTCONVx 902 design and the MROMx 906 design are simplified.
      <br/>
      ICOMMONx 904 is implemented as combinatorial logic or programmable array logic latched in early phase one of the DECODE2 stage.
      <br/>
      All x86 instructions use this logic.
    </p>
    <p num="57">
      Selector circuit ROPSELECTx 1500 (FIG. 15) is representative of each of the ROPSELECT0718, ROPSELECT1728, ROPSELECT2738, and ROPSELECT3748.
      <br/>
      ROPSELECTx 1500 selects either the outputs of the FASTCONVx 902 and the ICOMMONx 904, or the outputs of the MROMx 906 and the ICOMMONx 904, and generates dispatch information.
      <br/>
      ROPSELECTx 1500 also selects the immediate field constant values to drive immediate address or constants to the functional units 131-136.
      <br/>
      Another unit, ROPSHARED 790, is responsive to information from the ROPSELECTx 1500 in each of the dispatch positions 710, 720, 730 and 740 for generating dispatch information for resources that are shared by all dispatch positions.
    </p>
    <p num="58">The IDECCNTL 760 is any suitable state machine for controlling the operation of the various units of the IDECODE 108.</p>
    <p num="59">
      The function of the IDECODE 108 of FIG. 7 for frequently used x86 instructions which map to three or fewer ROPs is illustrated by how the ADD instruction of FIG. 6 is processed.
      <br/>
      The ROPMUX 700 drives the ADD instruction to the first three dispatch positions 710, 720 and 730.
      <br/>
      The ADD instruction is processed in the FASTCONVx 902 and ICOMMONx 904 units of the dispatch positions 710, 720 and 730.
      <br/>
      Hence, FASTCONVO 712 and ICOMMONO 714 provide initial logic operations to convert the ADD instruction into the first ROP LOAD TEMP &lt;-- EBX+ECX*8. In a similar manner, FASTCONV1722 and ICOMMON1724 provide initial logic operations to convert the ADD instruction into the second ROP ADD TEMP, TEMP, EAX; and FASTCONV2732 and ICOMMON2734 provide initial logic operations to convert the ADD instruction into the third ROP STORE EBX+ECX*8 &lt;-- TEMP.
    </p>
    <p num="60">
      The function of the IDECODE 108 of FIG. 7 for infrequently used x86 instructions and for x86 instructions which map to a sequence of four or more ROPs is illustrated by how the XADD instruction of FIG. 6 is processed.
      <br/>
      The XADD instruction, which is positioned at the head of the BYTEQ 106, is driven by the ROPMUX 700 to all four dispatch positions 710, 720, 730 and 740, and is processed in the ICOMMONx 904 units of the dispatch positions 710, 720, 730 and 740.
      <br/>
      The XADD instruction is also supplied to the IDECNTL760, which determines an entrypoint value for accessing the MROMO 716, MROM1726, MROM2736 and MROM3746, and for accessing the control ROM 750.
      <br/>
      Based on the entrypoint, ROP information for the first ROP in the sequence is read out of the MROM0716 and combined with the output of ICOMMON0714 to furnish the first ROP LOAD TEMP1, EAX. In a similar manner, ROP information for the second ROP in the sequence is read out of the MROM1726 in accordance with the value of the entrypoint and combined with the output of ICOMMON0724 to fsh the second ROP ADD TEMP0, TEMP1, ECX; ROP information for the third ROP in the sequence is read out of the MROM2736 in accordance with the value of the entrypoint and combined with the output of ICOMMON0734 to furnish the third ROP STORE EAX, TEMP0; and ROP information for the fourth ROP in the sequence is read out of the MROM3746 in accordance with the value of the entrypoint and combined with the output of ICOMMON0744 to furnish the fourth ROP OR ECX, TEMP1.
      <br/>
      In the event that the x86 instruction were to map to more than the number of dispatch positions available for processing it (the XADD instruction, which maps to four ROPs, does not), processing would continue in the next cycle with the fifth ROP being dispatched from dispatch position 0.
    </p>
    <p num="61">The ROP Multiplexer ROPMUX</p>
    <p num="62">
      The ROPMUX 700, which is shown in FIG. 9 with connections to other elements of the IDECODE 108 and various flnctional blocks in the architecture of the processor 100 shown in FIG. 1, is responsible for allocating a complete pre-decoded x86 instruction in the BYTEQ 106 to one or more of the dispatch positions 710, 720, 730 and 740 in the IDECODE 108.
      <br/>
      One or more pre-decoded x86 instructions are directed concurrently from the BYTEQ 106 to available ones of the dispatch positions 710, 720, 730 and 740, beginning with the x86 instruction at the head of the BYTEQ 106.
      <br/>
      For example, if each of the first four pre-decoded x86 instructions in the BYTEQ 106 maps to one ROP, the first pre-decoded x86 instruction at the head of the BYTEQ 106 is muxed to dispatch position 0, the second pre-decoded x86 instruction is muxed to dispatch position 1, the third pre-decoded x86 instruction is muxed to dispatch position 2, and the fourth pre-decoded x86 instruction is muxed to dispatch position 3.
      <br/>
      Alternatively, if the second pre-decoded x86 instruction in the BYTEQ 106 maps to two ROPs, the first pre-decoded x86 instruction is muxed to dispatch position 0, the second pre-decoded x86 instruction is muxed to dispatch positions 1 and 2, and the third pre-decoded x86 instruction is muxed to dispatch position 3.
    </p>
    <p num="63">
      A pre-decoded x86 instruction which does not map to microcode ROM and does not entirely fit in the dispatch window is allocated as many dispatch positions 710, 720, 730 and 740 as available in the first dispatch window.
      <br/>
      The IDECCNTL 760 uses a signal PARTIALDISP1:0 to determine whether some of the ROPs of the x86 instruction at the front of the dispatch window have been dispatched, so that the already dispatched ROPs are not allocated dispatch positions.
    </p>
    <p num="64">The byte queue entries of a pre-decoded x86 instruction which maps to microcode ROM and which resides at the head of queue of the BYTEQ 106 are directed to all four dispatch positions 710, 720, 730 and 740.</p>
    <p num="65">
      The operation of the ROPMUX 700 is shown in FIG. 10, which is a flowchart of a scanning function for the BYTEQ 106; and in FIG. 11 and FIG. 12, which depict how elements of specific tppes of pre-decoded x86 instructions in the BYTEQ 106 are directed to dispatch positions in the IDECODE 108 by the ROPMUX 700.
      <br/>
      When the BYTEQ 106 becomes valid after a shifting operation, the ROPMUX 700 "scans" the BYTEQ 106 to identify and to obtain certain information about complete pre-decoded x86 instructions and the number of ROPs to which they map.
      <br/>
      To avoid unnecessary delay, the scanning preferably is performed essentially concurrently using either combinatorial logic or programmable array logic.
      <br/>
      The flowchart of FIG. 10 is furnished to illustrate the various operations performed by the byte queue scan logic, and is not to be interpreted as necessarily suggesting a sequential ordering of those various operations.
    </p>
    <p num="66">
      In operation 1002, the byte queue scan finction identifies the instructions in the BYTEQ 106, beginning at the head of queue, which collectively map to four ROPs.
      <br/>
      If the end of queue is encountered before four ROPs are detected, the byte queue scan function identifies all instructions in the BYTEQ 106.
      <br/>
      The instructions are identified by detecting their respective start bits in the array BYTEQS, and the number of ROPs associated with each instruction is determined by identifyig its opcode byte and detecting the value of ROP bits associated with the opcode byte.
      <br/>
      Complete instructions are identified by determining that the start bit of the instruction has an opposing end bit in the array BYTEQE.
    </p>
    <p num="67">For example, consider the scan function as applied to the queue entries shown in FIG. 11. Bit BYTEQS0 identifies the start of the first instruction I1, the opcode byte I1-OC for instruction I1 is identified by bit BYTEQP20, and the number of ROPs, hence the number of dispatch positions required to be allocated to instruction I1, is indicated by opcode bits BYTEQP10 and BYTEQP00. In a similar manner, the start of the second instruction I2 is identified by the bit BYTEQS3, its opcode byte is identified by bit BYTEQP25, and the number of ROPs to which instruction I2 maps is identified by bits BYTEQP15 and BYTEQPO5. Instructions I1 and I2 are complete instructions, since set bit BYTEQS0 has an opposing set bit BYTEQE2, and set bit BYTEQS3 has an opposing set bit BYTEQE11.</p>
    <p num="68">
      In operation 1004, the ROPMUX 700 generates control signals ROPxNUM1:0 for indicating for the ROPs in the dispatch positions their respective position in the sequence of ROPs for a given instruction (event 804 in FIG. 8).
      <br/>
      For the example of FIG. 11, ROPONUM is 0, ROPINUM is 1, ROP2NUM is 2, and ROP3NUM is 0.
    </p>
    <p num="69">
      In operation 1006, a determination is made of whether the pre-decoded x86 instruction at the head of the BYTEQ 106 is a microcode ROM mapped instruction.
      <br/>
      The operations of FIG. 10B are performed if the predecoded x86 instruction at the head of the BYTEQ 106 is a microcode ROM mapped instruction.
      <br/>
      The operations of FIG. 10C are performed if the pre-decoded x86 instruction at the head of the BYTEQ 106 is not a microcode ROM mapped instruction.
    </p>
    <p num="70">
      When the pre-decoded x86 instruction at the head of the BYTEQ 106 is not a microcode ROM mapped instruction, dispatch positions 710, 720, 730 and 740 are allocated in operation 1032 (FIG. 10C) to pre-decoded x86 instructions depending on the number of ROPs to which each pre-decoded x86 instruction maps and the number of dispatch positions available (event 806 of FIG. 8).
      <br/>
      ROPXNUM for the dispatch positions allocated in this manner are assigned their respective values, control signal ROPMROM is not asserted, and MUXVALx for each dispatch position is asserted.
      <br/>
      For example, assume that the value of BYTEQP10 and BYTEQP00 for instruction I1 is 10, indicating that instruction I1 maps to three ROPs.
      <br/>
      The first three dispatch positions 0, 1 and 2 are available and are allocated to instruction 1, as shown in FIG. 11. For instruction I2, assume that the value of BYTEQP15 and BYTEQP05 are also 10, indicating that the instruction I2 maps to three ROPs.
      <br/>
      Since only one dispatch position is available, it is allocated to instruction I2.
      <br/>
      Note that dispatch position resources are not available in the present decode stage for full allocation to the instruction I2.
      <br/>
      The remaining two required dispatch positions are allocated to instruction I2 in the next cycle, after instruction I2 is shifted to the head of the BYTEQ 106 and in accordance with control signal PARTIALDISP, which is set to the value two.
      <br/>
      If any of the x86 instructions pending for the current dispatch window and not at the head of the BYTEQ 106 maps to microcode ROM, dispatch positions are still allocated.
      <br/>
      However, ROPxNUM for dispatch positions allocated in this manner is "don't care," since control signal ROPMROM is not asserted and ROPs dispatched from dispatch positions allocated to x86 instructions which map to microcode ROM but which are not at the head of queue are not marked valid (MUXVALx for dispatch position x is not asserted).
      <br/>
      Invalid ROPs are not processed in subsequent pipeline stages of the processor 100.
    </p>
    <p num="71">
      In operation 1034, each dispatch position receives four elements from a pre-decoded x86 instruction stored in the BYTEQ 106.
      <br/>
      The four elements are a consolidated prefix data element, an opcode element, a mod rim element, and a sib element.
      <br/>
      If an element is not present in the pre-decoded x86 instruction, as determined from the start and end bits of the instruction, the information received at the dispatch position corresponding to the absent element is treated as "don't care" information.
      <br/>
      For example, a consolidated prefix element is not present in instruction I1 of FIG. 11.
    </p>
    <p num="72">
      In the example of FIG. 11, the instructions to which dispatch positions are allocated are instructions I1 and I2.
      <br/>
      The first instruction I1 includes byte queue elements I1-OC, I1-MRM and I1-SIB, which are respectively the opcode element, the mod r/m element, and the sib element of, illustratively, the ADD instruction of FIG. 6.
      <br/>
      ROPMUX 700 drives these three byte queue elements, along with a null element corresponding to an absent consolidated prefix element, to the dispatch positions allocated it, namely the first, second, and third dispatch positions.
      <br/>
      The second pre-decoded x86 instruction I2 is, illustratively, obtained from an x86 instruction having prefix modifiers, two opcodes, mod r/m data, sib data, and displacement/immediate data.
      <br/>
      The second instruction I2 begins with two prefix elements, a re-coded prefix element I2-PREI followed by the consolidated prefix element I2-PREC.
      <br/>
      Following are the opcode element I2-OC (the first opcode of the raw x86 instruction signaling a two opcode instruction is represented by a bit in the consolidated prefix element I2-PREC), the mod rim element I2-MODRM, and the sib element I2-SIB.
      <br/>
      The four byte queue elements which follow are all displacement/intermediate bytes of instruction I2.
      <br/>
      ROPMUX 700 drives I2-PREC, I2-OC, I2-MRM, and I2-SIB to the dispatch position allocated it, namely the fourth dispatch position.
    </p>
    <p num="73">
      In operation 1036, the next heads of queue are determined for one, two, three and four ROPs dispatched.
      <br/>
      This information is used for shifting the BYTEQ 106.
      <br/>
      FIG. 12 shows dispatch of instructions after instruction 12 is shifted to the head of the BYTEQ 106.
      <br/>
      Since the set of three ROPs to which the instruction I2 maps was only partially dispatched in the decode stage shown in FIG. 11, the first two dispatch positions 0 and 1 are allocated to the remaining ROPs corresponding to instruction I2 in accordance with control signal PARTIALDISP1:0, which has a value of two (binary 10).
      <br/>
      Assuming instructions I3 and I4 each map to one ROP, dispatch position 2 is allocated to instruction I3 and dispatch position 3 is allocated to instruction I4.
    </p>
    <p num="74">
      When the pre-decoded x86 instruction at the head of the BYTEQ 106 is a microcode ROM mapped instruction, all four dispatch positions are allocated to the microcode ROM mapped instruction.
      <br/>
      For a microcode ROM mapped instruction, the value of BYTEQP1 and BYTEQPO is 11, indicating that the instruction is microcode ROM mapped.
      <br/>
      If the allocation of four dispatch position resources is not sufficient for completing dispatch of the ROP sequence to which the x86 instruction maps, the four dispatch position resources are again allocated to the microcode mapped instruction in the next cycle.
      <br/>
      ROPXNUM for dispatch positions allocated in this manner is "don't care" since it is not used, the dispatch positions are marked valid (MUXVAL3:0 bits are asserted), and control signal ROPMROM is asserted since the microcode mapped x86 instruction is at the head of queue.
    </p>
    <p num="75">
      In operation 1022, the IDECCNTL 760 forms a microcode ROM entrypoint and accesses an ROP sequence contained in MROMO 716, MROM1726, MROM2736, and MROM3746.
      <br/>
      Initially, the entrypoint is based on the ROP0PRE, ROP0OP, ROP0MODRM, and ROP0SIB elements at the head of the BYTEQ 106 as well as on processor state information such as mode (real/protected) and priority level information obtained from the pre-decoded x86 instruction, and subsequently on other information from the microcode sequence itself.
    </p>
    <p num="76">
      In operation 1024, the consolidated prefix data element, the opcode element, the mod r/m element, and the sib element from the microcode mapped x86 instruction at the head of the BYTEQ 106 are furnished as the signals ROPxPRE, ROPxOP, ROPxMODRM, and ROPxSIB elements to all of the dispatch positions for use by ICOMMONx.
      <br/>
      If an element is not present in the pre-decoded x86 instruction, as determined from the start and end bits of the instruction, the information received at the dispatch position corresponding to the absent element is treated as "don't care" information.
    </p>
    <p num="77">
      In operation 1026, the next heads of queue are determined for one, two, three and four ROPs dispatched.
      <br/>
      This information is used for shifting the BYTEQ 106 in the event that the microcode mapped x86 instruction is fully dispatched.
    </p>
    <p num="78">
      The various data, address, and control signals associated with the ROPMUX 700 become valid at different times in the FETCH, DECODE1, and DECODE2 pipeline stages in order to complete the instruction decode in only two decode stages.
      <br/>
      During the FETCH stage, certain branching information from the ICACHE 104 to the ROPMUX 700 becomes valid.
      <br/>
      Branch prediction is use in the processor 100 of FIG. 1 because the technique allows an adequate instruction-fetch rate in the presence of branches and is needed to achieve performance with multiple issue.
      <br/>
      Branching is disclosed in U.S. patent application Ser.
      <br/>
      No. 08/146,382 filed Oct. 29, 1993, which is incorporated herein by reference in its entirely, and which issued as U.S. Pat. No. 5,651,125. Other suitable branching techniques and systems are well known in the art.
    </p>
    <p num="79">
      As shown in FIG. 8, the sixteen raw bytes BYTEQx7:0 from the BYTEQ 106 to the ROPMUX 700 become valid in early phase one of the DECODE1 stage.
      <br/>
      Also in early phase one of the DECODE1 stage, pre-decode information inputs from the BYTEQ 106 to the ROPMUX 700 become valid.
      <br/>
      These are the pre-decode start byte indication BYTEQS15:0, the pre-decode valid byte indication BYTEQV15:0, the pre-decode end byte indication BYTEQE15:0, the byte pre-decode information BYTEQP215:0, BYTEQP115:0, and BYTEQP015:0. BYTEQP2 is set if the associated byte is an opcode byte.
      <br/>
      Also becoming valid in early phase one is the control signal PARTIALDISP1:0 from the IDECCNTL 760, which indicates the number of ROPs left to be dispatched for the x86 instruction at the head of the BYTEQ 106.
    </p>
    <p num="80">
      Also in early phase one of the DECODE1 stage, branch information inputs from the BYTEQ 106 to the ROPMUX 700 become valid.
      <br/>
      These are the byte non-sequential indication BYTEQNS15:0, the byte cache column indication BYTEQCLM115:0 and BYTEQCLM015:0. The use of this information is discussed in U.S. patent application Ser.
      <br/>
      No. 08/145,905, filed Oct. 29, 1993 (David B. Witt and Michael D. Goddard, "PreDecoded Instruction Cache and Method Therefor Particularly Suitable for Variable Byte-Length Instructions"), which is incorporated herein by reference in its entirety.
    </p>
    <p num="81">
      A number of signals furnished to the dispatch positions become valid in late phase one of the DECODE1 stage.
      <br/>
      As shown in FIG. 8, signal ROPxNUM1:0 is furnished to the FASTCONVx 902 to indicate whether the dispatch position is allocated to the first, second or third ROP in a particular ROP sequence, or is allocated to microcode ROM.
      <br/>
      Signal ROPMROM to the IDECCNTL 760 becomes valid to indicate whether the x86 instruction at the head of the byte queue is a microcode ROM instruction.
    </p>
    <p num="82">
      Also in late phase one of the DECODE1 stage, signal ROPxDIFF1:0 to the IDECCNTL 760 becomes valid to indicate the number of ROPs left in the allocated x86 instruction for each possible dispatch.
      <br/>
      ROPXDIFF is furnished to the IDECCNTL 760.
      <br/>
      ROPxDIFF is used by the IDECCNTL 760 to determine PARTIALDISP, which is the number of ROPs remaining to be dispatch for the pre-decoded x86 instruction at the head of queue in the next cycle.
      <br/>
      PARTIALDISP1:0 is latched for the next cycle from one of the ROPxDIFF signals, selected on the basis of the number of ROPs predicted to be dispatched from the current dispatch window.
      <br/>
      For the example of FIG. 11, ROP0DIFF is 2, ROP1DIFF is 1, ROP2DIFF is 0, AND ROP3DIFF is 2.
      <br/>
      Assuming the IDECCNTL 760 determines that all four ROPs in the dispatch window are to be dispatched, ROP3DIFF is selected and latched as PARTIALDISP.
      <br/>
      The value of PARTIALDISP for the next cycle shown in FIG. 12 is therefore two.
    </p>
    <p num="83">
      The following signals, which also become valid late in phase one of the DECODE1 stage, are furnished to various blocks within each of the dispatch positions 710, 720, 730 and 740.
      <br/>
      Signal MUXVAL3:0 contains ROP valid bits for the dispatch positions 710, 720, 730 and 740 respectively.
      <br/>
      The bits of MUXVAL are respectively furnished to the ICOMMONx 904 blocks of the dispatch positions 710, 720, 730 and 740, which generate dispatch control signals based on their values.
      <br/>
      Signals ROPxPRE7:0, ROPxOP7:0, ROPxMODRM7:0, and ROPxSIB7:0, which are furnished in whole or in part to FASTCONVx 902, ICOMMONx 904, and IDECCNTL 760 (x=0,1,2,3) are the prefix, opcode, modrm, and sib bytes of the x86 instruction to which the dispatch position x is allocated.
      <br/>
      Note that if a particular byte does not apply to a particular instruction, it is treated as a don't care.
      <br/>
      For example, FIG. 11 shows that because instruction I1 does not contain a prefix byte, dispatch positions 0, 1 and 2 receive invalid data in the relative position of the prefix byte.
      <br/>
      This invalid data may be, for example, the result of resetting all of the bits in the prefix byte position in the absence of a prefix byte, although other implementations are suitable as well.
      <br/>
      In any event, the ROPMUX 700 identifies the data as invalid because it is outside the range identified by the instruction start and end bits, and ignores it.
    </p>
    <p num="84">
      None of the bits of ROPxPRE7:0 are set unless the byte is valid and its end bit is not set (which indicates it is part of the previous instruction).
      <br/>
      The prefix, information is summarized in the consolidated byte just before the opcode, and contains the information listed in Table 3.
    </p>
    <p num="85">
      --        TABLE 3
      <br/>
      --        BITS        VALUE         MEANING
      <br/>
      --        7:5         000           no segment prefix
      <br/>
      --                    001           CS segment override prefix
      <br/>
      --                    010           DS segment override prefix
      <br/>
      --                    011           ES segment override prefix
      <br/>
      --                    100           FS segment override prefix
      <br/>
      --                    101           GS segment override prefix
      <br/>
      --                    110           SS segment override prefix
      <br/>
      --                    111           reserved
      <br/>
      --        4:3         00            no repeat or lock prefix
      <br/>
      --                    01            LOCK prefix
      <br/>
      --                    10            REPNE prefix
      <br/>
      --                    11            REP/REPE prefix
      <br/>
      --        2           0             no operand size prefix
      <br/>
      --                    1             operand size prefix
      <br/>
      --        1           0             no address size prefix
      <br/>
      --                    1             address size prefix
      <br/>
      --        0           0             no two byte opcode prefix
      <br/>
      --                    1             two byte opcode prefix
    </p>
    <p num="86">
      The signals D1SHFT15:0 through D4SHFT15:0 from the ROPMUX 700 to the ICACHE 104 also become valid in late phase one of the DECODE1 stage, as shown in FIG. 8.
      <br/>
      These signals indicate to the ICACHE 104 the position of the byte that should be shifted to the front of the byte queue for all possible numbers of ROPs dispatched: 1, 2, 3, or 4 ROPs.
      <br/>
      Which of the signals is used depends on an estimate determined by the IDECCNTL 760 and communicated to the ICACHE 104 as signals DISPATCH0 through DISPATCH4.
    </p>
    <p num="87">
      The following signals, which are furnished to the ROPSELECTx 1500 (see FIG. 15), become valid early in phase one of the DECODE2 stage.
      <br/>
      Signal ROPxDI63:0 contains the raw instruction bytes from the byte queue right justified according to the last byte of the allocated x86 instruction.
      <br/>
      For an instruction containing four byte displacement/immediate data, for example, ROPxDI63:0 would contain the raw prefix byte, the raw opcode byte, the raw modify r/m byte, the raw sib byte, and the four raw bytes of the displacement/immediate data.
      <br/>
      Signal ROPPRDTKN3:0 is the allocated non-sequential indication from the last byte of the x86 instruction.
      <br/>
      Signal ROPxCLM1:0 is the allocated cache column indication from the last byte of the x86 instruction.
    </p>
    <p num="88">
      Signal CS32X16 from the code segment register, which provides a 32 bit or 16 bit indication, is a processor state related signal.
      <br/>
      The signal is in effect changed in a serial manner and so is static when IDECODE 108 is active.
    </p>
    <p num="89">Control of Byte Queue Shift Operations</p>
    <p num="90">
      The byte queue entries of pre-decoded x86 instructions for which ROP dispatch is completed are shifted out of the BYTEQ 106 to provide space for the elements of new pre-decoded x86 instructions.
      <br/>
      The BYTEQ 106 comprises a barrel shifter capable of shifting from 0 to 15 locations in one cycle.
      <br/>
      Shifting of the BYTEQ 106 is controlled by signals DlSHFT15:0 through D4SHFT15:0 and DISPATCH0 through DISPATCH4, which advantageously are generated by the ROPMUX 700 and the IDECCNTL 760 respectively at appropriate times in the DECODE1 stage so that the BYTEQ 106 can be shifted in a timely manner for the next decode cycle.
    </p>
    <p num="91">
      Since the IDECODE 108 is a two-stage decoder with dispatch occurring in the DECODE2 stage, the BYTEQ 106 needs to be shifted before the actual number of ROPs dispatched is known.
      <br/>
      The ROPMUX 700 receives various inputs from the ICACHE 104 that are valid in early phase one of the DECODE1 stage, and by late phase one of the DECODE1 stage indicates back to the ICACHE 104 by signals D1SHFT15:0 through D4SHFT15:0 how to shift the byte for each of the possible dispatch scenarios, i.e. the dispatch of 0, 1, 2, 3, or 4 ROPs.
      <br/>
      The ICACHE 104 uses this information in phase two of the DECODE1 stage to set up the load/shift logic for the BYTEQ 106.
      <br/>
      Very late in phase two of the DECODE1 stage, the IDECCNTL 760 communicates a prediction of how many ROPs are going to be shifted out of the BYTEQ 106, and the ICACHE 104 shifts and fills the byte queue dynamically in phase one of the following DECODE1 stage.
      <br/>
      A prediction is used because information regarding the full status of the functional units and the ROP types is not known until after the DECODE1 stage.
    </p>
    <p num="92">
      Evaluation of DSHFT15:0 through D4SHFT15:0 in the ROPMUX 700 begins as soon as the dispatch positions 0, 1, 2 and 3 receive pre-decoded x86 instructions from the BYTEQ 106, and DISHFT15:0 through D4SHFT15:0 become valid late in the first phase of the DECODE1 stage.
      <br/>
      D1SHFT15:0 indicates the byte queue entry that should be shifted to the head of the BYTEQ 106 if only one ROP is dispatched, D2SHFT15:0 indicates the byte queue entry that should be shifted to the head of the BYTEQ 106 if two ROPs are dispatched, D3SHFT15:0 indicates the byte queue entry that should be shifted to the head of the BYTEQ 106 if three ROPs are dispatched, and D4SHFT15:0 indicates the byte queue entry that should be shifted to the head of the BYTEQ 106 if four ROPs are dispatched.
      <br/>
      Advantageously, the evaluation of DISHFT15:0 through D4SHFT15:0 is initiated as soon as possible and well before the actual number of ROPs dispatched is known to avoid wasting clock cycles.
    </p>
    <p num="93">
      The prediction of how many ROPs are going to be dispatched is performed in the IDECCNTL 760 and communicated to the ICACHE 104 by an appropriate one of the signals DISPATCH0 (no ROPs dispatched) through DISPATCH4 (four ROPs dispatched).
      <br/>
      Signals DISPATCH0 through DISPATCH4 select none of or a corresponding one of the signals DOSHFT15:0 through D4SHFT15:0, which then controls the shifting of the BYTEQ 106.
    </p>
    <p num="94">
      In the embodiment of FIG. 9, prediction is achieved by applying two rules.
      <br/>
      First, past predicted taken branches (next ROP nonsequential) are not dispatched to simplify program counter maintenance.
      <br/>
      Second, the two ROPs used for a floating point operation need to be dispatched in the same cycle and, in one embodiment, from the first two dispatch positions, or in an alternative embodiment, from two of the first three dispatch positions.
      <br/>
      Typically, if all ROPs are fastpath integer ROPs, the IDECCNTL 760 predicts a four ROP dispatch.
      <br/>
      Note that many different prediction rules are possible, even rules permitting past predicted taken branches to be dispatched and permitting two floating point ROPs of a floating point operation to be dispatched from any dispatch position and even from different dispatch windows, although the use of such rules would require greater speed for performing the more complex logical calculations.
    </p>
    <p num="95">
      The prediction is based on signals QVAL3:0 and QPRDTKN3:0 from the ROPSELECTx 1500 (FIG. 15), all of which become valid in mid phase two of the DECODE1 stage, as well as the upper five bits of the raw x86 opcode byte.
      <br/>
      The signal QVAL3:0 is a phase two latched version of MUXVAL.
      <br/>
      QVAL3:0 is used in the prediction to take into account non-dispatch of invalid ROPs.
      <br/>
      The signal QPRDTKN3:0, which indicates whether ROPs in the dispatch window are in a predicted taken branch, is a phase two latched version of BYTEQNSx. QPRDTKN3:0 is used in the prediction to detect past predicted taken branches (next ROP nonsequential) so that subsequent ROPs in the dispatch window are not dispatched.
    </p>
    <p num="96">
      The actual number of ROPs dispatched is not known until very late in the second phase of DECODE2, based on various signals from the functional units 131-136 and from the ROB 114.
      <br/>
      These signals include the flmctional unit full signals ALU0FULL, ALU1FULL, LSFULL1:0, BRNFULL:1:0 and FPTFULL; the reorder buffer allocation indication ROBSTAT3:0; and the ROB empty indication ROBEMPTY.
      <br/>
      For each valid ROP at decode, the corresponding bit of ROBSTAT3:0 indicates whether a location of the ROB 114 is available for allocation to it.
      <br/>
      The ROB empty indication ROBEMPTY is asserted to indicate when a serialization event can be initiated.
    </p>
    <p num="97">
      Because the prediction technique in the embodiment of FIG. 9 yields a prediction which is equal to or greater than actual number of ROPs eventually dispatched, the actual number of ROPs dispatched may not agree with the prediction made late in the first phase of the DECODE1 stage.
      <br/>
      In this event, the IDECODE 108 stalls until the remaining undispatched ROPs are dispatched in subsequent cycles.
      <br/>
      The stall is controlled by signal DISPALL from the IDECCNTL 760 to the ROPMUX 700.
      <br/>
      If DISPALL does not assert by the late second phase of the DECODE1 stage, it signals to the following phase one that the ROPs which should dispatch in the DECODE2 stage will not dispatch.
      <br/>
      When DISPALL is not asserted, latches in the ROPSELECTx 1500 which latch the DECODE1 stage signals for the DECODE2 stage are not activated so that DECODE1 signals are prevented from moving into the DECODE2 stage.
    </p>
    <p num="98">
      In the example of FIG. 11, ROPMUX 700 directs the elements of the first pre-decoded x86 instruction (I1-OC, I1-MRM, and I1-SIB) to the first, second and third dispatch positions, and the elements of the second pre-decoded x86 instruction (I2-PREC, I2-OC, I2-MRM, and I2-SIB) to the third dispatch position.
      <br/>
      Both D1SHFT and D2SHFT are assigned the bit pattern "0000000000000001" (the position of the binary 1 in the bit pattern indicates the byte that is to be shifted to the head of queue position) representing no shift, since the first x86 instruction should remain at the head of the BYTEQ 106 if less than three ROPs, the number needed to fully execute the first x86 instruction, are dispatched.
      <br/>
      D3SHFT is assigned the bit pattern "0000000000001000" representing shift left three entries (put the fourth byte at the head of queue), since the first x86 instruction I-1 is fully executed if ROPs are dispatched from the first three dispatch positions, and therefore should be shifted out of the BYTEQ 106 and the second pre-decoded x86 instruction I-2 shifted to the front of the BYTEQ 106 to make room for new pre-decoded x86 instructions.
      <br/>
      D4SHFT is assigned the same bit pattern "0000000000001000" representing shift left three entries, since the second x86 instruction I-2 should go to and remain at the head of the BYTEQ 106 if less than three ROPs, the number needed to fully execute the second x86 instruction I-2, are dispatched.
    </p>
    <p num="99">
      Subsequently, very late in the second phase of the DECODE1 stage, DISPATCH0 is asserted if no ROPs are predicted dispatched in the current cycle, resulting in no shifting of the BYTEQ 106 in the next cycle; DISPATCH1 is asserted if only one ROP from the first dispatch position is predicted dispatched in the current cycle, resulting in no shifting of the BYTEQ 106 in the next cycle; DISPATCH2 is asserted if two ROPs are predicted dispatched from the first two dispatch positions in the current cycle, resulting in no shifting of the BYTEQ 106 in the next cycle; DISPATCH3 is asserted if three ROPs are predicted dispatched from the first three dispatch positions in the current cycle, resulting in a three entry left shift of the BYTEQ 106 in the next cycle; and DISPATCH4 is asserted if four ROPs are predicted dispatched from all of the dispatch positions in the current cycle, resulting in a three entry left shift of the BYTEQ 106 in the next cycle.
      <br/>
      FIG. 12 shows the positions in the BYTEQ 106 of the second pre-decoded x86 instruction I-2, the third pre-decoded x86 instruction I-3, and the fourth pre-decoded x86 instruction I1 after a dispatch of all four ROPs in the prior decode cycle.
    </p>
    <p num="100">ROPMUX-FASTCONVx-ICOMMONx-ROPSELECTx Operation</p>
    <p num="101">FASTCONVx 902 and ICOMMONx 904 are involved in the fast conversion of many types of "simple" x86 instructions into ROPs using signals received from the ROPMUX 700.</p>
    <p num="102">
      Consider first the signals applied to the FASTCONVx 902.
      <br/>
      ROPxNUM specifies the number of the ROP to be generated at ROP position x in the sequence of ROPs needed to execute the x86 instruction, wherein the total number of ROPs in the sequence is specified by bits BYTEQP1a and BYTEQP0a corresponding to the byte queue element "a" in which bit BYTEQP2a is set.
      <br/>
      In the example of FIG. 11, BYTEQP20 is set, which corresponds to the first byte queue element II-OC containing the ADD opcode.
      <br/>
      ROPONUM presented to FASTCONV0 is 00, ROP1NUM presented to FASTCONV1 is 01, ROP2NUM presented to FASTCONV2 is 10.
      <br/>
      In the example of FIG. 11, BYTEQP25 is also set, which corresponds to the opcode in the second instruction I2 contained in the sixth byte queue element from the head of the BYTEQ 106.
      <br/>
      ROP3NUM presented to FASTCONV3 is 00.
    </p>
    <p num="103">
      Signal ROPxPRE2:0 from the ROPMUX 700 are bits from a consolidated prefix and provide the information set forth in Table 3.
      <br/>
      In particular, bit 2 indicates whether an operand size prefix is present.
      <br/>
      An operand size prefix inverts the sense of the default operand size specified by the default operand size attribute specified by the DefaultAttr flag in the code segment descriptor register CS_desc (not shown).
      <br/>
      Bit 1 indicates whether an address size prefix is present.
      <br/>
      An address size prefix inverts the sense of the default address size specified by the default address size attribute specified by the DefaultAttr flag in the code segment descriptor register CS_desc (not shown).
      <br/>
      Bit 0 indicates whether a two byte opcode is present.
      <br/>
      The ICACHE 104 detects all such two opcode instructions, and represents the first indicator opcode as ROPxPRE0.
    </p>
    <p num="104">
      For the example of FIG. 11, the raw x86 instruction from which the first pre-decoded instruction I1 is derived is the ADD instruction shown in FIG. 6, which has no prefix and is a single opcode instruction.
      <br/>
      Accordingly, ROPOPRE2:0, ROP1PRE2:0 and ROP2PRE2:0 in dispatch positions 0, 1 and 2 respectively are 000.
      <br/>
      If the second raw x86 instruction I2 is presumed to be a two opcode instruction such as the "move with sign extension" instruction MOVSX added for the 386 instruction set, and is presumed to have two prefixes which invert the sense of the default operand size and the default address, ROP3PRE2:0 in dispatch position 3 would be 111.
    </p>
    <p num="105">Also for the example of FIG. 11, signals ROP0OP, ROP1OP and ROP2OP are the signal BYTEQ07:0, which is the x86 ADD instruction byte 00000001, while signal ROP3OP is the signal BYTEQ57:0, which is the second instruction byte of the raw x86 instruction from which pre-decoded x86 instruction I2 is derived.</p>
    <p num="106">
      Also for the example of FIG. 11, signals ROP0MODRM7:0, ROP1MODRM7:0 and ROP2MODRM7:0 are the signal BYTEQ17:0, which is the mod r/m byte 00000011 of the raw x86 instruction from which the pre-decoded x86 instruction I1 is derived.
      <br/>
      Signal ROP3MODRM7:0 is the signal BYTEQ67:0, which is the mod r/m byte of the raw x86 instruction from which pre-decoded x86 instruction I2 is derived.
    </p>
    <p num="107">
      Using any suitable combinatorial logic or programmable array logic, the FASTCONVx 902 in each of the dispatch positions converts ROPxOP7:0 into appropriate signals for use by the ROPSELECTx 1500 in assembling ROP control and data signals for dispatch position x and encoding its operand and destination pointers.
      <br/>
      The converted ROP is an appropriate one of the ROPs in the sequence to which the raw x86 instruction maps, based on ROPxNUM1:0 and determined in accordance with ROPxPRE2:0 and ROPxMODRM7:0. The FASTCONVx 902 performs these functions for all of the simple x86 instructions, including, illustratively, register-to-register instructions, memory-to-register instructions, register-to-memory instructions, arithmetic instructions, shift instructions, and branching instructions.
    </p>
    <p num="108">
      The signals at the output of the FASTCONVx 902, which become valid late in phase two of the DECODE1 stage, are ITYPE2:0, which indicates the type of ROP for selecting an appropriate one of the functional units; IOP7:0, which indicates the RISC opcode itself; USEA, which indicates that the A operand should be used in constructing the ROP; USEB, which indicates that the B operand should be used in constructing the ROP; AREG9:0, which contains the operand pointer into the REGF 112 and the ROB 114 for the A operand; BREG9:0, which contains the operand pointer into the REGF 112 and the ROB 114 for the B operand; DREG9:0, which contains the destination pointer into the REGF 112 and the ROB 114; ROBDEC6:0, which furnishes integer and floating point flag update control information to the ROB 114; USEDISP, which indicates that the displacement field should be used; SERIAL, which provides for a serialization event such as state variable updates and test variable reads by indicating that the pipeline must empty before further ROPs are dispatched; FORCE8BIT, which indicates that the operation is a byte-oriented operation, and IMMSEL2:0, which indicates what portions of the immediate data should be selected.
      <br/>
      These signals are fliished to ROPSELECTx 1500 under the same name but with an "F" prefix, as shown in FIG. 15.
    </p>
    <p num="109">
      Using any suitable latched combinatorial logic, the ICOMMONx 904 in each of the dispatch positions pipelines and converts its input signals into control signals for use by the ROPSELECTx 1500 in encoding ROPs, and also provides certain information for floating point operations.
      <br/>
      The ICOMMONx 904 performs these functions for all x86 instructions, including the simple instructions converted in FASTCONVx 902 as well as the rarely used and complicated instructions read out of the MROM0716, MROM1726, MROM2736, and MROM3746 under control of the IDECCNTL 760.
    </p>
    <p num="110">
      The inputs to the ICOMMONx from the ROPMUX 700 are as follows.
      <br/>
      Bits ROPxPRE7:1 are from the consolidated prefix byte, if present, and provide the information stated in Table 3.
      <br/>
      In particular, bits 7:5 indicate whether a default segment should be overridden, and if so, by which segment descriptor.
      <br/>
      Bits 4:3 indicate whether a lock prefix or a repeat prefix is present, and if so, which prefix.
      <br/>
      Bit 2 indicates whether an operand size prefix is present.
      <br/>
      Bit 1 indicates whether an address size prefix is present.
      <br/>
      In the example of FIG. 11, the raw x86 instruction from which the first pre-decoded instruction I1 is derived is the ADD instruction shown in FIG. 6, which has no prefix and is a single opcode instruction.
      <br/>
      Accordingly, ROP0PRE7:1, ROP1PRE7:1 and ROP2PRE7:1 in dispatch positions 0, 1 and 2 respectively are 000.
      <br/>
      If the second raw x86 instruction I2 is presumed to be a two opcode instruction such as the "move with sign extension" instruction MOVSX added for the 386 instruction set, and is presumed to have two prefixes to indicate a CS segment override as well as to invert the sense of the default operand size and the default address, ROP3PRE2:0 in dispatch position 3 is 0010011.
      <br/>
      Bits ROP0OP2:0, ROP1OP2:0 and ROP2OP2:0 are latched from bits BYTEQ02:0, which is the x86 ADD instruction byte portion 001, while bits ROP3OP2:0 are the bits BYTEQ52:0, which is a portion of the second instruction byte of the raw x86 instruction from which pre-decoded x86 instruction I2 is derived.
      <br/>
      Bits ROP0MODRM7:0, ROP1MODRM7:0 and ROP2MODRM7:0 are from BYTEQ1 7:0, which is the mod r/m byte 00000011 of the raw x86 instruction from which the pre-decoded x86 instruction I1 is derived.
      <br/>
      Bits ROP3MODRM7:0 are from BYTEQ67:0, which is the mod r/m byte of the raw x86 instruction from which pre-decoded x86 instruction 12 is derived.
      <br/>
      Similarly, bits ROPOSIB7:0, ROP1SIB7:0 and ROP2SIB7:0 are from BYTEQ27:0, which is the sib byte 11001011 of the raw x86 instruction from which the pre-decoded x86 instruction I1 is derived.
      <br/>
      Bits ROP3SIB7:0 are from BYTEQ77:0, which is the sib byte of the raw x86 instruction from which pre-decoded x86 instruction I2 is derived.
    </p>
    <p num="111">
      The ICOMMONx 904 isolates certain bits of the input signals ROPxOP2:0, ROPxMODRM7:0 and ROPxSIB7:0, which it furnishes to the ROPSELECTx 1500 for the determination of destination and operand pointers as well as register selection and other control information.
      <br/>
      Register pointers may appear in any one or more of five locations: bits 2:0 of the opcode byte, bits 5:3 of the modrm byte (REG1), bits 2:0 of the modrm byte (REG2), bits 5:3 of the sib byte (ADDR1), bits 2:0 of the sib byte (ADDR2).
      <br/>
      These bits are used by the ICOMMONx 904 for obtaining opcode and register information for ROP instructions, which is fuimshed in signals ROPOPREG2:0, ROPREG12:0, ROPREG22:0, ROPADDR1 2:0, and ROPADDR22:0. Instruction format and timing information is set forth in more detail in Appendix E of a publication of the Intel Corporation entitled "Intel486 (tm)  Microprocessor Family: Programmer's Reference Manual", Santa Clara, Calif., 1992, which is incorporated herein by reference in its entirety.
    </p>
    <p num="112">
      MUXVAL3:0 contains four valid bits for respective ROPs in the four dispatch positions.
      <br/>
      Each bit MUXVALx for dispatch position x is obtained from the valid bit of the pre-decoded x86 instruction from which the ROP in the dispatch position x is obtained.
      <br/>
      MUXVALx for an ROP in dispatch position x is asserted only if the pre-decoded source x86 instruction of the ROP is valid and the ROP itself is valid.
    </p>
    <p num="113">
      The signals at the output of the ICOMMONx 904, which are fuimshed to the ROPSELECTx 1500, are shown in FIG. 15. These signals become valid early in phase one of the DECODE2 stage.
      <br/>
      Many of the signals pertain to memory operand encoding.
      <br/>
      Signal ADDR32X16 indicates whether the address size is 32-bit or 16-bit Signal DATA32X16 indicates whether the operands of the instruction are doubleword or word.
      <br/>
      Signal SELADDRA16 pertains to the A operand, and controls selection of the BX register or the BP register in the 16-bit addressing mode.
      <br/>
      Signal SELADDRB 161:0 pertain to the B operand, and controls selection of the BX, BP, SI or DI registers in the 16-bit addressing mode.
      <br/>
      Signal SELADDRB321:0 indicates whether REG2, ADDR1 or ADDR2 is used in the 32-bit addressing mode.
      <br/>
      In this manner, all x86 addressing modes for the fastpath and the microcode mapped path are handled in common.
      <br/>
      Signal ADDRUSEA indicates whether to use the A operand, which is not used in all addressing modes.
      <br/>
      Signal ADDRUSEB indicates whether to use the B operand, which is not used in all addressing modes.
      <br/>
      Signal DISPSEL1:0 indicates how the displacement field is handled, and is interpreted as follows: 0xx binary--zero extend; 1xx binary--sign extend to 32 bits; x00 binary--none; x01 binary--8 bit; x10 binary--16 bit; x11 binary--32 bit.
      <br/>
      Signal FPREINS6:0 is a pre-instruction load/store signal which acts as a mode override for the LSSEC 134.
      <br/>
      When asserted, bit 6 forces the 32-bit addressing mode without changing the processor state.
      <br/>
      When asserted, bit 5 forces a locked access.
      <br/>
      When 0, bit 4 commands the use of the address segment indicated by the x86 instruction; when 1, bit 4 indicates that the segment is specified in bits 3:0. Some of the signals are used in floating point operations.
      <br/>
      Signal FPREOP10:0 contains bits ROPxMODRM2:0 and ROPxOP7:0. Signal FPREVAL is a latched version of MUXVAL.
      <br/>
      Signals ROPOPREG2:0, ROPREG1 2:0, ROPREG22:0, ROPADDR1 2:0 and ROPADDR22:0 are discussed above.
    </p>
    <p num="114">ROPMUX-IDECCNTL-MROMx-ROPSELECT Operation</p>
    <p num="115">
      Microcode ROM instruction sequencing is controlled by the IDECCNTL 760, which establishes an entrypoint based on prefix, opcode, mod r/m, sib, processor state, and exception information, and uses the entrypoint for reading an ROP sequence from the MROM0716, MROM1726, MROM2736, and MROM3746 at four ROPs per cycle.
      <br/>
      The sequencing logic is located in the IDECCNTL 760, which receives signal MROMC11:0 from the control ROM 750 and furnishes signals GOMROM and MROMMADDR9:0 to access the MROM0716, MROM1726, MROM2736, MROM4746, and the control ROM 750.
    </p>
    <p num="116">
      FIG. 10A shows steps for controlling the sequencing of ROPs.
      <br/>
      Signal ROPMROM is asserted when a microcode mapped pre-decoded x86 instruction is at the head of the BYTEQ 106.
      <br/>
      As indicated by operation 1022, the IDECCNTL 760 determines the MROM entrypoint based on four elements received from the microcode mapped x86 instruction at the head of the BYTEQ 106.
      <br/>
      The four elements are a consolidated prefix data element, an opcode element, a mod r/m element, and a sib element.
      <br/>
      If an element is not present in the pre-decoded x86 instruction, as determined from the start and end bits of the instruction, the information received at the dispatch position corresponding to the absent element is treated as "don't care" information.
    </p>
    <p num="117">
      As indicated by operation 1024, the IDECCNTL 760 uses signals ROP0PRE, ROP0OP, ROP0MODRM, and ROP0SIB for accessing MROMx 906.
      <br/>
      This is shown as event 808 in FIG. 8.
      <br/>
      FIG. 13 is a block diagram of the MROM control portion of the IDECCNTL 760.
      <br/>
      The IDECCNTL 760 accesses the MROMx 906 of the several dispatch positions in the second phase of the DECODE1 stage.
      <br/>
      Sequencing control logic 1302 is a state machine of any suitable design which controls a multiplexer 1306 for furnishing microcode ROM entrypoint addresses on MROMADDR9:0. The sequencing control logic 1302 is responsive to a control word from the control ROM 750, and the prefix, opcode, mod r/m, sib, processor state, and exception indication signals from various units of the IDECODE 108 and other units of the processor 100.
      <br/>
      An initial microcode entrypoint is generated by an initial entry point generator 1304, which is a programmable logic array of any suitable design, based on ROP0PRE, ROP0OP, ROP0MODRM and ROP0SIB, which become valid before the second phase access of the microcode ROM; see ROPMUX event 806 in FIG. 8.
    </p>
    <p num="118">
      For accessing MROM0716, MROM1726, MROM2736, and MROM3746 at the beginning of a particular microcode ROM sequence, the output of the initial entrypoint generator 1304 is selected by the multiplexer 1306 and applied to the control ROM 750 as well as to the MROMx 906 in each of the dispatch positions x. Subsequent MROMx 906 accesses are selected from an incrementer 1310, a return latch 1308, and the bus XTARGET9:0, depending on the sequencing mechanism.
      <br/>
      The positions of the ROPs in the MROMx 906 are fixed.
      <br/>
      Accordingly, all ROPs in a particular line are dispatched before those in the next line are dispatched.
      <br/>
      To simplify the logic that determines when the last ROP of a line has been dispatched, partially filled lines right justify the ROPs to the third dispatch position 740 and indicate a null type in the unused dispatch positions, if any.
    </p>
    <p num="119">
      Two mechanisms are used for controlling the sequencing of ROPs: the sequence control field, and the microbranch ROPs.
      <br/>
      The sequence control field takes effect in the DECODE1 stage, which is the stage in which the MROMx 906 is accessed.
      <br/>
      On the other hand, microbranch ROPs are dispatched to the BRNSEC 135 for execution, and so have a delayed effect.
    </p>
    <p num="120">
      The sequence control field provides several capabilities through the incrementer 1310 and the return latch 1308: microcode subroutine call/return (single level supported), unconditional branching to any MROM location on a block aligned basis, conditional branching within plus or minus thirty-two blocks based on the processor state, and indicating end-of-sequence.
      <br/>
      The control words of the sequence control field are stored in the control ROM 750, which contains 1024 control words.
      <br/>
      Each control word is 12 bits in length.
      <br/>
      In the illustrative encoding scheme shown in FIG. 14, one control word applies to each "group of four" dispatch window.
      <br/>
      Each control word is interpreted in a manner dependent on its leading bits.
      <br/>
      If control ROM bits 11:10 are 00, a "miscellaneous control" format field is indicated.
      <br/>
      Bits 9:8 of the miscellaneous control format field are 00 binary to indicate a sequencing implemented by the incrementer 1310, are 01 binary to indicate an unconditional branch to the value contained in the return latch 1308 after the four ROPs in the current dispatch window are dispatched, and are 10 to indicate an exit.
      <br/>
      If control ROM bits 11:10 are 01, an unconditional branch is indicated, with the branching address being indicated by bits 9:0. If control ROM bits 11:10 are 10, a conditional branch is indicated to SEQMADDR9:5.vertline."branch taken address" based on a "condition specifier" (testing prefixes, opcode, mod r/m, sib, processor state, or exception indications) after the four ROPs in the current dispatch window are dispatched.
      <br/>
      The condition is specified by bits 9:6 and the branching offset is specified by bits 5:0. If control ROM bits 11:10 are 11, a call target is indicated, with the target being indicated by bits 9:0. A "call target" causes an unconditional branch to a "subroutine entrypoint" after the four ROPs in the current dispatch window are dispatched, and the return latch 1308 is updated with the next sequential address.
      <br/>
      Note that the microsubroutine call control word is also useful as an unconditional branch absolute if the "return latch 1308" is not currently valid.
    </p>
    <p num="121">
      Microbranch ROPs are performed like instruction-level branches, being dispatched to the BRNSEC 135 for execution and subject to correction on mispredictions.
      <br/>
      Microbranches are distinguished from instruction-level branches by the decode position of the microbranch and an exit code in the sequence control field.
      <br/>
      Instruction-level branch ROPs are the last ROP in a sequence, and hence appear in the third dispatch position with a sequence exit code.
      <br/>
      Other branches are considered microbranches.
      <br/>
      Bit0 in INSBRN accompanies the ROP to the BRNSEC 135.
      <br/>
      Also an MROM address is sent rather than an instruction address for target address formation or branch correction.
      <br/>
      On a microbranch correction, the BRNSEC 135 indicates to the IDECODE 108 via the XTARGET bus 103 that the correction address is an MROM address rather than a PC.
      <br/>
      Microbranch ROPs basically offer an unconditional branch capability and conditional branching based on a register value being zero, non-zero, positive, or negative.
    </p>
    <p num="122">The ROPSELECTx and ROPSHARED</p>
    <p num="123">
      The ROPSELECTx 1500, which is present in each dispatch position, selects information from the FASTCONVx 902, ICOMMONx 904, MROMx 906, and ROPMUX 700 and directs this information to the REGF 112 and the ROB 114, as well as to various functional units of the processor 100.
      <br/>
      The ROPSELECTx 1500 also furnishes information to ROPSHARED 790 for dispatch to shared resources.
      <br/>
      Information dispatched includes an A operand pointer, a B operand pointer, a destination pointer, information on the instruction type, the instruction opcode, interrupt enable, backup enable, and instruction end, and constant values.
      <br/>
      The various data and control paths between the ROPSELECTx 1500 and other elements of ICACHE 104 and the register file REGF 112, the reorder buffer ROB 114, and an illustrative functional unit FU are shown in FIG. 15.
    </p>
    <p num="124">
      The various input signals associated with the ROPSELECTx 1500 become valid at different times in the DECODE1 and DECODE2 pipeline stages.
      <br/>
      One of the signals, SS32X16 is the 32 bit or 16 bit indication from the stack segment register, is a processor state related signal.
      <br/>
      The signal is in effect changed in a serial manner and so is static when EDECODE 108 is active.
    </p>
    <p num="125">
      Late in phase one of the DECODE1 stage, raw x86 instruction information from the ROPMUX 700 becomes valid.
      <br/>
      ROPDI63:0 contains the raw instruction bytes from the BYTEQ 106 right justified according to the last byte of the allocated x86 instruction.
      <br/>
      ROPPRDTKN is the allocated non-sequential indication from the last byte of the allocated x86 instruction, and is used by the BRNSEC 135 to determine whether branch was predicted taken or not taken when the instruction was read out.
      <br/>
      ROPCLM1:0 is the allocated cache column indication from the last byte of the allocated x86 instruction, and is used to access the appropriate locations of the ICACHE 104 during cache update.
    </p>
    <p num="126">
      Early in phase two of the DECODE1 stage, some of the general inputs become valid.
      <br/>
      USEMROM indicates when asserted that the ROPSELECT MROMx 906 inputs should be used instead of the FASTCONVx 902 inputs.
    </p>
    <p num="127">The signals from the FASTCONVx 902, ICOMMONx 904 and MROMx 906 become valid early in the first phase of the DECODE2 stage.</p>
    <p num="128">
      The ROPSHARED 790 allocates dispatch information to shared resources according to valid types.
      <br/>
      In mid phase one of the DECODE2 stage, input ROPVAL3:0, which are the ROP valid bits from the IDECCNTL to the ROB 114, become valid.
      <br/>
      The ROPSHARED 790 also receives signals from the ROPSELECTx 1500 in each of the dispatch positions for processing and dispatch to shared resources.
      <br/>
      These signals become valid in mid phase one and early phase two of the DECODE2 stage.
    </p>
    <p num="129">
      In mid phase one of the DECODE2 stage, the instruction type PRExTYP2:0 (x=0,1,2,3) and the opcodes PREOPxB7:0 (x=0,1,2,3) from the ROPSELECTx 1500 in each of the dispatch positions become valid.
      <br/>
      Instruction type information PRETYP2:0 is selected from MITYPE and FITYPE based on USEMROM.
      <br/>
      Opcode information PREOPB7:0 assumes the value MIOP or FIOP based on USEMROM, although PREOPB7:6 is replaced by the destination size DESTSIZE for some opcode types.
    </p>
    <p num="130">
      In early phase two of the DECODE2 stage, the following inputs to the ROPSHARED 790 from the ROPSELECTx 1500 become valid: DISPxB31:0 (x=0,1,2,3), PRExINS7:0 (x=0,1,2,3), FPTxOP10:0 (x=0,1,2,3), CLMx1:0 (x=0,1,2,3), and PRDTKNx.
      <br/>
      DISPxB31:0 is the 32-bit displacement field which is selected from ROPDI63:0 depending on the value of DISPSEL1:0 and FUSEDISP and MUSEDISP as follows.
      <br/>
      DISPSEL1:0 is determined from the address mode and is interpreted as follows: 00 binary--none; 01 binary--8 bit, sign extend to 32 bits; 10 binary--16 bit, sign extend to 32 bits; and 11 binary--32 bit.
      <br/>
      FUSEDISP/MUSEDISP determines whether or not the displacement should actually be used.
      <br/>
      When FUSEDISP/MUSEDISP is not asserted, a zero displacement is supplied.
      <br/>
      PRExINS7:0 is extra opcode information for loads and stores, with PREINS7:6 being scale bits, PREINS5 being an address "32X16" bit, PREINS4 being a lock bit, and PREINS3:0 being segment bits.
      <br/>
      PRExINS is selected from the fast path pre-instruction information FPREINS or from the microcode ROM pre-instruction information MPREINS in accordance with USEMROM and DISPALL.
      <br/>
      FPTOPx10:0 is a delayed version of FPREOP10:0. CLMx1:0 is the cache column from the last byte of the x86 instructions, a delayed version of ROPCLM.
      <br/>
      PRDTKN3:0 is the non-sequential indications, a delayed version of ROPPRDTKN.
    </p>
    <p num="131">
      The ROPSELECTx 1500 in each of the dispatch positions and the ROPSHARED 790 cooperatively select operands for instructions dispatched to the various functional units of the processor 100.
      <br/>
      The REGF is illustratively a large set of general purpose registers.
      <br/>
      The register number is simply decoded by the REGF 112, and the value in the selected entry is provided.
      <br/>
      In contrast, the ROB 114 is a unit which contains a number of storage locations which are dynamically allocated to instruction results.
      <br/>
      When an instruction is decoded, its result value is assigned a reorder-buffer location, and its destination-register number is associated with this location, in effect renaming the destination register to the reorder buffer location.
      <br/>
      When a subsequent instruction refers to the renamed destination register to obtain the value stored in the register, the instruction obtains instead the value stored in the reorder buffer or a tag (the index into the reorder buffer) for this value if the value has not yet been computed.
      <br/>
      To provide this capability, the ROB 114 is illustratively implemented as a content addressable memory, so that the ROB 114 compares the register number to the register numbers in all entries, and returns the value or tag in the entry which has a matching register number, if any.
    </p>
    <p num="132">
      When an instruction is decoded, the register numbers of its source operands are used to access the ROB 114 and the REGF 112 simultaneously.
      <br/>
      If the reorder buffer does not have an entry whose register number matches the source register number, then the value in the register file is selected as the operand.
      <br/>
      If the reorder buffer does have one or more matching entries, the value of the most recent entry is selected if available, and otherwise the tag for the value is selected.
      <br/>
      Either the value or its tag is copied to an appropriate one of the reservation stations of the various functional units in the processor 100.
    </p>
    <p num="133">
      The operand furnishing function is implemented using various outputs of the ROPSELECTx 1500 and the ROPSHARED 790 furnished to the REGF 112 and the ROB 114.
      <br/>
      These outputs become valid during the DECODE2 stage in preparation for the EXECUTE stage.
      <br/>
      Signals USEARD, USEBRD, and ROBALLOC from the ROPSELECTx 1500 to the REGF 112 and the ROB 114, and signals RDAPTR, RDBPTR, and DESTREGB from the ROPSELECTx 1500 to the ROB 114 become valid in mid phase one of DECODE2.
      <br/>
      USEARD is a register use indicator to the ROB 114 and the REGF 112.
      <br/>
      USEARD is derived from FUSEA, MUSEA,and ADDRUSEA depending on respectively whether the x86 instruction is being processed in the FASTCONVx 902, is being processed in the MROMx 906, or involves a special x86 address mode.
      <br/>
      USEBRD is the B operand version of USEARD, and is derived in a manner similar to USEARD.
      <br/>
      ROBALLOC15:0 indicates ROP allocation information and is derived from FROBDEC or MROBDEC depending on USEMROM and DISPALL.
      <br/>
      ROBALLOC contains 4 bits of allocation data for each valid ROP at decode, encoding its requirements for register writeback in bit 3 and its requirements integer/floating point flag modifications in bits 2:0. RDAPTR8:0 is the A source operand pointer to the ROB 114.
      <br/>
      Generally, RDAPTR6:3 is derived from inputs ROPOPREG, ROPREG1, and ROPREG2 from ICOMMONx 904 when the instruction involves a destination or a source register, or a special x86 address mode.
      <br/>
      However, RDAPTR is obtained from FAREG or MAREG when the x86 instruction is being processed in the FASTCONVx 902 or in the MROMx 906.
      <br/>
      RDBPTR8:0 is the B operand version of RDAPTR, and is derived in a manner similar to RDAPTR except from the B operand version of the input signals.
      <br/>
      DESTREGB8:0 is the destination pointer to the ROB 114, and is derived in a manner similar to RDAPTR except from the destination version of the input signals.
    </p>
    <p num="134">
      Dispatched instructions also require type and opcode information, which is furnished by the IDECCNTL 760 and which also become valid during the DECODE2 stage in preparation for the EXECUTE stage.
      <br/>
      Signal INSDISP3:0 indicates the dispatch positions from which ROPs are to be dispatched in the current cycle.
      <br/>
      Each of the type signals INSxTYPE2:0 alerts a particular functional unit to process an instruction from dispatch position x. A different type signal is used for each of the functional units, which provides various capabilities, including the capability of toggling arithmetic and logic operations between the ALU0131 and the ALU1132, as well as the capability of using one function unit for multiple purposes (e.g., ALU1 for arithmetic and logic operations as well as for shift operations).
      <br/>
      Signal XINSDISP3:0 indicates which ROPs are dispatched.
      <br/>
      Signal WRITEFIFO indicates whether the BRNSEC 135 should write a predicted taken address on the XTARGET bus into a prediction FIFO.
      <br/>
      Signal COMMIT indicates whether a serialized event is being dispatched.
    </p>
    <p num="135">
      In late phase one of the DECODE2 stage, signals RDFLGPTR and USEFLGRD from the ROPSHARED 790 to the REGF 112 and the ROB 114 become valid.
      <br/>
      RDFLGPTR2:0, which is the integer flag source operand pointers, is set to the appropriate RDxFLGPTR2:0 based on the dispatch position of the first undispatched ROP mapped to the branch section BRNSEC 135.
      <br/>
      If none of the ROPs is mapped to the branch section BRNSEC 135, RDFLGPTR2:0 is set to 0.
      <br/>
      USEFLGRD1:0, which is the usage indication, is encoded to indicate the dispatch position of the first undispatched ROP mapped to the branch section BRNSEC 135.
    </p>
    <p num="136">
      In early phase two of the DECODE2 stage, the remaining signals from the ROPSELECTx 1500 and the ROPSHARED 790 to the ROB 114 and, in some cases, the REGF 112 become valid.
      <br/>
      CONSTB31:0 is the 32-bit constant field to the REGF 112, and is selected from ROPDI63:0 depending on the value of IMMSEL2:0 and FUSEB and MUSEB as follows.
      <br/>
      IMMSEL2:0 is determined from the 486 instruction and is interpreted as follows: Oxx binary - zero extend; 1xx binary--sign extend to 32 bits; x00 binary--none; x01 binary--8 bit; x10 binary--16 bit; x11 binary--32 bit.
      <br/>
      When FUSEB/MUSEB is asserted, a zero constant is supplied.
      <br/>
      When FUSEB/MUSEB is not asserted, a constant is selected based on FBREG9:8/MBREG9:8 as follows: 00 binary--none; 01 binary--use x86 instruction immediate data; 10 binary--8 bit constant from FBREG7:0/MBREG7:0, no sign extend; 11 binary--8 bit constant from FBREG7:0/MBREG7:0, sign extend.
      <br/>
      In addition, the 8 bit constant can be extended to 16 bits when FUSEA/MUSEA is not asserted and FBREG9/MBREG9 is asserted.
      <br/>
      INSTEI is the instruction end information for the ROB 114, and is used in program counter maintenance.
      <br/>
      ENINTR is the external interrupt enable indication for the ROB 114.
      <br/>
      INSTEI and ENINTR are derived from FROBDEC or MROBDEC depending on USEMROM and DISPALL.
      <br/>
      FPTOPC10:0, which is the floating point opcode of the last x86 floating point instruction executed and which is used for state updating upon retiring of the floating point instruction, is set to the appropriate floating point opcode ROPxOP2:0 .vertline.
      <br/>
      ROPxMODRM7:0 based on the dispatch position of the first undispatched ROP mapped to the floating point section.
      <br/>
      If none of the ROPs is mapped to the floating point section, FPTOPC9:0 is "don't care."
    </p>
    <p num="137">
      The ROPSELECTx 1500 and the ROPSHARED 790 dispatch information to various functional units in the processor 100 which becomes valid early in phase two of the DECODE2 stage.
      <br/>
      The ROPSELECTx 1500 in each of the dispatch positions furnish AHIGHBYTE and BHIGHBYTE, which are the source operand high byte indications to the functional units.
      <br/>
      AHIGHBYTE is derived from FAREG and BHIGHBYTE is derived from FBREG.
      <br/>
      The ROPSHARED 790 furnishes INSOPxB7:0 (x=0,1,2,3), which are the instruction ROP opcode encodings and are dispatched to the ALU0131, the ALU1 &amp; SHF 132, the LSSEC 134, and the BRNSEC 135.
    </p>
    <p num="138">
      In addition to INSOPxB, the LSSEC 134 also receives a number of outputs of the ROPSHARED 790 which become valid in mid phase two of the DECODE2 stage.
      <br/>
      INSLSOB7:0 and INSLSlB7:0 are extra ROP information, and are muxed and latched versions of PRExINS7:0 mapped to the first two undispatched ROPs to the load/store section, as follows: INSLSxB7:6, scale factor; INSLSxB5, address size (32X16); INSLSxB4, lock prefix; and INSLSxB3:0 0000 reserved, 0001 CS, 0010 DS, 0011 ES, 0100 FS, 0101 GS, 0110 SS, and others defined by microcode.
      <br/>
      FASTCN0B3 1:0 and FASTCN1B3 1:0 are fast displacement paths to the load/store section LSSEC 134, and are muxed and latched versions of DISPxB31:0 mapped to the first two undispatched ROPs mapped to the load/store section.
      <br/>
      These busses are "don't care" if there is no corresponding dispatch to the load/store section.
    </p>
    <p num="139">
      In addition to INSOPxB, the BRNSEC 135 also receives an output of the ROPSHARED 790 which become valid in mid phase two of the DECODE2 stage.
      <br/>
      INSBRN4:0 is extra ROP information mapped to the first undispatched ROP to the branch section (indicated by signal USEFLGRD1:0), as follows: INSBRN4, exchange underflow; INSBRN3:2, cache column selected from CLMx1:0; INSBRN1, branch predicted taken selected from PRDTKNx; and INSBRN0, microbranch indication (1:ICACHE 104; 0:IDECODE 108).
    </p>
    <p num="140">
      Very late in phase two of the DECODE1 stage, DISPALL becomes valid and in conjunction with signal USEMROM controls the dispatch from ROPSELECTx 1500 as set forth in Table 4.
      <br/>
      DISPALL indicates when asserted that everything expected to be dispatched in PH1 will be dispatched.
    </p>
    <p num="141">
      -- TABLE 4
      <br/>
      -- USEMROM     DISPALL     COMMENT
      <br/>
      -- x           0           Try to dispatch the rest of the previous ROPs
      <br/>
      -- 0           1           Dispatch from the new FASTCONV ROPs
      <br/>
      -- 1           1           Dispatch from the new MROMx ROPs
    </p>
    <p num="142">
      While the invention has been described with reference to various embodiments, it will be understood that these embodiments are illustrative and that the scope of the invention is not limited to them.
      <br/>
      Many variations, modifications, additions and improvements of the embodiments described are possible.
      <br/>
      For example, the number of ROPs in each dispatch window is illustrative, and may be varied.
      <br/>
      The size of the ICACHE 104 and the BYTEQ 106, the number of dispatch positions in the IDECODE 108, the number of source operand buses, the number of TAD buses, the number of result buses, and the number of writeback buses are illustrative, and may be varied.
      <br/>
      The phasing of many of the various signals is illustrative, and may be varied.
      <br/>
      The functions of the various signals are illustrative, and the signals may be modified by assigning some functions to other signals or by integrating other functions into the signals.
      <br/>
      Types of memory other than read only memory may be used in the MROMx 906.
      <br/>
      Additional functions may be added to the IDECODE 108.
      <br/>
      The manner of maintaining the speculative execution state of the processor is illustrative, and other arrangements such as a single reservation station may be used.
      <br/>
      These and other variations, modifications, additions and improvements may fall within the scope of the invention as defined in the claims which follow.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>An apparatus comprising:</claim-text>
      <claim-text>an instruction queue including storage for a plurality of first-type instructions;</claim-text>
      <claim-text>distribution logic coupled to the instruction queue and having a plurality "m" of outputs to direct information from "n" (n &lt;= m) of the first-type instructions to ones of the distribution logic outputs, up to m outputs; a plurality "m" of conversion paths respectively coupled to the distribution logic outputs to convert the "n" first-type instructions directed thereto into "p" (p &gt;= n) second-type instructions to which the "n" first-type instructions map, wherein the first-type instructions map to particular sets of one or more second-type instructions in accordance with a predefined first-type to second-type mapping;</claim-text>
      <claim-text>and dispatch logic coupled to the conversion paths to dispatch the "p" second-type for execution.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. An apparatus as in claim 1 wherein the distribution logic includes multiplexer logic coupled between the instruction queue and the distribution logic outputs to direct information from a single first-type instruction to a number of the distribution logic outputs equal to a number of the second-type instructions to which the single first-type instruction maps.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. An apparatus as in claim 1 wherein the conversion paths are coupled to simultaneously convert at least one first-type instruction that maps to at least two second-type instructions in accordance with the predefined first-type to second-type mapping.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. An apparatus as in claim 1 wherein the conversion paths are coupled to convert plural first-type instructions that each map to at least two second-type instructions.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. An apparatus as in claim 1, wherein at least some of the first-type instructions map to corresponding sets of at least two of the second-type instructions.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. An apparatus,as in claim 1, wherein the first-type instructions comprise Complex Instruction Set Computer ("CISC") instructions.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. An apparatus as in claim 1, wherein the first-type instructions comprise x86 instructions.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. An apparatus as in claim 1, wherein the second-type instructions comprise RISC-like operations ("ROPs").</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. An apparatus comprising: an instruction queue including storage for a plurality of CISC instructions, wherein the CISC instructions map to one or more RISC-like operations ("ROPs") in accordance with a predefined CISC instruction to ROP mapping; a multiplexer coupled to the instruction queue and responsive to predecode information indicative of a mapping number of ROPs to which an associated one of the CISC instruction maps, the multiplexer having a plurality "m" of outputs to direct information from ones of the CISC instructions to mapping numbers of the multiplexer outputs, up to "m" CISC instructions;</claim-text>
      <claim-text>and a plurality "m" of CISC instruction to ROP conversion paths, each conversion path coupled to a respective multiplexer output to convert a CISC instruction directed thereto to a respective one of the ROPs to which the CISC instruction maps.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. An apparatus as in claim 9, wherein the instruction queue includes storage for the predecode information.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. An apparatus as in claim 9, further comprising dispatch logic coupled to the conversion paths to dispatch ROPs converted thereby to a RISC processor, in parallel.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. A method of decoding plural complex instruction set computer ("CISC") instructions into plural RISC-ike operations ("ROPs") for parallel dispatch to a superscalar processor core, the method comprising: storing a plurality, "n" or greater, of the CISC instructions in an instruction queue; selectively routing "n" of the CISC instructions to a plurality "p" (p&gt;n) of dispatch positions in accordance with predefined mappings of each of the "n" CISC instructions to one or more corresponding ROPs; converting, simultaneously for each of the dispatch positions, each of the "n" instructions into the corresponding one or more ROPs, wherein at least one of the "n" CISC instructions is converted to at least two corresponding ROPs, and wherein the simultaneously converted ROPs total "p" (p&gt;n); driving the "p" converted ROPs from the "p" dispatch positions in parallel to the superscalar processor core.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. A method as in claim 12, further comprising: directing information from each of the "n" CISC instructions to mapping numbers of conversion paths in response to predecode information indicative of a particular mapping number of ROPs to which an associated one of the "n" CISC instruction maps.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. A method comprising, directing information from each of plural complex instruction set computer ("CISC") instructions to conversion paths; simultaneously converting the plural CISC instructions along the conversion paths and supplying plural RISC-like operations ("ROPs") in accordance with a predefined mapping of each of the CISC instructions to corresponding of the ROPs, wherein at least one of the plural CISC instructions so converted maps to a set of plural of the supplied ROPs.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. A method as recited in claim 14, further comprising: dispatching the supplied ROPs, in parallel, to reservation station logic associated with execution units of a processor core.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. A method as recited in claim 14, further comprising: dispatching the supplied ROPs, in parallel, to a superscalar processor core.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. A method as recited in claim 14, wherein a first CISC instructions converted by a first subset of the conversion paths maps to plural of the supplied ROPs;</claim-text>
      <claim-text>and wherein at least a second CISC instruction converted by a second subset of the conversion paths maps to a single of the supplied ROPs, the first and the second subsets simultaneously converting respective CISC instructions.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. An apparatus for decoding CISC instructions into RISC-like operations ("ROPs") for dispatch to a RISC processor, wherein the CISC instructions map to respective numbers of ROPs in accordance with a predefined CISC instruction to ROP mapping, the apparatus comprising: means for aligning CISC opcodes and addressing information of the CISC instructions into dispatch positions based on the numbers of ROPs to which the CISC instructions map; means for decoding the CISC opcodes and addressing information into ROP opcodes and addressing information based on, for each CISC instruction, the position of the dispatch position decoding the CISC instruction relative to other dispatch positions decoding the same CISC instruction;</claim-text>
      <claim-text>and means for driving the ROP opcodes and addressing information from the dispatch positions in parallel to the RISC processor.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. An instruction path for a complex instruction set computer ("CISC") processor having a reduced instruction set computer ("RISC") superscalar core, instruction path comprising: a plurality of dispatch positions; distribution logic coupled to an instruction store to direct a first CISC instruction, which maps to a sequence of one or more RISC-like operations ("ROPs") in accordance with a predefined CISC instruction to ROP mapping, to a selectively-determined subset of the dispatch positions, in parallel;</claim-text>
      <claim-text>means associated with each of the subset of dispatch positions for converting a CISC instruction directed thereto into a respective one of the ROPs of the ROP sequence, in parallel;</claim-text>
      <claim-text>and means for dispatching converted ROPs to the superscalar RISC core, in parallel.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. A processor comprising: a queue having a head-of-queue position and containing and instruction at the head-of-queue position, the head-of-queue instruction being a first-type instruction having a first type opcode and first-to-second type opcode mapping indicia; an instruction decoder comprising:</claim-text>
      <claim-text>- a multiplexer coupled to the queue;</claim-text>
      <claim-text>and - a plurality of first-to-second type opcode converters having an hierarchical relationship with one another, a first subset of the first-to-second type opcode converters of a size determined by the mapping indicia of the head-of-queue instruction being coupled by the multiplexer to the first type opcode of the head-of-queue instruction;</claim-text>
      <claim-text>and - a superscalar processor core having a plurality of hierarchical second-type instruction inputs respectively coupled to outputs of the first-to-second type opcode converters in accordance with the hierarchy thereof.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. A processor as in claim 20: wherein the superscalar processor core comprises a RISC-ike processor core; wherein the first-type instructions comprise predecoded x86 instructions;</claim-text>
      <claim-text>and wherein the second-type instructions comprise RISC-like operations ("ROPs").</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. A processor as in claim 20 wherein each first-type opcode maps to a number of one or more second-type opcodes, the mapping indicia being, for a particular first type opcode, the number of second type opcodes to which the particular opcode maps.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. A computer system as in claim 20 wherein the head-of-queue instruction further includes an opcode marker, the first subset of first-to-second type opcode converters being coupled by the multiplexer in accordance with the opcode marker to the first type opcode of the head-of-queue instruction.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. A processor as in claim 23 wherein the opcode marker is a bit.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. A processor as in claim 24 wherein the opcode marker bit is maintained in a bit array component of the queue.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. A processor as in claim 23 wherein the queue comprises a plurality of component queues, including a first type instruction queue, an opcode marker queue, and a mapping indicia queue.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. A processor as in claim 26 wherein the first type instruction queue is an 8 * 16 bit queue, the opcode marker queue is a 1 * 16 bit queue, and the mapping indicia queue is a 2 * 16 bit queue.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. A processor as in claim 20 wherein the queue further contains a next-in-queue instruction following the head-of-queue instruction, the next-in-queue instruction being a first type instruction having a first type opcode and first-to-second type opcode mapping indicia, and a second subset of the type opcode converters of a size determined by the mapping indicia of the next-in-queue instruction being coupled by the multiplexer to the first type opcode of the next-in-queue instruction, the second subset of type opcode converters being exclusive of the first subset of converters and a higher hierarchical order.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. A computer system comprising the processor of claim 20 and a memory coupled to the queue of the processor, the memory containing a program sequence of x86 instructions.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. An instruction decoder comprising: a plurality of hierarchically-araanged first type instruction inputs, each comprising a first type opcode input field, an opcode marker input field, and a first-to-second type opcode mapping indicia input field; a switch array having inputs coupled to the opcode input fields; a plurality of first-to-second type opcode converters having inputs coupled to outputs of the switch array;</claim-text>
      <claim-text>and control logic having inputs coupled to the opcode marker input fields and the mapping indicia input fields, the control logic having an output coupled to the switch array and being responsive to values in the opcode marker input fields and the mapping indicia input fields to couple a lowest ordered opcode input field of the switch array having an asserted value in the opcode marker field to a first subset of the first-to-second type opcode converters through the switch array, the first subset of the first-to-second type opcode converters having a size determined by the mapping indicia input field of the lowest order instruction input.</claim-text>
    </claim>
    <claim num="31">
      <claim-text>31. An instruction decoder as in claim 30 wherein the control logic is further responsive to values in the opcode marker input fields and the mapping indicia input fields to couple a second-lowest ordered opcode input field of the switch array having an asserted value in the opcode marker field to a second subset of the type opcode converters through the switch array, the second subset of type opcode converters having a size determined by the mapping indicia input field of the second-lowest order instruction input when the plurality of first-to-second type opcode converters is not fewer than the mapping indicia input field of the lowest order instruction input plus the mapping indicia input field of the second-lowest order instruction input.</claim-text>
    </claim>
    <claim num="32">
      <claim-text>32. An instruction decoder as in claim 30 wherein the control logic is further responsive to values in the opcode marker input fields and the mapping indicia input fields to couple a third-lowest ordered opcode input field of the switch array having an asserted value in the opcode marker field to a third subset of the type opcode converters through the switch array, the third subset of type opcode converters having a size determined by the mapping indicia input field and the third-lowest order instruction input when the plurality of first-to-second type opcode converters is not fewer than the mapping indicia input field of the lowest order instruction input plus the mapping indicia input field of the second-lowest order instruction input plus the mapping indicia input field of the third-lowest order instruction input.</claim-text>
    </claim>
    <claim num="33">
      <claim-text>33. An instruction path as in claim 19, wherein the distribution logic further directs a second CISC instruction which maps to a single ROP to a single selectively-determined additional one of the dispatch positions;</claim-text>
      <claim-text>and wherein the instruction path further comprises means associated with the additional one of the dispatch positions for converting a CISC instruction directed thereto into the single ROP.</claim-text>
    </claim>
    <claim num="34">
      <claim-text>34. An instruction path as in claim 33, wherein the distribution logic comprises multiplexing logic coupled between the instruction store and conversion means associated with each of the dispatch positions, including the first subset and the single additional dispatch position, to selectively direct information from particular CISC instructions in the instruction store to unallocated ones of the dispatch positions in accordance with predefined numbers of ROPs to which the particular CISC instructions map.</claim-text>
    </claim>
  </claims>
</questel-patent-document>