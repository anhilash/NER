<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185596B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185596</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185596</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference family-id="26323418" extended-family-id="808293">
      <document-id>
        <country>US</country>
        <doc-number>09050958</doc-number>
        <kind>A</kind>
        <date>19980401</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09050958</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>831214</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>IL</country>
        <doc-number>12077697</doc-number>
        <kind>A</kind>
        <date>19970504</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1997IL-0120776</doc-number>
      </priority-claim>
      <priority-claim kind="national" sequence="2">
        <country>IL</country>
        <doc-number>12131197</doc-number>
        <kind>A</kind>
        <date>19970714</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="2">
        <doc-number>1997IL-0121311</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   7/52        20060101AFI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>52</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   7/72        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>72</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G09C   1/00        20060101ALI20051220RMJP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>09</class>
        <subclass>C</subclass>
        <main-group>1</main-group>
        <subgroup>00</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <generating-office>
          <country>JP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051220</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>708491000</text>
        <class>708</class>
        <subclass>491000</subclass>
      </main-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-007/72M</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>007</main-group>
        <subgroup>72M</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-007/728</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>7</main-group>
        <subgroup>728</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20130101</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>30</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>6</number-of-drawing-sheets>
      <number-of-figures>6</number-of-figures>
      <image-key data-format="questel">US6185596</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Apparatus &amp; method for modular multiplication &amp; exponentiation based on Montgomery multiplication</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>NISHIMOTO TETSUNORI</text>
          <document-id>
            <country>US</country>
            <doc-number>3621218</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US3621218</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>LEININGER JOEL CALVIN, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4110832</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4110832</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>CIRCELLO JOSEPH C, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>4538238</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4538238</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>SUH CHUNG WOOK, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5954788</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5954788</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="5">
          <text>MIYAGUCHI SHOJI</text>
          <document-id>
            <country>US</country>
            <doc-number>4514592</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US4514592</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="6">
          <text>MORITA HIKARU</text>
          <document-id>
            <country>US</country>
            <doc-number>5073870</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5073870</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="7">
          <text>EVEN SHIMON</text>
          <document-id>
            <country>US</country>
            <doc-number>5101431</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5101431</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="8">
          <text>IWAMURA KEIICHI, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5321752</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5321752</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="9">
          <text>PETRO JOHN</text>
          <document-id>
            <country>US</country>
            <doc-number>5349551</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5349551</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="10">
          <text>ARAZI BENJAMIN</text>
          <document-id>
            <country>US</country>
            <doc-number>5448639</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5448639</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <patcit num="11">
          <text>GRESSEL CARMI D, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5513133</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5513133</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="1">
          <text>P.L. Montgomery, "Modular Multiplication Without Trial Division", Mathematics of Computation, vol. 44, pp. 519-521.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="2">
          <text>S.R. Dusse and B.S. Kaliski Jr., "A Cryptographic Library For The Motorola DSP 56000", Proc Eurocrypt '90, Springer-Verlag, Berlin.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Fortress U&amp;T Ltd.</orgname>
            <address>
              <address-1>Beer Sheva, IL</address-1>
              <city>Beer Sheva</city>
              <country>IL</country>
            </address>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>FORTRESS U &amp; T</orgname>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Hadad, Isaac</name>
            <address>
              <address-1>Beer Sheva, IL</address-1>
              <city>Beer Sheva</city>
              <country>IL</country>
            </address>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Arazi, Benjamin</name>
            <address>
              <address-1>Omer, IL</address-1>
              <city>Omer</city>
              <country>IL</country>
            </address>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Gressel, Carmi David</name>
            <address>
              <address-1>Mobile Post Negev, IL</address-1>
              <city>Mobile Post Negev</city>
              <country>IL</country>
            </address>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Dror, Itai</name>
            <address>
              <address-1>Beer Sheva, IL</address-1>
              <city>Beer Sheva</city>
              <country>IL</country>
            </address>
          </addressbook>
          <nationality>
            <country>IL</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Merchant &amp; Gould P.C.</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>Mai, Tan V.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      A modular arithmetic method and microelectronic apparatus therefore, operative to perform a sequence of interleaved Montgomery type multiplications and squaring operations, involves performing a sequence of modular multiplications and squarings using only a single carry save adder.
      <br/>
      Each multiplication is operative to perform the equivalent of three natural integer multiplication operations using an anticipatory device to determine a Y0 value, such that a result is an exponentiation.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>FIELD OF THE INVENTION</heading>
    <p num="1">The present invention relates to apparatus and methods for modular multiplication and exponentiation and for serial integer division.</p>
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="2">A compact microelectronic device for performing modular multiplication and exponentiation over large numbers is described in Applicant's U.S. Pat. No. 5,513,133, the disclosure of which is hereby incorporated by reference.</p>
    <p num="3">The disclosures of all publications mentioned in the specification and of the publications cited therein are hereby incorporated by reference.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="4">The present invention seeks to provide improved apparatus and methods for modular multiplication and exponentiation and for serial integer division.</p>
    <p num="5">There is thus provided, in accordance with a preferred embodiment of the present invention, a modular multiplication and exponentiation system including a serial-parallel arithmetic logic unit (ALU) including a single multiplier including a single carry-save adder and preferably including a serial division device operative to receive a dividend of any bit length and a divisor of any bit length and to compute a quotient and a remainder.</p>
    <p num="6">Further in accordance with a preferred embodiment of the present invention, the system is operative to multiply at least one pair of integer inputs of any bit length.</p>
    <p num="7">Still further in accordance with a preferred embodiment of the present invention, the at least one pair of integer inputs includes two pairs of integer inputs.</p>
    <p num="8">Additionally in accordance with a preferred embodiment of the present invention, the ALU is operative to generate a product of integer inputs and to reduce the size of the product without previously computing a zero-forcing Montgomery constant, J0.</p>
    <p num="9">Also provided, in accordance with another preferred embodiment of the present invention, is serial integer division apparatus including a serial division device operative to receive a dividend of any bit length and a divisor of any bit length and to compute a quotient and a remainder.</p>
    <p num="10">Further in accordance with a preferred embodiment of the present invention, the apparatus includes a pair of registers for storing a pair of integer inputs and which is operative to multiply a pair of integer inputs, at least one of which exceeds the bit length of its respective register, without interleaving.</p>
    <p num="11">Also provided, in accordance with yet another preferred embodiment of the present invention, is a modular multiplication and exponentiation system including a serial-parallel multiplying device having only one carry-save accumulator and being operative to perform a pair of multiplications and to sum results thereof.</p>
    <p num="12">Additionally provided, in accordance with still another preferred embodiment of the present invention, is a modular multiplication and exponentiation method including providing a serial-parallel arithmetic logic unit (ALU) including a single modular multiplying device having a single carry-save adder, and employing the serial-parallel ALU to perform modular multiplication and exponentiation.</p>
    <p num="13">Further provided, in accordance with yet another preferred embodiment of the present invention, is a method for natural (not modular) multiplication of large integers, the method including providing a serial-parallel arithmetic logic unit (ALU) including a single modular multiplying device having a single carry-save adder, and employing the serial-parallel ALU to perform natural (not modular) multiplication of large integers.</p>
    <p num="14">Further in accordance with a preferred embodiment of the present invention, the employing step includes multiplying a first integer of any bit length by a second integer of any bit length to obtain a first product, multiplying a third integer of any bit length by a fourth integer of any bit length to obtain a second product, and summing the first and second products with a fifth integer of any bit length to obtain a sum.</p>
    <p num="15">Still further in accordance with a preferred embodiment of the present invention, the employing step includes performing modular multiplication and exponentiation with a multiplicand, multiplier and modulus of any bit length.</p>
    <p num="16">Additionally in accordance with a preferred embodiment of the present invention, the system also includes a double multiplicand precomputing system for executing Montgomery modular multiplication with only one precomputed constant.</p>
    <p num="17">Further in accordance with yet another preferred embodiment of the present invention, is the employing step includes performing Montgomery multiplication including generating a product of integer inputs including a multiplier and a multiplicand, and executing modular reduction without previously computing a Montgomery constant J0.</p>
    <p num="18">Further in accordance with a preferred embodiment of the present invention, the Montgomery constant J0 includes a function of N mod 2k, where N is a modulus of the modular reduction and k is the bit-length of the multiplicand.</p>
    <p num="19">Still further in accordance with a preferred embodiment of the present invention, the employing step includes performing a sequence of interleaved Montgomery multiplication operations.</p>
    <p num="20">Additionally in accordance with a preferred embodiment of the present invention, each of the interleaved Montgomery multiplication operations is performed without previously computing the number of times the modulus must be summated into a congruence of the multiplication operation in order to force a result with at least k significant zeros.</p>
    <p num="21">Still further in accordance with a preferred embodiment of the present invention, the system also includes a data preprocessor operative to collect and serially summate multiplicands generated in an i'th interleaved Montgomery multiplication operation thereby to generate a sum and to feed in the sum to an (i+1)'th Montgomery multiplication operation.</p>
    <p num="22">Additionally in accordance with a preferred embodiment of the present invention, the function includes an additive inverse of a multiplicative inverse of N mod 2k.</p>
    <p num="23">Further in accordance with a preferred embodiment of the present invention, the method also comprises computing J0 by resetting Ai and B to zero and setting S0 =1.</p>
    <p num="24">
      The present invention also relates to a compact microelectronic arithmetic logic unit, ALU, for performing modular and normal (natural, non-negative field of integers) multiplication, division, addition, subtraction and exponentiation over very large integers.
      <br/>
      When referring to modular multiplication and squaring using Montgomery methods, reference is made to the specific parts of the device as a modular arithmetic coprocessor, and the acronym, MAP, is used.
      <br/>
      Reference is also made to the Montgomery multiplication methods as MM.
    </p>
    <p num="25">
      The present invention also relates to arithmetic processing of large integers.
      <br/>
      These large numbers can be in the natural field of (non-negative) integers or in the Galois field of prime numbers, GF(p), and also of composite prime moduli.
      <br/>
      More specifically, the invention relates to a device that can implement modular multiplications/exponentiations of large numbers, which is suitable for performing the operations essential to Public Key Cryptographic authentication and encryption protocols, which work over increasingly large operands and which cannot be executed efficiently with present generation modular arithmetic coprocessers, and cannot be executed securely with software implementations.
      <br/>
      The invention can be driven by any 4 bit or longer processor, achieving speeds which can surpass present day digital signal processors.
    </p>
    <p num="26">
      The present invention also relates to the hardware implementation of large operand integer arithmetic, especially as concerns the numerical manipulations in a derivative of a procedure known as the interleaved Montgomery multiprecision modular multiplication method often used in encryption software oriented systems, but also of intrinsic value in basic arithmetic operations on long operand integers; in particular, A * B+C * D+S, wherein there is no theoretical limit on the sizes of A, B, C, D, or S. In addition, the device is especially attuned to perform modular multiplication and exponentiation.
      <br/>
      The basic device is particularly suited to be a modular arithmetic co-processor (MAP), also including a device for performing division of very large integers, wherein the divisor can have a bit length as long as the modulus register N and the bit length of the dividend can be as large as the bit length of two concatenated registers.
    </p>
    <p num="27">
      This device preferably performs all of the functions of U.S. Pat. No. 5,513,133, with the same order of logic gates, in less than half the number of machine clock cycles.
      <br/>
      This is mostly because there is only one double action serial/parallel multiplier instead of two half size multipliers using the same carry save accumulator mechanism, the main component of a conventional serial parallel multiplier.
      <br/>
      The new arithmetic logic unit, ALU, or specifically the modular arithmetic coprocessor, MAP, preferably intrinsically obviates a separate multiplication process which would have preceded the new process.
      <br/>
      This process would also have required a second Montgomery constant, J0, which is now also preferably obviated.
      <br/>
      Stated differently, instead of the two constants in the previous Montgomery procedures, and the delays encountered, only one constant is now computed, and the delay caused by the now superfluous J type multiplications (explained later) is preferably removed.
    </p>
    <p num="28">Further, by better control of the data manipulations, between the CPU and this peripheral device, operands which are performed on operand, longer than the natural register size of the device, can preferably be performed at reduced processing times using less temporary storage memory.</p>
    <p num="29">Three related methods are known for performing modular multiplication with Montgomery's methodology. �P. L. Montgomery, "Modular Multiplication without trial division", Mathematics of Computation, vol. 44, pp.519-521, 1985�, hereinafter referred to as "Montgomery", �S. R. Dusse and B. S. Kaliski Jr., "A cryptographic library for the Motorola DSP 56000", Proc Eurocrypt'90, Springer-Verlag, Berlin, 1990� hereinafter referred to as "Dusse" the method of U.S. Pat. No. 4,514,592 to Miyaguchi, and the method of U.S. Pat. No. 5,101,431, to Even, and the method of U.S. Pat. No. 5,321,752 to Iwamura, and the method of U.S. Pat. No. 5,448,639, to Arazi, and the method of U.S. Pat. No. 5,513,133 to Gressel.</p>
    <p num="30">The preferred architecture is of a machine that can be integrated to any microcontroller design, mapped into the host controller's memory; while working in parallel with the controller which for very long commands constantly swap or feed operands to and from the data feeding mechanism, allowing for modular arithmetic computations of any popular length where the size of the coprocessor volatile memory necessary for manipulations should rarely be more than three times the length of the largest operand.</p>
    <p num="31">
      This solution preferably uses only one multiplying device which inherently serves the function of two multiplying devices, in previous implementations.
      <br/>
      Using present popular technologies, it enables the integration of the complete solution including a microcontroller with memories onto a 4 by 4.5 by 0.2 mm microelectronic circuit.
    </p>
    <p num="32">The invention is also directed to the architecture of a digital device which is intended to be a peripheral to a conventional digital processor, with computational, logical and architectural novel features relative to the processes published by Montgomery and Dusse, as described in detail below.</p>
    <p num="33">
      A concurrent process and a unique hardware architecture are provided, to perform modular exponentiation without division preferably with the same number of operations as would be performed with a classic multiplication/division device, wherein a classic device would perform both a multiplication and a division on each operation.
      <br/>
      A particular feature of a preferred embodiment of the present invention is the concurrency of operations performed by the device to allow for unlimited operand lengths, with uninterrupted efficient use of resources, allowing for the basic large operand integer arithmetic functions.
    </p>
    <p num="34">The advantages realized by a preferred embodiment of this invention result from a synchronized sequence of serial processes, which are merged to simultaneously (in parallel) achieve three multiplication operations on n bit operands, using one multiplexed k bit serial/parallel multiplier in (n+k) effective clock cycles, accomplishing the equivalent of three multiplication computations, as prescribed by Montgomery.</p>
    <p num="35">
      By synchronizing and on the fly detecting and on the fly preloading and simultaneous addition of next to be used operands, the machine operates in a deterministic fashion, wherein all multiplications and exponentiations are executed in a predetermined number of clock cycles.
      <br/>
      Conditional branches are replaced with local detection and compensation devices, thereby providing a basis for the simple type control mechanism, which, when refined, typically include a series of self-exciting cascaded counters.
      <br/>
      The basic operations herein described can be executed in deterministic time using the device described in U.S. Pat. No. 5,513,133 as manufactured both by Motorola in East Kilbride, Scotland under the trade name SC-49, and by SGS-Thomson in Rousset, France, under the trade name ST16-CF54.
    </p>
    <p num="36">
      The machine has particularly lean demands on volatile memory for most operations, as operands are loaded into and stored in the device for the total length of the operation; however, the machine preferably exploits the CPU onto which it is appended, to execute simple loads and unloads, and sequencing of commands to the machine, whilst the machine performs its large number computations.
      <br/>
      The exponentiation processing time is virtually independent of the CPU which controls it.
      <br/>
      In practice, no architectural changes are necessary when appending the machine to any CPU.
      <br/>
      The hardware device is self-contained, and can be appended to any CPU bus.
    </p>
    <p num="37">Apparatus for accelerating the modular multiplication and exponentiation process is preferably provided, including means for precomputing the necessary constants.</p>
    <p num="38">
      The preferred embodiments of the invention described herein provide a modular mathematical operator for public key cryptographic applications on portable Smart Cards, typically identical in shape and size to the popular magnetic stripe credit and bank cards.
      <br/>
      Similar Smart Cards (as per U.S. Pat. No. 5,513,133) are being used in the new generation of public key cryptographic devices for controlling access to computers, databases, and critical installations; to regulate and secure data flow in commercial, military and domestic transactions; to decrypt scrambled pay television programs, etc.
      <br/>
      It should be appreciated that these devices are also incorporated in computer and fax terminals, door locks, vending machines, etc.
    </p>
    <p num="39">
      The hardware described carries out modular multiplication and exponentiation by applying the +character pullout}operator in a novel way.
      <br/>
      Further, the squaring can be carried out in the same method, by applying it to a multiplicand and a multiplier that are equal.
      <br/>
      Modular exponentiation involves a succession of modular multiplications and squarings, and therefore is carried out by a method which comprises the repeated, suitably combined and oriented application of the aforesaid multiplication, squaring and exponentiation methods.
    </p>
    <p num="40">When describing the workings of a preferred embodiment of the ALU we describe synchronization in effective clock cycles, referring to those cycles when the unit is performing an arithmetic operation, as opposed to real clock cycles, which would include idle cycles whence the ALU may stand, and multiplexers, flipflops, and other device settings may be altered, in preparation for a new phase of operations.</p>
    <p num="41">In a preferred embodiment, a method for executing a Montgomery modular multiplication, (with reference to squaring and normal multiplication) wherein the multiplicand A (which may be stored either in the CPU's volatile RAM or in the SA register, 130, the multiplier B in the B register 1000, which is concatenation of 70 and 80 and the modulus N in the N register, 1005, which is a concatenation of 200 and 210; comprise m characters of k bits each, the multiplicand and the multiplier generally not being greater than the modulus, comprises the steps of:</p>
    <p num="42">1)--loading the multiplier B and the modulus, N, into respective registers of n bit length, wherein n=m * k;</p>
    <p num="43">
      - +multiplying in normal field positive, natural, integers, N is a second multiplier}
      <br/>
      - +if n is longer than the B, N and S registers, values are typically loaded and unloaded in and out of these registers during the course of an iteration, allowing the machine to be virtually capable of manipulating any length of modulus}
      <br/>
      2)--setting the output of the register SB to zero, S*d Flush (250)=1 for the first iteration;
      <br/>
      3)--resetting extraneous borrow and carry flags (controls, not specified in the patent);
      <br/>
      4)--executing m iterations, each iteration comprising the following operations:
      <br/>
      (0 &lt;= i &lt;= m-1)
      <br/>
      - a) transferring the next character Ai-1 of the multiplicand A from volatile storage to the Ai Load Buffer, 290.
      <br/>
      - b) simultaneously serially loading the Ci Load Buffer, 320, with N0 (the LS k bits of N), while rotating the contents of the Ai Load Buffer, thereby serially adding the contents of the Ai load buffer with N0 by means of the serial adder FA1, 330, thereby serially loading the Ai+Ci Load Buffer with th(sum N0 +Ai-1,
    </p>
    <p num="44">
      -  The preloading phase ends here.
      <br/>
      This phase is typically executed whilst the MAP was performing a previous multiplication iteration.
      <br/>
      Processes a) and b) can be executed simultaneously, wherein the Ai-1 character is loaded into its respective register, whilst the Ai stream is synchronized with the rotation of the N0 register, loading R2, 320.
      <br/>
      Simultaneously, the Ai stream and the N0 stream are summated and loaded into the R3 register, 340.
      <br/>
      -  Squaring a quantity from the B register, can be executed wherein at the initialization, Steps a) and b) the first k bits of Bd are inserted into R1, as the B0 register is rotated, simultaneously with the N0 register.
      <br/>
      Subsequent k bit Bi strings are preloaded into the R1 register, as they are fed serially into the ALU.
      <br/>
      - c) the machine is stopped.
      <br/>
      Operands in buffers R1, R2, and R3 are latched into latches L1, 360; L2, 370; and L3, 380.
      <br/>
      -  The L0--"0" latch, is a pseudo latch, as this is simply a literal command signal entering each of the AND gates in the inputs or outputs of the 390, multiplexer.
      <br/>
      - for the next k effective clock cycles
      <br/>
      -  i) at each effective clock cycle the Y0 SENSE anticipates the next bit of Y0 and loads this bit through M3 multiplexer, 300, into the Ci Load Buffer, while shifting out the Ai bits from the R1 register and simultaneously loading the Ci Load Buffer with k bits of Y0 and adding the output of R1 with Y0 and loading this value into the R3 Buffer,
      <br/>
      -  ii) simultaneously multiplying N0 (in L2, Ci Latch) by the incoming Y0 bit, and multiplying Ai by the next incoming bit of Bd, by means of logically choosing through the M_K multiplexer, 390, the desired value from one of the four latches, L0, L1, L2, or L3; thereby adding the two results.
      <br/>
      If neither the Y0 bit nor the B bit is one, an all zero value is multiplexed into the CSA, if only the N0 bit is one, N0 alone is multiplexed/added into the CSA, if only the B bit is a one, Ai-1 is added into the CSA, if both the B bit and the N0 bit are ones, then Ai-1 +N0 are added into the CSA,
      <br/>
      -  iii) then adding to this summation; as it serially exits the Carry Save k+1 Bit Accumulator bit by bit, (the X stream); the next relevant bit of Sd in through the serial adder, FA2, 460.
    </p>
    <p num="45">
      In MM these first k bits of the Z stream are zero.
      <br/>
      In this first phase the result of Y0 * N0 +Ai-1 * B0 +S0 has been computed, the LS k all zero bits appeared on the Z*out stream, and the MS k+1 bits of the multiplying device are saved in the CSA Carry Save Accumulator; the R1, R2 and R3 preload buffers hold the values Ai-1, Y0 and Y0 +Ai-1, respectively.
      <br/>
      - e) at the last effective, (m+1) * k'th, clock cycle he machine is stopped, buffers R2, and R3 are latched into L2, and L3
    </p>
    <p num="46">The value of L1 is unchanged.</p>
    <p num="47">
      The initial and continuing conditions for the next k * (m-1) effective clock cycles are:
      <br/>
      the multipliers are the bit streams from B, starting from the k'th bit of B and the remaining bit stream from N, also starting from the k'th bit of N;
      <br/>
      and the multiplicands in L1, L2, and L3 are Ai-1, Y0, and Y0 +Ai-1, at the start the CS adder contains the value as described in d), and the S stream will feed in the next k * (m-1) bits into the FA2 full adder;
      <br/>
      during the next k * m effective clock cycles, Nd, delayed k clock cycles in unit 470, is subtracted in serial subtractor, 480, from the Z stream, to sense if (Z/2k mod 2k*m), the result which is to go into the B or S register, is larger than or equal to N. Regardless of what is sensed by the serial subtractor, 460, if at the +(m+1) * k}'th effective clock cycle, the SO1 flip-flop of the CSA is a one, then the total result is certainly larger than N, and N will be subtracted from the result, as the result, partial or final, exits its register.
      <br/>
      - f) for the next k * (m-1) effective clock cycles:
      <br/>
      -  the N0 Register, 210, is rotated either synchronously with incoming Ai bits, or at another suitable timing, loading R1, R2, and R3, as described in a) and b), for the next iteration,
      <br/>
      -  for these k * (m-1) effective clock cycles, the remaining MS bits of N now multiply Y0, the remaining MS B bits continue multiplying Ai-1.
      <br/>
      If neither the N bit nor the B bit is one, an all zero value is multiplexed into the CSA.
      <br/>
      If only the N bit is one, Y0 alone is multiplexed/added into the CSA.
      <br/>
      If only the B bit is a one, Ai-1 is added into the CSA.
      <br/>
      If both the B bit and the Y0 bit are ones, then Ai-1 +Y0 are added into the CSA.
    </p>
    <p num="48">
      Simultaneously the serial output from the CSA is added to the next k * (m-1) S bits through the FA2 adder, unit 460, which outputs the Z stream,
      <br/>
      the relevant part of the Z output stream is the first non-zero k * (m-1) bits of Z.
    </p>
    <p num="49">
      The Z stream is switched into the SB register, for the first m-1 iterations and into the SB or B register, as defined for the last iteration;
      <br/>
      on the last iteration, the Z stream, which, disregarding the LS k zero bits, is the final B* stream.
      <br/>
      This stream is directed to the B register, to be reduced by N, if necessary, as it is used in subsequent multiplications and squares;
      <br/>
      on the last iteration, Nd, delayed k clock cycles, is subtracted by a serial subtractor from the Z stream, to sense if the result, which goes into B, is larger than or equal to N.
    </p>
    <p num="50">
      At the end of this stage, all the bits from the N, B, and SB registers have been fed into the ALU, and the final k+1 bits of result are in the CSA, ready to be flushed out.
      <br/>
      - g) the device is stopped.
      <br/>
      The S flush, 250; the B flush, 240; and the N flush, 260; are set to output zero strings, to assure that in the next phase the last k+1 most significant bits will be flushed out of the CSA. (In a regular multiplication, the M7 MUX, 450, is set to accept the Last Carry from the previous iteration of S.) S has m * k+1 significant bits, but the S register has only mk cells to receive this data.
      <br/>
      This last bit is intrinsically saved in the overflow mechanism.
    </p>
    <p num="51">
      As was explained in e, Nd, delayed k clock cycles in 470, is subtracted from the Z stream, synchronized with the significant outputs from X, to provide a fine-tune to the sense mechanism to determine if the result which goes into the B or S register is larger than or equal to N. 480 and 490 comprise a serial comparator device, where only the last borrow command bit for modular calculations, and the (k * m+1)'th bit for regular multiplications in the natural field of integers are saved.
      <br/>
      this overflow/borrow command is detected at the m * k'th effective clock cycle.
      <br/>
      - h) The device is clocked another k cycles, completely flushing out the CSA, while another k bits are exiting Z to the defined output register.
    </p>
    <p num="52">
      The instruction to the relevant flip flop commanding serial subtractor 90 or 500 to execute a subtract of N on the following exit streams is set at the last effective, (m+1) * k'th, clock cycle, of the iteration if (Z/2k -N) &gt;= N (Z includes the m * k'th MS bit), sensed by, the following signals:
      <br/>
      the SO1 bit, which is the data out bit from second least significant cell of the CSA, is a one,
      <br/>
      or if the COZ bit, which is the internal carry out in the X+S adder, 460, is a one.
      <br/>
      or if the borrow bit from the 480 sense subtractor is not set.
    </p>
    <p num="53">This mechanism appears in U.S. Pat. No. 5,513,133 as manufactured both by Motorola and SGS-Thomson.</p>
    <p num="54">
      For multiplication in the field of natural numbers, it is preferable to detect an overflow, if the m-k'th MS bit is a one, can happen in the superscalar multiplier, and cannot happen in the mechanism of U.S. Pat. No. 5,513,133. This overflow can then be used in the next iteration to insert a MS one in the S (temporary result) stream.
      <br/>
      - j) is this the last iteration
      <br/>
      -  NO, return to c)
      <br/>
      -  YES continue to m)
      <br/>
      - k) the correct value of the result can now exit from either the B or S register.
    </p>
    <p num="55">
      Y0 bits are anticipated in the following manner in the Y0S-Y0SENSE unit, 430, from five deterministic quantities:
      <br/>
      i the LS bit of the Ai-L1 Latch AND the next bit of the Bd Stream; A0 * Bd ;
      <br/>
      ii the LS Carry Out bit from the Carry Save Accumulator; CO0 ;
      <br/>
      iii the Sout bit from the second LS cell of the CSA; SO1 ;
      <br/>
      iv the next bit from the S stream, Sd,
      <br/>
      v the Carry Out bit from the 460, Full Adder; COZ ;
    </p>
    <p num="56">
      These five values are XORed together to produce the next Y0 bit; Y0i :
      <br/>
      Y0i =A0 * Bd.sym.CO0.sym.SO1.sym.Sd.sym.CO. sub.Z
    </p>
    <p num="57">If the Y0i bit is a one, then another N of the same rank (multiplied by the necessary power of 2), is typically added, otherwise, N, the modulus, is typically not added.</p>
    <p num="58">Multiplication of long natural integers in the normal field of numbers.</p>
    <p num="59">
      This apparatus is suited to efficiently perform multiplications and summations of normal integers.
      <br/>
      If these operands are all of no longer than k bit length, the process preferably is executed without interleave, where the Z stream of 2k+1 bits are directed to final storage.
      <br/>
      For integers longer than k bits, the process is similar to the predescribed interleaved modular arithmetic process, excepting that the result will now potentially be one bit longer than twice the length of the longest operand.
      <br/>
      Further the apparatus of the invention is capable, using the resources available in the described device, to simultaneously perform two separate multiplications, A, multiplicand, preferably loaded in segments in the R1--Ai register, times B, the multiplier, of A, preferably loaded into the B register as previously designated, plus N, a second multiplier, preferably loaded into the N register, times an operand, C, loaded into the R2 Register, plus S, a bit stream entering the apparatus, on the first iteration, only from the Sd, signal line, preferably from the SA register.
      <br/>
      The Y0 SENSE apparatus is not used.
      <br/>
      The multiplicands are summated into the R3 register prior to the initiation of an iteration.
      <br/>
      At initiation of the iteration, registers R1, R2, and R3 are copied into latches L1, L2, and L3 until the end of an iteration.
      <br/>
      Meanwhile, during the mk+k+1 effective clock cycles of an iteration, the next segments of A and C are again preloaded and summated in preparation for the next iteration.
    </p>
    <p num="60">
      At each iteration, the first LS k bits of the result on the Z stream, which are, now, (not by definition zero, as in MM) directed to a separate storage, vacated to accumulate the LS portion of the result, again suitably the SA register.
      <br/>
      The most significant mk+1 bits comprise the SB, temporary quantity, for the next iteration.
      <br/>
      In the last phase, similar to g, i, and j, the CSA is flushed out of accumulated value.
      <br/>
      The LS portion, for numbers which are longer than the multiplier registers, can be exited through the normal data out register and unloader, units 60 and 30, respectively.
    </p>
    <p num="61">The MS, 2m'th bit of the result is read from the LAST CARRY bit of the FA2, unit 460, through the OVERFL0W signal line.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="62">
      The present invention will be understood and appreciated from the following detailed description, taken in conjunction with the drawings in which:
      <br/>
      FIGS. 1A-1B, taken together, form a simplified block diagram of a serial-parallel super scalar arithmetic logic unit (ALU) constructed and operative in accordance with one embodiment of the present invention;
      <br/>
      FIG. 2 is a simplified block diagram of a preferred implementation of the serial integer division apparatus of FIG. 1A which is also useful separately for serial integer division applications, particularly for very large numbers;
      <br/>
      FIG. 3 is a simplified block diagram of a public key crypto-computer for smart cards or terminus which includes the serial-parallel arithmetic logic unit of FIGS. 1A-1B;
      <br/>
      FIG 4 is a table showing stages of operation of a division of a dividend by a divisor using the division apparatus of FIG. 2, for an example wherein the effective bit-length of the divisor is half of the effective bit-length of the dividend; and
      <br/>
      FIG. 5 is a table showing stages of operation of a division of a dividend by a divisor using the division apparatus of FIG. 2, for an example wherein the effective bit-length of the divisor is less than half of the effective bit-length of the dividend.
    </p>
    <heading>DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
    <p num="63">
      FIGS. 1A-1B, taken together, form a simplified block diagram of a serial-parallel arithmetic logic unit (ALU) constructed and operative in accordance with a preferred embodiment of the present invention.
      <br/>
      The apparatus of FIGS. 1A-1B, preferably include the following components:
    </p>
    <p num="64">
      Single Multiplexers--Controlled Switching Elements which select one signal or bit stream from a multiplicity of inputs of signals and direct it this chosen signal to a single output.
      <br/>
      Multiplexers are marked M1 to M13, and are intrinsic parts of larger elements.
    </p>
    <p num="65">M_K Multiplexer, 390, is an array of k+1 single multiplexers, and chooses which of the four k or k+1 inputs are to be added into the CSA, 410.</p>
    <p num="66">
      The B (1000), SA (130), SB (180), and N (1005) are the four main serial main registers in a preferred embodiment.
      <br/>
      The SA is conceptually and practically redundant, but can considerably accelerate very long number computations, and save volatile memory resources, especially in the case where the length of the modulus is 2 * k * m bits long, and also simplify long division computations.
    </p>
    <p num="67">
      Serial Adders and Serial Subtractors are logic elements that have two serial inputs and one serial output, and summate or perform subtraction on two long strings of bits.
      <br/>
      Components 90 and 480 are subtractors, 330, and 460 are serial adders.
      <br/>
      The propagation time from input to output is very small.
      <br/>
      Serial subtractor 90 reduces B* to B if B* is larger than or equal to N. Serial Subtractor 480, is used, as part of a comparator component to detect if B* will be larger than or equal to N. Full Adder 330, adds the two bit streams which feed the Load Buffer; 340, with a value that is equal to the sum of the values in the 290 and 320 Load Buffers.
    </p>
    <p num="68">
      Fast Loaders and Unloaders, 10 and 20, and 30 and 40, respectively, are devices to accelerate the data flow from the CPU controller.
      <br/>
      This can comprise of DMA or other hardware accelerators, in a preferred embodiment. 20 and 40 are for reversing the data word, as is necessary for reconciling the division input and output of FIG. 2.
    </p>
    <p num="69">Data In, 50, is a parallel in serial out device, as the present ALU device is a serial fed systolic processor, and data is fed in, in parallel, and processed in serial.</p>
    <p num="70">
      Data Out, 60, is a serial in parallel out device, for outputting results from the coprocessor.
      <br/>
      The quotient generator is that part of FIG. 2 which generates a quotient bit at each iteration of the dividing mechanism.
    </p>
    <p num="71">Flush Signals on Bd, 240; on S*d, 250; and on Nd, 260, are made to assure that the last k+1 bits can flush out the CSA, as the alternative would be a complicated k+1 bit parallel output element to retrieve the MS k+1 bits of the accumulator.</p>
    <p num="72">Load Buffers R1, 290; R2, 320; and R3, 340 are serial in parallel out shift registers adapted to receive the three possible more than zero multiplicand combinations.</p>
    <p num="73">Latches L1, 360; L2, 370; and L3, 380; are made to receive the outputs from the load buffers, thereby allowing the load buffers, the temporal enablement to process the next phase of data before this data is preferably latched into L2, L2, and L3.</p>
    <p num="74">Y0 Sense, 430, is the logic device which determines the number of times the modulus is accumulated, in order that a k bit string of LS zeros will exit at Z in Montgomery Multiplications and squares.</p>
    <p num="75">One bit delay devices 100, 220 and 230 are inserted in the respective data streams to accommodate for synchronization problems between the data preparation devices in FIG. 1A, and the data processing devices in FIG. 1B.</p>
    <p num="76">The k bit delay, shift register, 470, assures that if Z/2k is larger than or equal to N, the comparison of Z/2k and N will be made with synchronization.</p>
    <p num="77">The Carry Save Accumulator is almost identical to a serial/parallel multiplier, excepting for the fact that three different larger than zero values can be summated, instead of the single value as usually is latched onto the input of the s/p multiplier.</p>
    <p num="78">The Insert Last Carry, 440, is used to insert the mk+1'th bit of the S stream, as the S register is only mk bits long.</p>
    <p num="79">The borrow/overflow detect, 490, can either detect if a result is larger than or equal to the modulus (from N), or if the mk'th bit is a one.</p>
    <p num="80">The control mechanism is not depicted, but is preferably understood to be a set of cascaded counting devices, with switches set for systolic data flow.</p>
    <p num="81">
      For modular multiplication in the prime and composite prime field of numbers, we define A and B to be the multiplicand and the multiplier, and N to be the modulus which is usually larger than A or B. N also denotes the register where the value of the modulus is stored. N, may, in some instances, be smaller than A. We define A, B, and N as m k=n bit long operands.
      <br/>
      Each k bit group will be called a character, the size of the group defined by the size of the multiplying device.
      <br/>
      Then A, B, and N are each m characters long.
      <br/>
      For ease in following the step by step procedural explanations, assume that A, B, and N are 512 bits long, (n=512); assume that k is 64 bits long because of the present cost effective length of such a multiplier, and data manipulation speeds of simple CPUs; and m=8 is the number of characters in an operand and also the number of iterations in a squaring or multiplying loop with a 512 bit operand.
      <br/>
      All operands are positive integers.
      <br/>
      More generally, A, B, N, n, k and m may assume any suitable values.
    </p>
    <p num="82">In non-modular functions, the N and S registers can be used for temporary storage of other arithmetic operands.</p>
    <p num="83">
      We use the symbol, .tbd., to denote congruence of modular numbers, for example 16.tbd.2 mod 7, and we say 16 is congruent to 2 modulo 7 as 2 is the remainder when 16 is divided by 7.
      <br/>
      When we write Y mod N.tbd.X mod N; both Y and X may be larger than N; however, for positive X and Y, the remainders will be identical.
      <br/>
      Note also that the congruence of a negative integer Y, is Y+u N, where N is the modulus, and if the congruence of Y is to be less than N, u will be the smallest integer which will give a positive result.
    </p>
    <p num="84">
      We use the symbol, .Yen., to denote congruence in a more limited sense.
      <br/>
      During the processes described herein, a value is often either the desired value, or equal to the desired value plus the modulus.
      <br/>
      For example X.Yen.2 mod 7.
      <br/>
      X can be equal to 2 or 9.
      <br/>
      We say X has limited congruence to 2 mod 7.
    </p>
    <p num="85">When we write X=A mod N, we define X as the remainder of A divided by N; e.g., 3=45 mod 7.</p>
    <p num="86">
      In number theory the modular multiplicative inverse is a basic concept.
      <br/>
      For example, the modular multiplicative inverse of X is written as X-1, which is defined by X X-1 mod N=1.
      <br/>
      If X=3, and N=13, then X-1 =9, i.e., the remainder of 3 * 9 divided by 13 is 1.
    </p>
    <p num="87">The acronyms MS and LS are used to signify most significant and least significant when referencing bits, characters, and full operand values, as is conventional in digital nomenclature.</p>
    <p num="88">
      Throughout this specification N designates both the value N, and the name of the shift register which contains N. An asterisk superscript on a value, denotes that the value, as stands, is potentially incomplete or subject to change.
      <br/>
      A is the value of the number which is to be exponentiated, and n is the bit length of the N operand.
      <br/>
      After initialization when A is "Montgomery normalized" to A* (A*=2n A--to be explained later) A* and N are constant values throughout the intermediate step in the exponentiation.
      <br/>
      During the first iteration, after initialization of an exponentiation, B is equal to A*. B is also the name of the register wherein the accumulated value which finally equals the desired result of exponentiation resides. S* designates a temporary value, and S, SA and SB designate, also, the register or registers in which all but the single MS bit of S is stored. (S* concatenated with this MS bit is identical to S.) S(i-1) denotes the value of S at the outset of the i'th iteration; S0 denotes the LS character of an S(i)'th value.
    </p>
    <p num="89">We refer to the process, (defined later) +character pullout}(A * B)N as multiplication in the P field, or sometimes, simply, a multiplication operation.</p>
    <p num="90">
      As we have used the standard structure of a serial/parallel multiplier as the basis for constructing a double acting serial parallel multiplier, we differentiate between the summating part of the multiplier, which is based on carry save accumulation, (as opposed to a carry look ahead adder, or a ripple adder, the first of which is considerably more complicated and the second very slow), and call it a carry save adder or accumulator, and deal separately with the preloading mechanism and the multiplexer and latches, which allow us to simultaneously multiply A times B and C times D, summate both results, e.g., A * B+C * D, converting this accumulator into a very powerful engine.
      <br/>
      Additional logic is added to this multiplier in order to provide for an anticipated sense operation necessary for modular reduction and serial summation necessary to provide powerful modular arithmetic and ordinary integer arithmetic on very large numbers.
    </p>
    <p num="91">Montgomery Modular Multiplication</p>
    <p num="92">
      In a classic approach for computing a modular multiplication, A * B mod N, the remainder of the product A * B is computed by a division process.
      <br/>
      Implementing a conventional division of large operands is more difficult to perform than serial/parallel multiplications.
    </p>
    <p num="93">
      Using Montgomery's modular reduction method, division is essentially replaced by multiplications using two precomputed constants.
      <br/>
      In the procedure demonstrated herein, there is only one precomputed constant, which is a function of the modulus.
      <br/>
      This constant is, or can be, computed using this ALU device.
    </p>
    <p num="94">A simplified presentation of the Montgomery process, as is used in this device is now provided, followed by a complete preferred description.</p>
    <p num="95">
      If we have an odd number (an LS bit one), e.g., 1010001 (=8110) we can always transform this odd number to an even number (a single LS bit of zero) by adding to it another fixing, compensating odd number, e.g., 1111 (=1510); as 1111+1010001=1100000 (9610).
      <br/>
      In this particular case, we have found a number that produced five LS zeros, because we knew in advance the whole string, 81, and could easily determine a binary number which we could add to 81, and would produce a new binary number that would have as many LS zeros as we might need.
      <br/>
      This fixing number is be odd, else it has no effect on the progressive LS bits of a result.
    </p>
    <p num="96">
      If our process is a clocked serial/parallel carry save process, where it is desired to have a continuous number of LS zeros, and wherein at each clock cycle we only have to fix the next bit, at each clock it is sufficient to add the fix, if the next bit would potentially be a one or not to add the fix if the potential bit were to be a zero.
      <br/>
      However, in order not to cause interbit overflows (double carries), this fix is preferably summated previously with the multiplicand, to be added into the accumulator when the relevant multiplier bit is one, and the Y Sense also detects a one.
    </p>
    <p num="97">
      Now, as in modular arithmetic, we only are interested in the remainder of a value divided by the modulus, we know that we can add the modulus any number of times to a value, and still have a value that would have the same remainder.
      <br/>
      This means that we can add YN= SIGMA yi 2i N to any integer, and still have the same remainder; Y being the number of times we add in the modulus, N, to produce the required LS zeros.
      <br/>
      As described, the modulus that we add can only be odd.
      <br/>
      Methods exist wherein even moduli are defined as 2i times the odd number that results when i is the number of LS zeros in the even number.
    </p>
    <p num="98">
      The problem solved by the Montgomery interleaved variations, is aimed at reducing the limited storage place we have for numbers, and the cost effective size of the multipliers.
      <br/>
      This is especially useful when performing public key cryptographic functions where we are constantly multiplying one large integer, e.g., n=1024 bit, by another large integer; a process that would ordinarily produce a double length 2048 bit integer.
    </p>
    <p num="99">We can add in Ns (the modulus) enough times to A * B=X or A * B+S=X during the process of multiplications (or squaring) so that we will have a number, Z, that has n LS zeros, and, at most, n+1 MS bits.</p>
    <p num="100">We can continue using such numbers, disregarding the LS n bits, if we remember that by disregarding these zeros, we have divided the desired result by 2n.</p>
    <p num="101">
      When the LS n bits are disregarded, and we only use the most significant n (or n+1) bits, then we have effectively multiplied the result by 2-n, the modular inverse of 2n.
      <br/>
      If we would subsequently re-multiply this result by 2n mod N (or 2n) we would obtain a value congruent to the desired result (having the same remainder) as A * B+S mod N. As is seen, using MM, the result is preferably multiplied by 22n to overcome the 2-n parasitic factor reintroduced by the MM.
    </p>
    <heading>EXAMPLE</heading>
    <p num="102">A * B+S mod N=(12 * 11+10) mod 13=(1100 * 1011+1010)2 mod 10112.</p>
    <p num="103">We will add in 2i N whenever a fix is necessary on one of the n LS bits.</p>
    <p num="104">
      --
      <br/>
      --           B         1011
      <br/>
      -- x         A         1100
      <br/>
      -- add       S         1010
      <br/>
      -- add       A(0)  * B 0000
      <br/>
      --           ----                sum of LS bit = 0 not add N
      <br/>
      -- add       20 (N * 0) 0000
      <br/>
      -- sum                 0101       --&gt; 0 LS bit leaves carry save adder
      <br/>
      -- add       A(1)  * B 0000
      <br/>
      --           ----                sum of LS bit = 0 - add N
      <br/>
      -- add       21 (N * 1) 1101
      <br/>
      -- sum                 1001       --&gt; 0 LS bit leaves CS adder
      <br/>
      -- add       A(2)  * B 1011
      <br/>
      --           ----                sum LS bit = 0 don't add N
      <br/>
      -- add       22 (N * 0) 0000
      <br/>
      -- sum                 1010       --&gt; 0 LS bit leaves CS adder
      <br/>
      -- add       A(3)  * B 1011
      <br/>
      --           ----                sum LS bit = 1 add N
      <br/>
      -- add       23(N * 1)  1101
      <br/>
      -- sum                 10001      --&gt; 0 LS bit leaves CS adder
    </p>
    <p num="105">And the result is 10001 00002 mod 13=17 * 24 mod 13.</p>
    <p num="106">
      As 17 is larger than 13 we subtract 13, and the result is:
      <br/>
      17 * 24.tbd.4 * 24 mod 13.
    </p>
    <p num="107">formally 2-n (AB+S)mod N=9 (12 * 11+10) mod 13.tbd.4.</p>
    <p num="108">In Montgomery arithmetic we utilize only the MS non-zero result (4) and effectively remember that the real result has been divided by 2n ; n zeros having been forced onto the MM result.</p>
    <p num="109">We have added in (8+2) * 13=10 * 13 which effectively multiplied the result by 24 mod 13.tbd.3. In effect, had we used the superfluous zeros, we can say that we have performed, AB * B+Y * N+S-(12 * 11+10 * 13+10) in one process, which will be described possible on a preferred embodiment.</p>
    <p num="110">Check-(12 * 11+10) mod 13=12; 4 * 3=12.</p>
    <p num="111">In summary, the result of a Montgomery Multiplication is the desired result multiplied by 2-n.</p>
    <p num="112">To retrieve the previous result back into a desired result using the same multiplication method, we would have to Montgomery Multiply the previous result by 22n, which we will call H, as each MM leaves us with a parasitic factor of 2-n.</p>
    <p num="113">
      The Montgomery Multiply function +character pullout}(A * B)N performs a multiplication modulo N of the A * B product into the P field. (In the above example, where we derived 4).
      <br/>
      The retrieval from the P field back into the normal modular field is performed by enacting P on the result of +character pullout}(A * B)N using the precomputed constant H. Now, if P.tbd.+character pullout}(A * B)N, it follows that +character pullout}(P * H)N.tbd.A * B mod N; thereby performing a normal modular multiplication in two P field multiplications.
    </p>
    <p num="114">
      Montgomery modular reduction averts a series of multiplication and division operations on operands that are n and 2n bits long, by performing a series of multiplications, additions, and subtractions on operands that are n or n+1 bits long.
      <br/>
      The entire process yields a result which is smaller than or equal to N. For given A, B and odd N there is always a Q, such that A * B+Q * N will result in a number whose n LS bits are zero, or:
      <br/>
      P * 2n =A * B+Q * N
    </p>
    <p num="115">This means that we have an expression 2n bits long, whose n LS bits are zero.</p>
    <p num="116">
      Now, let I * 2n =1 mod N (I exists for all odd N).
      <br/>
      Multiplying both sides of the previous equation by I yields the following congruences:
    </p>
    <p num="117">
      from the left side of the equation:
      <br/>
      P * I * 2n.tbd.P mod N; (Remember that I * 2n +- 1 mod N)
    </p>
    <p num="118">
      and from the right side:
      <br/>
      A * B * I+Q * N * I.tbd.AB * I mod N; (Remember that Q * N * I.tbd.0 mod N)
    </p>
    <p num="119">
      therefore:
      <br/>
      P.tbd.A * B * I mod N.
    </p>
    <p num="120">This also means that a parasitic factor I=2-n mod N is introduced each time a P field multiplication is performed.</p>
    <p num="121">
      We define the P operator such that:
      <br/>
      P.tbd.A * B * I mod N.tbd.+character pullout}(A * B)N.
    </p>
    <p num="122">
      and we call this "multiplication of A times B in the P field", or Montgomery Multiplication.
      <br/>
      The retrieval from the P field can be computed by operating +character pullout}on P-H, making:
      <br/>
      +character pullout}(P * H)N.tbd.A * B mod N;
    </p>
    <p num="123">
      We can derive the value of H by substituting P in the previous congruence.
      <br/>
      We find:
      <br/>
      +character pullout}(P * H)N.tbd.(A * B * I)(H)(I) mod N;
      <br/>
      (see that A * B * I &lt;-- P; H &lt;-- H; I &lt;--  and any multiplication operation introduces a parasitic I)
      <br/>
      If H is congruent to the multiple inverse of I2 then the congruence is valid, therefore:
      <br/>
      H=I-2 mod N.tbd.22n mod N (H is a function of N and we call it the H parameter)
    </p>
    <p num="124">
      In conventional Montgomery methods, to enact the P operator on A * B, the following process may be employed, using the precomputed constant J:
      <br/>
      1) X=A * B
      <br/>
      2) Y=(X * J) mod 2n (only the n LS bits are necessary)
      <br/>
      3) Z=X+Y * N
      <br/>
      4) S=Z/2n (The requirement on J is that it forces Z to be divisible by 2n)
      <br/>
      5) P.Yen.S mod N (N is to be subtracted from S, if S &gt;= N) Finally, at step 5):
      <br/>
      P.Yen.+character pullout}(A * B)N,
    </p>
    <p num="125">�After the subtraction of N, if necessary: P=+character pullout}(A * B)N.�</p>
    <p num="126">
      Following the above:
      <br/>
      Y=A * B * J mod 2n (using only the n LS bits);
    </p>
    <p num="127">
      and:
      <br/>
      Z=A * B+(A * B * J mod 2n) * N.
    </p>
    <p num="128">
      In order that Z be divisible by 2n (the n LS bits of Z are preferably zero) and the following congruence will exist:
      <br/>
      �A * B+(A * B * J mod 2n) * N� mod 2n.tbd.0
    </p>
    <p num="129">
      In order that this congruence will exist, N * J mod 2n are congruent to -1 or:
      <br/>
      J.tbd.-N1 mod 2n.
    </p>
    <p num="130">and we have found the constant J.</p>
    <p num="131">
      J, therefore, is a precomputed constant which, is a function of N only.
      <br/>
      However, in a machine that outputs a MM result, bit by bit, provision should be made to add in Ns at each instance where the output bit in the LS string would otherwise have been a zero, thereby obviating the necessity of precomputing J and subsequently computing Y=A * B * J mod 2n, as Y can be detected bit by bit using hardwired logic.
      <br/>
      We have also described that this methodic can only work for odd Ns.
    </p>
    <p num="132">Therefore, as is apparent, the process described employs three multiplications, one summation, and a maximum of one subtraction, for the given A, B, N, and a precomputed constant to obtain +character pullout}(A * B)N. Using this result, the same process and a precomputed constant, H, (a function of the module N) we are able to find A B mod N. As A can also be equal to B, this basic operator can be used as a device to square or multiply in the modular arithmetic.</p>
    <p num="133">Interleaved Montgomery Modular Multiplication</p>
    <p num="134">The previous section describes a method for modular multiplication which involved multiplications of operands which were all n bits long, and results which required 2n +1 bits of storage space.</p>
    <p num="135">Using Montgomery's interleaved reduction (as described in the aforementioned paper by Dusse), it is possible to perform the multiplication operations with shorter operands, registers, and hardware multipliers; enabling the implementation of an electronic device with relatively few logic gates.</p>
    <p num="136">
      First we will describe how the device can work, if at each iteration of the interleave, we compute the number of times that N is added, using the J0 constant.
      <br/>
      Later, we describe how to interleave, using a hardwire derivation of Y0, which will eliminate the J0+ phase of each multiplication +2) in the following example}, and enable us to integrate the functions of two separate serial/multipliers into the new single generic multiplier which can perform A * B+C * N+S at better than double speed using similar silicon resources.
    </p>
    <p num="137">Using a k bit multiplier, it is convenient to define characters of k bit length; there are m characters in n bits; i.e., m * k=n.</p>
    <p num="138">J0 will be the LS character of J.</p>
    <p num="139">
      Therefore:
      <br/>
      J0.tbd.-N0-1 mod 2k (J0 exists as N is odd).
    </p>
    <p num="140">
      Note, the J and J0 constants are compensating numbers that when enacted on the potential output, tell us how many times to add the modulus, in order to have a predefined number of least significant zeros.
      <br/>
      We will later describe an additional advantage to the present serial device; since, as the next serial bit of output can be easily determined, we can always add the modulus (always odd) to the next intermediate result.
      <br/>
      This is the case if, without this addition, the output bit, the LS serial bit exiting the CSA, would have been a "1"; thereby adding in the modulus to the previous even intermediate result, and thereby promising another LS zero in the output string.
      <br/>
      Remember, congruency is maintained, as no matter how many times the modulus is added to the result, the remainder is constant.
    </p>
    <p num="141">In the conventional use of Montgomery's interleaved reduction, +character pullout}(A * B)N is enacted in m iterations as described in steps (1) to (5):</p>
    <p num="142">
      Initially S(0)=0 (the .Yen. value of S at the outset of the first iteration).
      <br/>
      For i=1, 2 . . . m:
      <br/>
      1) X=S(i-1)+Ai-1 * B (Ai-1 is the i-1 th character of A; S(i-1) is the value of S at the outset of the i'th iteration.)
      <br/>
      2) Y0 =X0 * J0 mod 2k (The LS k bits of the product of X0 * J0)
    </p>
    <p num="143">- (The process uses and computes the k LS bits only, e.g., the least significant 64 bits)</p>
    <p num="144">
      In the preferred implementation, this step is obviated, because in a serial machine Y0 can be anticipated bit by bit.
      <br/>
      3) Z=X+Y0 * N
      <br/>
      4) S(i)=Z/2k (The k LS bits of Z are always 0, therefore Z is always divisible by 2k.
      <br/>
      This division is tantamount to a k bit right shift as the LS k bits of Z are all zeros; or as will be seen in the circuit, the LS k bits of Z are simply disregarded.
      <br/>
      (5) S(i)=S(i) mod N (N is to be subtracted from those S(i)'s which are larger than N).
    </p>
    <p num="145">Finally, at the last iteration (after the subtraction of N, when necessary), C=S(m)=+character pullout}(A * B)N. To derive F=A * B mod N, the P field computation, +character pullout}(C * H)N, is performed</p>
    <p num="146">
      It is desired to know, in a preferred embodiment, that for all S(i)'s, S(i) is smaller than 2N.
      <br/>
      This also means, that the last result (S(m)) can always be reduced to a quantity less than N with, at most, one subtraction of N.
    </p>
    <p num="147">We observe that for operands which are used in the process:</p>
    <p num="148">
      S(i-1)&lt;2n+1 (the temporary register can be one bit longer than the B or N register),
      <br/>
      B&lt;N&lt;2n and Ai-1 &lt;2k.
    </p>
    <p num="149">
      By definition:
      <br/>
      S(i)=Z/2k (The value of S at the end of the process, before a possible subtraction)
    </p>
    <p num="150">For all Z, Z(i)&lt;2n+k+1.</p>
    <p num="151">
      Xmax =Smax +Ai * B&lt;2n+1 -1+(2k -1)(2n -1)
      <br/>
      Qmax =Y0 N&lt;(2k -1)(2n -1)
    </p>
    <p num="152">
      therefore:
      <br/>
      Zmax &lt;2k+n+1 -2k+1 +1&lt;2k+n+1 -1.
    </p>
    <p num="153">
      and as Zmax is divided by 2k :
      <br/>
      S(m)&lt;2n+1 -21.
    </p>
    <p num="154">Because Nmin &gt;2n -2, S(m)max is always less than 2 * Nmin, and therefore, one subtraction is all that is necessary on a final result.</p>
    <p num="155">S(m)max -Nmin =(2n+1 -21 -1)-(2n -1)=2n -4&lt;Nmin.</p>
    <p num="156">Example of a Montgomery interleaved modular multiplication:</p>
    <p num="157">The following computations in the hexadecimal format clarify the meaning of the interleaved method:</p>
    <p num="158">N=a59, (the modulo), A=99b, (the multiplier), B=5c3 (the multiplicand), n=12, (the bit length of N), k=4, (the size in bits of the multiplier and also the size of a character), and m=3, as n=k * m.</p>
    <p num="159">J0 =7 as 7 * 9.tbd.-1 mod 16 and H.tbd.22 * 12 mod a59.tbd.44b.</p>
    <p num="160">The expected result is F.tbd.A * B mod N.tbd.99b * 5c3 mod a59.tbd.375811 mod a59=22016.</p>
    <p num="161">Initially: S(0)=0</p>
    <p num="162">
      Step 1 X=S(0)+A0 * B=0+b * 5c3=3f61
      <br/>
      Y0 =X0 * J0 mod 2k =7 (Y0 --hardwire anticipated in new MAP)
      <br/>
      Z=X+Y0 * N=3f61+7 * a59=87d0
      <br/>
      S(1)=Z/2k =87d
      <br/>
      Step 2 X=S(1)+A1 * B=87d+9 * 5c3=3c58
      <br/>
      Y0 =X0 * J0 mod 2k =8 * 7 mod 24 =8 (Hardwire anticipated)
      <br/>
      Z=X+Y0 * N=3c58+52c8=8f20
      <br/>
      S(2)=Z/2k =8f2
      <br/>
      Step 3 X=S(2)+A2 * B=8f2+9 * 5c3=3ccd
      <br/>
      Y0 =d * 7 mod 24 =b (Hardwire anticipated)
      <br/>
      Z=X+Y0 * N=3ccd+b * a59=aea0
      <br/>
      S(3)=Z/2k =aea,
      <br/>
      as S(3)&gt;N,
      <br/>
      S(m)=S(3)-N=aea-a59=91
    </p>
    <p num="163">Therefore C=+character pullout}(A * B)N=9116.</p>
    <p num="164">Retrieval from the P field is performed by computing +character pullout}(C * H)N:</p>
    <p num="165">
      Again initially: S(0)=0
      <br/>
      Step 1 X=S(0)+C0 * H=0+1 * 44b=44b
      <br/>
      Y0 =d (Hardwire anticipated in new MAP)
      <br/>
      Z=X+Y0 * N=44b+8685=8ad0
      <br/>
      S(1)=Z/2k =8ad
      <br/>
      Step 2 X=S(1)+C1 * H=8ad+9 * 44b=2f50
      <br/>
      Y0 =0 (Hardwire anticipated in new MAP)
      <br/>
      Z=X+Y0 * N=2f50+0=2f50
      <br/>
      S(2)=Z/2k =2f5
      <br/>
      Step 3 X=S(2)+C2 * H=2f5+0 * 44b=2f5
      <br/>
      Y0 =3 (Hardwire anticipated in new MAP)
      <br/>
      Z=X+Y0 * N=2f5+3 * a59=2200
      <br/>
      S(3)=Z/2k =22016
    </p>
    <p num="166">which is the expected value of 99b 5c3 mod a59.</p>
    <p num="167">
      If at each step we disregard k LS zeros, we are in essence multiplying the n MS bits by 2k.
      <br/>
      Likewise, at each step, the i'th segment of the multiplier is also a number multiplied by 2ik, giving it the same rank as S(i).
    </p>
    <p num="168">It can also be noted that in another preferred embodiment, wherein it is of some potential value to know the J0 constant.</p>
    <p num="169">Exponentiation</p>
    <p num="170">
      The following derivation of a sequence �D.
      <br/>
      Knuth, The art of computer programming, vol. 2: Seminumerical algorithms, Addison-Wesley, Reading, Mass., 1981� hereinafter referred to as "Knuth", explains a sequence of squares and multiplies, which implements a modular exponentiation.
    </p>
    <p num="171">
      After precomputing the Montgomery constant, H=22n, as this device can both square and multiply in the P field, we compute:
      <br/>
      C=AE mod N.
    </p>
    <p num="172">
      Let E(j) denote the j bit in the binary representation of the exponent E, starting with the MS bit whose index is 1 and concluding with the LS bit whose index is q, we can exponentiate as follows for odd exponents:
      <br/>
      A*.Yen.+character pullout}(A * H)N A* is now equal to A * 2n.
    </p>
    <p num="173">
      B=A*
      <br/>
      FOR j=2 TO q-1
      <br/>
      B.Yen.+character pullout}(B * B)N
    </p>
    <p num="174">
      IF E(j)=1 THEN
      <br/>
      B.Yen.+character pullout}(B * A*)N
    </p>
    <heading>ENDFOR</heading>
    <p num="175">
      B.Yen.+character pullout}(B * A)N E(0)=1; B is the last desired temporary result multiplied by 2n,
      <br/>
      A is the original A.
    </p>
    <p num="176">
      C=B
      <br/>
      C=C-N if C &gt;= N.
    </p>
    <p num="177">After the last iteration, the value B is .Yen. to AE mod N, and C is the final value.</p>
    <p num="178">
      To clarify, we shall use the following example:
      <br/>
      E=1011 --&gt; E(1)=1; E(2)=0; E(3)=1; E(4)=1;
    </p>
    <p num="179">
      To find A1011 mod N; q=4
      <br/>
      A*=+character pullout}(A * H)N=AI-2 I=AI-1 mod N
      <br/>
      B=A*
      <br/>
      FOR j=2to q
      <br/>
      B=+character pullout}(B * B)N which produces: A2 (I-1)2 * I=A2 * I-1
      <br/>
      E(2)=0; B=A2 * I-1
      <br/>
      j=3 B=+character pullout}(B * B)N=A2 (I-1)2 * I=A4 * I-1
      <br/>
      E(3)=1B=+character pullout}(B * A*)N=(A4 * I-1) (AI-1) * I=A5 * I-1
      <br/>
      j=4 B=+character pullout}(B * B)N=A10 * I-2 * I=A 10 * I-1
    </p>
    <p num="180">As E(4) was odd, the last multiplication will be by A, to remove the parasitic I-1.</p>
    <p num="181">
      B=+character pullout}(B * A)N=A10 * I -1 * A * I=A11
      <br/>
      C=B
    </p>
    <p num="182">A method for computing the H parameter by a reciprocal process is described in U.S. Pat. No. 5,513,133.</p>
    <p num="183">A Long Division Process</p>
    <p num="184">FIG. 2 illustrates a preferred embodiment of a deterministic processing device for performing long division, using the data manipulation devices available on the processor of FIG. 1A.</p>
    <p num="185">FIGS. 4 and 5 are examples of the operation of the apparatus of FIG. 2.</p>
    <p num="186">
      In a division process, wherein the divisor, d, is in the range of d, 2n-1 &lt;d&lt;2n ; and the dividend, D, is in the range of D, 22n-1 &lt;D&lt;22n ; the apparatus is used most simply. d is preloaded into the N right-shift register, 1005 (a concatenation of the N0 and the N1 registers, 210 and 200) in FIG. 2, the MS n bits of the dividend, D, are preloaded in the B right-shift register, 1000, and the n LS bits of D are reverse loaded into the SA right shift register 130.
      <br/>
      This is essentially, as one would arrange digits for manual long division realizing that the new LS bits are fed from SA to SB at each new trial subtraction.
      <br/>
      The SB register is preloaded with all zeros.
    </p>
    <p num="187">
      In the initialization iteration, the overflow flip flop 170 of FIG. 2 is initially reset.
      <br/>
      The N register, which now contains the divisor, d, is trial subtracted from B, the MS bits of D, whilst both the B and N registers are rotated; wherein their outputs are fed into the serial subtractor 90, whose output is B-fN, f=1 for subtract, f=0, for don't subtract.
      <br/>
      The quotient generator, 120, is a detector which determines if B &gt;= N, and transmits a NEXT SUBTRACT which determines if d will be subtracted from B, in 90, in the next iteration; this signal is a one, if, and only if, B is larger than or equal to N. This NEXT SUBTRACT bit denotes success, and is the most significant bit of the quotient, and is also clocked into the SB register, 180.
      <br/>
      As this is clocked into the SB register, a zero is shifted out of the SB register, into the SA register, forcing a NEW LS BIT out of the SA register.
      <br/>
      Note, that as these registers are all right shift registers, both the quotient in SB and the dividend value in SA, are held in reverse order.
    </p>
    <p num="188">
      In the next iterations, at the first effective clock cycle, a NEW LS BIT, shifted out of the SA precedes the output, R, of 90, thereby multiplying R by 2 and adding the value of the NEW LS BIT to 2R.
      <br/>
      This concatenated value is rotated back into the B register, and is also tested in 120, to determine if on the next round f=1 or f=0.
    </p>
    <p num="189">Finally, the remainder is in the B register, n bits of the quotient are in the SB register and the most significant bits of the quotient are in the SA register.</p>
    <p num="190">
      The most significant one of both the dividend and the divisor is preferably in the most significant bit cells of the B register and the N register, for all sizes of D and d. The number of iterations necessary to obtain a result is decreased for Ds which are smaller than 22n-1, and is increased for ds which are smaller than 2n-1.
      <br/>
      The device is hardware driven, and firmware compensations may be provided for shifting operands when unloading the device.
    </p>
    <p num="191">
      The program residing in the non-volatile memory of FIG. 3, preferably ascertains that the registers are loaded, and defines for the control register, a number of iterations necessary for a successful division process.
      <br/>
      The quotient bits are rereversed, byte by byte, when processed through the reverse data out unloader, units 60 and 40.
    </p>
    <p num="192">This processor is an element useful for computing the H Parameter, and also is preferably used in computations of the Euclidean functions.</p>
    <p num="193">The serial integer division apparatus of FIG. 1A and the double acting multiplier of FIG. 1B which performs A * B+C * D+S, typically do not operate simultaneously.</p>
    <p num="194">In the example of FIG. 4, the dividend B is 187 (10111011), the divisor N is 7 (111), and once division is carried out, the quotient is found to be 20 (10100) and the remainder is found to be 7 (111).</p>
    <p num="195">In the example of FIG. 5, the dividend B is 173 (10101101), the divisor N is 5 (101), and once division is carried out, the quotient is found to be 34 (100010) and the remainder is found to be 3 (11).</p>
    <p num="196">A carry-save accumulator is illustrated in FIG. 5 of U.S. Pat. No. 5,513,133 to Gressel.</p>
    <p num="197">A serial full adder is illustrated in FIG. 7 of the above-referenced U.S. Patent to Gressel.</p>
    <p num="198">A serial subtracter is illustrated in FIG. 8 of the above-referenced U.S. Patent to Gressel.</p>
    <p num="199">Division apparatus is illustrated in FIG. 9 of the above-referenced U.S. Patent to Gressel.</p>
    <p num="200">The term "normal field of integers" refers to non-negative integers e.g. natural numbers.</p>
    <p num="201">According to a preferred embodiment of the present invention, the system shown and described herein is operative to compute J0 by resetting a and b to zero and setting S0 =1.</p>
    <p num="202">
      A portion of the disclosure of this patent document contains material which is subject to copyright protection.
      <br/>
      The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.
    </p>
    <p num="203">
      It is appreciated that the software components of the present invention may, if desired, be implemented in ROM (read-only memory) form.
      <br/>
      The software components may, generally, be implemented in hardware, if desired, using conventional techniques.
    </p>
    <p num="204">
      It is appreciated that various features of the invention which are, for clarity, described in the contexts of separate embodiments may also be provided in combination in a single embodiment.
      <br/>
      Conversely, various features of the invention which are, for brevity, described in the context of a single embodiment may also be provided separately or in any suitable subcombination.
    </p>
    <p num="205">
      It will be appreciated by persons skilled in the art that the present invention is not limited to what has been particularly shown and described hereinabove.
      <br/>
      Rather, the scope of the present invention is defined only by the claims that follow:
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>A microelectronic apparatus for performing a Montgomery type modular multiplication of P(Ai * B)N, wherein Ai is a multiplicand, B is a multiplier and N is a modulus, which is limited congruent to a remainder of Ai, times B, over N, times 2-k, input operands being at least n bits in length, and a result being at least 2k+1 bits long, including k disregarded least significant zero bits, which are not saved, where k is not less than n, the apparatus comprising:</claim-text>
      <claim-text>a first (B), and second (N) main memory register, each register holding at least one at least n bit long operand, said registers being respectively operative to store the multiplier, and the modulus, wherein the modulus is odd and is smaller than 2n ; a modular multiplying device for at least k bit input multiplicands, with only one carry save adder, being at least k+1 bits long, and being operative to accept k bit multiplicands, the multiplication device operative to switch into the carry save adder, in turn, multiplicand values, and in turn to receive multiplier values from a B register, and an "on the fly" simultaneously generated anticipated value, Y0, as a multiplier which is operative to force k least significant zero output bits in the first phase, wherein at each effective machine cycle at least one designated multiplicand is added into the carry save adder; a digital logic sensing detector, operative to form the "on the fly" anticipated value, Y0, indicating when a modulus value is to be added to the value in the carry save adder such that all first k least significant multiplication output bits are forced to zero; the multiplicand values to be switched in turn into the carry save adder consisting of one or two of the following three multiplicands, an all-zero string value, the multiplicand Ai, and the modulus value N; the multiplier values which are input in turn into the multiplying device in the first phase being first the B operand, and concurrently, the second multiplier value consisting of the "on the fly" anticipated value, Y0, in the form of a k bit string, to force least significant zeroes in the output; the carry save adder being operative to output values simultaneously as multiplicands are added into the carry save adder; an output transfer mechanism, operative in a second phase to output a final P(A * B)N result from the carry save adder.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. Apparatus as in claim 1 wherein summations into the carry save adder are activated by successively higher order multiplier bits loaded one after another serially.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. Apparatus as in claim 2, wherein the successively loaded multiplier bits: are operative to cause no summation into the carry save adder if both the input multiplier bit and a corresponding input Y0 bit are zeroes;</claim-text>
      <claim-text>- are operative to add in only the Ai multiplicand if the input multiplier bit is a one and the corresponding Y0 bit is a zero; - are operative to add in only the N, modulus, if the multiplier bit is a zero, and the corresponding Y0 bit is a one;</claim-text>
      <claim-text>and - are operative to add in the summation of the modulus, N, with the multiplicand Ai if both the input multiplier bit and the corresponding Y0 bit are ones.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. Apparatus according to claim 3, operative to preload multiplicand values Ai and modulus values N, into two designated preload buffers, and to summate these values into a third multiplicand preload buffer, obviating the necessity of adding in each multiplicand value separately, when corresponding multiplier and Y0 bits are both ones.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. Apparatus as in claim 4, where the preload buffers are serially fed and where multiplicand values are preloaded into the preload buffers on the fly from any of the registers or from the CPU via any of the registers.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. Apparatus as in claim 1, wherein the multiplier values are serially input and the output of the carry save adder is serially output, wherein the detect device is operative to anticipate, on only one bit, whether the modulus value is to be added into the carry save adder.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. Apparatus as in claim 6 wherein k LS zeroes egress from the modular multiplying device controlled by the following three quantities in anticipating a next Y0 bit: i) the LS bit of the Ai register AND the next bit of the B Stream, A0 * Bd ; ii) the LS Carry Out bit from the carry save adder, CO0 ; iii) the Sout bit from the second LS cell of the carry save adder, SO1.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. Apparatus as in claim 7, wherein the three values A0 * Bd, CO0, and SO1 are XORed together to output a valid Y0 anticipatory bit.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. Apparatus as in claim 1 wherein k LS zeroes egress from the modular multiplying device controlled by the following three quantities in anticipating a next Y0 bit: i) the LS bit of the Ai register AND the next bit of the B Stream, A0 * Bd ; ii) the LS Carry Out bit from the carry save adder, CO0 ; iii) the Sout bit from the second LS cell of the carry save adder, SO1.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. Apparatus as in claim 9, wherein the three value, A0 * Bd, CO0, and SO1 are XORed together to output a valid Y0 anticipatory bit.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. Apparatus according to claim 1, further comprising a comparator operative to sense an output from the modular multiplying device, of which output the LS k bits are disregarded, wherein the output is larger than the modulus, N, and smaller than 2N, the comparator being operative to control a modular reduction using a value output from the memory register to which an output stream from the multiplier device is destined, thus avoiding the need to allot a second memory storage device for smaller Montgomery product values.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. Apparatus as in claim 1, wherein a serial comparator is operative to sense when an output Z/2k, from the modular multiplication device is larger than 2n, thereby being operative to set an overflow bit.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. Apparatus, as in claim 1, which, when the Y0 multiplier input is replaced by a constant zero input, is operative to perform natural integer multiplication of Ai times B in the normal field of integers.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. An apparatus, as in claim 1, which, when the Y0 multiplier input is replaced by a constant zero input, is operative to perform natural integer multiplication of Ai times B whilst another value, S, emanating from an n bit register, is summatable therewith to generate a value Ai times B plus S.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. Apparatus according to claim 1, which, when the Y0 multiplier input is replaced by the output of a memory register operative to feed an operand C, and the operand N is replaced by an alternative operand D, is operative to perform natural integer multiplication of Ai times B and C times D whilst another value, S, emanating from another register, is summatable therewith in the normal field of integers so as to generate a value Ai times B plus C times D plus S.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. Apparatus as in claim 1 with which Montgomery modular multiplication is performable with only one precomputed Montgomery variable, and not requiring the use of a J0 Montgomery constant.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The apparatus of claim 1, wherein a Montgomery J0 constant is computed by resetting both the A operand value and the B operand value to zero and setting a partial result value, S0, to 1.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. Apparatus for performing a Montgomery type modular multiplication denoted P(A * B)N which is congruent to A * B * 2-n mod N in the normal field of natural integers, wherein n is larger than k, the multiplication process being performable in iterations in a plurality of phases including a first phase, a second phase, and a final phase, with input operands into a multiplying device, the operands at each iteration consisting of modulus N, a multiplier B, a previously computed partial result, Sn-1, and a k-bit string segment of A, a multiplicand, the segments progressing from the A0 string segment to the Am-1 string segment, wherein each iterative result is summated into a next temporary result Sn, in turn, wherein LS bits of iterative results are zeroes, the apparatus comprising: first (B), second (S) and third (N) main memory registers, each register capable of storing and outputting operands and being respectively operative to store the multiplier value B, the partial result values at each respective stage S and the modulus N; a modular multiplying device operative to summate into a single carry save adder with at least k bits in turn one or two of a plurality of multiplicand values during phases of the iterative multiplication process, and in turn to receive, as multipliers, an input from the B register, a value, Y0, from an "on the fly" anticipating unit usable as a multiplier to force LS zero output bits in each iteration, and values from the modulus, N, register; the multiplicand parallel registers operative at least to receive in turn, values from the A, B, and N register sources, and in turn, also the value Y0, being a multiplicand zero forcing value; a LS zero forcing Y0 detector device operative to generate a binary string operative to be a multiplier during the first phase and operative to be a multiplicand in the second phase; multiplicand values to be switched into the carry save adder for the first phase comprising a first zero value, a second value, Ai, which is a k bit string segment of a multiplicand, A, and a third value N0, being the least significant k bits of the modulus, N; wherein a temporary result value, Sn-1, resulting from a previous iteration, is operative to be summated with a value emanating from the carry save adder, to generate a partial result Sn for the next iteration; multiplicand values to be input, in turn, into the carry save adder for the second phase being, a first zero value, a second Ai operand, remaining in place from the first phase, and a third Y0 value having been anticipated in the first phase; multiplier values input into the multiplying device in the first phase being an LS string, B0, being the least significant string segment of the B operand, concurrently multiplying with the second multiplier value consisting of an anticipated Y0 string which is simultaneously loaded into a preload multiplicand buffer for the second phase; the two multiplier values input into the apparatus during the second phase being the MS n-k bit values from the multiplier B, and the n-k bits of the modulus, N, respectively;</claim-text>
      <claim-text>and a multiplying flush out device operative in the last phase to transfer the MS segment of a result value remaining in the carry save adder into a result register.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. Apparatus as in claim 18, operative to anticipate the Y0 value using LS values of the multiplicand, and present inputs of the multiplier, B, carry out values from the carry save adder, summation values from the carry save adder, the present values from the previously computed partial result Sn-1, and carry out values from the adder which summates the result from the carry save adder with the previous partial result.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. Apparatus as in claim 19, for anticipating the next Y0 bit, Y0i, operative to use binary values: i) the LS bit of the Ai AND the next bit of the Bd Stream, A0 * Bd ; ii) the LS Carry Out bit from the carry save adder, CO0 ; iii) the Sout bit from the second LS cell of the carry save adder, SO1 ; iv) the next bit from the S stream, Sd ;</claim-text>
      <claim-text>and v) the Carry Out bit from the Full Adder, COz ; - and is operative to XOR the values together as defined by -Y0i =A0 * Bd.sym.CO0.sym.SO1.sym.Sd.sym.CO. sub.z.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. An apparatus as in claim 18 comprising at least one subtractor sensor operative to compare the output result to N, the modulus, the subtractor mechanism operative to actuate a second subtractor to reduce the modulus value from the larger than N result value, thereby to output a modular reduced value which is limited congruent to the output result value, and a smaller than N value as output from an allotted register, thus avoiding any need to allot a second memory storage for any smaller result.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. Apparatus as in claim 18 in which a carry out sensor is operative to determine if an output result operand, after disregarding k zeroes, is larger than 2n-1, wherein the sensor is operative to actuate an overflow flag.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. Apparatus as in claim 18 where a value which is a summation of two multiplicands is loaded into a preload k+1 bit buffer memory register concurrently whilst one of the multiplicands is loaded into a preload buffer.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. Apparatus as in claim 18 wherein next use multiplicands are preloaded into preload register buffer on the fly.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. Apparatus as in claim 18 wherein, if both multiplier bits are zeroes, an all zero k bit multiplicand is added into the carry save adder, wherein if the B multiplier bit is one and the second multiplier bit is zero, a value in the Ai register is added into the carry save adder, and if the second multiplier bit is one and the B multiplier bit is zero, the second multiplicand is added into the carry save adder, and if both multiplier bits are ones then the summation Ai +N0 is added into the carry save adder during the first phase, and wherein Ai +Y0 is added into the carry save adder during the next phase.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. Apparatus as in claim 18 wherein buffers and registers are operative to be loaded with values from external memory sources and said buffers and registers are operative to be unloaded into an external memory source during computations, such that the maximum size of the operands is dependent on available memory.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. Apparatus as in claim 18 wherein a main memory register comprises at least one of a group comprising serial in/serial out, parallel in/parallel out, serial in/parallel out, and parallel in/serial out memory registers.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. Apparatus as in claim 18 wherein at the final phase of a Montgomery multiplication type iteration, the multiplier inputs are zeroes operative to flush out the MS segment of the carry save adder memory.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. An apparatus as in claim 18 where next use multiplicands are preloaded into a preload memory buffer on the fly.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. An apparatus as in claim 18 wherein multiplicand values are preloaded into the preload buffers on the fly from a central storage memory.</claim-text>
    </claim>
  </claims>
</questel-patent-document>