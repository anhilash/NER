<?xml version="1.0" encoding="UTF-8"?>
<questel-patent-document lang="en" date-produced="20180805" produced-by="Questel" schema-version="3.23" file="US06185671B2.xml">
  <bibliographic-data lang="en">
    <publication-reference publ-desc="Granted patent as second publication">
      <document-id>
        <country>US</country>
        <doc-number>06185671</doc-number>
        <kind>B2</kind>
        <date>20010206</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>US6185671</doc-number>
      </document-id>
    </publication-reference>
    <original-publication-kind>B2</original-publication-kind>
    <application-reference is-representative="YES" family-id="21983671" extended-family-id="42113776">
      <document-id>
        <country>US</country>
        <doc-number>09053358</doc-number>
        <kind>A</kind>
        <date>19980331</date>
      </document-id>
      <document-id data-format="questel">
        <doc-number>1998US-09053358</doc-number>
      </document-id>
      <document-id data-format="questel_Uid">
        <doc-number>43172122</doc-number>
      </document-id>
    </application-reference>
    <language-of-filing>en</language-of-filing>
    <language-of-publication>en</language-of-publication>
    <priority-claims>
      <priority-claim kind="national" sequence="1">
        <country>US</country>
        <doc-number>5335898</doc-number>
        <kind>A</kind>
        <date>19980331</date>
        <priority-active-indicator>Y</priority-active-indicator>
      </priority-claim>
      <priority-claim data-format="questel" sequence="1">
        <doc-number>1998US-09053358</doc-number>
      </priority-claim>
    </priority-claims>
    <dates-of-public-availability>
      <publication-of-grant-date>
        <date>20010206</date>
      </publication-of-grant-date>
    </dates-of-public-availability>
    <classifications-ipcr>
      <classification-ipcr sequence="1">
        <text>G06F   9/30        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="2">
        <text>G06F   9/318       20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>318</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
      <classification-ipcr sequence="3">
        <text>G06F   9/38        20060101A I20051008RMEP</text>
        <ipc-version-indicator>
          <date>20060101</date>
        </ipc-version-indicator>
        <classification-level>A</classification-level>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>38</subgroup>
        <classification-value>I</classification-value>
        <generating-office>
          <country>EP</country>
        </generating-office>
        <classification-status>R</classification-status>
        <classification-data-source>M</classification-data-source>
        <action-date>
          <date>20051008</date>
        </action-date>
      </classification-ipcr>
    </classifications-ipcr>
    <classification-national>
      <country>US</country>
      <main-classification>
        <text>712216000</text>
        <class>712</class>
        <subclass>216000</subclass>
      </main-classification>
      <further-classification sequence="1">
        <text>712023000</text>
        <class>712</class>
        <subclass>023000</subclass>
      </further-classification>
      <further-classification sequence="2">
        <text>712210000</text>
        <class>712</class>
        <subclass>210000</subclass>
      </further-classification>
      <further-classification sequence="3">
        <text>712E09025</text>
        <class>712</class>
        <subclass>E09025</subclass>
      </further-classification>
      <further-classification sequence="4">
        <text>712E09036</text>
        <class>712</class>
        <subclass>E09036</subclass>
      </further-classification>
      <further-classification sequence="5">
        <text>712E09049</text>
        <class>712</class>
        <subclass>E09049</subclass>
      </further-classification>
      <further-classification sequence="6">
        <text>712E09050</text>
        <class>712</class>
        <subclass>E09050</subclass>
      </further-classification>
      <further-classification sequence="7">
        <text>712E09061</text>
        <class>712</class>
        <subclass>E09061</subclass>
      </further-classification>
    </classification-national>
    <classifications-ecla>
      <classification-ecla sequence="1">
        <text>G06F-009/30X6</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30X6</subgroup>
      </classification-ecla>
      <classification-ecla sequence="2">
        <text>G06F-009/30A1P</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30A1P</subgroup>
      </classification-ecla>
      <classification-ecla sequence="3">
        <text>G06F-009/30R4</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30R4</subgroup>
      </classification-ecla>
      <classification-ecla sequence="4">
        <text>G06F-009/30R4C</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30R4C</subgroup>
      </classification-ecla>
      <classification-ecla sequence="5">
        <text>G06F-009/30R5D</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>30R5D</subgroup>
      </classification-ecla>
      <classification-ecla sequence="6">
        <text>G06F-009/38E</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38E</subgroup>
      </classification-ecla>
      <classification-ecla sequence="7">
        <text>G06F-009/38E1</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38E1</subgroup>
      </classification-ecla>
      <classification-ecla sequence="8">
        <text>G06F-009/38E2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38E2</subgroup>
      </classification-ecla>
      <classification-ecla sequence="9">
        <text>G06F-009/38H2</text>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>009</main-group>
        <subgroup>38H2</subgroup>
      </classification-ecla>
    </classifications-ecla>
    <patent-classifications>
      <patent-classification sequence="1">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30192</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30192</subgroup>
        <symbol-position>F</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="2">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30036</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30036</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="3">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30105</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30105</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="4">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/30112</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>30112</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="5">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3013</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3013</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="6">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3836</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3836</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="7">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3838</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3838</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="8">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/384</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>384</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140317</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="9">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3842</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3842</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="10">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3855</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3855</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140317</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="11">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3857</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3857</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140317</date>
        </action-date>
      </patent-classification>
      <patent-classification sequence="12">
        <classification-scheme office="EP" scheme="CPC">
          <date>20130101</date>
        </classification-scheme>
        <classification-symbol>G06F-009/3863</classification-symbol>
        <section>G</section>
        <class>06</class>
        <subclass>F</subclass>
        <main-group>9</main-group>
        <subgroup>3863</subgroup>
        <symbol-position>L</symbol-position>
        <classification-value>I</classification-value>
        <classification-status>B</classification-status>
        <classification-data-source>H</classification-data-source>
        <action-date>
          <date>20140321</date>
        </action-date>
      </patent-classification>
    </patent-classifications>
    <number-of-claims>30</number-of-claims>
    <exemplary-claim>1</exemplary-claim>
    <figures>
      <number-of-drawing-sheets>7</number-of-drawing-sheets>
      <number-of-figures>7</number-of-figures>
      <image-key data-format="questel">US6185671</image-key>
    </figures>
    <invention-title format="original" lang="en" id="title_en">Checking data type of operands specified by an instruction using attributes in a tagged array architecture</invention-title>
    <references-cited>
      <citation srep-phase="examiner">
        <patcit num="1">
          <text>SAGER DAVID J, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5519841</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5519841</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="2">
          <text>YELLIN FRANK, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5740441</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5740441</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="3">
          <text>WALKER WADE A</text>
          <document-id>
            <country>US</country>
            <doc-number>5765016</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5765016</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="4">
          <text>THUSOO SHALESH, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5790826</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5790826</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="5">
          <text>KOSARAJU CHAKRAVARTHY</text>
          <document-id>
            <country>US</country>
            <doc-number>5884071</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5884071</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="6">
          <text>RODGERS SCOTT DION, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5889982</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5889982</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="7">
          <text>LUEDTKE MARK R, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>5978901</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US5978901</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <patcit num="8">
          <text>LYNCH THOMAS W, et al</text>
          <document-id>
            <country>US</country>
            <doc-number>6009511</doc-number>
            <kind>A</kind>
          </document-id>
          <document-id data-format="questel">
            <doc-number>US6009511</doc-number>
          </document-id>
        </patcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="1">
          <text>Microsoft, Microsoft Press Computer Dictionary, 3rd, Ed., 1997, pp. 254,342,480.</text>
        </nplcit>
      </citation>
      <citation srep-phase="examiner">
        <nplcit num="2">
          <text>Rosenberg, Jerry, Dictionary of Computers, Information Processing &amp; and Telecommunications, 1987, p. 672.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="3">
          <text>Visual Instruction Set (VIS) User's Guide, Sun Microsystems, Version 1.1, Mar. 1997, pp i-xii, 1-127.</text>
        </nplcit>
      </citation>
      <citation srep-phase="applicant">
        <nplcit num="4">
          <text>AMD-3D Technology Manual, Advance Micro Devices, (AMD), Feb. 1998, pp i-x, 1-58.</text>
        </nplcit>
      </citation>
    </references-cited>
    <parties>
      <applicants>
        <applicant data-format="original" app-type="applicant" sequence="1">
          <addressbook lang="en">
            <orgname>Intel Corporation</orgname>
            <address>
              <address-1>Santa Clara, CA, US</address-1>
              <city>Santa Clara</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
        <applicant data-format="questel" app-type="applicant" sequence="2">
          <addressbook lang="en">
            <orgname>INTEL</orgname>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </applicant>
      </applicants>
      <inventors>
        <inventor data-format="original" sequence="1">
          <addressbook lang="en">
            <name>Pentovski, Vladimir</name>
            <address>
              <address-1>Folsom, CA, US</address-1>
              <city>Folsom</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="2">
          <addressbook lang="en">
            <name>Bennett, Gerald</name>
            <address>
              <address-1>Folsom, CA, US</address-1>
              <city>Folsom</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="3">
          <addressbook lang="en">
            <name>Fischer, Stephen A.</name>
            <address>
              <address-1>Shingle Springs, CA, US</address-1>
              <city>Shingle Springs</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="4">
          <addressbook lang="en">
            <name>Heit, Eric</name>
            <address>
              <address-1>Folsom, CA, US</address-1>
              <city>Folsom</city>
              <state>CA</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="5">
          <addressbook lang="en">
            <name>Hinton, Glenn J.</name>
            <address>
              <address-1>Portland, OR, US</address-1>
              <city>Portland</city>
              <state>OR</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
        <inventor data-format="original" sequence="6">
          <addressbook lang="en">
            <name>Roussel, Patrice L.</name>
            <address>
              <address-1>Portland, OR, US</address-1>
              <city>Portland</city>
              <state>OR</state>
              <country>US</country>
            </address>
          </addressbook>
          <nationality>
            <country>US</country>
          </nationality>
        </inventor>
      </inventors>
      <agents>
        <agent sequence="1" rep-type="agent">
          <addressbook lang="en">
            <orgname>Blakely, Sokoloff, Taylor &amp; Zafman LLP</orgname>
          </addressbook>
        </agent>
      </agents>
    </parties>
    <examiners>
      <primary-examiner>
        <name>An, Meng-Ai T.</name>
      </primary-examiner>
    </examiners>
    <lgst-data>
      <lgst-status>EXPIRED</lgst-status>
    </lgst-data>
  </bibliographic-data>
  <abstract format="original" lang="en" id="abstr_en">
    <p id="P-EN-00001" num="00001">
      <br/>
      The present invention discloses a method and apparatus for matching data types of operands in an instruction.
      <br/>
      A type code of an operand used by the instruction is determined.
      <br/>
      An attribute value of a storage element which corresponds to the operand is read from a speculative array.
      <br/>
      This attribute value is then compared with the type code.
    </p>
  </abstract>
  <description format="original" lang="en" id="desc_en">
    <heading>BACKGROUND OF THE INVENTION</heading>
    <p num="1">
      1.
      <br/>
      Field of the Invention
    </p>
    <p num="2">
      This invention relates to microprocessor systems.
      <br/>
      In particular, the invention relates to data type checking using a tagged array architecture.
    </p>
    <p num="3">2. Description of Related Art</p>
    <p num="4">
      Specific implementations of high performance microprocessors tend to exploit the particular design aspects in order to achieve high performance or other design objectives.
      <br/>
      These implementations usually involve different internal data representations.
      <br/>
      The incompatibility of the internal data representations between different implementations causes many problems including incorrect and/or unexpected results.
    </p>
    <p num="5">
      One of the basic internal representations is the data type of the operands in an operation or instruction.
      <br/>
      Typical operations or instructions involve two source operands and a destination operand.
      <br/>
      To maintain consistency of the representation, the types of data at four localities have to match.
      <br/>
      These localities include the operation itself, the two source operands, and the destination operand.
      <br/>
      In addition to the data type, the size of the operand is also important.
      <br/>
      For example, a double-precision floating-point operation expects the two source operands and the destination operand to be represented in a 64-bit floating-point number format.
      <br/>
      A type or size mismatch is an indication of some kind of error, such as incorrect parameters, programming mistake, etc.
    </p>
    <p num="6">
      Type checking of data can be enforced through a number of methods.
      <br/>
      One method is to associate a specific set of registers of predetermined type and size for a predetermined set of instructions.
      <br/>
      For example, floating-point instructions can only access floating-point registers.
      <br/>
      The disadvantages of this method include the use of large silicon area for implementing the pre-assigned registers.
      <br/>
      Another method is the use of compilers to check for data types.
      <br/>
      The compiler method, however, involves a high overhead for testing data values and results in lower performance.
      <br/>
      In addition, not all compilers are compatible; therefore, a program that works under one operating system may not work under another operating system.
    </p>
    <p num="7">
      In pipelined and superscalar microprocessors, the problem of type mismatch is even more difficult.
      <br/>
      In particular, the prefetching of instructions and out-of-order execution render data type tracking difficult.
      <br/>
      Other problems associated with instruction decoding and execution also create architectural challenges.
      <br/>
      Some examples of these problems are aliased register sets, instruction retirement, mispredicted branches, and exception processing.
    </p>
    <p num="8">Therefore there is a need in the technology to provide an efficient method to facilitate data type matching.</p>
    <heading>SUMMARY OF THE INVENTION</heading>
    <p num="9">
      The present invention discloses a method and apparatus for matching data types of operands in an instruction.
      <br/>
      A type code of an operand used by the instruction is determined.
      <br/>
      An attribute value of a storage element which corresponds to the operand is read from a speculative array.
      <br/>
      This attribute value is then compared with the type code.
    </p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading>
    <p num="10">
      The features and advantages of the invention will become apparent from the following detailed description of the invention in which:
      <br/>
      FIG. 1 is a diagram illustrating one embodiment of a computer system 100 in accordance with the teachings of the invention.
      <br/>
      FIG. 2 is a diagram illustrating one embodiment of a processor 110 according to one embodiment of the invention.
      <br/>
      FIG. 3 is a diagram illustrating a tag array block according to one embodiment of the invention.
      <br/>
      FIG. 4 is a diagram illustrating the organization of the retired array 302 and the speculative array 304 according to one embodiment of the invention.
      <br/>
      FIG. 5 is a diagram illustrating a write circuit 500 for writing the array tag values according to one embodiment of the invention.
      <br/>
      FIG. 6 is a diagram illustrating the match and update circuit 266 according to one embodiment of the invention.
      <br/>
      FIG. 7 is a flowchart illustrating a process P700 to perform data type checking using a tagged array architecture according to one embodiment of the invention.
    </p>
    <heading>DESCRIPTION OF THE PRESENT INVENTION</heading>
    <p num="11">
      A method and apparatus for checking data types in microprocessor operations is disclosed.
      <br/>
      The method uses a tagged architecture that associates a set of registers with a set of tag values stored in two tag arrays: a speculative array and a retirement array.
      <br/>
      When a micro-operation is issued, the corresponding tag values of the sources are read from the speculative array.
      <br/>
      These values are matched against the values decoded from the micro-operation and the destination values.
      <br/>
      If these tag values do not match, a fault condition occurs.
      <br/>
      When a micro-operation is retired, the retirement array is updated.
      <br/>
      When there is an exception condition, the retirement array is transferred to the speculative array to maintain the data type.
      <br/>
      The method provides a fast and efficient mechanism to check data types.
    </p>
    <p num="12">
      In the following description, for purposes of explanation, numerous details are set forth in order to provide a thorough understanding of the present invention.
      <br/>
      However, it will be apparent to one skilled in the art that these specific details are not required in order to practice the present invention.
      <br/>
      In other instances, well known electrical structures and circuits are shown in block diagram form in order not to obscure the present invention.
    </p>
    <p num="13">FIG. 1 is a diagram illustrating one embodiment of a processor 110 in accordance with the teachings of the present invention.</p>
    <p num="14">The processor 110 represents a central processing unit of any type of architecture, such as complex instruction set computers (CISC), reduced instruction set computers (RISC), very long instruction word (VLIW), or hybrid architecture.</p>
    <p num="15">
      FIG. 1 illustrates that the processor 110 includes a decode unit 116, a set of registers 114, a tag array unit 119, an execution unit 112, and an internal bus 111 for executing instructions.
      <br/>
      Of course, the processor 110 contains additional circuitry, which is not necessary to understanding the invention.
      <br/>
      The decode unit 116, registers 114 and execution unit 112 are coupled together by the internal bus 111.
      <br/>
      The decode unit 116 is used for decoding instructions received by processor 110 into control signals and/or microcode entry points.
      <br/>
      In response to these control signals and/or microcode entry points, the execution unit 112 performs the appropriate operations.
      <br/>
      The decode unit 116 may be implemented using any number of different mechanisms (e.g., a look-up table, a hardware implementation, a PLA, etc.).
    </p>
    <p num="16">
      The decode unit 116 is shown including packed data instruction set 118 for performing operations on packed data.
      <br/>
      The number format for these operations can be any convenient format, including single-precision, double-precision, and extended floating-point numbers, signed and unsigned integers, and non-numeric data.
      <br/>
      In one embodiment, the arithmetic operations performed responsive to at least some of the packed data instructions use a single-precision 32 bit floating-point number format However, the arithmetic instructions may be applied to integer data as well.
      <br/>
      Furthermore, in one embodiment, the processor 110 is a superscalar pipelined processor (e.g., similar to the Pentium.RTM. pro processor manufactured by Intel Corporation of Santa Clara, Calif.).
      <br/>
      In addition to the packed data instructions, the processor 110 can include new instructions and/or instructions similar to or the same as those found in existing general purpose processors.
      <br/>
      For example, in one embodiment the processor 110 supports an instruction set which is compatible with the Intel Architecture instruction set used by existing processors, such as the Pentium.RTM. processor.
      <br/>
      Alternative embodiments of the invention may contain more or less, as well as different, packed data instructions and still utilize the teachings of the invention.
    </p>
    <p num="17">
      The register set 114 represents a storage area on processor 110 for storing information, e.g., control/status information, packed and/or scalar integer data, packed and/or scalar floating-point data, etc.
      <br/>
      The tag array unit 119 is coupled to the register set 114 to provide the tag values which are used for matching data types in accordance to the teachings of the present invention.
      <br/>
      The tag array unit 119 will be described in more detail later.
    </p>
    <heading>THEORY OF THE TAGGED ARRAY ARCHITECTURE</heading>
    <p num="18">
      A microarchitecture may have different implementations.
      <br/>
      Each implementation may correspond to a different instruction set.
      <br/>
      For example, a regular packed data implementation treats an operand as a 64-bit data, while an extended packed data implementation treats an operand as a 128-bit data.
      <br/>
      Software written for one implementation may not work in another implementation.
    </p>
    <p num="19">
      In microprocessors, most instructions involve the use of a set of registers.
      <br/>
      A decoded instruction may correspond to a number of micro-operations (or uOps).
      <br/>
      Each instruction typically specifies two source operands and one destination operand.
      <br/>
      These operands may come from memory or registers.
      <br/>
      However, at the micro level, most, if not all, operands are stored in registers (in dedicated registers and/or dynamically allocated registers using a register renaming technique).
      <br/>
      In one embodiment, an instruction specifies two registers, one of which is designated as a source and the destination.
      <br/>
      The registers specified by the instructions are referred to as architectural registers.
      <br/>
      Different implementations use the architectural registers in different ways (e.g., dedicated registers, dynamically allocated registers using register renaming, etc.).
      <br/>
      Thus, the invention is not limited to how the architectural registers are implemented.
    </p>
    <p num="20">
      During the decoding process, the source and destination architectural registers are identified.
      <br/>
      In addition, the type of data involved in the associated uOps is also recognized.
      <br/>
      Enforcing the strong-type consistency involves matching the attributes of the uOps to those of the operands.
      <br/>
      In other words, the attributes as expected by the uOp should be the same with the attributes associated with the source and destination architectural registers.
    </p>
    <p num="21">
      To implement the strong-type policy, the attributes of each architectural register in the set of architectural registers should be kept track of.
      <br/>
      In one embodiment, this is accomplished by maintaining an array that stores the attributes for the set of architectural registers.
      <br/>
      When a uOp is issued from the instruction decoder, the information about the uOp and the source and destination architectural registers is extracted to look up the attributes stored in the array.
      <br/>
      Matching of the attributes can then be performed by comparing the expected attributes and the current attributes of the specified source and destination architectural registers.
      <br/>
      This array is constantly updated as the uOps are issued.
      <br/>
      Therefore, the attributes of the architectural registers are kept track of.
      <br/>
      This array is referred to as the speculative array.
    </p>
    <p num="22">
      There are, however, two problems that need to be resolved for the implementation of the attribute tracking mechanism.
      <br/>
      The first problem is the incorrect updating of the attributes in the speculative array due to branch misprediction.
      <br/>
      The second problem is the concurrent dependency.
    </p>
    <p num="23">
      In pipelined and superscalar architectures, the instructions are continuously fetched and executed based on some pre-defined program order.
      <br/>
      A commonly known problem in pipelined architecture is the branch prediction.
      <br/>
      This problem arises because the a branch instruction may alter the normal program flow which interferes with the sequential fetching and decoding of the instructions.
      <br/>
      The problem is partially resolved by applying a branch prediction algorithm to guess the next instruction to be fetched.
      <br/>
      However, the prediction may still be incorrect.
      <br/>
      When this occurs, the instructions that were fetched and decoded in the pipeline based on the incorrect prediction are wrong and the attributes of the associated architectural registers during the updating of the speculative array are no longer valid.
      <br/>
      In this case, it is necessary to return back to the previous condition before the misprediction.
      <br/>
      A mechanism that facilitates this restoration is the retirement mechanism.
    </p>
    <p num="24">
      An instruction is retired when it is determined that it is no longer needed in the instruction buffer.
      <br/>
      Usually, an instruction is retired when its execution is guaranteed.
      <br/>
      Retirement of an instruction can occur after, at the same time, or even before the execution of the instruction.
      <br/>
      Regardless of when an instruction is retired, the attributes at the time it is retired are the valid attributes.
      <br/>
      Therefore, if these attributes are stored and updated only when an instruction is retired, they can be used to restore the previous and correct condition (e.g., prior to when a branch was mispredicted).
      <br/>
      This is implemented by storing these retiring attributes in another array, referred to as a retired array.
    </p>
    <p num="25">
      The retired array essentially stores the same attributes as in the speculative array, with some lag time.
      <br/>
      In other words, the speculative array contains the latest and most current attributes of the architectural registers, but these attribute values may be incorrect (e.g., due to a mispredicted branch).
      <br/>
      The retired array is updated with the attributes of an instruction when it is retired.
      <br/>
      When there is an error requiring the processor to be backed up to a previous state, the contents of the retired array are transferred to the speculative array to restore the attributes to the condition prior to the exception condition.
    </p>
    <p num="26">
      The concurrent dependency problem may cause an incorrect matching.
      <br/>
      This problem arises when there is dependency in the concurrently issued uOps within the same macro clock cycle.
      <br/>
      In one embodiment, up to three uOps may be issued in a macro clock cycle.
      <br/>
      An architectural register may be used by more than one uOp.
      <br/>
      For example, an architectural register may be a destination of a first uOp and a source architectural register of the second uOp.
      <br/>
      In this case, the attributes of the architectural register are updated when the first uOp is issued.
      <br/>
      These updated attributes may then be incorrectly read by the second (or third) uOp.
      <br/>
      Other dependency problems may arise which cause incorrect matching of the attributes.
    </p>
    <p num="27">
      To resolve this problem, an overriding mechanism is implemented.
      <br/>
      This overriding mechanism essentially keeps a copy of the attributes of a architectural register.
      <br/>
      This copy will be re-used by a subsequent uOp when there is a dependency condition, even if the attributes are updated in the speculative array by an earlier uOp.
      <br/>
      A circuit to analyze the dependency across the uOps generates a select signal to select this copy for use by a uOp if it determines that a dependency exists between this uOp and an earlier uOp.
    </p>
    <heading>IMPLEMENTATION OF THE TAGGED ARRAY ARCHITECTURE</heading>
    <p num="28">
      In one embodiment of an out-of-order processor that uses a register renaming and a re-order buffer, the tagged array architecture is implemented in the register allocation table (RAT).
      <br/>
      While one embodiment is described in which an out-of-order processor with a specific internal architecture is described, alternative embodiments can be in-order processors and/or use a different internal architecture (e.g., a different register renaming mechanism, a different instruction ordering mechanism than a re-order buffer, etc.) The attribute of a architectural register includes a tag field and a size field.
    </p>
    <p num="29">Tag Field Functionality</p>
    <p num="30">
      For each architectural register, there is a tag field indicating the tag value associated with the operand in the architectural register.
      <br/>
      In one embodiment, the tag field is 3-bit to encode up to 8 types of data.
      <br/>
      The encoding of the tag field accommodates a number of data types, including character, integer, floating-point (single precision and double precision).
    </p>
    <p num="31">Size Bit Functionality</p>
    <p num="32">
      For each architectural register, there is a size field indicating the size of the operand.
      <br/>
      If there is a size mismatch between either of the two sources and the destination, then a data tag fault is detected.
    </p>
    <p num="33">
      For simplicity, in the following description, tag field and tag values are used to describe the attribute.
      <br/>
      The size field and size values can be used together with the tag field and tag values.
      <br/>
      Furthermore, any other attributes can also be included.
    </p>
    <p num="34">
      FIG. 2 is a diagram illustrating a processor 110 according to one embodiment of the invention.
      <br/>
      For clarity, only a portion of the processor 110 which is useful in describing the invention is shown in FIG. 2.
      <br/>
      The processor 110 includes a bus interface unit 210, an instruction cache 212, the instruction decoder 116, a microcode instruction sequencer 230, a decoded instruction queue 240, a register allocation table (RAT) 242, the tag array unit 119, the architectural register set 114, a register unit 244, a reservation station 246, an execution unit 250, and a write-back bus 255.
    </p>
    <p num="35">
      The bus interface unit 210 fetched the instruction opcode from the external program memory.
      <br/>
      The program memory corresponds to the program/code 136 (FIG. 1).
      <br/>
      The fetched opcodes are stored in the instruction code cache 212.
      <br/>
      The instruction decoder 116 reads the opcodes from the instruction cache 212 and decodes the instruction.
      <br/>
      A number of decoders may be used to decode the instruction opcode.
    </p>
    <p num="36">
      The microcode instruction sequencer 230 generates the address for the microprogrammed routine that corresponds to the decoded instruction.
      <br/>
      The micro-instructions are stored in a microprogrammed memory (not shown).
      <br/>
      The decoded instruction is stored in the decoded instruction queue 240.
      <br/>
      The decoded instruction includes a number of micro-operations (or uOps).
      <br/>
      The uOps are issued from the instruction decoder 116 and go to the tag array unit 119 and the architectural register allocation table (RAT) 242.
    </p>
    <p num="37">
      The tag array unit 119 includes a tag array block 262, a write circuit 264, and a match and update circuit 266.
      <br/>
      The tag array block 262 includes the two arrays that are used to store the tag values.
      <br/>
      The write circuit 264 writes the tag values to the two arrays.
      <br/>
      The match and update circuit 266 performs the matching of the data types associated with the uOp.
    </p>
    <p num="38">
      The register allocation table 242 determines the source of the register operands for the uops.
      <br/>
      The register unit 244 stores the uops.
      <br/>
      In one embodiment, the register unit 244 is referred to a re-order buffer (ROB).
      <br/>
      In one embodiment, the uops are stored in the register unit 244 in strict program order.
      <br/>
      The reservation station 246 copies multiple uOps from the register unit 244 and queues them up for delivery to the appropriate functional elements in the execution unit 112.
      <br/>
      The execution unit 112 includes functional elements needed to execute the instruction such as arithmetic logic unit, floating-point unit, etc.
      <br/>
      The results produced by the execution unit 112 are written back to the register unit 244 via the write-back bus 255.
    </p>
    <p num="39">
      The tagged architecture as implemented in the tag array unit 119 can operate in an out-of-order processor or an in-order processor.
      <br/>
      The tag array unit 119 is used to perform type checking to maintain compatibility of data type among different implementations.
    </p>
    <p num="40">
      FIG. 3 is a diagram illustrating a tag array block 262.
      <br/>
      The array block 262 includes a retired array 302, a speculative array 304, a read decode circuit 310, a retirement write decode circuit 330, and data and signals 315, 320, 322, 325, 335, 340, and 350.
    </p>
    <p num="41">
      The read decode circuit 310 receives the instruction decoder (ID) logical sources 315 to generate the appropriate read enables 312.
      <br/>
      The speculative array 304 receives the read enables 312 from the read decode circuit 310 and the tag data write values 320 and the write enables 322.
      <br/>
      The read enables 312 are used during the uOp issuance.
      <br/>
      Upon receipt of the read enables 312, the speculative array 304 generates the tag data read values 325 for the uOps.
      <br/>
      The tag data write values 320 are written into the speculative array 304 for those check set (chkset) encodings which set the destination tag values.
    </p>
    <p num="42">
      The retirement write decode circuit 330 receives the retiring logical destination 335 and the retirement valid pointers 340 to generate the retiring write enables 342 for updating the retired array 302.
      <br/>
      The retired array 302 receives the retiring write enables 342 from the retirement write decode circuit 330 and the retiring write values 345.
      <br/>
      The retiring write values 345 represent the tag values of the retiring uOps.
      <br/>
      When a uOp is retired, its tag values are written into the retired array 302.
    </p>
    <p num="43">
      The speculative array 304 and the retired array 302 both receive the exception condition signals 350.
      <br/>
      The exception condition signals 350 represent a condition where there is an exception that alters the normal program flow, such as a mispredicted branch.
      <br/>
      Upon receiving the exception signal, the contents of the retired array 302 are transferred to the speculative array 304.
    </p>
    <p num="44">FIG. 4 is a diagram illustrating the organization of the retired array 302 and the speculative array 304.</p>
    <p num="45">
      For every physical register mapped for a given architectural register as part of the current speculative state, there is an entry in the speculative array and the retired array.
      <br/>
      For example, if two 64-bit physical registers are used to provide a single 128-bit architectural register, two entries would be used.
    </p>
    <p num="46">
      In the illustrative example shown in FIG. 4, the retired array 302 includes eight tag fields 411, 412, 413, 414, 415, 416, 417, and 418, corresponding to the R0, R1, R2, R3, R4, R5, R6, and R7 architectural registers, respectively.
      <br/>
      The speculative array 304 is organized in a similar fashion as the retired array 302.
      <br/>
      The speculative array 304 includes eight tag fields 431, 432, 433, 434, 435, 436, 437, and 438, corresponding to the R0, R1, R2, R3, R4, R5, R6, and R7 architectural registers, respectively.
      <br/>
      When the retired array 302 is transferred to the speculative array 304, the contents of the tag fields of the registers are copied from the retired array 302 to the corresponding tag fields in the speculative array 304.
    </p>
    <p num="47">
      Variations of the organization of the two arrays is possible.
      <br/>
      For example, additional attribute fields can be included (e.g., size).
      <br/>
      The number of tag fields may also vary depending on the number of registers.
    </p>
    <p num="48">
      When a uOp is issued, its sources are used to look up the tag field of the corresponding architectural registers in the speculative array 304.
      <br/>
      When a uOp is retired, its corresponding tag field is written to the retirement array 302.
      <br/>
      The retirement array 302 therefore stores the updated values of the tag field at the time the uOps are retired.
      <br/>
      When there is an exception condition, the tag field in the speculative array is no longer valid; therefore, the contents of the retired array 302 are transferred to the speculative array 304.
    </p>
    <p num="49">
      FIG. 5 is a diagram illustrating a write circuit 500 for writing the array tag values.
      <br/>
      The write circuit 500 includes a speculative write circuit 510, a speculative storage element 515, an inverter 520, a transistor 525, a retired write circuit 530, a retired storage element 535, an inverter 540, a transistor 545, a pulldown/select stack 550, data and signals 312, 320, 322, 325, 342, 549, 564, and 570.
    </p>
    <p num="50">
      The speculative write circuit 510 receives the write enables 322, the retired copy enable 564, the tag data write values 320, and the retired copy data 549 from the retired write circuit 530.
      <br/>
      The write enables 322 activate the writing cycle in the write circuit 510.
      <br/>
      The tag data write values 320 provide the data for the write circuit 510 to write to the speculative array 304.
      <br/>
      The retired copy enable 564 is the enable signal to start the copying of the retired array 302 to the speculative array 304.
      <br/>
      The retired copy data 549 comes from the retired array 304 and is the data to be written to the speculative array 304 when there is an exception condition.
      <br/>
      The speculative storage element 515 stores the written information.
      <br/>
      As shown in FIG. 5, the storage element 515 is merely a representative of the storage elements in the speculative array 304.
    </p>
    <p num="51">
      The inverter 520, the transistor 525, and the pulldown/select stack 550 provide the data path for reading.
      <br/>
      The read enables 312 select the proper fields for reading from the array.
      <br/>
      The tag data read values 325 are the tag values as read from the speculative array 304.
    </p>
    <p num="52">
      The retired write circuit 530 receives the retiring write enables 342, the reset enable 570, and the retiring write data 345.
      <br/>
      The retiring write enables 342 activate the writing cycle when a uOp is retiring.
      <br/>
      The retiring write data 345 are the tag values of the retiring uOp to be written into the retired array 530.
      <br/>
      The reset enable 570 starts the reset sequence when the retired array 302 is initialized upon power on reset or other reset conditions.
      <br/>
      The retired storage element 535 stores the written information.
      <br/>
      As shown in FIG. 5, the storage element 535 is merely a representative of the storage elements in the retired array 302.
    </p>
    <p num="53">
      The inverter 540 and the transistor 545 provide the data path for transferring to the speculative array.
      <br/>
      The retired copy data 549 represents the tag values as read from the retired array 302.
    </p>
    <p num="54">
      FIG. 6 is a diagram illustrating the match and update circuit 266.
      <br/>
      The match and update circuit 266 performs all of the source and destination tag checking and sets the appropriate tag values in the tag array.
      <br/>
      The match and update circuit 266 includes a matching tag generator 620, a write enable generator 630, a dependency analyzer 640, an override circuit 650, and a comparator, and data and signals 315, 320, 3222, 325, 610, 612, 614, 616, and 680.
    </p>
    <p num="55">
      The match and update circuit 266 reads out tag values from the speculative array 304 for the current set of uOps, compares with the tag requirements mandated by each of the uOps itself.
      <br/>
      For example, an extended integer uOp requires that both of its sources have extended integer tag values, and that these sources have a 128-bit size as indicated by the size bit.
      <br/>
      The match and update circuit 266 then checks for concurrent uOp dependencies between the previous destination and later sources, and then flags any faults.
      <br/>
      The match and update circuit 266 uses the tag values from the speculative array 304, the extended opcode modifiers, and the extended uOp modifiers.
      <br/>
      The match and update circuit 266 generates a set of tag fault detection bits for each issued uOp.
      <br/>
      For tag checking between uOp sources and uOp destination type, the ID logical source values index into the speculative array 304 and read out the appropriate source tag and size values.
      <br/>
      For each uOp, its source tag and size values are compared against the uOp's check set encoding.
    </p>
    <p num="56">
      The matching tag generator 620 receives the uOp checkset encodings 610 and the uOp tag type 612.
      <br/>
      From this information, the matching tag generator 620 generates the tag data write values 320 and a type code representing the expected data type and the size of the operand of the uOp.
      <br/>
      The comparator 660 compares this type code with the tag values as read from the override circuit 650.
    </p>
    <p num="57">
      The override circuit 650 essentially maintains a copy of the tag data read values of the first uOp.
      <br/>
      The override circuit 650 receives the dependency information from the dependency analyzer 640.
      <br/>
      If the information indicates that there is a dependency, the override circuit switches to the copy of the previous tag data read values.
      <br/>
      If there is no dependency, the override circuit 650 uses the currently read tag values read values 325.
    </p>
    <p num="58">The write enable generator 630 receives the uOp checkset encodings 610, the ID logical destination 614, and the RAT uOp valid bits 616 to generate the appropriate write enables 322.</p>
    <p num="59">
      The dependency analyzer 640 receives the ID logical destination 614 and the ID logical sources 315 and performs a dependency analysis.
      <br/>
      The dependency analyzer essentially includes storage elements to store the source and destination information of successive uOps and compare these values.
      <br/>
      If there is dependency condition, the dependency analyzer 640 asserts a signal to the override circuit 650.
      <br/>
      An example of a dependency condition is when the ID logical destination 614 of a uOp is the same as the ID logical source 315 of a subsequent uOp.
    </p>
    <p num="60">FIG. 7 is a flowchart illustrating a process P700 to perform data type checking using a tagged array architecture.</p>
    <p num="61">
      At START, the process P700 enters block B710.
      <br/>
      In block B710, the uOps are issued from the instruction decoder.
      <br/>
      In one embodiment, three uOps are issued at the same time.
      <br/>
      The process P700 then enters block B715 where each of the 3 uOp's sources are used to index into the speculative array to read out the tag value associated with each architectural register.
      <br/>
      The process P700 then enters block B720 where the new tag values are written into the speculative array for valid uOps.
    </p>
    <p num="62">
      The process P700 then enters block B725 to compare the tag type indicated by the uOp itself and the tag values associated with its sources.
      <br/>
      In block B730, the process P700 determines if the tag values are matched.
      <br/>
      If NO, the process P700 enters block B735.
      <br/>
      If YES, the process P700 enters block B750.
    </p>
    <p num="63">
      In block B735, the process P700 sends the fault information to the register unit.
      <br/>
      Then the process P700 enters block B740 to begin appropriate exception processing.
      <br/>
      The process P700 then goes to block B770.
      <br/>
      In one embodiment, the process P700 terminates after the exception processing.
    </p>
    <p num="64">
      In block B750, the process P700 issues the uOps whose tag values have been matched to the register unit and the reservation station.
      <br/>
      The process P700 then enters block B755 to begin execution of the uOps.
      <br/>
      Then the process P700 enters block B760 to retire the uOps.
      <br/>
      In one embodiment, the process P700 does not retire the uOps after the execution, but rather before or concurrently with the execution of the uOps.
      <br/>
      After the uOps are retired, the process P700 enters block B765 to update the retired tag array by writing the tag values of the retired uOps in the retired array.
    </p>
    <p num="65">
      After the retired tag array is updated in block B765, the process P700 enters block B770 to determine if there is any exception condition.
      <br/>
      If NO, the process P700 terminates.
      <br/>
      If YES, the process P700 enters block B775 to transfer the entire retired tag array to the speculative array to maintain the tag values.
      <br/>
      The process P700 then terminates.
    </p>
    <p num="66">
      The present invention provides an efficient mechanism to check the data types in uOps through the maintenance of two tag arrays.
      <br/>
      The present invention therefore avoids the data type mismatch problems frequently found in different implementations of the microprocessor.
    </p>
    <p num="67">
      While this invention has been described with reference to illustrative embodiments, this description is not intended to be construed in a limiting sense.
      <br/>
      Various modifications of the illustrative embodiments, as well as other embodiments of the invention, which are apparent to persons skilled in the art to which the invention pertains are deemed to lie within the spirit and scope of the invention.
    </p>
  </description>
  <claims format="original" lang="en" id="claim_en">
    <claim num="1">
      <claim-text>What is claimed is:</claim-text>
      <claim-text>1.</claim-text>
      <claim-text>An apparatus comprising:</claim-text>
      <claim-text>a speculative array to store a set of attributes corresponding to a set of architectural registers; a read circuit coupled to the speculative array to read an attribute value of a storage element corresponding to an operand of an instruction;</claim-text>
      <claim-text>and a match circuit coupled to the speculative array to compare the attribute value read from the speculative array and a type code of the operand specified by the instruction, the match circuit comprising:</claim-text>
      <claim-text>- an override circuit to select the attribute value based on a select signal representing a dependency condition, - a matching generator to generate the type code, - a comparator coupled to the matching generator and the override circuit to compare the attribute value and the type code, the comparator generating tag fault information if there is a mismatch between the attribute value and the type code, and - a dependency generator to generate the select signal.</claim-text>
    </claim>
    <claim num="2">
      <claim-text>2. The apparatus of claim 1 further comprises: a retired array coupled to the speculative array to store a set of retired attributes, the retired attributes corresponding to the set of registers.</claim-text>
    </claim>
    <claim num="3">
      <claim-text>3. The apparatus of claim 2 wherein the retired array is updated when the instruction is retired.</claim-text>
    </claim>
    <claim num="4">
      <claim-text>4. The apparatus of claim 2 wherein contents of the retired array are transferred to the speculative array when there is an exception condition.</claim-text>
    </claim>
    <claim num="5">
      <claim-text>5. The apparatus of claim 4 wherein the exception condition includes a branch misprediction.</claim-text>
    </claim>
    <claim num="6">
      <claim-text>6. The apparatus of claim 1 wherein the attribute value includes a tag field.</claim-text>
    </claim>
    <claim num="7">
      <claim-text>7. The apparatus of claim 1 wherein the override circuit stores a copy of the attribute value.</claim-text>
    </claim>
    <claim num="8">
      <claim-text>8. The apparatus of claim 1 wherein the matching generator receives an encoding representing an instruction type.</claim-text>
    </claim>
    <claim num="9">
      <claim-text>9. The apparatus of claim 1 wherein the dependency generator compares a destination code of a first instruction with a source code of a second instruction, the first and second instructions being logically successive.</claim-text>
    </claim>
    <claim num="10">
      <claim-text>10. The apparatus of claim 4 further comprises: a speculative write circuit coupled to the speculative array to update the speculative array;</claim-text>
      <claim-text>and a retired write circuit coupled to the retired array to update the retired array when the instruction is retired.</claim-text>
    </claim>
    <claim num="11">
      <claim-text>11. A method comprising: storing a set of attributes corresponding to a set of architectural registers in a speculative array; reading an attribute value of a storage element corresponding to an operand of an instruction;</claim-text>
      <claim-text>and matching the attribute value read from the speculative array and a type code of the operand specified by the instruction, the matching comprising: - selecting the attribute value based on a select signal representing a dependency condition, - generating the type code, - comparing the attribute value with the type code, - generating tag fault information if there is a mismatch between the attribute value and the type code, and - generating the select signal.</claim-text>
    </claim>
    <claim num="12">
      <claim-text>12. The method of claim 11 further comprises: storing a set of retired attributes in a retired array, the retired attributes corresponding to the set of registers.</claim-text>
    </claim>
    <claim num="13">
      <claim-text>13. The method of claim 12 further comprising updating the retired array when the instruction is retired.</claim-text>
    </claim>
    <claim num="14">
      <claim-text>14. The method of claim 12 further comprising transferring contents of the retired array to the speculative array when there is an exception condition.</claim-text>
    </claim>
    <claim num="15">
      <claim-text>15. The method of claim 14 wherein the exception condition includes a branch misprediction.</claim-text>
    </claim>
    <claim num="16">
      <claim-text>16. The method of claim 11 wherein the attribute value includes a tag field.</claim-text>
    </claim>
    <claim num="17">
      <claim-text>17. The method of claim 11 wherein selecting the attribute value comprises storing a copy of the attribute value.</claim-text>
    </claim>
    <claim num="18">
      <claim-text>18. The method of claim 11 wherein generating the type code comprises receiving an encoding representing an instruction type.</claim-text>
    </claim>
    <claim num="19">
      <claim-text>19. The method of claim 11 wherein generating the select signal comprises comparing a destination code of a first instruction with a source code of a second instruction, the first and second instructions being logically successive.</claim-text>
    </claim>
    <claim num="20">
      <claim-text>20. The method of claim 14 further comprises: updating the speculative array by a speculative write circuit;</claim-text>
      <claim-text>and updating the retired array when the instruction is retired by a retired write circuit.</claim-text>
    </claim>
    <claim num="21">
      <claim-text>21. A processor comprising: an instruction decoder to decode an instruction;</claim-text>
      <claim-text>and a tagged array block coupled to the instruction decoder to perform type checking, the tagged array block comprising: - a speculative array to store a set of attributes corresponding to a set of architectural registers, - a read circuit coupled to the speculative array to read an attribute value of a storage element corresponding to an operand of the instruction, and - a match circuit coupled to the speculative array to compare the attribute value read from the speculative array and a type code of the operand specified by the instruction, the match circuit comprising:</claim-text>
      <claim-text>-  an override circuit to select the attribute value based on a select signal representing a dependency condition, -  a matching generator to generate the type code, -  a comparator coupled to the matching generator and the override circuit to compare the attribute value and the type code, the comparator generating tag fault information if there is a mismatch between the attribute value and the type code, and -  a dependency generator to generate the select signal.</claim-text>
    </claim>
    <claim num="22">
      <claim-text>22. The processor of claim 21 wherein the tagged array block further comprises: a retired array coupled to the speculative array to store a set of retired attributes, the retired attributes corresponding to the set of registers.</claim-text>
    </claim>
    <claim num="23">
      <claim-text>23. The processor of claim 22 wherein the retired array is updated when the instruction is retired.</claim-text>
    </claim>
    <claim num="24">
      <claim-text>24. The processor of claim 22 wherein contents of the retired array are transferred to the speculative array when there is an exception condition.</claim-text>
    </claim>
    <claim num="25">
      <claim-text>25. The processor of claim 24 wherein the exception condition includes a branch misprediction.</claim-text>
    </claim>
    <claim num="26">
      <claim-text>26. The processor of claim 21 wherein the attribute value includes a tag field.</claim-text>
    </claim>
    <claim num="27">
      <claim-text>27. The processor of claim 21 wherein the override circuit stores a copy of the attribute value.</claim-text>
    </claim>
    <claim num="28">
      <claim-text>28. The processor of claim 21 wherein the matching generator receives an encoding representing an instruction type.</claim-text>
    </claim>
    <claim num="29">
      <claim-text>29. The processor of claim 21 wherein the dependency generator compares a destination code of a first instruction with a source code of a second instruction, the first and second instructions being logically successive.</claim-text>
    </claim>
    <claim num="30">
      <claim-text>30. The processor of claim 24 wherein the tagged array block further comprises: a speculative write circuit coupled to the speculative array to update the speculative array;</claim-text>
      <claim-text>and a retired write circuit coupled to the retired array to update the retired array when the instruction is retired.</claim-text>
    </claim>
  </claims>
</questel-patent-document>